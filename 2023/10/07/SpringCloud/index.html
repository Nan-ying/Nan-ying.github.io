<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="SpringCloud, Nan-ying&#39;s Blog">
    <meta name="description" content="1.认识微服务1.1.单体架构单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。

当项目规模较小时，这种模">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>SpringCloud | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">SpringCloud</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/SpringCloud/">
              <span class="chip bg-color">SpringCloud</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
              微服务
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-10-07
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 30k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          119 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p>单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。</p>
<p><img src="169796321521885.jpeg" alt="img"></p>
<p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p>
<p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p>
<ul>
<li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li>
<li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li>
<li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li>
</ul>
<p>在上述问题中，前两点相信大家在实战过程中应该深有体会。对于第三点系统可用性问题，很多同学可能感触不深。接下来我们就通过黑马商城这个项目，给大家做一个简单演示。</p>
<p>首先，我们修改hm-service模块下的<code>com.hmall.controller.HelloController</code>中的<code>hello</code>方法，模拟方法执行时的耗时：</p>
<p><img src="169796321521886.png" alt="img"></p>
<p>接下来，启动项目，目前有两个接口是无需登录即可访问的：</p>
<ul>
<li><code>http://localhost:8080/hi</code></li>
<li><code>http://localhost:8080/search/list</code></li>
</ul>
<p>经过测试，目前<code>/search/list</code> 是比较正常的，访问耗时在30毫秒左右。</p>
<p>接下来，我们假设<code>/hi</code>这个接口是一个并发较高的热点接口，我们通过Jemeter来模拟500个用户不停访问。在课前资料中已经提供了Jemeter的测试脚本：</p>
<p><img src="169796321521887.png" alt="img"></p>
<p>导入Jemeter并测试：</p>
<p><img src="169796321521888.png" alt="img"></p>
<p>这个脚本会开启500个线程并发请求<code>http://localhost/hi</code>这个接口。由于该接口存在执行耗时（500毫秒），这就服务端导致每秒能处理的请求数量有限，最终会有越来越多请求积压，直至Tomcat资源耗尽。这样，其它本来正常的接口（例如<code>/search/list</code>）也都会被拖慢，甚至因超时而无法访问了。</p>
<p>我们测试一下，启动测试脚本，然后在浏览器访问<code>http://localhost:8080/search/list</code>这个接口，会发现响应速度非常慢：</p>
<p><img src="169796321521889.png" alt="img"></p>
<p>如果进一步提高<code>/hi</code>这个接口的并发，最终会发现<code>/search/list</code>接口的请求响应速度会越来越慢。</p>
<p>可见，单体架构的可用性是比较差的，功能之间相互影响比较大。</p>
<p>当然，有同学会说我们可以做水平扩展。</p>
<p>此时如果我们对系统做水平扩展，增加更多机器，资源还是会被这样的热点接口占用，从而影响到其它接口，并不能从根本上解决问题。这也就是单体架构的扩展性差的一个原因。</p>
<p>而要想解决这些问题，就需要使用微服务架构了。</p>
<h2 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2.微服务"></a>1.2.微服务</h2><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p>
<ul>
<li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li>
<li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li>
<li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li>
</ul>
<p>例如，黑马商城项目，我们就可以把商品、用户、购物车、交易等模块拆分，交给不同的团队去开发，并独立部署：</p>
<p><img src="169796321521890.jpeg" alt="img"></p>
<p>那么，单体架构存在的问题有没有解决呢？</p>
<ul>
<li>团队协作成本高？<ul>
<li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li>
</ul>
</li>
<li>系统发布效率低？<ul>
<li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li>
</ul>
</li>
<li>系统可用性差？<ul>
<li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务。</li>
</ul>
</li>
</ul>
<p>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正式分布式架构的一种最佳实践的方案。</p>
<p>当然，微服务架构虽然能解决单体架构的各种问题，但在拆分的过程中，还会面临很多其它问题。比如：</p>
<ul>
<li>如果出现跨服务的业务该如何处理？</li>
<li>页面请求到底该访问哪个服务？</li>
<li>如何实现各个服务之间的服务隔离？</li>
</ul>
<p>这些问题，我们在后续的学习中会给大家逐一解答。</p>
<h2 id="1-3-SpringCloud"><a href="#1-3-SpringCloud" class="headerlink" title="1.3.SpringCloud"></a>1.3.SpringCloud</h2><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合了。</p>
<p><img src="169796321521891.png" alt="img"></p>
<p>而且SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择了！</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p>
<p>目前SpringCloud最新版本为<code>2022.0.x</code>版本，对应的SpringBoot版本为<code>3.x</code>版本，但它们全部依赖于JDK17，目前在企业中使用相对较少。</p>
<table>
<thead>
<tr>
<th align="center"><strong>SpringCloud版本</strong></th>
<th align="center"><strong>SpringBoot版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">2022.0.x</a> aka Kilburn</td>
<td align="center">3.0.x</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td>
<td align="center">2.6.x, 2.7.x (Starting with 2021.0.3)</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td>
<td align="center">2.4.x, 2.5.x (Starting with 2020.0.3)</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td>
<td align="center">2.2.x, 2.3.x (Starting with SR5)</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td>
<td align="center">2.0.x</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td>
<td align="center">1.5.x</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td>
<td align="center">1.5.x</td>
</tr>
</tbody></table>
<p>因此，我们推荐使用次新版本：Spring Cloud 2021.0.x以及Spring Boot 2.7.x版本。</p>
<p>另外，Alibaba的微服务产品SpringCloudAlibaba目前也成为了SpringCloud组件中的一员，我们课堂中也会使用其中的部分组件。</p>
<p>在我们的父工程hmall中已经配置了SpringCloud以及SpringCloudAlibaba的依赖：</p>
<p><img src="169796321521892.png" alt="img"></p>
<p>对应的版本：</p>
<p><img src="169796321521993.png" alt="img"></p>
<p>这样，我们在后续需要使用SpringCloud或者SpringCloudAlibaba组件时，就无需单独指定版本了。</p>
<h1 id="2-微服务拆分"><a href="#2-微服务拆分" class="headerlink" title="2.微服务拆分"></a>2.微服务拆分</h1><p>接下来，我们就一起将黑马商城这个单体项目拆分为微服务项目，并解决其中出现的各种问题。</p>
<h2 id="2-1-熟悉黑马商城"><a href="#2-1-熟悉黑马商城" class="headerlink" title="2.1.熟悉黑马商城"></a>2.1.熟悉黑马商城</h2><p>首先，我们需要熟悉黑马商城项目的基本结构：</p>
<p><img src="169796321521994.png" alt="img"></p>
<p>大家可以直接启动该项目，测试效果。不过，需要修改数据库连接参数，在application-local.yaml中：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:
  db:
    host: 192.168.150.101 # 修改为你自己的虚拟机IP地址
    pw: 123 # 修改为docker中的MySQL密码</code></pre>

<p>同时配置启动项激活的是local环境：</p>
<p><img src="169796321521995.png" alt="img"></p>
<h3 id="2-1-1-登录"><a href="#2-1-1-登录" class="headerlink" title="2.1.1.登录"></a>2.1.1.登录</h3><p>首先来看一下登录业务流程：</p>
<p><img src="image-20231022163148663.png" alt="image-20231022163148663"></p>
<p>登录入口在<code>com.hmall.controller.UserController</code>中的<code>login</code>方法：</p>
<p><img src="169796321521996.png" alt="img"></p>
<h3 id="2-2-2-搜索商品"><a href="#2-2-2-搜索商品" class="headerlink" title="2.2.2.搜索商品"></a>2.2.2.搜索商品</h3><p>在首页搜索框输入关键字，点击搜索即可进入搜索列表页面：</p>
<p><img src="169796321521997.png" alt="img"></p>
<p>该页面会调用接口：<code>/search/list</code>，对应的服务端入口在<code>com.hmall.controller.SearchController</code>中的<code>search</code>方法：</p>
<p><img src="169796321521998.png" alt="img"></p>
<p>这里目前是利用数据库实现了简单的分页查询。</p>
<h3 id="2-2-3-购物车"><a href="#2-2-3-购物车" class="headerlink" title="2.2.3.购物车"></a>2.2.3.购物车</h3><p>在搜索到的商品列表中，点击按钮<code>加入购物车</code>，即可将商品加入购物车：</p>
<p><img src="169796321521999.png" alt="img"></p>
<p>加入成功后即可进入购物车列表页，查看自己购物车商品列表：</p>
<p><img src="1697963215219100.png" alt="img"></p>
<p>同时这里还可以对购物车实现修改、删除等操作。</p>
<p>相关功能全部在<code>com.hmall.controller.CartController</code>中：</p>
<p><img src="1697963215219101.png" alt="img"></p>
<p>其中，查询购物车列表时，由于要判断商品最新的价格和状态，所以还需要查询商品信息，业务流程如下：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<h3 id="2-2-4-下单"><a href="#2-2-4-下单" class="headerlink" title="2.2.4.下单"></a>2.2.4.下单</h3><p>在购物车页面点击<code>结算</code>按钮，会进入订单结算页面：</p>
<p><img src="1697963215220102.png" alt="img"></p>
<p>点击提交订单，会提交请求到服务端，服务端做3件事情：</p>
<ul>
<li>创建一个新的订单</li>
<li>扣减商品库存</li>
<li>清理购物车中商品</li>
</ul>
<p>业务入口在<code>com.hmall.controller.OrderController</code>中的<code>createOrder</code>方法：</p>
<p><img src="1697963215220103.png" alt="img"></p>
<h3 id="2-2-5-支付"><a href="#2-2-5-支付" class="headerlink" title="2.2.5.支付"></a>2.2.5.支付</h3><p>下单完成后会跳转到支付页面，目前只支持<strong>余额支付</strong>：</p>
<p><img src="1697963215220104.png" alt="img"></p>
<p>在选择<strong>余额支付</strong>这种方式后，会发起请求到服务端，服务端会立刻创建一个支付流水单，并返回支付流水单号到前端。</p>
<p>当用户输入用户密码，然后点击确认支付时，页面会发送请求到服务端，而服务端会做几件事情：</p>
<ul>
<li>校验用户密码</li>
<li>扣减余额</li>
<li>修改支付流水状态</li>
<li>修改交易订单状态</li>
</ul>
<p>请求入口在<code>com.hmall.controller.PayController</code>中：</p>
<p><img src="1697963215220105.png" alt="img"></p>
<h2 id="2-2-服务拆分原则"><a href="#2-2-服务拆分原则" class="headerlink" title="2.2.服务拆分原则"></a>2.2.服务拆分原则</h2><p>服务拆分一定要考虑几个问题：</p>
<ul>
<li>什么时候拆？</li>
<li>如何拆？</li>
</ul>
<h3 id="2-2-1-什么时候拆"><a href="#2-2-1-什么时候拆" class="headerlink" title="2.2.1.什么时候拆"></a>2.2.1.什么时候拆</h3><p>一般情况下，对于一个初创的项目，首先要做的是验证项目的可行性。因此这一阶段的首要任务是敏捷开发，快速产出生产可用的产品，投入市场做验证。为了达成这一目的，该阶段项目架构往往会比较简单，很多情况下会直接采用单体架构，这样开发成本比较低，可以快速产出结果，一旦发现项目不符合市场，损失较小。</p>
<p>如果这一阶段采用复杂的微服务架构，投入大量的人力和时间成本用于架构设计，最终发现产品不符合市场需求，等于全部做了无用功。</p>
<p>所以，对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为****微服务架构</strong>。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）。</p>
<p>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）。</p>
<h3 id="2-2-2-怎么拆"><a href="#2-2-2-怎么拆" class="headerlink" title="2.2.2.怎么拆"></a>2.2.2.怎么拆</h3><p>之前我们说过，微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析：</p>
<ul>
<li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li>
<li><strong>低****耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li>
</ul>
<p><strong>高内聚</strong>首先是<strong>单一职责，</strong>但不能说一个微服务就一个接口，而是要保证微服务内部业务的完整性为前提。目标是当我们要修改某个业务时，最好就只修改当前微服务，这样变更的成本更低。</p>
<p>一旦微服务做到了高内聚，那么服务之间的<strong>耦合度</strong>自然就降低了。</p>
<p>当然，微服务之间不可避免的会有或多或少的业务交互，比如下单时需要查询商品数据。这个时候我们不能在订单服务直接查询商品数据库，否则就导致了数据耦合。而应该由商品服务对应暴露接口，并且一定要保证微服务对外<strong>接口的稳定性</strong>（即：尽量保证接口外观不变）。虽然出现了服务间调用，但此时无论你如何在商品服务做内部修改，都不会影响到订单微服务，服务间的耦合度就降低了。</p>
<p>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：</p>
<ul>
<li><strong>纵向</strong>拆分</li>
<li><strong>横向</strong>拆分</li>
</ul>
<p>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</p>
<p>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</p>
<p>当然，由于黑马商城并不是一个完整的项目，其中的短信发送、风控管理并没有实现，这里就不再考虑了。而其它的业务按照纵向拆分，可以分为以下几个微服务：</p>
<ul>
<li>用户服务</li>
<li>商品服务</li>
<li>订单服务</li>
<li>购物车服务</li>
<li>支付服务</li>
</ul>
<h2 id="2-3-拆分购物车、商品服务"><a href="#2-3-拆分购物车、商品服务" class="headerlink" title="2.3.拆分购物车、商品服务"></a>2.3.拆分购物车、商品服务</h2><p>接下来，我们先把商品管理功能、购物车功能抽取为两个独立服务。</p>
<p>一般微服务项目有两种不同的工程结构：</p>
<ul>
<li>完全解耦：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul>
<li>优点：服务之间耦合度低</li>
<li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li>
</ul>
</li>
<li>Maven聚合：整个项目为一个Project，然后每个微服务是其中的一个Module<ul>
<li>优点：项目代码集中，管理和运维方便（授课也方便）</li>
<li>缺点：服务之间耦合，编译时间较长</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：</p>
<p>为了授课方便，我们会采用Maven聚合工程，大家以后到了企业，可以根据需求自由选择工程结构。</p>
<p>在hmall父工程之中，我已经提前定义了SpringBoot、SpringCloud的依赖版本，所以为了方便期间，我们直接在这个项目中创建微服务module.</p>
<h3 id="2-3-1-商品服务"><a href="#2-3-1-商品服务" class="headerlink" title="2.3.1.商品服务"></a>2.3.1.商品服务</h3><p>在hmall中创建module：</p>
<p><img src="1697963215220106.png" alt="img"></p>
<p>选择maven模块，并设定JDK版本为11：</p>
<p>商品模块，我们起名为<code>item-service</code>：</p>
<p><img src="image-20231022171923810.png" alt="image-20231022171923810"></p>
<p>引入依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;hmall&lt;/artifactId&gt;
        &lt;groupId&gt;com.heima&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;item-service&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--common--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.heima&lt;/groupId&gt;
            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--web--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--数据库--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>

<p>编写启动类：</p>
<p><img src="1697963215220109.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.item;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@MapperScan("com.hmall.item.mapper")
@SpringBootApplication
public class ItemApplication {
    public static void main(String[] args) {
        SpringApplication.run(ItemApplication.class, args);
    }
}</code></pre>

<p>接下来是配置文件，可以从<code>hm-service</code>中拷贝：</p>
<p><img src="1697963215220110.png" alt="img"></p>
<p>其中，<code>application.yaml</code>内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8081
spring:
  application:
    name: item-service
  profiles:
    active: dev
  datasource:
    url: jdbc:mysql://${hm.db.host}:3306/hm-item?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai # 这里为方便，用同一sql中不同的数据库来代替在不同的sql中配置
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: ${hm.db.pw}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto
logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"
knife4j:
  enable: true
  openapi:
    title: 商品服务接口文档
    description: "信息"
    email: zhanghuyi@itcast.cn
    concat: 虎哥
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - com.hmall.item.controller</code></pre>

<p>剩下的<code>application-dev.yaml</code>和<code>application-local.yaml</code>直接从hm-service拷贝即可。</p>
<p>然后拷贝<code>hm-service</code>中与商品管理有关的代码到<code>item-service</code>，如图：</p>
<p><img src="1697963215220111.png" alt="img"></p>
<p>这里有一个地方的代码需要改动，就是<code>ItemServiceImpl</code>中的<code>deductStock</code>方法：</p>
<p><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1/SpringCloud/img/1697963215220112.png" alt="img"><img src="1697963215220113.png" alt="img"></p>
<p><strong>改动前</strong></p>
<p><strong>改动后</strong></p>
<p>这也是因为ItemMapper的所在包发生了变化，因此这里代码必须修改包路径。</p>
<p>最后，还要导入数据库表。默认的数据库连接的是虚拟机，在你docker数据库执行课前资料提供的SQL文件：</p>
<p><img src="1697963215220114.png" alt="img"></p>
<p>最终，会在数据库创建一个名为hm-item的database，将来的每一个微服务都会有自己的一个database：</p>
<p><img src="1697963215220115.png" alt="img"></p>
<p><strong>注意</strong>：在企业开发的生产环境中，每一个微服务都应该有自己的<strong>独立数据库服务</strong>，而不仅仅是database，课堂我们用database来代替。</p>
<p>接下来，就可以启动测试了，在启动前我们要配置一下启动项，让默认激活的配置为<code>local</code>而不是<code>dev</code>：</p>
<p><img src="1697963215220116.png" alt="img"></p>
<p>在打开的编辑框填写<code>active profiles</code>:</p>
<p><img src="1697963215220117.png" alt="img"></p>
<p>接着，启动<code>item-service</code>，访问商品微服务的swagger接口文档：<a target="_blank" rel="noopener" href="http://localhost:8081/doc.html">http://localhost:8081/doc.html</a></p>
<p>然后测试其中的根据id批量查询商品这个接口：</p>
<p><img src="1697963215220118.png" alt="img"></p>
<p>测试参数：100002672302,100002624500,100002533430，结果如下：</p>
<p><img src="1697963215221119.png" alt="img"></p>
<p>说明商品微服务抽取成功了。</p>
<h3 id="2-3-2-购物车服务"><a href="#2-3-2-购物车服务" class="headerlink" title="2.3.2.购物车服务"></a>2.3.2.购物车服务</h3><p>与商品服务类似，在hmall下创建一个新的<code>module</code>，起名为<code>cart-service</code>:</p>
<p><img src="1697963215221120.png" alt="img"></p>
<p>然后是依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;hmall&lt;/artifactId&gt;
        &lt;groupId&gt;com.heima&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cart-service&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--common--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.heima&lt;/groupId&gt;
            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--web--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--数据库--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>

<p>然后是启动类：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@MapperScan("com.hmall.cart.mapper")
@SpringBootApplication
public class CartApplication {
    public static void main(String[] args) {
        SpringApplication.run(CartApplication.class, args);
    }
}</code></pre>

<p>然后是配置文件，同样可以拷贝自<code>item-service</code>，不过其中的<code>application.yaml</code>需要修改：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8082
spring:
  application:
    name: cart-service
  profiles:
    active: dev
  datasource:
    url: jdbc:mysql://${db.host}:3306/hm-cart?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: ${db.pw}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto
logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"
knife4j:
  enable: true
  openapi:
    title: 商品服务接口文档
    description: "信息"
    email: zhanghuyi@itcast.cn
    concat: 虎哥
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - com.hmall.cart.controller</code></pre>

<p>最后，把hm-service中的与购物车有关功能拷贝过来，最终的项目结构如下：</p>
<p><img src="1697963215221121.png" alt="img"></p>
<p>特别注意的是<code>com.hmall.cart.service.impl.CartServiceImpl</code>，其中有两个地方需要处理：</p>
<ul>
<li>需要<strong>获取登录用户信息</strong>，但登录校验功能目前没有复制过来，先写死固定用户id</li>
<li>查询购物车时需要<strong>查询商品信息</strong>，而商品信息不在当前服务，需要先将这部分代码注释</li>
</ul>
<p><img src="1697963215221122.png" alt="img"></p>
<p>我们对这部分代码做如下修改：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.service.impl;

import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.hmall.cart.domain.dto.CartFormDTO;
import com.hmall.cart.domain.po.Cart;
import com.hmall.cart.domain.vo.CartVO;
import com.hmall.cart.mapper.CartMapper;
import com.hmall.cart.service.ICartService;
import com.hmall.common.exception.BizIllegalException;
import com.hmall.common.utils.BeanUtils;
import com.hmall.common.utils.CollUtils;
import com.hmall.common.utils.UserContext;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;

/**
 * &lt;p&gt;
 * 订单详情表 服务实现类
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2023-05-05
 */
@Service
@RequiredArgsConstructor
public class CartServiceImpl extends ServiceImpl&lt;CartMapper, Cart&gt; implements ICartService {

    // private final IItemService itemService;

    @Override
    public void addItem2Cart(CartFormDTO cartFormDTO) {
        // 1.获取登录用户
        Long userId = UserContext.getUser();

        // 2.判断是否已经存在
        if (checkItemExists(cartFormDTO.getItemId(), userId)) {
            // 2.1.存在，则更新数量
            baseMapper.updateNum(cartFormDTO.getItemId(), userId);
            return;
        }
        // 2.2.不存在，判断是否超过购物车数量
        checkCartsFull(userId);

        // 3.新增购物车条目
        // 3.1.转换PO
        Cart cart = BeanUtils.copyBean(cartFormDTO, Cart.class);
        // 3.2.保存当前用户
        cart.setUserId(userId);
        // 3.3.保存到数据库
        save(cart);
    }

    @Override
    public List&lt;CartVO&gt; queryMyCarts() {
        // 1.查询我的购物车列表
        List&lt;Cart&gt; carts = lambdaQuery().eq(Cart::getUserId, 1L /*TODO UserContext.getUser()*/).list();
        if (CollUtils.isEmpty(carts)) {
            return CollUtils.emptyList();
        }
        // 2.转换VO
        List&lt;CartVO&gt; vos = BeanUtils.copyList(carts, CartVO.class);
        // 3.处理VO中的商品信息
        handleCartItems(vos);
        // 4.返回
        return vos;
    }

    private void handleCartItems(List&lt;CartVO&gt; vos) {
        // 1.获取商品id TODO 处理商品信息
        /*Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
        // 2.查询商品
        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);
        if (CollUtils.isEmpty(items)) {
            throw new BadRequestException("购物车中商品不存在！");
        }
        // 3.转为 id 到 item的map
        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));
        // 4.写入vo
        for (CartVO v : vos) {
            ItemDTO item = itemMap.get(v.getItemId());
            if (item == null) {
                continue;
            }
            v.setNewPrice(item.getPrice());
            v.setStatus(item.getStatus());
            v.setStock(item.getStock());
        }*/
    }

    @Override
    public void removeByItemIds(Collection&lt;Long&gt; itemIds) {
        // 1.构建删除条件，userId和itemId
        QueryWrapper&lt;Cart&gt; queryWrapper = new QueryWrapper&lt;Cart&gt;();
        queryWrapper.lambda()
                .eq(Cart::getUserId, UserContext.getUser())
                .in(Cart::getItemId, itemIds);
        // 2.删除
        remove(queryWrapper);
    }

    private void checkCartsFull(Long userId) {
        int count = lambdaQuery().eq(Cart::getUserId, userId).count();
        if (count &gt;= 10) {
            throw new BizIllegalException(StrUtil.format("用户购物车课程不能超过{}", 10));
        }
    }

    private boolean checkItemExists(Long itemId, Long userId) {
        int count = lambdaQuery()
                .eq(Cart::getUserId, userId)
                .eq(Cart::getItemId, itemId)
                .count();
        return count &gt; 0;
    }
}</code></pre>

<p>最后，还是要导入数据库表，在本地数据库直接执行课前资料对应的SQL文件：</p>
<p><img src="1697963215221123.png" alt="img"></p>
<p>在数据库中会出现名为<code>hm-cart</code>的<code>database</code>，以及其中的<code>cart</code>表，代表购物车：</p>
<p><img src="1697963215221124.png" alt="img"></p>
<p>接下来，就可以测试了。不过在启动前，同样要配置启动项的<code>active profile</code>为<code>local</code>：</p>
<p><img src="1697963215221125.png" alt="img"></p>
<p>然后启动<code>CartApplication</code>，访问swagger文档页面：<a target="_blank" rel="noopener" href="http://localhost:8082/doc.html">http://localhost:8082/doc.html</a></p>
<p>我们测试其中的<code>查询我的购物车列表</code>接口：</p>
<p><img src="1697963215221126.png" alt="img"></p>
<p>无需填写参数，直接访问：</p>
<p><img src="1697963215221127.png" alt="img"></p>
<p>我们注意到，其中与商品有关的几个字段值都为空！这就是因为刚才我们注释掉了查询购物车时，查询商品信息的相关代码。</p>
<p>那么，我们该如何在<code>cart-service</code>服务中实现对<code>item-service</code>服务的查询呢？</p>
<h2 id="2-4-服务调用"><a href="#2-4-服务调用" class="headerlink" title="2.4.服务调用"></a>2.4.服务调用</h2><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询。</p>
<p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p>
<p>因此，现在查询购物车列表的流程变成了这样：</p>
<p><img src="image-20231022181345024.png" alt="image-20231022181345024"></p>
<p>代码中需要变化的就是这一步：</p>
<p><img src="1697963215221128.png" alt="img"></p>
<p>那么问题来了：我们该如何跨服务调用，准确的说，如何在<code>cart-service</code>中获取<code>item-service</code>服务中的提供的商品数据呢？</p>
<p>大家思考一下，我们以前有没有实现过类似的远程查询的功能呢？</p>
<p>答案是肯定的，我们前端向服务端查询数据，其实就是从浏览器远程查询服务端数据。比如我们刚才通过Swagger测试商品查询接口，就是向<code>http://localhost:8081/items</code>这个接口发起的请求：</p>
<p><img src="1697963215221129.png" alt="img"></p>
<p>而这种查询就是通过http请求的方式来完成的，不仅仅可以实现远程查询，还可以实现新增、删除等各种远程请求。</p>
<p>假如我们在cart-service中能模拟浏览器，发送http请求到item-service，是不是就实现了跨微服务的<strong>远程调用</strong>了呢？</p>
<p>那么：我们该如何用Java代码发送Http的请求呢？</p>
<h3 id="2-4-1-RestTemplate"><a href="#2-4-1-RestTemplate" class="headerlink" title="2.4.1.RestTemplate"></a>2.4.1.RestTemplate</h3><p>Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。</p>
<blockquote>
<p>org.springframework.web.client public class RestTemplate</p>
<p>extends InterceptingHttpAccessor</p>
<p>implements RestOperations</p>
<p>-—————————————————————————————————————</p>
<p>同步客户端执行HTTP请求，在底层HTTP客户端库(如JDK HttpURLConnection、Apache HttpComponents等)上公开一个简单的模板方法API。RestTemplate通过HTTP方法为常见场景提供了模板，此外还提供了支持不太常见情况的通用交换和执行方法。 RestTemplate通常用作共享组件。然而，它的配置不支持并发修改，因此它的配置通常是在启动时准备的。如果需要，您可以在启动时创建多个不同配置的RestTemplate实例。如果这些实例需要共享HTTP客户端资源，它们可以使用相同的底层ClientHttpRequestFactory。 注意:从5.0开始，这个类处于维护模式，只有对更改和错误的小请求才会被接受。请考虑使用org.springframework.web.react .client. webclient，它有更现代的API，支持同步、异步和流场景。  </p>
<p>-—————————————————————————————————————</p>
<p>自: 3.0 参见: HttpMessageConverter, RequestCallback, ResponseExtractor, ResponseErrorHandler</p>
</blockquote>
<p>其中提供了大量的方法，方便我们发送Http请求，例如：</p>
<p><img src="1697963215221130.png" alt="img"></p>
<p>可以看到常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p>
<p>我们在<code>cart-service</code>服务中定义一个配置类：</p>
<p><img src="1697963215221131.png" alt="img"></p>
<p>先将RestTemplate注册为一个Bean：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RemoteCallConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}</code></pre>

<h3 id="2-4-2-远程调用"><a href="#2-4-2-远程调用" class="headerlink" title="2.4.2.远程调用"></a>2.4.2.远程调用</h3><p>接下来，我们修改<code>cart-service</code>中的<code>com.hmall.cart.service.impl.CartServiceImpl</code>的<code>handleCartItems</code>方法，发送http请求到<code>item-service</code>：</p>
<p><img src="1697963215221132.png" alt="img"></p>
<p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p>
<ul>
<li>① 请求方式</li>
<li>② 请求路径</li>
<li>③ 请求参数</li>
<li>④  返回值类型</li>
</ul>
<p><code>handleCartItems</code>方法的完整代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void handleCartItems(List&lt;CartVO&gt; vos) {
    // TODO 1.获取商品id
    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
    // 2.查询商品
    // List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);
    // 2.1.利用RestTemplate发起http请求，得到http的响应
    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(
            "http://localhost:8081/items?ids={ids}",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() {
            },
            Map.of("ids", CollUtil.join(itemIds, ","))
    );
    // 2.2.解析响应
    if(!response.getStatusCode().is2xxSuccessful()){
        // 查询失败，直接结束
        return;
    }
    List&lt;ItemDTO&gt; items = response.getBody();
    if (CollUtils.isEmpty(items)) {
        return;
    }
    // 3.转为 id 到 item的map
    Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));
    // 4.写入vo
    for (CartVO v : vos) {
        ItemDTO item = itemMap.get(v.getItemId());
        if (item == null) {
            continue;
        }
        v.setNewPrice(item.getPrice());
        v.setStatus(item.getStatus());
        v.setStock(item.getStock());
    }
}</code></pre>

<p>好了，现在重启<code>cart-service</code>，再次测试查询我的购物车列表接口：</p>
<p><img src="1697963215221133.png" alt="img"></p>
<p>可以发现，所有商品相关数据都已经查询到了。</p>
<p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>什么时候需要拆分微服务？</p>
<ul>
<li>如果是创业型公司，最好先用单体架构快速迭代开发，验证市场运作模型，快速试错。当业务跑通以后，随着业务规模扩大、人员规模增加，再考虑拆分微服务。</li>
<li>如果是大型企业，有充足的资源，可以在项目开始之初就搭建微服务架构。</li>
</ul>
<p>如何拆分？</p>
<ul>
<li>首先要做到高内聚、低耦合</li>
<li>从拆分方式来说，有横向拆分和纵向拆分两种。纵向就是按照业务功能模块，横向则是拆分通用性业务，提高复用性</li>
</ul>
<p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p>
<ul>
<li>基于Http协议</li>
<li>基于Dubbo协议</li>
</ul>
<p>我们课堂中使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可，更符合微服务的需要。</p>
<p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p>
<ul>
<li>注册RestTemplate到Spring容器</li>
<li>调用RestTemplate的API发送请求，常见方法有：<ul>
<li>getForObject：发送Get请求并返回指定类型对象</li>
<li>PostForObject：发送Post请求并返回指定类型对象</li>
<li>put：发送PUT请求</li>
<li>delete：发送Delete请求</li>
<li>exchange：发送任意类型请求，返回ResponseEntity</li>
</ul>
</li>
</ul>
<h1 id="3-服务注册和发现Nacos"><a href="#3-服务注册和发现Nacos" class="headerlink" title="3.服务注册和发现Nacos"></a>3.服务注册和发现Nacos</h1><p>在上一章我们实现了微服务拆分，并且通过Http请求实现了跨微服务的远程调用。不过这种手动发送Http请求的方式存在一些问题。</p>
<p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，我们进行了多实例部署，如图：</p>
<p><img src="image-20231023143148876.png" alt="image-20231023143148876"></p>
<p>此时，每个<code>item-service</code>的实例其IP或端口不同，问题来了：</p>
<ul>
<li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li>
<li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li>
<li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li>
<li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li>
</ul>
<p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p>
<h2 id="3-1-注册中心原理"><a href="#3-1-注册中心原理" class="headerlink" title="3.1.注册中心原理"></a>3.1.注册中心原理</h2><p>在微服务远程调用的过程中，包括两个角色：</p>
<ul>
<li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li>
<li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li>
</ul>
<p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p>
<p><img src="image-20231023143848783.png" alt="image-20231023143848783"></p>
<p>流程如下：</p>
<ul>
<li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li>
<li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li>
<li>调用者自己对实例列表负载均衡，挑选一个实例</li>
<li>调用者向该实例发起远程调用</li>
</ul>
<p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p>
<ul>
<li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li>
<li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li>
<li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li>
<li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li>
</ul>
<h2 id="3-2-Nacos注册中心"><a href="#3-2-Nacos注册中心" class="headerlink" title="3.2.Nacos注册中心"></a>3.2.Nacos注册中心</h2><p>目前开源的注册中心框架有很多，国内比较常见的有：</p>
<ul>
<li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li>
<li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li>
<li>Consul：HashiCorp公司出品，目前集成在SPringCloud中，不限制微服务语言</li>
</ul>
<p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多，课堂中我们会Nacos为例来学习。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p>
<p>我们基于Docker来部署Nacos的注册中心，首先我们要准备MySQL数据库表，用来存储Nacos的数据。由于是Docker部署，所以大家需要将资料中的SQL文件导入到你<strong>Docker中的MySQL容器</strong>中：</p>
<p><img src="1697963215221135.png" alt="img"></p>
<p>最终表结构如下：</p>
<p><img src="1697963215221136.png" alt="img"></p>
<p>然后，找到课前资料下的nacos文件夹：</p>
<p><img src="1697963215221137.png" alt="img"></p>
<p>其中的<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为你自己的虚拟机IP地址：</p>
<p><img src="1697963215221138.png" alt="img"></p>
<p>然后，将课前资料中的<code>nacos</code>目录上传至虚拟机的<code>/root</code>目录。</p>
<p>进入root目录，然后执行下面的docker命令：</p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \
--name nacos \
--env-file ./nacos/custom.env \
-p 8848:8848 \
-p 9848:9848 \
-p 9849:9849 \
--restart=always \
nacos/nacos-server:v2.1.0-slim</code></pre>

<p>启动完成后，访问下面地址：<a target="_blank" rel="noopener" href="http://192.168.71.100:8848/nacos/%E3%80%82">http://192.168.71.100:8848/nacos/。</a></p>
<p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p>
<p><img src="1697963215222139.png" alt="img"></p>
<h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>接下来，我们把<code>item-service</code>注册到Nacos，步骤如下：</p>
<ul>
<li>引入依赖</li>
<li>配置Nacos地址</li>
<li>重启</li>
</ul>
<h3 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1.添加依赖"></a>3.3.1.添加依赖</h3><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos 服务注册发现--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<h3 id="3-3-2-配置Nacos"><a href="#3-3-2-配置Nacos" class="headerlink" title="3.3.2.配置Nacos"></a>3.3.2.配置Nacos</h3><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  application:
    name: item-service # 服务名称
  cloud:
    nacos:
      server-addr: 192.168.150.101:8848 # nacos地址</code></pre>

<h3 id="3-3-3-启动服务实例"><a href="#3-3-3-启动服务实例" class="headerlink" title="3.3.3.启动服务实例"></a>3.3.3.启动服务实例</h3><p>为了测试一个服务多个实例的情况，我们再配置一个<code>item-service</code>的部署实例：</p>
<p><img src="1697963215222140.png" alt="img"></p>
<p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p>
<p><img src="1697963215222141.png" alt="img"></p>
<p>重启<code>item-service</code>的两个实例：</p>
<p><img src="1697963215222142.png" alt="img"></p>
<p>访问nacos控制台，可以发现服务注册成功：</p>
<p><img src="1697963215222143.png" alt="img"></p>
<p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p>
<p><img src="1697963215222144.png" alt="img"></p>
<h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p>
<ul>
<li>引入依赖</li>
<li>配置Nacos地址</li>
<li>发现并调用服务</li>
</ul>
<h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p>
<p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos 服务注册发现--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p>
<p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p>
<h3 id="3-4-2-配置Nacos地址"><a href="#3-4-2-配置Nacos地址" class="headerlink" title="3.4.2.配置Nacos地址"></a>3.4.2.配置Nacos地址</h3><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    nacos:
      server-addr: 192.168.150.101:8848</code></pre>

<h3 id="3-4-3-发现并调用服务"><a href="#3-4-3-发现并调用服务" class="headerlink" title="3.4.3.发现并调用服务"></a>3.4.3.发现并调用服务</h3><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p>
<p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p>
<ul>
<li>随机</li>
<li>轮询</li>
<li>IP的hash</li>
<li>最近最少访问</li>
<li>…</li>
</ul>
<p>这里我们可以选择最简单的随机负载均衡。</p>
<p>另外，服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</p>
<p><img src="1697963215222145.png" alt="img"></p>
<p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口：</p>
<p><img src="1697963215222146.png" alt="img"></p>
<p>但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p>
<p><img src="1697963215222147.png" alt="img"></p>
<p>经过swagger测试，发现没有任何问题。</p>
<h1 id="4-OpenFeign"><a href="#4-OpenFeign" class="headerlink" title="4.OpenFeign"></a>4.OpenFeign</h1><p>在上一章，我们利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了：</p>
<p><img src="1697963215222148.png" alt="img"></p>
<p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p>
<p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p>
<p>其实远程调用的关键点就在于四个：</p>
<ul>
<li>请求方式</li>
<li>请求路径</li>
<li>请求参数</li>
<li>返回值类型</li>
</ul>
<p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p>
<p>接下来，我们就通过一个快速入门的案例来体验一下OpenFeign的便捷吧。</p>
<h2 id="4-1-快速入门"><a href="#4-1-快速入门" class="headerlink" title="4.1.快速入门"></a>4.1.快速入门</h2><p>我们还是以cart-service中的查询我的购物车为例。因此下面的操作都是在cart-service中进行。</p>
<h3 id="4-1-1-引入依赖"><a href="#4-1-1-引入依赖" class="headerlink" title="4.1.1.引入依赖"></a>4.1.1.引入依赖</h3><p>在<code>cart-service</code>服务的pom.xml中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--openFeign--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--负载均衡器--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<h3 id="4-1-2-启用OpenFeign"><a href="#4-1-2-启用OpenFeign" class="headerlink" title="4.1.2.启用OpenFeign"></a>4.1.2.启用OpenFeign</h3><p>接下来，我们在<code>cart-service</code>的<code>CartApplication</code>启动类上添加注解，启动OpenFeign功能：</p>
<p><img src="1697963215222149.png" alt="img"></p>
<h3 id="4-1-3-编写OpenFeign客户端"><a href="#4-1-3-编写OpenFeign客户端" class="headerlink" title="4.1.3.编写OpenFeign客户端"></a>4.1.3.编写OpenFeign客户端</h3><p>在<code>cart-service</code>中，定义一个新的接口，编写Feign客户端：</p>
<p>其中代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.client;

import com.hmall.cart.domain.dto.ItemDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@FeignClient("item-service")
public interface ItemClient {

    @GetMapping("/items")
    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam("ids") Collection&lt;Long&gt; ids);
}</code></pre>

<p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p>
<ul>
<li><code>@FeignClient("item-service")</code> ：声明服务名称</li>
<li><code>@GetMapping</code> ：声明请求方式</li>
<li><code>@GetMapping("/items")</code> ：声明请求路径</li>
<li><code>@RequestParam("ids") Collection&lt;Long&gt; ids</code> ：声明请求参数</li>
<li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li>
</ul>
<p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p>
<p>我们只需要直接调用这个方法，即可实现远程调用了。</p>
<h3 id="4-1-4-使用FeignClient"><a href="#4-1-4-使用FeignClient" class="headerlink" title="4.1.4.使用FeignClient"></a>4.1.4.使用FeignClient</h3><p>最后，我们在<code>cart-service</code>的<code>com.hmall.cart.service.impl.CartServiceImpl</code>中改造代码，直接调用<code>ItemClient</code>的方法：</p>
<p><img src="1697963215222150.png" alt="img"></p>
<p>feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作，是不是看起来优雅多了。</p>
<p>而且，这里我们不再需要RestTemplate了，还省去了RestTemplate的注册。</p>
<h2 id="4-2-连接池"><a href="#4-2-连接池" class="headerlink" title="4.2.连接池"></a>4.2.连接池</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p>
<ul>
<li>HttpURLConnection：默认实现，不支持连接池</li>
<li>Apache HttpClient ：支持连接池</li>
<li>OKHttp：支持连接池</li>
</ul>
<p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p>
<h3 id="4-2-1-引入依赖"><a href="#4-2-1-引入依赖" class="headerlink" title="4.2.1.引入依赖"></a>4.2.1.引入依赖</h3><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--OK http 的依赖 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<h3 id="4-2-2-开启连接池"><a href="#4-2-2-开启连接池" class="headerlink" title="4.2.2.开启连接池"></a>4.2.2.开启连接池</h3><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">feign:
  okhttp:
    enabled: true # 开启OKHttp功能</code></pre>

<p>重启服务，连接池就生效了。</p>
<h3 id="4-2-3-验证"><a href="#4-2-3-验证" class="headerlink" title="4.2.3.验证"></a>4.2.3.验证</h3><p>我们可以打断点验证连接池是否生效，在<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>中的<code>execute</code>方法中打断点：</p>
<p><img src="1697963215222151.png" alt="img"></p>
<p>Debug方式启动cart-service，请求一次查询我的购物车方法，进入断点：</p>
<p><img src="1697963215222152.png" alt="img"></p>
<p>可以发现这里底层的实现已经改为<code>OkHttpClient</code></p>
<h2 id="4-3-最佳实践"><a href="#4-3-最佳实践" class="headerlink" title="4.3.最佳实践"></a>4.3.最佳实践</h2><p>将来我们要把与下单有关的业务抽取为一个独立微服务:<code>trade-service</code>，不过我们先来看一下<code>hm-service</code>中原本与下单有关的业务逻辑。</p>
<p>入口在<code>com.hmall.controller.OrderController</code>的<code>createOrder</code>方法，然后调用了<code>IOrderService</code>中的<code>createOrder</code>方法。</p>
<p>由于下单时前端提交了商品id，为了计算订单总价，需要查询商品信息：</p>
<p><img src="1697963215223153.png" alt="img"></p>
<p>也就是说，如果拆分了交易微服务（<code>trade-service</code>），它也需要远程调用<code>item-service</code>中的根据id批量查询商品功能。这个需求与<code>cart-service</code>中是一样的。</p>
<p>因此，我们就需要在<code>trade-service</code>中再次定义<code>ItemClient</code>接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？</p>
<h3 id="4-3-1-思路分析"><a href="#4-3-1-思路分析" class="headerlink" title="4.3.1.思路分析"></a>4.3.1.思路分析</h3><p>相信大家都能想到，避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p>
<ul>
<li>思路1：抽取到微服务之外的公共module</li>
<li>思路2：每个微服务自己抽取一个module</li>
</ul>
<p>如图：</p>
<p><img src="1697963215223154.jpeg" alt="img"></p>
<p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p>
<p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p>
<p>由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.</p>
<h3 id="4-3-2-抽取Feign客户端"><a href="#4-3-2-抽取Feign客户端" class="headerlink" title="4.3.2.抽取Feign客户端"></a>4.3.2.抽取Feign客户端</h3><p>在<code>hmall</code>下定义一个新的module，命名为hm-api</p>
<p><img src="1697963215223155.png" alt="img"></p>
<p>其依赖如下：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;hmall&lt;/artifactId&gt;
        &lt;groupId&gt;com.heima&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;hm-api&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--open feign--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- load balancer--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- swagger 注解依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;1.6.6&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>

<p>然后把ItemDTO和ItemClient都拷贝过来，最终结构如下：</p>
<p><img src="1697963215223156.png" alt="img"></p>
<p>现在，任何微服务要调用<code>item-service</code>中的接口，只需要引入<code>hm-api</code>模块依赖即可，无需自己编写Feign客户端了。</p>
<h3 id="4-3-3-扫描包"><a href="#4-3-3-扫描包" class="headerlink" title="4.3.3.扫描包"></a>4.3.3.扫描包</h3><p>接下来，我们在<code>cart-service</code>的<code>pom.xml</code>中引入<code>hm-api</code>模块：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--feign模块--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.heima&lt;/groupId&gt;
    &lt;artifactId&gt;hm-api&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<p>删除<code>cart-service</code>中原来的ItemDTO和ItemClient，重启项目，发现报错了：</p>
<p><img src="1697963215223157.png" alt="img"></p>
<p>这里因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而cart-service的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错了。</p>
<p>解决办法很简单，在cart-service的启动类上添加声明即可，两种方式：</p>
<ul>
<li>方式1：声明扫描包：</li>
</ul>
<p><img src="1697963215223158.png" alt="img"></p>
<ul>
<li>方式2：声明要用的FeignClient</li>
</ul>
<p><img src="1697963215223159.png" alt="img"></p>
<h2 id="4-4-日志配置"><a href="#4-4-日志配置" class="headerlink" title="4.4.日志配置"></a>4.4.日志配置</h2><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p>
<ul>
<li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li>
<li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p>
<h3 id="4-4-1-定义日志级别"><a href="#4-4-1-定义日志级别" class="headerlink" title="4.4.1.定义日志级别"></a>4.4.1.定义日志级别</h3><p>在hm-api模块下新建一个配置类，定义Feign的日志级别：</p>
<p><img src="1697963215223160.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;

public class DefaultFeignConfig {
    @Bean
    public Logger.Level feignLogLevel(){
        return Logger.Level.FULL;
    }
}</code></pre>

<h3 id="4-4-2-配置"><a href="#4-4-2-配置" class="headerlink" title="4.4.2.配置"></a>4.4.2.配置</h3><p>接下来，要让日志级别生效，还需要配置这个类。有两种方式：</p>
<ul>
<li><strong>局部</strong>生效：在某个<code>FeignClient</code>中配置，只对当前<code>FeignClient</code>生效</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@FeignClient(value = "item-service", configuration = DefaultFeignConfig.class)</code></pre>

<ul>
<li><strong>全局</strong>生效：在<code>@EnableFeignClients</code>中配置，针对所有<code>FeignClient</code>生效。</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</code></pre>

<p>日志格式：</p>
<pre class="line-numbers language-Plain" data-language="Plain"><code class="language-Plain">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; GET http://item-service/items?ids=100000006163 HTTP/1.1
17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; END HTTP (0-byte body)
17:35:32:278 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- HTTP/1.1 200  (127ms)
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] connection: keep-alive
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] content-type: application/json
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] date: Fri, 26 May 2023 09:35:32 GMT
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] keep-alive: timeout=60
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] transfer-encoding: chunked
17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] 
17:35:32:280 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] [{"id":100000006163,"name":"巴布豆(BOBDOG)柔薄悦动婴儿拉拉裤XXL码80片(15kg以上)","price":67100,"stock":10000,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t23998/350/2363990466/222391/a6e9581d/5b7cba5bN0c18fb4f.jpg!q70.jpg.webp","category":"拉拉裤","brand":"巴布豆","spec":"{}","sold":11,"commentCount":33343434,"isAD":false,"status":2}]
17:35:32:281 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- END HTTP (369-byte body)</code></pre>

<h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a>5.作业</h1><h2 id="5-1-拆分微服务"><a href="#5-1-拆分微服务" class="headerlink" title="5.1.拆分微服务"></a>5.1.拆分微服务</h2><p>将hm-service中的其它业务也都拆分为微服务，包括：</p>
<ul>
<li>user-service：用户微服务，包含用户登录、管理等功能</li>
<li>trade-service：交易微服务，包含订单相关功能</li>
<li>pay-service：支付微服务，包含支付相关功能</li>
</ul>
<p>其中交易服务、支付服务、用户服务中的业务都需要知道当前登录用户是谁，目前暂未实现，先将用户id写死。</p>
<p><strong>思考</strong>：如何才能在每个微服务中都拿到用户信息？如何在微服务之间传递用户信息？</p>
<h2 id="5-2-定义FeignClient"><a href="#5-2-定义FeignClient" class="headerlink" title="5.2.定义FeignClient"></a>5.2.定义FeignClient</h2><p>在上述业务中，包含大量的微服务调用，将被调用的接口全部定义为FeignClient，将其与对应的DTO放在hm-api模块</p>
<h2 id="5-3-将微服务与前端联调"><a href="#5-3-将微服务与前端联调" class="headerlink" title="5.3.将微服务与前端联调"></a>5.3.将微服务与前端联调</h2><p>课前资料提供了一个<code>hmall-nginx</code>目录，其中包含了Nginx以及我们的前端代码：</p>
<p><img src="1697963215223161.png" alt="img"></p>
<p>将其拷贝到一个不包含中文、空格、特殊字符的目录，启动后即可访问到页面：</p>
<ul>
<li>18080是用户端页面</li>
<li>18081是管理端页面</li>
</ul>
<p>之前<code>nginx</code>内部会将发向服务端请求全部代理到8080端口，但是现在拆分了N个微服务，8080不可用了。请通过<code>Nginx</code>配置，完成对不同微服务的反向代理。</p>
<p><strong>认真思考这种方式存在哪些问题</strong>，<strong>有什么好的解决方案</strong>？</p>
<p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/NNAtw4CFQijiYakX8tgczWvWn0b?create_from=create_doc_to_wiki">https://b11et3un53m.feishu.cn/wiki/NNAtw4CFQijiYakX8tgczWvWn0b?create_from=create_doc_to_wiki</a></p>
<hr>
<p>在昨天的作业中，我们将黑马商城拆分为5个微服务：</p>
<ul>
<li>用户服务</li>
<li>商品服务</li>
<li>购物车服务</li>
<li>交易服务</li>
<li>支付服务</li>
</ul>
<p>由于每个微服务都有不同的地址或端口，入口不同，相信大家在与前端联调的时候发现了一些问题：</p>
<ul>
<li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li>
<li>前端无法调用nacos，无法实时更新服务列表</li>
</ul>
<p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p>
<ul>
<li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li>
<li>当微服务之间调用时，该如何传递用户信息？</li>
</ul>
<p>不要着急，这些问题都可以在今天的学习中找到答案，我们会通过<strong>网关</strong>技术解决上述问题。今天的内容会分为3章：</p>
<ul>
<li>第一章：网关路由，解决前端请求入口的问题。</li>
<li>第二章：网关鉴权，解决统一登录校验和用户信息获取的问题。</li>
<li>第三章：统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li>
</ul>
<p>通过今天的学习你将掌握下列能力：</p>
<ul>
<li>会利用微服务网关做请求路由</li>
<li>会利用微服务网关做登录身份校验</li>
<li>会利用Nacos实现统一配置管理</li>
<li>会利用Nacos实现配置热更新</li>
</ul>
<p>好了，接下来我们就一起进入今天的学习吧。</p>
<h1 id="1-网关路由"><a href="#1-网关路由" class="headerlink" title="1.网关路由"></a>1.网关路由</h1><h2 id="1-1-认识网关"><a href="#1-1-认识网关" class="headerlink" title="1.1.认识网关"></a>1.1.认识网关</h2><p>什么是网关？</p>
<p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p>
<p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p>
<ul>
<li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li>
<li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li>
</ul>
<p><img src="169811723298744.jpeg" alt="img"></p>
<p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p>
<ul>
<li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li>
<li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li>
</ul>
<p><img src="16981172328811.jpeg" alt="img"></p>
<p>在SpringCloud当中，提供了两种网关实现方案：</p>
<ul>
<li>Netflix Zuul：早期实现，目前已经淘汰</li>
<li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li>
</ul>
<p>课堂中我们以SpringCloudGateway为例来讲解，官方网站：</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-gateway#learn">https://spring.io/projects/spring-cloud-gateway#learn</a></p>
<h2 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2.快速入门"></a>1.2.快速入门</h2><p>接下来，我们先看下如何利用网关实现请求路由。由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p>
<ul>
<li>创建网关微服务</li>
<li>引入SpringCloudGateway、NacosDiscovery依赖</li>
<li>编写启动类</li>
<li>配置网关路由</li>
</ul>
<h3 id="1-2-1-创建项目"><a href="#1-2-1-创建项目" class="headerlink" title="1.2.1.创建项目"></a>1.2.1.创建项目</h3><p>首先，我们要在hmall下创建一个新的module，命名为hm-gateway，作为网关微服务：</p>
<p><img src="16981172328812.png" alt="img"></p>
<h3 id="1-2-2-引入依赖"><a href="#1-2-2-引入依赖" class="headerlink" title="1.2.2.引入依赖"></a>1.2.2.引入依赖</h3><p>在<code>hm-gateway</code>模块的<code>pom.xml</code>文件中引入依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;hmall&lt;/artifactId&gt;
        &lt;groupId&gt;com.heima&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;hm-gateway&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--common--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.heima&lt;/groupId&gt;
            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--网关--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--nacos discovery--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--负载均衡--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>

<h3 id="1-2-3-启动类"><a href="#1-2-3-启动类" class="headerlink" title="1.2.3.启动类"></a>1.2.3.启动类</h3><p>在<code>hm-gateway</code>模块的<code>com.hmall.gateway</code>包下新建一个启动类：</p>
<p><img src="16981172328823.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}</code></pre>

<h3 id="1-2-4-配置路由"><a href="#1-2-4-配置路由" class="headerlink" title="1.2.4.配置路由"></a>1.2.4.配置路由</h3><p>接下来，在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8080
spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: 192.168.150.101:8848
    gateway:
      routes:
        - id: item # 路由规则id，自定义，唯一
          uri: lb://item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表
          predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务
            - Path=/items/**,/search/** # 这里是以请求路径作为判断规则
        - id: cart
          uri: lb://cart-service
          predicates:
            - Path=/carts/**
        - id: user
          uri: lb://user-service
          predicates:
            - Path=/users/**,/addresses/**
        - id: trade
          uri: lb://trade-service
          predicates:
            - Path=/orders/**
        - id: pay
          uri: lb://pay-service
          predicates:
            - Path=/pay-orders/**</code></pre>

<h3 id="1-2-5-测试"><a href="#1-2-5-测试" class="headerlink" title="1.2.5.测试"></a>1.2.5.测试</h3><p>启动GatewayApplication，以 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 拼接微服务接口路径来测试。例如：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/items/page?pageNo=1&amp;pageSize=1">http://localhost:8080/items/page?pageNo=1&amp;pageSize=1</a></p>
<p><img src="16981172328824.png" alt="img"></p>
<p>此时，启动UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了：</p>
<h2 id="1-3-路由过滤"><a href="#1-3-路由过滤" class="headerlink" title="1.3.路由过滤"></a>1.3.路由过滤</h2><p>路由规则的定义语法如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      routes:
        - id: item
          uri: lb://item-service
          predicates:
            - Path=/items/**,/search/**</code></pre>

<p>其中routes对应的类型如下：</p>
<p><img src="16981172328825.png" alt="img"></p>
<p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p>
<p><img src="16981172328826.png" alt="img"></p>
<p>四个属性含义如下：</p>
<ul>
<li><code>id</code>：路由的唯一标示</li>
<li><code>predicates</code>：路由断言，其实就是匹配条件</li>
<li><code>filters</code>：路由过滤条件，后面讲</li>
<li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li>
</ul>
<p>这里我们重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p>
<table>
<thead>
<tr>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>说明</strong></th>
<th align="center"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">After</td>
<td align="center">是某个时间点后的请求</td>
<td align="center">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="center">Before</td>
<td align="center">是某个时间点之前的请求</td>
<td align="center">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td align="center">Between</td>
<td align="center">是某两个时间点之前的请求</td>
<td align="center">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">请求必须包含某些cookie</td>
<td align="center">- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td align="center">Header</td>
<td align="center">请求必须包含某些header</td>
<td align="center">- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求必须是访问某个host（域名）</td>
<td align="center">- Host=<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">请求方式必须是指定方式</td>
<td align="center">- Method=GET,POST</td>
</tr>
<tr>
<td align="center">Path</td>
<td align="center">请求路径必须符合指定规则</td>
<td align="center">- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td align="center">Query</td>
<td align="center">请求参数必须包含指定参数</td>
<td align="center">- Query=name, Jack或者- Query=name</td>
</tr>
<tr>
<td align="center">RemoteAddr</td>
<td align="center">请求者的ip必须是指定范围</td>
<td align="center">- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td align="center">weight</td>
<td align="center">权重处理</td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="2-网关登录校验"><a href="#2-网关登录校验" class="headerlink" title="2.网关登录校验"></a>2.网关登录校验</h1><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p>
<h2 id="2-1-鉴权思路分析"><a href="#2-1-鉴权思路分析" class="headerlink" title="2.1.鉴权思路分析"></a>2.1.鉴权思路分析</h2><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p>
<ul>
<li>每个微服务都需要知道JWT的秘钥，不安全</li>
<li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li>
</ul>
<p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p>
<ul>
<li>只需要在网关和用户服务保存秘钥</li>
<li>只需要在网关开发登录校验功能</li>
</ul>
<p>此时，登录校验的流程如图：</p>
<p><img src="image-20231024145816082.png" alt="image-20231024145816082"></p>
<p>不过，这里存在几个问题：</p>
<ul>
<li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li>
<li>网关校验JWT之后，如何将用户信息传递给微服务？</li>
<li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li>
</ul>
<p><img src="image-20231024150701922.png" alt="image-20231024150701922"></p>
<p>这些问题将在接下来几节一一解决。</p>
<h2 id="2-2-网关过滤器"><a href="#2-2-网关过滤器" class="headerlink" title="2.2.网关过滤器"></a>2.2.网关过滤器</h2><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p>
<p><img src="image-20231024145848148.png" alt="image-20231024145848148"></p>
<p>如图所示：</p>
<ol>
<li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li>
<li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li>
<li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li>
<li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li>
<li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li>
<li>最终把响应结果返回。</li>
</ol>
<p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求了！</p>
<p>那么，该如何实现一个网关过滤器呢？</p>
<p>网关过滤器链中的过滤器有两种：</p>
<ul>
<li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li>
<li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li>
</ul>
<p><strong>注意</strong>：过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务。</p>
<p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/**
 * 处理请求并将其传递给下一个过滤器
 * @param exchange 当前请求的上下文，其中包含request、response等各种数据
 * @param chain 过滤器链，基于它向下传递请求
 * @return 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。
 */
Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);</code></pre>

<p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p>
<p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p>
<p><img src="image-20231024151952293.png" alt="image-20231024151952293"></p>
<p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p>
<p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p>
<p>使用的使用只需要在application.yaml中这样配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      routes:
      - id: test_route
        uri: lb://test-service
        predicates:
          -Path=/test/**
        filters:
          - AddRequestHeader=key, value # 逗号之前是请求头的key，逗号之后是value</code></pre>

<p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      default-filters: # default-filters下的过滤器可以作用于所有路由
        - AddRequestHeader=key, value
      routes:
      - id: test_route
        uri: lb://test-service
        predicates:
          -Path=/test/**</code></pre>

<h2 id="2-3-自定义过滤器"><a href="#2-3-自定义过滤器" class="headerlink" title="2.3.自定义过滤器"></a>2.3.自定义过滤器</h2><p>无论是<code>GatewayFilter</code>还是<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p>
<h3 id="2-3-1-自定义GatewayFilter"><a href="#2-3-1-自定义GatewayFilter" class="headerlink" title="2.3.1.自定义GatewayFilter"></a>2.3.1.自定义GatewayFilter</h3><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。最简单的方式是这样的：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Component
public class PrintAnyGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt; {
    @Override
    public GatewayFilter apply(Object config) {
        return new GatewayFilter() {
            @Override
            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                // 获取请求
                ServerHttpRequest request = exchange.getRequest();
                // 编写过滤器逻辑
                System.out.println("过滤器执行了");
                // 放行
                return chain.filter(exchange);
            }
        };
    }
}</code></pre>

<p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！</p>
<p>然后在yaml配置中这样使用：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      default-filters:
            - PrintAny # 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</code></pre>

<p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Component
public class PrintAnyGatewayFilterFactory // 父类泛型是内部类的Config类型
                extends AbstractGatewayFilterFactory&lt;PrintAnyGatewayFilterFactory.Config&gt; {

    @Override
    public GatewayFilter apply(Config config) {
        // OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：
        // - GatewayFilter：过滤器
        // - int order值：值越小，过滤器执行优先级越高
        return new OrderedGatewayFilter(new GatewayFilter() {
            @Override
            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                // 获取config值
                String a = config.getA();
                String b = config.getB();
                String c = config.getC();
                // 编写过滤器逻辑
                System.out.println("a = " + a);
                System.out.println("b = " + b);
                System.out.println("c = " + c);
                // 放行
                return chain.filter(exchange);
            }
        }, 100);
    }

    // 自定义配置属性，成员变量名称很重要，下面会用到
    @Data
    static class Config{
        private String a;
        private String b;
        private String c;
    }
    // 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取
    @Override
    public List&lt;String&gt; shortcutFieldOrder() {
        return List.of("a", "b", "c");
    }
        // 返回当前配置类的类型，也就是内部的Config
    @Override
    public Class&lt;Config&gt; getConfigClass() {
        return Config.class;
    }

}</code></pre>

<p>然后在yaml文件中使用：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      default-filters:
            - PrintAny=1,2,3 # 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</code></pre>

<p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p>
<p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      default-filters:
            - name: PrintAny
              args: # 手动指定参数名，无需按照参数顺序
                a: 1
                b: 2
                c: 3</code></pre>

<h3 id="2-3-2-自定义GlobalFilter"><a href="#2-3-2-自定义GlobalFilter" class="headerlink" title="2.3.2.自定义GlobalFilter"></a>2.3.2.自定义GlobalFilter</h3><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Component
public class PrintAnyGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 编写过滤器逻辑
        System.out.println("未登录，无法访问");
        // 放行
        // return chain.filter(exchange);

        // 拦截
        ServerHttpResponse response = exchange.getResponse();
        response.setRawStatusCode(401);
        return response.setComplete();
    }

    @Override
    public int getOrder() {
        // 过滤器执行顺序，值越小，优先级越高
        return 0;
    }
}</code></pre>

<h2 id="2-4-登录校验"><a href="#2-4-登录校验" class="headerlink" title="2.4.登录校验"></a>2.4.登录校验</h2><p>接下来，我们就利用自定义<code>GlobalFilter</code>来完成登录校验。</p>
<h3 id="2-4-1-JWT工具"><a href="#2-4-1-JWT工具" class="headerlink" title="2.4.1.JWT工具"></a>2.4.1.JWT工具</h3><p>登录校验需要用到JWT，而且JWT的加密需要秘钥和加密工具。这些在<code>hm-service</code>中已经有了，我们直接拷贝过来：</p>
<p><img src="16981172328827.png" alt="img"></p>
<p>具体作用如下：</p>
<ul>
<li><code>AuthProperties</code>：配置登录校验需要拦截的路径，因为不是所有的路径都需要登录才能访问</li>
<li><code>JwtProperties</code>：定义与JWT工具有关的属性，比如秘钥文件位置</li>
<li><code>SecurityConfig</code>：工具的自动装配</li>
<li><code>JwtTool</code>：JWT工具，其中包含了校验和解析<code>token</code>的功能</li>
<li><code>hmall.jks</code>：秘钥文件</li>
</ul>
<p>其中<code>AuthProperties</code>和<code>JwtProperties</code>所需的属性要在<code>application.yaml</code>中配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:
  jwt:
    location: classpath:hmall.jks # 秘钥地址
    alias: hmall # 秘钥别名
    password: hmall123 # 秘钥文件密码
    tokenTTL: 30m # 登录有效期
  auth:
    excludePaths: # 无需登录校验的路径
      - /search/**
      - /users/login
      - /items/**</code></pre>

<h3 id="2-4-2-登录校验过滤器"><a href="#2-4-2-登录校验过滤器" class="headerlink" title="2.4.2.登录校验过滤器"></a>2.4.2.登录校验过滤器</h3><p>接下来，我们定义一个登录校验的过滤器：</p>
<p><img src="16981172328828.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway.filter;

import com.hmall.common.exception.UnauthorizedException;
import com.hmall.common.utils.CollUtils;
import com.hmall.gateway.config.AuthProperties;
import com.hmall.gateway.util.JwtTool;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.List;

@Component
@RequiredArgsConstructor
@EnableConfigurationProperties(AuthProperties.class)
public class AuthGlobalFilter implements GlobalFilter, Ordered {

    private final JwtTool jwtTool;

    private final AuthProperties authProperties;

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1.获取Request
        ServerHttpRequest request = exchange.getRequest();
        // 2.判断是否不需要拦截
        if(isExclude(request.getPath().toString())){
            // 无需拦截，直接放行
            return chain.filter(exchange);
        }
        // 3.获取请求头中的token
        String token = null;
        List&lt;String&gt; headers = request.getHeaders().get("authorization");
        if (!CollUtils.isEmpty(headers)) {
            token = headers.get(0);
        }
        // 4.校验并解析token
        Long userId = null;
        try {
            userId = jwtTool.parseToken(token);
        } catch (UnauthorizedException e) {
            // 如果无效，拦截
            ServerHttpResponse response = exchange.getResponse();
            response.setRawStatusCode(401);
            return response.setComplete();
        }

        // TODO 5.如果有效，传递用户信息
        System.out.println("userId = " + userId);
        // 6.放行
        return chain.filter(exchange);
    }

    private boolean isExclude(String antPath) {
        for (String pathPattern : authProperties.getExcludePaths()) {
            if(antPathMatcher.match(pathPattern, antPath)){
                return true;
            }
        }
        return false;
    }

    @Override
    public int getOrder() {
        return 0;
    }
}</code></pre>

<p>重启测试，会发现访问/items开头的路径，未登录状态下不会被拦截：</p>
<p><img src="16981172328839.png" alt="img"></p>
<p>访问其他路径则，未登录状态下请求会被拦截，并且返回<code>401</code>状态码：</p>
<p><img src="169811723288310.png" alt="img"></p>
<h2 id="2-5-微服务获取用户"><a href="#2-5-微服务获取用户" class="headerlink" title="2.5.微服务获取用户"></a>2.5.微服务获取用户</h2><p>现在，网关已经可以完成登录校验并获取登录用户身份信息。但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p>
<p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p>
<p>据图流程图如下：</p>
<p><img src="169811723288411.jpeg" alt="img"></p>
<p>因此，接下来我们要做的事情有：</p>
<ul>
<li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务</li>
<li>编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行</li>
</ul>
<h3 id="2-5-1-保存用户到请求头"><a href="#2-5-1-保存用户到请求头" class="headerlink" title="2.5.1.保存用户到请求头"></a>2.5.1.保存用户到请求头</h3><p>首先，我们修改网关登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p>
<p><img src="169811723288412.png" alt="img"></p>
<h3 id="2-5-2-拦截器获取用户"><a href="#2-5-2-拦截器获取用户" class="headerlink" title="2.5.2.拦截器获取用户"></a>2.5.2.拦截器获取用户</h3><p>在hm-common中已经有一个用于保存登录用户的ThreadLocal工具：</p>
<p><img src="169811723288413.png" alt="img"></p>
<p>其中已经提供了保存和获取用户的方法：</p>
<p><img src="169811723288414.png" alt="img"></p>
<p>接下来，我们只需要编写拦截器，获取用户信息并保存到<code>UserContext</code>，然后放行即可。</p>
<p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在<code>hm-common</code>中，并写好自动装配。这样微服务只需要引入<code>hm-common</code>就可以直接具备拦截器功能，无需重复编写。</p>
<p>我们在<code>hm-common</code>模块下定义一个拦截器：</p>
<p><img src="169811723288415.png" alt="img"></p>
<p>具体代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.common.interceptor;

import cn.hutool.core.util.StrUtil;
import com.hmall.common.utils.UserContext;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UserInfoInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.获取请求头中的用户信息
        String userInfo = request.getHeader("user-info");
        // 2.判断是否为空
        if (StrUtil.isNotBlank(userInfo)) {
            // 不为空，保存到ThreadLocal
                UserContext.setUser(Long.valueOf(userInfo));
        }
        // 3.放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserContext.removeUser();
    }
}</code></pre>

<p>接着在<code>hm-common</code>模块下编写<code>SpringMVC</code>的配置类，配置登录拦截器：</p>
<p><img src="169811723288416.png" alt="img"></p>
<p>具体代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.common.config;

import com.hmall.common.interceptor.UserInfoInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new UserInfoInterceptor());
    }
}</code></pre>

<p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是<code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。</p>
<p>基于SpringBoot的自动装配原理，我们要将其添加到<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中：</p>
<p><img src="169811723288417.png" alt="img"></p>
<p>内容如下：</p>
<pre class="line-numbers language-Properties" data-language="Properties"><code class="language-Properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.hmall.common.config.MyBatisConfig,\
  com.hmall.common.config.MvcConfig</code></pre>

<h3 id="2-5-3-恢复购物车代码"><a href="#2-5-3-恢复购物车代码" class="headerlink" title="2.5.3.恢复购物车代码"></a>2.5.3.恢复购物车代码</h3><p>之前我们无法获取登录用户，所以把购物车服务的登录用户写死了，现在需要恢复到原来的样子。</p>
<p>找到<code>cart-service</code>模块的<code>com.hmall.cart.service.impl.CartServiceImpl</code>：</p>
<p><img src="169811723288418.png" alt="img"></p>
<p>修改其中的<code>queryMyCarts</code>方法：</p>
<p><img src="169811723288419.png" alt="img"></p>
<h2 id="2-6-OpenFeign传递用户"><a href="#2-6-OpenFeign传递用户" class="headerlink" title="2.6.OpenFeign传递用户"></a>2.6.OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p>
<p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p>
<p><img src="169811723288520.jpeg" alt="img"></p>
<p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p>
<p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p>
<p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p>
<p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface RequestInterceptor {

  /**
   * Called for every request. 
   * Add data using methods on the supplied {@link RequestTemplate}.
   */
  void apply(RequestTemplate template);
}</code></pre>

<p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p>
<p>由于<code>FeignClient</code>全部都是在<code>hm-api</code>模块，因此我们在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器：</p>
<p><img src="169811723288521.png" alt="img"></p>
<p>在<code>com.hmall.api.config.DefaultFeignConfig</code>中添加一个Bean：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Bean
public RequestInterceptor userInfoRequestInterceptor(){
    return new RequestInterceptor() {
        @Override
        public void apply(RequestTemplate template) {
            // 获取登录用户
            Long userId = UserContext.getUser();
            if(userId == null) {
                // 如果为空则直接跳过
                return;
            }
            // 如果不为空则放入请求头中，传递给下游微服务
            template.header("user-info", userId.toString());
        }
    };
}</code></pre>

<p>好了，现在微服务之间通过OpenFeign调用时也会传递登录用户信息了。</p>
<h4 id="整体拦截如下"><a href="#整体拦截如下" class="headerlink" title="整体拦截如下"></a>整体拦截如下</h4><p>主要有三个部分：</p>
<ol>
<li>网关</li>
<li>所有微服务前的拦截器</li>
<li>微服务间调用，基于OpenFeign的拦截器</li>
</ol>
<p><img src="image-20231025153012770.png" alt="image-20231025153012770"></p>
<h1 id="3-配置管理"><a href="#3-配置管理" class="headerlink" title="3.配置管理"></a>3.配置管理</h1><p>到目前为止我们已经解决了微服务相关的几个问题：</p>
<ul>
<li>微服务远程调用</li>
<li>微服务注册、发现</li>
<li>微服务请求路由、负载均衡</li>
<li>微服务登录用户信息传递</li>
</ul>
<p>不过，现在依然还有几个问题需要解决：</p>
<ul>
<li>网关路由在配置文件中写死了，如果变更必须重启微服务</li>
<li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li>
<li>每个微服务都有很多重复的配置，维护成本高</li>
</ul>
<p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p>
<p><img src="169811723288522.jpeg" alt="img"></p>
<p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p>
<p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p>
<h2 id="3-1-配置共享"><a href="#3-1-配置共享" class="headerlink" title="3.1.配置共享"></a>3.1.配置共享</h2><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p>
<ul>
<li>在Nacos中添加共享配置</li>
<li>微服务拉取配置</li>
</ul>
<h3 id="3-1-1-添加共享配置"><a href="#3-1-1-添加共享配置" class="headerlink" title="3.1.1.添加共享配置"></a>3.1.1.添加共享配置</h3><p>以cart-service为例，我们看看有哪些配置是重复的，可以抽取的：</p>
<p>首先是jdbc相关配置：</p>
<p><img src="169811723288523.png" alt="img"></p>
<p>然后是日志配置：</p>
<p><img src="169811723288524.png" alt="img"></p>
<p>然后是swagger以及OpenFeign的配置：</p>
<p><img src="169811723288525.png" alt="img"></p>
<p>我们在nacos控制台分别添加这些配置。</p>
<p>首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p>
<p><img src="169811723288526.png" alt="img"></p>
<p>在弹出的表单中填写信息：</p>
<p><img src="169811723288527.png" alt="img"></p>
<p>其中详细的配置如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  datasource:
    url: jdbc:mysql://${hm.db.host:192.168.150.101}:${hm.db.port:3306}/${hm.db.database}?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: ${hm.db.un:root}
    password: ${hm.db.pw:123}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto</code></pre>

<p>注意这里的jdbc的相关参数并没有写死，例如：</p>
<ul>
<li><code>数据库ip</code>：通过<code>${hm.db.host:192.168.150.101}</code>配置了默认值为<code>192.168.150.101</code>，同时允许通过<code>${hm.db.host}</code>来覆盖默认值</li>
<li><code>数据库端口</code>：通过<code>${hm.db.port:3306}</code>配置了默认值为<code>3306</code>，同时允许通过<code>${hm.db.port}</code>来覆盖默认值</li>
<li><code>数据库database</code>：可以通过<code>${hm.db.database}</code>来设定，无默认值</li>
</ul>
<p>然后是统一的日志配置，命名为<code>shared-log.yaml</code>，配置内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"</code></pre>

<p>然后是统一的swagger配置，命名为<code>shared-swagger.yaml</code>，配置内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">knife4j:
  enable: true
  openapi:
    title: ${hm.swagger.title:黑马商城接口文档}
    description: ${hm.swagger.description:黑马商城接口文档}
    email: ${hm.swagger.email:zhanghuyi@itcast.cn}
    concat: ${hm.swagger.concat:虎哥}
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - ${hm.swagger.package}</code></pre>

<p>注意，这里的swagger相关配置我们没有写死，例如：</p>
<ul>
<li><code>title</code>：接口文档标题，我们用了<code>${hm.swagger.title}</code>来代替，将来可以有用户手动指定</li>
<li><code>email</code>：联系人邮箱，我们用了<code>${hm.swagger.email:``zhanghuyi@itcast.cn``}</code>，默认值是<code>zhanghuyi@itcast.cn</code>，同时允许用户利用<code>${hm.swagger.email}</code>来覆盖。</li>
</ul>
<h3 id="3-1-2-拉取共享配置"><a href="#3-1-2-拉取共享配置" class="headerlink" title="3.1.2.拉取共享配置"></a>3.1.2.拉取共享配置</h3><p>接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p>
<p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p>
<p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？</p>
<p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了。</p>
<p><img src="169811723288528.jpeg" alt="img"></p>
<p>因此，微服务整合Nacos配置管理的步骤如下：</p>
<p>1）引入依赖：</p>
<p>在cart-service模块引入依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos配置管理--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--读取bootstrap文件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<p>2）新建bootstrap.yaml</p>
<p>在cart-service中的resources目录新建一个bootstrap.yaml文件：</p>
<p><img src="169811723288529.png" alt="img"></p>
<p>内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  application:
    name: cart-service # 服务名称
  profiles:
    active: dev
  cloud:
    nacos:
      server-addr: 192.168.150.101 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
        shared-configs: # 共享配置
          - dataId: shared-jdbc.yaml # 共享mybatis配置
          - dataId: shared-log.yaml # 共享日志配置
          - dataId: shared-swagger.yaml # 共享日志配置</code></pre>

<p>3）修改application.yaml</p>
<p>由于一些配置挪到了bootstrap.yaml，因此application.yaml需要修改为：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8082
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
hm:
  swagger:
    title: 购物车服务接口文档
    package: com.hmall.cart.controller
  db:
    database: hm-cart</code></pre>

<p>重启服务，发现所有配置都生效了。</p>
<h2 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2.配置热更新"></a>3.2.配置热更新</h2><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10，对应代码如下：</p>
<p><img src="169811723288530.png" alt="img"></p>
<p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p>
<p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p>
<p>这就要用到Nacos的配置热更新能力了，分为两步：</p>
<ul>
<li>在Nacos中添加配置</li>
<li>在微服务读取配置</li>
</ul>
<h3 id="3-2-1-添加配置到Nacos"><a href="#3-2-1-添加配置到Nacos" class="headerlink" title="3.2.1.添加配置到Nacos"></a>3.2.1.添加配置到Nacos</h3><p>首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：</p>
<p><img src="169811723288631.png" alt="img"></p>
<p>注意文件的dataId格式：</p>
<pre class="line-numbers language-Plain" data-language="Plain"><code class="language-Plain">[服务名]-[spring.active.profile].[后缀名]</code></pre>

<p>文件名称由三部分组成：</p>
<ul>
<li>**<code>服务名</code>**：我们是购物车服务，所以是<code>cart-service</code></li>
<li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li>
<li>**<code>后缀名</code>**：例如yaml</li>
</ul>
<p>这里我们直接使用<code>cart-service.yaml</code>这个名称，则不管是dev还是local环境都可以共享该配置。</p>
<p>配置内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:
  cart:
    maxAmount: 1 # 购物车商品数量上限</code></pre>

<p>提交配置，在控制台能看到新添加的配置：</p>
<p><img src="169811723288632.png" alt="img"></p>
<h3 id="3-2-2-配置热更新"><a href="#3-2-2-配置热更新" class="headerlink" title="3.2.2.配置热更新"></a>3.2.2.配置热更新</h3><p>接着，我们在微服务中读取配置，实现配置热更新。</p>
<p>在<code>cart-service</code>中新建一个属性读取类：</p>
<p><img src="169811723288633.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "hm.cart")
public class CartProperties {
    private Integer maxAmount;
}</code></pre>

<p>接着，在业务中使用该属性加载类：</p>
<p><img src="169811723288634.png" alt="img"></p>
<p>测试，向购物车中添加多个商品：</p>
<p><img src="169811723288635.png" alt="img"></p>
<p>我们在nacos控制台，将购物车上限配置为5：</p>
<p><img src="169811723288636.png" alt="img"></p>
<p>无需重启，再次测试购物车功能：</p>
<p><img src="169811723288637.png" alt="img"></p>
<p>加入成功！</p>
<p>无需重启服务，配置热更新就生效了！</p>
<h2 id="3-3-动态路由（少用）"><a href="#3-3-动态路由（少用）" class="headerlink" title="3.3.动态路由（少用）"></a>3.3.动态路由（少用）</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p>
<p><img src="image-20231025172754428.png" alt="image-20231025172754428"></p>
<p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p>
<ul>
<li>如何监听Nacos配置变更？</li>
<li>如何把路由信息更新到路由表？</li>
</ul>
<h3 id="3-3-1-监听Nacos配置变更"><a href="#3-3-1-监听Nacos配置变更" class="headerlink" title="3.3.1.监听Nacos配置变更"></a>3.3.1.监听Nacos配置变更</h3><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：</p>
<p><a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p>
<p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void addListener(String dataId, String group, Listener listener)</code></pre>

<p>请求参数说明：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数名</strong></th>
<th align="center"><strong>参数类型</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">dataId</td>
<td align="center">string</td>
<td align="center">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节。</td>
</tr>
<tr>
<td align="center">group</td>
<td align="center">string</td>
<td align="center">配置分组，一般是默认的DEFAULT_GROUP。</td>
</tr>
<tr>
<td align="center">listener</td>
<td align="center">Listener</td>
<td align="center">监听器，配置变更进入监听器的回调函数。</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String serverAddr = "{serverAddr}";
String dataId = "{dataId}";
String group = "{group}";
// 1.创建ConfigService，连接Nacos
Properties properties = new Properties();
properties.put("serverAddr", serverAddr);
ConfigService configService = NacosFactory.createConfigService(properties);
// 2.读取配置
String content = configService.getConfig(dataId, group, 5000);
// 3.添加配置监听器
configService.addListener(dataId, group, new Listener() {
        @Override
        public void receiveConfigInfo(String configInfo) {
        // 配置变更的通知处理
                System.out.println("recieve1:" + configInfo);
        }
        @Override
        public Executor getExecutor() {
                return null;
        }
});</code></pre>

<p>这里核心的步骤有2步：</p>
<ul>
<li>创建ConfigService，目的是连接到Nacos</li>
<li>添加配置监听器，编写配置变更的通知处理逻辑</li>
</ul>
<p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p>
<p><img src="169811723288638.png" alt="img"></p>
<p>NacosConfigManager中是负责管理Nacos的ConfigService的，具体代码如下：</p>
<p><img src="169811723288639.png" alt="img"></p>
<p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p>
<p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String getConfigAndSignListener(
    String dataId, // 配置文件id
    String group, // 配置组，走默认
    long timeoutMs, // 读取配置的超时时间
    Listener listener // 监听器
) throws NacosException;</code></pre>

<p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p>
<h3 id="3-3-2-更新路由"><a href="#3-3-2-更新路由" class="headerlink" title="3.3.2.更新路由"></a>3.3.2.更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package org.springframework.cloud.gateway.route;

import reactor.core.publisher.Mono;

/**
 * @author Spencer Gibb
 */
public interface RouteDefinitionWriter {
        /**
     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由
     */
        Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route);
        /**
     * 根据路由id删除某个路由
     */
        Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId);

}</code></pre>

<p>这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：</p>
<ul>
<li>id：路由id</li>
<li>predicates：路由匹配规则</li>
<li>filters：路由过滤器</li>
<li>uri：路由目的地</li>
</ul>
<p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p>
<pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{
  "id": "item",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}
  }],
  "filters": [],
  "uri": "lb://item-service"
}</code></pre>

<p>以上JSON配置就等同于：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    gateway:
      routes:
        - id: item
          uri: lb://item-service
          predicates:
            - Path=/items/**,/search/**</code></pre>

<p>OK，我们所需要用到的SDK已经齐全了。</p>
<h3 id="3-3-3-实现动态路由"><a href="#3-3-3-实现动态路由" class="headerlink" title="3.3.3.实现动态路由"></a>3.3.3.实现动态路由</h3><p>首先， 我们在网关gateway引入依赖：</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--统一配置管理--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--加载bootstrap--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: 192.168.150.101
      config:
        file-extension: yaml
        shared-configs:
          - dataId: shared-log.yaml # 共享日志配置</code></pre>

<p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8080 # 端口
hm:
  jwt:
    location: classpath:hmall.jks # 秘钥地址
    alias: hmall # 秘钥别名
    password: hmall123 # 秘钥文件密码
    tokenTTL: 30m # 登录有效期
  auth:
    excludePaths: # 无需登录校验的路径
      - /search/**
      - /users/login
      - /items/**</code></pre>

<p>然后，在<code>gateway</code>中定义配置监听器：</p>
<p><img src="169811723288640.png" alt="img"></p>
<p>其代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway.route;

import cn.hutool.json.JSONUtil;
import com.alibaba.cloud.nacos.NacosConfigManager;
import com.alibaba.nacos.api.config.listener.Listener;
import com.alibaba.nacos.api.exception.NacosException;
import com.hmall.common.utils.CollUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.route.RouteDefinition;
import org.springframework.cloud.gateway.route.RouteDefinitionWriter;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import javax.annotation.PostConstruct;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executor;

@Slf4j
@Component
@RequiredArgsConstructor
public class DynamicRouteLoader {

    private final RouteDefinitionWriter writer;
    private final NacosConfigManager nacosConfigManager;

    // 路由配置文件的id和分组
    private final String dataId = "gateway-routes.json";
    private final String group = "DEFAULT_GROUP";
    // 保存更新过的路由id
    private final Set&lt;String&gt; routeIds = new HashSet&lt;&gt;();

    @PostConstruct
    public void initRouteConfigListener() throws NacosException {
        // 1.注册监听器并首次拉取配置
        String configInfo = nacosConfigManager.getConfigService()
                .getConfigAndSignListener(dataId, group, 5000, new Listener() {
                    @Override
                    public Executor getExecutor() {
                        return null;
                    }

                    @Override
                    public void receiveConfigInfo(String configInfo) {
                        updateConfigInfo(configInfo);
                    }
                });
        // 2.首次启动时，更新一次配置
        updateConfigInfo(configInfo);
    }

    private void updateConfigInfo(String configInfo) {
        log.debug("监听到路由配置变更，{}", configInfo);
        // 1.反序列化
        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);
        // 2.更新前先清空旧路由
        // 2.1.清除旧路由
        for (String routeId : routeIds) {
            writer.delete(Mono.just(routeId)).subscribe();
        }
        routeIds.clear();
        // 2.2.判断是否有新的路由要更新
        if (CollUtils.isEmpty(routeDefinitions)) {
            // 无新路由配置，直接结束
            return;
        }
        // 3.更新路由
        routeDefinitions.forEach(routeDefinition -&gt; {
            // 3.1.更新路由
            writer.save(Mono.just(routeDefinition)).subscribe();
            // 3.2.记录路由id，方便将来删除
            routeIds.add(routeDefinition.getId());
        });
    }
}</code></pre>

<p>重启网关，任意访问一个接口，比如 <a target="_blank" rel="noopener" href="http://localhost:8080/search/list?pageNo=1&amp;pageSize=1%EF%BC%9A">http://localhost:8080/search/list?pageNo=1&amp;pageSize=1：</a></p>
<p><img src="169811723288741.png" alt="img"></p>
<p>发现是404，无法访问。</p>
<p>接下来，我们直接在Nacos控制台添加路由，路由文件名为<code>gateway-routes.json</code>，类型为<code>json</code>：</p>
<p><img src="169811723288742.png" alt="img"></p>
<p>配置内容如下：</p>
<pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">[
    {
        "id": "item",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}
        }],
        "filters": [],
        "uri": "lb://item-service"
    },
    {
        "id": "cart",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/carts/**"}
        }],
        "filters": [],
        "uri": "lb://cart-service"
    },
    {
        "id": "user",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/users/**", "_genkey_1":"/addresses/**"}
        }],
        "filters": [],
        "uri": "lb://user-service"
    },
    {
        "id": "trade",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/orders/**"}
        }],
        "filters": [],
        "uri": "lb://trade-service"
    },
    {
        "id": "pay",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/pay-orders/**"}
        }],
        "filters": [],
        "uri": "lb://pau-service"
    }
]</code></pre>

<p>无需重启网关，稍等几秒钟后，再次访问刚才的地址：</p>
<p><img src="169811723288743.png" alt="img"></p>
<p>网关路由成功了！</p>
<h1 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h1><p>将项目一拆分为一个微服务项目，并完成下列需求：</p>
<ul>
<li>基于OpenFeign实现服务间远程调用</li>
<li>定义网关，实现对微服务的请求路由</li>
<li>基于网关实现登录用户校验和用户信息传递</li>
</ul>
<p>以苍穹外卖为例，项目可以拆分为：</p>
<ul>
<li>业务服务：<ul>
<li>用户服务：用户、地址、登录等相关业务</li>
<li>产品服务：店铺、分类、菜品、套餐等业务</li>
<li>交易服务：订单、购物车业务</li>
<li>数据服务：工作台、报表统计等业务</li>
</ul>
</li>
<li>基础服务：<ul>
<li>支付服务：支付相关业务</li>
<li>文件服务：文件上传功能</li>
</ul>
</li>
</ul>
<h1 id="0-导言"><a href="#0-导言" class="headerlink" title="0.导言"></a>0.导言</h1><p>在微服务远程调用的过程中，还存在几个问题需要解决。</p>
<p>首先是<strong>业务健壮性</strong>问题：</p>
<p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p>
<p>还有<strong>级联失败</strong>问题：</p>
<p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p>
<p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p>
<p><img src="image-20231026154315958.png" alt="image-20231026154315958"></p>
<p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p>
<p><img src="image-20231026154336858.png" alt="image-20231026154336858"></p>
<p>这就是<strong>级联失败</strong>问题，或者叫<strong>雪崩</strong>问题。</p>
<p>还有跨服务的事务问题：</p>
<p>比如昨天讲到过的下单业务，下单的过程中需要调用多个微服务：</p>
<ul>
<li>商品服务：扣减库存</li>
<li>订单服务：保存订单</li>
<li>购物车服务：清理购物车</li>
</ul>
<p>这些业务全部都是数据库的写操作，我们必须确保所有操作的同时成功或失败。但是这些操作在不同微服务，也就是不同的Tomcat，这样的情况如何确保事务特性呢？</p>
<p>这些问题都会在今天找到答案。</p>
<p>今天的内容会分成几部分：</p>
<ul>
<li>微服务保护<ul>
<li>服务保护方案</li>
<li>请求限流</li>
<li>隔离和熔断</li>
</ul>
</li>
<li>分布式事务<ul>
<li>初识分布式事务</li>
<li>Seata</li>
</ul>
</li>
</ul>
<p>通过今天的学习，你将能掌握下面的能力：</p>
<ul>
<li>知道雪崩问题产生原因及常见解决方案</li>
<li>能使用Sentinel实现服务保护</li>
<li>理解分布式事务产生的原因</li>
<li>能使用Seata解决分布式事务问题</li>
<li>理解AT模式基本原理</li>
</ul>
<h1 id="1-微服务保护"><a href="#1-微服务保护" class="headerlink" title="1.微服务保护"></a>1.微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。这章我们就一起来学习一下微服务保护的常见方案以及对应的技术。</p>
<h2 id="1-1-服务保护方案"><a href="#1-1-服务保护方案" class="headerlink" title="1.1.服务保护方案"></a>1.1.服务保护方案</h2><p>微服务保护的方案有很多，比如：</p>
<ul>
<li>请求限流</li>
<li>线程隔离</li>
<li>服务熔断</li>
</ul>
<p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p>
<p>接下来，我们就逐一了解这些方案的原理。</p>
<h3 id="1-1-1-请求限流"><a href="#1-1-1-请求限流" class="headerlink" title="1.1.1.请求限流"></a>1.1.1.请求限流</h3><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p>
<p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p>
<p><img src="169830613916752.jpeg" alt="img"></p>
<h3 id="1-1-2-线程隔离"><a href="#1-1-2-线程隔离" class="headerlink" title="1.1.2.线程隔离"></a>1.1.2.线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口收到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p>
<p>线程隔离的思想来自轮船的舱壁模式：</p>
<p><img src="16983061391081.png" alt="img"></p>
<p>轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没。</p>
<p>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。</p>
<h3 id="1-1-3-服务熔断"><a href="#1-1-3-服务熔断" class="headerlink" title="1.1.3.服务熔断"></a>1.1.3.服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。</p>
<p>所以，我们要做两件事情：</p>
<ul>
<li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li>
<li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li>
</ul>
<p>暂时无法在飞书文档外展示此内容</p>
<h2 id="1-2-Sentinel"><a href="#1-2-Sentinel" class="headerlink" title="1.2.Sentinel"></a>1.2.Sentinel</h2><p>微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel，所以接下来我们学习Sentinel的使用。</p>
<h3 id="1-2-1-介绍和安装"><a href="#1-2-1-介绍和安装" class="headerlink" title="1.2.1.介绍和安装"></a>1.2.1.介绍和安装</h3><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。官方网站：</p>
<p><a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/">https://sentinelguard.io/zh-cn/</a></p>
<p>Sentinel 的使用可以分为两个部分:</p>
<ul>
<li><strong>核心库</strong>（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li>
<li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li>
</ul>
<p>为了方便监控微服务，我们先把Sentinel的控制台搭建出来。</p>
<p>1）下载jar包</p>
<p>下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p>
<p>也可以直接使用课前资料提供的版本：</p>
<p><img src="16983061391092.png" alt="img"></p>
<p>2）运行</p>
<p>将jar包放在任意非中文、不包含特殊字符的目录下，重命名为<code>sentinel-dashboard.jar</code>：</p>
<p><img src="16983061391093.png" alt="img"></p>
<p>然后运行如下命令启动控制台：</p>
<pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</code></pre>

<p>其它启动时可配置参数可参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9</a></p>
<p>3）访问</p>
<p>访问<a href="http://localhost:8090页面，就可以看到sentinel的控制台了：">http://localhost:8090页面，就可以看到sentinel的控制台了：</a></p>
<p><img src="16983061391104.png" alt="img"></p>
<p>需要输入账号和密码，默认都是：sentinel</p>
<p>登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身：</p>
<p><img src="16983061391105.png" alt="img"></p>
<h3 id="1-2-2-微服务整合"><a href="#1-2-2-微服务整合" class="headerlink" title="1.2.2.微服务整合"></a>1.2.2.微服务整合</h3><p>我们在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台，步骤如下： 1）引入sentinel依赖</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--sentinel--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; 
    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<p>2）配置控制台</p>
<p>修改application.yaml文件，添加下面内容：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090</code></pre>

<p>3）访问<code>cart-service</code>的任意端点</p>
<p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息：</p>
<p><img src="16983061391106.png" alt="img"></p>
<p>点击簇点链路菜单，会看到下面的页面：</p>
<p><img src="16983061391117.png" alt="img"></p>
<p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）。</p>
<p>因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p>
<p>不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径：</p>
<p><img src="16983061391128.png" alt="img"></p>
<p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p>
<p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p>
<p>首先，在<code>cart-service</code>的<code>application.yml</code>中添加下面的配置：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
      http-method-specify: true # 开启请求方式前缀</code></pre>

<p>然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化：</p>
<p><img src="16983061391129.png" alt="img"></p>
<h2 id="1-3-请求限流"><a href="#1-3-请求限流" class="headerlink" title="1.3.请求限流"></a>1.3.请求限流</h2><p>在簇点链路后面点击流控按钮，即可对其做限流配置：</p>
<p><img src="169830613911310.png" alt="img"></p>
<p>在弹出的菜单中这样填写：</p>
<p><img src="169830613911311.png" alt="img"></p>
<p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p>
<p>我们利用Jemeter做限流测试，我们每秒发出10个请求：</p>
<p><img src="169830613911312.png" alt="img"></p>
<p>最终监控结果如下：</p>
<p><img src="169830613911313.png" alt="img"></p>
<p>可以看出<code>GET:/carts</code>这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合我们的预期。</p>
<h2 id="1-4-线程隔离"><a href="#1-4-线程隔离" class="headerlink" title="1.4.线程隔离"></a>1.4.线程隔离</h2><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p>
<p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：</p>
<p><img src="image-20231028105727235.png" alt="image-20231028105727235"></p>
<p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p>
<p>所以，我们要对查询商品的FeignClient接口做线程隔离。</p>
<h3 id="1-4-1-OpenFeign整合Sentinel"><a href="#1-4-1-OpenFeign整合Sentinel" class="headerlink" title="1.4.1.OpenFeign整合Sentinel"></a>1.4.1.OpenFeign整合Sentinel</h3><p>修改cart-service模块的application.yml文件，开启Feign的sentinel功能：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">feign:
  sentinel:
    enabled: true # 开启feign对sentinel的支持</code></pre>

<p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源：</p>
<p><img src="169830613911314.png" alt="img"></p>
<h3 id="1-4-2-配置线程隔离"><a href="#1-4-2-配置线程隔离" class="headerlink" title="1.4.2.配置线程隔离"></a>1.4.2.配置线程隔离</h3><p>接下来，点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p>
<p><img src="169830613911415.png" alt="img"></p>
<p>在弹出的表单中填写下面内容：</p>
<p><img src="169830613911416.png" alt="img"></p>
<p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p>
<p><img src="169830613911417.png" alt="img"></p>
<p>我们利用Jemeter测试，每秒发送100个请求：</p>
<p><img src="169830613911418.png" alt="img"></p>
<p>最终测试结果如下：</p>
<p><img src="169830613911419.png" alt="img"></p>
<p>进入查询购物车的请求每秒大概在100，而在查询商品时却只剩下每秒10左右，符合我们的预期。</p>
<p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现不受影响：</p>
<p><img src="169830613911420.png" alt="img"></p>
<p>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响到其它接口。</p>
<h2 id="1-5-服务熔断"><a href="#1-5-服务熔断" class="headerlink" title="1.5.服务熔断"></a>1.5.服务熔断</h2><p>在上节课，我们利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了500毫秒延时），再加上线程隔离限定了线程数为5，导致接口吞吐能力有限，最终QPS只有10左右。这就导致了几个问题：</p>
<p>第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p>
<p>第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p>
<h3 id="1-5-1-编写降级逻辑"><a href="#1-5-1-编写降级逻辑" class="headerlink" title="1.5.1.编写降级逻辑"></a>1.5.1.编写降级逻辑</h3><p>触发限流或熔断后的请求不一定要直接报错，也可以<strong>返回一些默认数据或者友好提示</strong>，用户体验会更好。</p>
<p>给FeignClient编写失败后的降级逻辑有两种方式：</p>
<ul>
<li>方式一：FallbackClass，无法对远程调用的异常做处理</li>
<li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li>
</ul>
<p>这里我们演示方式二的失败降级处理。</p>
<p><strong>步骤一</strong>：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code>：</p>
<p><img src="169830613911421.png" alt="img"></p>
<p>代码如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.client.fallback;

import com.hmall.api.client.ItemClient;
import com.hmall.api.dto.ItemDTO;
import com.hmall.api.dto.OrderDetailDTO;
import com.hmall.common.exception.BizIllegalException;
import com.hmall.common.utils.CollUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.openfeign.FallbackFactory;

import java.util.Collection;
import java.util.List;

@Slf4j
public class ItemClientFallback implements FallbackFactory&lt;ItemClient&gt; {
    // 自己实现一个FeignClient ItemClient.
    // 正常时会调用ItemClient，异常是会调用此fallback
    @Override
    public ItemClient create(Throwable cause) {
        return new ItemClient() {
            @Override
            public List&lt;ItemDTO&gt; queryItemByIds(Collection&lt;Long&gt; ids) {
                log.error("远程调用ItemClient#queryItemByIds方法出现异常，参数：{}", ids, cause);
                // 查询购物车允许失败，查询失败，返回空集合
                return CollUtils.emptyList();
            }

            @Override
            public void deductStock(List&lt;OrderDetailDTO&gt; items) {
                // 库存扣减业务需要触发事务回滚，查询失败，抛出异常
                throw new BizIllegalException(cause);
            }
        };
    }
}</code></pre>

<p><strong>步骤二</strong>：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code>：</p>
<p><img src="169830613911522.png" alt="img"></p>
<p><strong>步骤三</strong>：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code>：</p>
<p><img src="169830613911523.png" alt="img"></p>
<p>重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑：</p>
<p><img src="169830613911524.png" alt="img"></p>
<p>但是未被限流的请求延时依然很高：</p>
<p><img src="169830613911525.png" alt="img"></p>
<p>导致最终的平局响应时间较长。</p>
<h3 id="1-5-2-服务熔断"><a href="#1-5-2-服务熔断" class="headerlink" title="1.5.2.服务熔断"></a>1.5.2.服务熔断</h3><p>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。</p>
<p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了。</p>
<p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p>
<p>断路器的工作状态切换有一个状态机来控制：</p>
<p><img src="image-20231029111402854.png" alt="image-20231029111402854"></p>
<p>状态机包括三个状态：</p>
<ul>
<li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li>
<li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li>
<li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul>
<li>请求成功：则切换到closed状态</li>
<li>请求失败：则切换到open状态</li>
</ul>
</li>
</ul>
<p>我们可以在控制台通过点击簇点后的**<code>熔断</code>**按钮来配置熔断策略：</p>
<p><img src="169830613911526.png" alt="img"></p>
<p>在弹出的表格中这样填写：</p>
<p><img src="169830613911827.png" alt="img"></p>
<p>这种是按照慢调用比例来做熔断，上述配置的含义是：</p>
<ul>
<li>RT超过200毫秒的请求调用就是慢调用</li>
<li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li>
<li>熔断持续时长20s</li>
</ul>
<p>配置完成后，再次利用Jemeter测试，可以发现：</p>
<p><img src="169830613911828.png" alt="img"></p>
<p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响。</p>
<p>此时整个购物车查询服务的平均RT影响不大：</p>
<p><img src="169830613911829.png" alt="img"></p>
<h1 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2.分布式事务"></a>2.分布式事务</h1><p>首先我们看看项目中的下单业务整体流程：</p>
<p><img src="image-20231029114703860.png" alt="image-20231029114703860"></p>
<p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</p>
<ul>
<li>交易服务：下单事务</li>
<li>购物车服务：清理购物车事务</li>
<li>库存服务：扣减库存事务</li>
</ul>
<p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败。</p>
<p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？</p>
<p>我们来做一个测试，先进入购物车页面：</p>
<p><img src="169830613911830.png" alt="img"></p>
<p>目前有4个购物车，然结算下单，进入订单结算页面：</p>
<p><img src="169830613911931.png" alt="img"></p>
<p>然后将购物车中某个商品的库存修改为<code>0</code>：</p>
<p><img src="169830613911932.png" alt="img"></p>
<p>然后，提交订单，最终因库存不足导致下单失败：</p>
<p><img src="169830613911933.png" alt="img"></p>
<p>然后我们去查看购物车列表，发现购物车数据依然被清空了，并未回滚：</p>
<p><img src="169830613911934.png" alt="img"></p>
<p>事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了。</p>
<p>这就是分布式事务问题，出现以下情况之一就可能产生分布式事务问题：</p>
<ul>
<li>业务跨多个服务实现</li>
<li>业务跨多个数据源实现</li>
</ul>
<p>接下来这一章我们就一起来研究下如何解决分布式事务问题。</p>
<h2 id="2-1-认识Seata"><a href="#2-1-认识Seata" class="headerlink" title="2.1.认识Seata"></a>2.1.认识Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的Seata了。</p>
<p><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p>
<p>就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p>
<p>Seata也不例外，在Seata的事务管理中有三个重要的角色：</p>
<ul>
<li><strong>TC</strong> <strong>(Transaction Coordinator) - 事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。 </li>
<li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li>
<li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>Seata的工作架构如图所示：</p>
<p><img src="169830613911935.png" alt="img"></p>
<p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p>
<p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p>
<h2 id="2-2-部署TC服务"><a href="#2-2-部署TC服务" class="headerlink" title="2.2.部署TC服务"></a>2.2.部署TC服务</h2><h3 id="2-2-1-准备数据库表"><a href="#2-2-1-准备数据库表" class="headerlink" title="2.2.1.准备数据库表"></a>2.2.1.准备数据库表</h3><p>Seata支持多种存储模式，但考虑到持久化的需要，我们一般选择基于数据库存储。执行课前资料提供的<code>《seata-tc.sql》</code>，导入数据库表：</p>
<p><img src="169830613911936.png" alt="img"></p>
<h3 id="2-2-2-准备配置文件"><a href="#2-2-2-准备配置文件" class="headerlink" title="2.2.2.准备配置文件"></a>2.2.2.准备配置文件</h3><p>课前资料准备了一个seata目录，其中包含了seata运行时所需要的配置文件：</p>
<p><img src="169830613912037.png" alt="img"></p>
<p>其中包含中文注释，大家可以自行阅读。</p>
<p>我们将整个seata文件夹拷贝到虚拟机的<code>/root</code>目录：</p>
<p><img src="169830613912038.png" alt="img"></p>
<h3 id="2-2-3-Docker部署"><a href="#2-2-3-Docker部署" class="headerlink" title="2.2.3.Docker部署"></a>2.2.3.Docker部署</h3><p>在虚拟机的<code>/root</code>目录执行下面的命令：</p>
<pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker run --name seata \
-p 8099:8099 \
-p 7099:7099 \
-e SEATA_IP=192.168.150.101 \
-v ./seata:/seata-server/resources \
--privileged=true \
--network hmall \
-d \
seataio/seata-server:1.5.2</code></pre>

<p>如果镜像下载困难，也可以把课前资料提供的镜像上传到虚拟机并加载：</p>
<p><img src="169830613912039.png" alt="img"></p>
<h2 id="2-3-微服务集成Seata"><a href="#2-3-微服务集成Seata" class="headerlink" title="2.3.微服务集成Seata"></a>2.3.微服务集成Seata</h2><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p>
<h3 id="2-3-1-引入依赖"><a href="#2-3-1-引入依赖" class="headerlink" title="2.3.1.引入依赖"></a>2.3.1.引入依赖</h3><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此<code>trade-service</code>模块不仅仅要引入seata依赖，还要引入nacos依赖:</p>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--统一配置管理--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;!--读取bootstrap文件--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;!--seata--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;!--sentinel--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
  &lt;/dependency&gt;</code></pre>

<h3 id="2-3-2-改造配置"><a href="#2-3-2-改造配置" class="headerlink" title="2.3.2.改造配置"></a>2.3.2.改造配置</h3><p>首先在nacos上添加一个共享的seata配置（避免重复配置），命名为<code>shared-seata.yaml</code>：</p>
<p><img src="169830613912140.png" alt="img"></p>
<p>内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">seata:
  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址
    type: nacos # 注册中心类型 nacos
    nacos:
      server-addr: 192.168.150.101:8848 # nacos地址
      namespace: "" # namespace，默认为空
      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP
      application: seata-server # seata服务名称
      username: nacos
      password: nacos
  tx-service-group: hmall # 事务组名称
  service:
    vgroup-mapping: # 事务组与tc集群的映射关系
      hmall: "default"</code></pre>

<p><img src="image-20231029121147697.png" alt="image-20231029121147697"></p>
<p>然后，改造<code>trade-service</code>模块，添加<code>bootstrap.yaml</code>：</p>
<p><img src="169830613912141.png" alt="img"></p>
<p>内容如下:</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:
  application:
    name: trade-service # 服务名称
  profiles:
    active: dev
  cloud:
    nacos:
      server-addr: 192.168.150.101 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
        shared-configs: # 共享配置
          - dataId: shared-jdbc.yaml # 共享mybatis配置
          - dataId: shared-log.yaml # 共享日志配置
          - dataId: shared-swagger.yaml # 共享日志配置
          - dataId: shared-seata.yaml # 共享seata配置</code></pre>

<p>可以看到这里加载了共享的seata配置。</p>
<p>然后改造application.yaml文件，内容如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:
  port: 8085
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
  sentinel:
    enabled: true # 开启Feign对Sentinel的整合
hm:
  swagger:
    title: 交易服务接口文档
    package: com.hmall.trade.controller
  db:
    database: hm-trade</code></pre>

<p>参考上述办法分别改造<code>hm-cart</code>和<code>hm-item</code>两个微服务模块。</p>
<h3 id="2-3-3-添加数据库表"><a href="#2-3-3-添加数据库表" class="headerlink" title="2.3.3.添加数据库表"></a>2.3.3.添加数据库表</h3><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。</p>
<p>将课前资料的seata-at.sql分别文件导入hm-trade、hm-cart、hm-item三个数据库中：</p>
<p><img src="169830613912142.png" alt="img"></p>
<p>结果：</p>
<p><img src="169830613912143.png" alt="img"></p>
<p>OK，至此为止，微服务整合的工作就完成了。可以参考上述方式对<code>hm-item</code>和<code>hm-cart</code>模块完成整合改造。</p>
<h3 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4.测试"></a>2.3.4.测试</h3><p>接下来就是测试的分布式事务的时候了。</p>
<p>我们找到<code>trade-service</code>模块下的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类中的<code>createOrder</code>方法，也就是下单业务方法。</p>
<p>将其上的<code>@Transactional</code>注解改为Seata提供的<code>@GlobalTransactional</code>：</p>
<p><img src="169830613912244.png" alt="img"></p>
<p><code>@GlobalTransactional</code>注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</p>
<p>我们重启<code>trade-service</code>、<code>item-service</code>、<code>cart-service</code>三个服务。再次测试，发现分布式事务的问题解决了！</p>
<p>那么，Seata是如何解决分布式事务的呢？</p>
<h2 id="2-4-XA模式"><a href="#2-4-XA模式" class="headerlink" title="2.4.XA模式"></a>2.4.XA模式</h2><p>Seata支持四种不同的分布式事务解决方案：</p>
<ul>
<li><strong>XA</strong></li>
<li><strong>TCC</strong></li>
<li><strong>AT</strong></li>
<li><strong>SAGA</strong></li>
</ul>
<p>这里我们以<code>XA</code>模式和<code>AT</code>模式来给大家讲解其实现原理。</p>
<p><code>XA</code> 规范 是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p>
<h3 id="2-4-1-两阶段提交"><a href="#2-4-1-两阶段提交" class="headerlink" title="2.4.1.两阶段提交"></a>2.4.1.两阶段提交</h3><p>A是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p>
<p>正常情况：</p>
<p><img src="169830613912245.png" alt="img"></p>
<p>异常情况：</p>
<p><img src="169830613912246.png" alt="img"></p>
<p>一阶段：</p>
<ul>
<li>事务协调者通知每个事务参与者执行本地事务</li>
<li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li>
</ul>
<p>二阶段：</p>
<ul>
<li>事务协调者基于一阶段的报告来判断下一步操作</li>
<li>如果一阶段都成功，则通知所有事务参与者，提交事务</li>
<li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li>
</ul>
<h3 id="2-4-2-Seata的XA模型"><a href="#2-4-2-Seata的XA模型" class="headerlink" title="2.4.2.Seata的XA模型"></a>2.4.2.Seata的XA模型</h3><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p>
<p><img src="169830613912447.png" alt="img"></p>
<p><code>RM</code>一阶段的工作：</p>
<ol>
<li>注册分支事务到<code>TC</code></li>
<li>执行分支业务sql但不提交</li>
<li>报告执行状态到<code>TC</code></li>
</ol>
<p><code>TC</code>二阶段的工作：</p>
<ol>
<li><code>TC</code>检测各分支事务执行状态<ol>
<li>如果都成功，通知所有RM提交事务</li>
<li>如果有失败，通知所有RM回滚事务</li>
</ol>
</li>
</ol>
<p><code>RM</code>二阶段的工作：</p>
<ul>
<li>接收<code>TC</code>指令，提交或回滚事务</li>
</ul>
<h3 id="2-4-3-优缺点"><a href="#2-4-3-优缺点" class="headerlink" title="2.4.3.优缺点"></a>2.4.3.优缺点</h3><p><code>XA</code>模式的优点是什么？</p>
<ul>
<li>事务的强一致性，满足ACID原则</li>
<li>常用数据库都支持，实现简单，并且没有代码侵入</li>
</ul>
<p><code>XA</code>模式的缺点是什么？</p>
<ul>
<li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li>
<li>依赖关系型数据库实现事务</li>
</ul>
<h2 id="2-5-AT模式"><a href="#2-5-AT模式" class="headerlink" title="2.5.AT模式"></a>2.5.AT模式</h2><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p>
<h3 id="2-5-1-Seata的AT模型"><a href="#2-5-1-Seata的AT模型" class="headerlink" title="2.5.1.Seata的AT模型"></a>2.5.1.Seata的AT模型</h3><p>基本流程图：</p>
<p><img src="169830613912448.png" alt="img"></p>
<p>阶段一<code>RM</code>的工作：</p>
<ul>
<li>注册分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ul>
<p>阶段二提交时<code>RM</code>的工作：</p>
<ul>
<li>删除undo-log即可</li>
</ul>
<p>阶段二回滚时<code>RM</code>的工作：</p>
<ul>
<li>根据undo-log恢复数据到更新前</li>
</ul>
<h3 id="2-5-2-流程梳理"><a href="#2-5-2-流程梳理" class="headerlink" title="2.5.2.流程梳理"></a>2.5.2.流程梳理</h3><p>我们用一个真实的业务来梳理下AT模式的原理。</p>
<p>比如，现在有一个数据库表，记录用户余额：</p>
<table>
<thead>
<tr>
<th align="center"><strong>id</strong></th>
<th align="center"><strong>money</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">100</td>
</tr>
</tbody></table>
<p>其中一个分支业务要执行的SQL为：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">update tb_account set money = money - 10 where id = 1</code></pre>

<p>AT模式下，当前分支事务执行流程如下：</p>
<p><strong>一阶段</strong>：</p>
<ol>
<li><code>TM</code>发起并注册全局事务到<code>TC</code></li>
<li><code>TM</code>调用分支事务</li>
<li>分支事务准备执行业务SQL</li>
<li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li>
</ol>
<pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{
  "id": 1, "money": 100
}</code></pre>

<ol>
<li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90</li>
<li><code>RM</code>报告本地事务状态给<code>TC</code></li>
</ol>
<p><strong>二阶段</strong>：</p>
<ol>
<li><code>TM</code>通知<code>TC</code>事务结束</li>
<li><code>TC</code>检查分支事务状态<ol>
<li>如果都成功，则立即删除快照</li>
<li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li>
</ol>
</li>
</ol>
<p>流程图：</p>
<p><img src="169830613912549.png" alt="img"></p>
<h3 id="2-5-3-AT与XA的区别"><a href="#2-5-3-AT与XA的区别" class="headerlink" title="2.5.3.AT与XA的区别"></a>2.5.3.AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p>
<ul>
<li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li>
<li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li>
<li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li>
</ul>
<p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。</p>
<h1 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h1><h2 id="3-1-编写降级逻辑"><a href="#3-1-编写降级逻辑" class="headerlink" title="3.1.编写降级逻辑"></a>3.1.编写降级逻辑</h2><p>给黑马商城中现有的FeignClient都编写对应的降级逻辑，并且改造项目中每一个微服务，将OpenFeign与Sentinel整合。</p>
<h2 id="3-2-解决分布式事务"><a href="#3-2-解决分布式事务" class="headerlink" title="3.2.解决分布式事务"></a>3.2.解决分布式事务</h2><p>除了下单业务以外，用户如果选择余额支付，前端会将请求发送到pay-service模块。而这个模块要做三件事情：</p>
<ul>
<li>直接从user-service模块调用接口，扣除余额付款</li>
<li>更新本地（pay-service）交易流水表状态</li>
<li>通知交易服务（trade-service）更新其中的业务订单状态</li>
</ul>
<p>流程如图：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>显然，这里也存在分布式事务问题。</p>
<p>对应的页面如下：</p>
<p><img src="169830613912550.png" alt="img"></p>
<p>当我们提交订单成功后，进入支付页面，选择余额支付，输入密码后点击确认支付即可。</p>
<p>前端会提交支付请求，业务接口的入口在<code>com.hmall.pay.controller.PayController</code>类的<code>tryPayOrderByBalance</code>方法：</p>
<p><img src="169830613912551.png" alt="img"></p>
<p>对应的service方法如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Override
@Transactional
public void tryPayOrderByBalance(PayOrderDTO payOrderDTO) {
    // 1.查询支付单
    PayOrder po = getById(payOrderDTO.getId());
    // 2.判断状态
    if(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus())){
        // 订单不是未支付，状态异常
        throw new BizIllegalException("交易已支付或关闭！");
    }
    // 3.尝试扣减余额
    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());
    // 4.修改支付单状态
    boolean success = markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());
    if (!success) {
        throw new BizIllegalException("交易已支付或关闭！");
    }
    // 5.修改订单状态
    tradeClient.markOrderPaySuccess(po.getBizOrderNo());
}</code></pre>

<p>利用seata解决这里的分布式事务问题，并思考这个业务实现有没有什么值得改进的地方</p>
 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/10/07/SpringCloud/">https://nan-ying.github.io/2023/10/07/SpringCloud/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/SpringCloud/">
              <span class="chip bg-color">SpringCloud</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-10-07T19-32-28',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/10/15/RabbitMQ/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="RabbitMQ">
                        
                        <span class="card-title">RabbitMQ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-10-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                    微服务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/RabbitMQ/">
                        <span class="chip bg-color">RabbitMQ</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/10/04/Docker/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="Docker">
                        
                        <span class="card-title">Docker</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-10-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                    微服务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2024</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >786.6k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
