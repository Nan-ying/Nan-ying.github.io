<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Spring, Nan-ying&#39;s Blog">
    <meta name="description" content="二、Spring1、Spring简介1.1、Spring概述官网地址：https://spring.io/

Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Spring | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Spring</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/Spring/">
              <span class="chip bg-color">Spring</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/SSM/" class="post-category">
              SSM
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-07-10
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 19.2k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          86 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h1 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h1><h1 id="1、Spring简介"><a href="#1、Spring简介" class="headerlink" title="1、Spring简介"></a>1、Spring简介</h1><h3 id="1-1、Spring概述"><a href="#1-1、Spring概述" class="headerlink" title="1.1、Spring概述"></a>1.1、Spring概述</h3><p>官网地址：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></p>
<blockquote>
<p>Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。</p>
<p>Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。</p>
<p>Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。</p>
<p>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO  编程模型来促进良好的编程实践。</p>
</blockquote>
<h3 id="1-2、Spring家族"><a href="#1-2、Spring家族" class="headerlink" title="1.2、Spring家族"></a>1.2、Spring家族</h3><p>项目列表：<a target="_blank" rel="noopener" href="https://spring.io/projects">https://spring.io/projects</a></p>
<h3 id="1-3、Spring-Framework"><a href="#1-3、Spring-Framework" class="headerlink" title="1.3、Spring Framework"></a>1.3、Spring Framework</h3><p>Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework为基础的。</p>
<h4 id="1-3-1、Spring-Framework特性"><a href="#1-3-1、Spring-Framework特性" class="headerlink" title="1.3.1、Spring Framework特性"></a>1.3.1、Spring Framework特性</h4><ul>
<li><p>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</p>
</li>
<li><p>控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</p>
</li>
<li><p>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</p>
</li>
<li><p>容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</p>
</li>
<li><p>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</p>
</li>
<li><p>声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。</p>
</li>
<li><p>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</p>
</li>
</ul>
<h4 id="1-3-2、Spring-Framework五大功能模块"><a href="#1-3-2、Spring-Framework五大功能模块" class="headerlink" title="1.3.2、Spring Framework五大功能模块"></a>1.3.2、Spring Framework五大功能模块</h4><table>
<thead>
<tr>
<th><strong>功能模块</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>Testing</td>
<td>提供了对 junit 或 TestNG 测试框架的整合。</td>
</tr>
<tr>
<td>Data Access/Integration</td>
<td>提供了对数据访问/集成的功能。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<h1 id="2、IOC"><a href="#2、IOC" class="headerlink" title="2、IOC"></a>2、IOC</h1><h2 id="2-1、IOC容器"><a href="#2-1、IOC容器" class="headerlink" title="2.1、IOC容器"></a>2.1、IOC容器</h2><h3 id="2-1-1、IOC思想"><a href="#2-1-1、IOC思想" class="headerlink" title="2.1.1、IOC思想"></a>2.1.1、IOC思想</h3><p>IOC：Inversion of Control，翻译过来是<strong>反转控制</strong>。</p>
<h4 id="①获取资源的传统方式"><a href="#①获取资源的传统方式" class="headerlink" title="①获取资源的传统方式"></a>①获取资源的传统方式</h4><p>自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。</p>
<p>在应用程序中的组件需要获取资源时，传统的方式是组件<strong>主动</strong>的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</p>
<h4 id="②反转控制方式获取资源"><a href="#②反转控制方式获取资源" class="headerlink" title="②反转控制方式获取资源"></a>②反转控制方式获取资源</h4><p>点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。</p>
<p>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由<strong>容器主动的将资源推送给需要的组件</strong>，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的<strong>被动</strong>形式。</p>
<h4 id="③DI"><a href="#③DI" class="headerlink" title="③DI"></a>③DI</h4><p>DI：Dependency Injection，翻译过来是<strong>依赖注入</strong>。</p>
<p>DI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。</p>
<p>所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。</p>
<blockquote>
<p>IOC 好处见 <strong>2.2.14、实验十四：基于xml的自动装配</strong>：与JavaWeb原生相比</p>
</blockquote>
<h3 id="2-1-2、IOC容器在Spring中的实现"><a href="#2-1-2、IOC容器在Spring中的实现" class="headerlink" title="2.1.2、IOC容器在Spring中的实现"></a>2.1.2、IOC容器在Spring中的实现</h3><p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：</p>
<h4 id="①BeanFactory"><a href="#①BeanFactory" class="headerlink" title="①BeanFactory"></a>①BeanFactory</h4><p>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p>
<h4 id="②ApplicationContext"><a href="#②ApplicationContext" class="headerlink" title="②ApplicationContext"></a>②ApplicationContext</h4><p>BeanFactory 的子接口，提供了更多高级特性。<strong>面向 Spring 的使用者</strong>，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p>
<h4 id="③ApplicationContext的主要实现类"><a href="#③ApplicationContext的主要实现类" class="headerlink" title="③ApplicationContext的主要实现类"></a>③ApplicationContext的主要实现类</h4><p><img src="5.png" alt="5"></p>
<table>
<thead>
<tr>
<th><strong>类型名</strong></th>
<th><strong>简介</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取<strong>类路径下</strong>的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>ConfigurableApplicationContext</td>
<td>ApplicationContext 的子接口，包含一些<strong>扩展方法refresh() 和 close()</strong> ，让ApplicationContext 具有启动、关闭和刷新上下文的能力。</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody></table>
<h2 id="2-2、基于XML管理bean"><a href="#2-2、基于XML管理bean" class="headerlink" title="2.2、基于XML管理bean"></a>2.2、基于XML管理bean</h2><h3 id="2-2-1、实验一：入门案例"><a href="#2-2-1、实验一：入门案例" class="headerlink" title="2.2.1、实验一：入门案例"></a>2.2.1、实验一：入门案例</h3><h4 id="①创建Maven-Module"><a href="#①创建Maven-Module" class="headerlink" title="①创建Maven Module"></a>①创建Maven Module</h4><h4 id="②引入依赖"><a href="#②引入依赖" class="headerlink" title="②引入依赖"></a>②引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

<p><img src="6.png" alt="6"></p>
<h4 id="③创建类HelloWorld"><a href="#③创建类HelloWorld" class="headerlink" title="③创建类HelloWorld"></a>③创建类HelloWorld</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld {
    public void sayHello(){
        System.out.println("helloworld");
    }
}</code></pre>

<p><img src="7.png" alt="7"></p>
<p><img src="8.png" alt="8"></p>
<h4 id="⑤在Spring的配置文件中配置bean"><a href="#⑤在Spring的配置文件中配置bean" class="headerlink" title="⑤在Spring的配置文件中配置bean"></a>⑤在Spring的配置文件中配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--
	配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
	通过bean标签配置IOC容器所管理的bean
	属性：
		id：设置bean的唯一标识
		class：设置bean所对应类型的全类名
--&gt;
&lt;bean id="helloworld" class="com.atguigu.spring.bean.HelloWorld"&gt;&lt;/bean&gt;</code></pre>

<h4 id="⑥创建测试类测试"><a href="#⑥创建测试类测试" class="headerlink" title="⑥创建测试类测试"></a>⑥创建测试类测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testHelloWorld(){
    //获取IOC容器
    ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");
    //获取IOC容器中的bean
    HelloWorld helloworld = (HelloWorld) ioc.getBean("helloworld");
    helloworld.sayHello();
}</code></pre>

<h4 id="⑦思路"><a href="#⑦思路" class="headerlink" title="⑦思路"></a>⑦思路</h4><p><img src="9.png" alt="9"></p>
<h4 id="⑧注意"><a href="#⑧注意" class="headerlink" title="⑧注意"></a>⑧注意</h4><p>Spring 底层默认通过反射技术<strong>调用组件类的无参构造器</strong>来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：</p>
<p><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld. &lt;init&gt;()</code></p>
<h3 id="2-2-2、实验二：获取bean"><a href="#2-2-2、实验二：获取bean" class="headerlink" title="2.2.2、实验二：获取bean"></a>2.2.2、实验二：获取bean</h3><h4 id="①方式一：根据id获取"><a href="#①方式一：根据id获取" class="headerlink" title="①方式一：根据id获取"></a>①方式一：根据id获取</h4><p>由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。</p>
<p>上个实验中我们使用的就是这种方式。</p>
<h4 id="②方式二：根据类型获取"><a href="#②方式二：根据类型获取" class="headerlink" title="②方式二：根据类型获取"></a>②方式二：根据类型获取</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testStudent(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-ioc.xml");
    Student student = ioc.getBean(Student.class);
    System.out.println(student);
}</code></pre>

<p><strong>注意：</strong></p>
<p>当根据类型获取bean时，要求IOC容器中指定类型的bean<strong>有且只能有一个</strong></p>
<ul>
<li>若没有任何一个类型匹配的bean，当IOC容器中一共配置了两个：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentOne" class="com.atguigu.spring.pojo.Student"&gt;&lt;/bean&gt;
&lt;bean id="studentTwo" class="com.atguigu.spring.pojo.Student"&gt;&lt;/bean&gt;</code></pre>

<p>​	此时抛出异常：<code>NoSuchBeanDefinitionException</code></p>
<ul>
<li>若有多个类型匹配的bean，此时抛出异常：<code>NoUniqueBeanDefinitionException</code></li>
</ul>
<p><strong>补充：</strong></p>
<p>==以后获取bean多用方式二==，因为很少会出现一个class类多个不同bean对象的形式，bean默认单例模式，同时也可以通过scope属性切换多例和单例</p>
<h4 id="③方式三：根据id和类型"><a href="#③方式三：根据id和类型" class="headerlink" title="③方式三：根据id和类型"></a>③方式三：根据id和类型</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testStudent(){
    ApplicationContext ioc = newClassPathXmlApplicationContext("applicationContext.xml");
    Student student = ioc.getBean("studentTwo", Student.class);
    System.out.println(student);
}</code></pre>

<h4 id="④扩展"><a href="#④扩展" class="headerlink" title="④扩展"></a>④扩展</h4><p>如果组件类实现了接口，根据接口类型可以获取 bean 吗？</p>
<blockquote>
<p>可以，前提是bean唯一</p>
</blockquote>
<p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？</p>
<blockquote>
<p>不行，因为bean不唯一</p>
</blockquote>
<h4 id="⑤结论"><a href="#⑤结论" class="headerlink" title="⑤结论"></a>⑤结论</h4><p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。</p>
<p>即通过<strong>bean的类型、bean所继承的类的类型、bean所实现的接口的类型</strong>都可以获取bean</p>
<h3 id="2-2-3、实验三：依赖注入之setter注入"><a href="#2-2-3、实验三：依赖注入之setter注入" class="headerlink" title="2.2.3、实验三：依赖注入之setter注入"></a>2.2.3、实验三：依赖注入之setter注入</h3><p>依赖注入，简单来说就是给类的属性进行赋值</p>
<h4 id="①创建学生类Student"><a href="#①创建学生类Student" class="headerlink" title="①创建学生类Student"></a>①创建学生类Student</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student {
    private Integer id;
    private String name;
    private Integer age;
    private String sex;
    public Student() {
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    public String getSex() {
        return sex;
    }
    public void setSex(String sex) {
        this.sex = sex;
    }
    @Override
    public String toString() {
        return "Student{" +
            "id=" + id +
            ", name='" + name + '\'' +
            ", age=" + age +
            ", sex='" + sex + '\'' +
            '}';
    }
}</code></pre>

<h4 id="②配置bean时为属性赋值"><a href="#②配置bean时为属性赋值" class="headerlink" title="②配置bean时为属性赋值"></a>②配置bean时为属性赋值</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentOne" class="com.atguigu.spring.bean.Student"&gt;
    &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;
    &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）--&gt;
    &lt;!-- value属性：指定属性值 --&gt;
    &lt;property name="id" value="1001"&gt;&lt;/property&gt;
    &lt;property name="name" value="张三"&gt;&lt;/property&gt;
    &lt;property name="age" value="23"&gt;&lt;/property&gt;
    &lt;property name="sex" value="男"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h4 id="③测试"><a href="#③测试" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testDIBySet(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("springdi.xml");
    Student studentOne = ioc.getBean("studentOne", Student.class);
    System.out.println(studentOne);
}</code></pre>

<h3 id="2-2-4、实验四：依赖注入之构造器注入"><a href="#2-2-4、实验四：依赖注入之构造器注入" class="headerlink" title="2.2.4、实验四：依赖注入之构造器注入"></a>2.2.4、实验四：依赖注入之构造器注入</h3><h4 id="①在Student类中添加有参构造"><a href="#①在Student类中添加有参构造" class="headerlink" title="①在Student类中添加有参构造"></a>①在Student类中添加有参构造</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}</code></pre>

<h4 id="②配置bean"><a href="#②配置bean" class="headerlink" title="②配置bean"></a>②配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentTwo" class="com.atguigu.spring.bean.Student"&gt;
    &lt;constructor-arg value="1002"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value="李四"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value="33"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value="女"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>

<blockquote>
<p>注意：</p>
<p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p>
<ul>
<li>index属性：指定参数所在位置的索引（从0开始）</li>
<li>name属性：指定参数名</li>
</ul>
</blockquote>
<h4 id="③测试-1"><a href="#③测试-1" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testDIBySet(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("springdi.xml");
    Student studentOne = ac.getBean("studentTwo", Student.class);
    System.out.println(studentOne);
}</code></pre>

<h3 id="2-2-5、实验五：特殊值处理"><a href="#2-2-5、实验五：特殊值处理" class="headerlink" title="2.2.5、实验五：特殊值处理"></a>2.2.5、实验五：特殊值处理</h3><h4 id="①字面量赋值"><a href="#①字面量赋值" class="headerlink" title="①字面量赋值"></a>①字面量赋值</h4><blockquote>
<p>什么是字面量？</p>
<p>int a = 10;</p>
<p>声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。</p>
<p>而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。</p>
<p>所以字面量没有引申含义，就是<strong>我们看到的这个数据本身</strong>。(比如null，看到是null，但本质不是字符串，是一个null值)</p>
</blockquote>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;
&lt;property name="name" value="张三"/&gt;</code></pre>

<h4 id="②null值"><a href="#②null值" class="headerlink" title="②null值"></a>②null值</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="name"&gt;
	&lt;null /&gt;
&lt;/property&gt;</code></pre>

<blockquote>
<p>注意：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="name" value="null"&gt;&lt;/property&gt;</code></pre>

<p>以上写法，为name所赋的值是字符串null</p>
</blockquote>
<h4 id="③xml实体"><a href="#③xml实体" class="headerlink" title="③xml实体"></a>③xml实体</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;
&lt;!-- 解决方案一：使用XML实体来代替 --&gt;
&lt;property name="expression" value="a &lt; b"/&gt; // a &lt; b</code></pre>

<h4 id="④CDATA节"><a href="#④CDATA节" class="headerlink" title="④CDATA节"></a>④CDATA节</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="expression"&gt;
    &lt;!-- 解决方案二：使用CDATA节 --&gt;
    &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;
    &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;
    &lt;!-- 所以CDATA节中写什么符号都随意 --&gt;
    &lt;!-- CDATA节是xml中一个特殊的标签，因此不能写在一个属性中 --&gt;
    &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;
&lt;/property&gt;</code></pre>

<h3 id="2-2-6、实验六：为类类型属性赋值"><a href="#2-2-6、实验六：为类类型属性赋值" class="headerlink" title="2.2.6、实验六：为类类型属性赋值"></a>2.2.6、实验六：为类类型属性赋值</h3><h4 id="创建班级类Clazz"><a href="#创建班级类Clazz" class="headerlink" title="创建班级类Clazz"></a>创建班级类Clazz</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Clazz {
    private Integer clazzId;
    private String clazzName;
    public Integer getClazzId() {
        return clazzId;
    }
    public void setClazzId(Integer clazzId) {
        this.clazzId = clazzId;
    }
    public String getClazzName() {
        return clazzName;
    }
    public void setClazzName(String clazzName) {
        this.clazzName = clazzName;
    }
    @Override
    public String toString() {
        return "Clazz{" +
            "clazzId=" + clazzId +
            ", clazzName='" + clazzName + '\'' +
            '}';
    }
    public Clazz() {
    }
    public Clazz(Integer clazzId, String clazzName) {
        this.clazzId = clazzId;
        this.clazzName = clazzName;
    }
}</code></pre>

<h4 id="修改Student类"><a href="#修改Student类" class="headerlink" title="修改Student类"></a>修改Student类</h4><p>在Student类中添加以下代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private Clazz clazz;
public Clazz getClazz() {
    return clazz;
}
public void setClazz(Clazz clazz) {
    this.clazz = clazz;
}</code></pre>

<h4 id="①方式一：引用外部已声明的bean"><a href="#①方式一：引用外部已声明的bean" class="headerlink" title="①方式一：引用外部已声明的bean"></a>①方式一：引用外部已声明的bean</h4><p>配置Clazz类型的bean：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="clazzOne" class="com.atguigu.spring.bean.Clazz"&gt;
    &lt;property name="clazzId" value="1111"&gt;&lt;/property&gt;
    &lt;property name="clazzName" value="财源滚滚班"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<p>为Student中的clazz属性赋值：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<p>错误演示：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;property name="clazz" value="clazzOne"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<blockquote>
<p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException:</p>
<p>Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found</p>
<p>意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p>
</blockquote>
<h4 id="②方式二：内部bean"><a href="#②方式二：内部bean" class="headerlink" title="②方式二：内部bean"></a>②方式二：内部bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;property name="clazz"&gt;
        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;
        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;
        &lt;bean id="clazzInner" class="com.atguigu.spring.bean.Clazz"&gt;
            &lt;property name="clazzId" value="2222"&gt;&lt;/property&gt;
            &lt;property name="clazzName" value="远大前程班"&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h4 id="③方式三：级联属性赋值（不常用）"><a href="#③方式三：级联属性赋值（不常用）" class="headerlink" title="③方式三：级联属性赋值（不常用）"></a>③方式三：级联属性赋值（不常用）</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;!-- 一定先引用某个bean为属性赋值，才可以使用级联方式更新属性 --&gt;
    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;
    &lt;property name="clazz.clazzId" value="3333"&gt;&lt;/property&gt;
    &lt;property name="clazz.clazzName" value="最强王者班"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h3 id="2-2-7、实验七：为数组类型属性赋值"><a href="#2-2-7、实验七：为数组类型属性赋值" class="headerlink" title="2.2.7、实验七：为数组类型属性赋值"></a>2.2.7、实验七：为数组类型属性赋值</h3><h4 id="①修改Student类"><a href="#①修改Student类" class="headerlink" title="①修改Student类"></a>①修改Student类</h4><p>在Student类中添加以下代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private String[] hobbies;
public String[] getHobbies() {
    return hobbies;
}
public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;
}</code></pre>

<h4 id="②配置bean-1"><a href="#②配置bean-1" class="headerlink" title="②配置bean"></a>②配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;
    &lt;property name="hobbies"&gt;
        &lt;array&gt;
            &lt;!-- 字面量类型用value --&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h3 id="2-2-8、实验八：为集合类型属性赋值"><a href="#2-2-8、实验八：为集合类型属性赋值" class="headerlink" title="2.2.8、实验八：为集合类型属性赋值"></a>2.2.8、实验八：为集合类型属性赋值</h3><h4 id="①为List集合类型属性赋值"><a href="#①为List集合类型属性赋值" class="headerlink" title="①为List集合类型属性赋值"></a>①为List集合类型属性赋值</h4><p>在Clazz类中添加以下代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private List&lt;Student&gt; students;
public List&lt;Student&gt; getStudents() {
    return students;
}
public void setStudents(List&lt;Student&gt; students) {
    this.students = students;
}</code></pre>

<p>配置bean：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="clazzTwo" class="com.atguigu.spring.bean.Clazz"&gt;
    &lt;property name="clazzId" value="4444"&gt;&lt;/property&gt;
    &lt;property name="clazzName" value="Javaee0222"&gt;&lt;/property&gt;
    &lt;property name="students"&gt;
        &lt;list&gt;
            &lt;!-- 类类型用ref --&gt;
            &lt;ref bean="studentOne"&gt;&lt;/ref&gt;
            &lt;ref bean="studentTwo"&gt;&lt;/ref&gt;
            &lt;ref bean="studentThree"&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<blockquote>
<p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p>
</blockquote>
<h4 id="②为Map集合类型属性赋值"><a href="#②为Map集合类型属性赋值" class="headerlink" title="②为Map集合类型属性赋值"></a>②为Map集合类型属性赋值</h4><p>创建教师类Teacher：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Teacher {
    private Integer teacherId;
    private String teacherName;
    public Integer getTeacherId() {
        return teacherId;
    }
    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }
    public String getTeacherName() {
        return teacherName;
    }
    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }
    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }
    public Teacher() {
    }
    @Override
    public String toString() {
        return "Teacher{" +
            "teacherId=" + teacherId +
            ", teacherName='" + teacherName + '\'' +
            '}';
    }
}</code></pre>

<p>在Student类中添加以下代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private Map&lt;String, Teacher&gt; teacherMap;
public Map&lt;String, Teacher&gt; getTeacherMap() {
    return teacherMap;
}
public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) {
    this.teacherMap = teacherMap;
}</code></pre>

<p>配置bean：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="teacherOne" class="com.atguigu.spring.bean.Teacher"&gt;
    &lt;property name="teacherId" value="10010"&gt;&lt;/property&gt;
    &lt;property name="teacherName" value="大宝"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="teacherTwo" class="com.atguigu.spring.bean.Teacher"&gt;
    &lt;property name="teacherId" value="10086"&gt;&lt;/property&gt;
    &lt;property name="teacherName" value="二宝"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;
    &lt;property name="hobbies"&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name="teacherMap"&gt;
        &lt;map&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10010&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean="teacherOne"&gt;&lt;/ref&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10086&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean="teacherTwo"&gt;&lt;/ref&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h4 id="③引用集合类型的bean"><a href="#③引用集合类型的bean" class="headerlink" title="③引用集合类型的bean"></a>③引用集合类型的bean</h4><p>可以考虑把内部bean提取出来，创建单独的bean，然后使用ref引用</p>
<p>但是由于bean是为类的属性赋值的，无法往里面添加数据，因此需要<strong>使用 util 命名空间</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// List
&lt;bean id="clazzTwo" class="com.atguigu.spring.bean.Clazz"&gt;
    &lt;property name="clazzId" value="4444"&gt;&lt;/property&gt;
    &lt;property name="clazzName" value="Javaee0222"&gt;&lt;/property&gt;
    &lt;property name="students" ref="students"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!--list集合类型的bean--&gt;
&lt;util:list id="students"&gt;
    &lt;ref bean="studentOne"&gt;&lt;/ref&gt;
    &lt;ref bean="studentTwo"&gt;&lt;/ref&gt;
    &lt;ref bean="studentThree"&gt;&lt;/ref&gt;
&lt;/util:list&gt;</code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// Map
&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;
    &lt;property name="id" value="1004"&gt;&lt;/property&gt;
    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;
    &lt;property name="age" value="26"&gt;&lt;/property&gt;
    &lt;property name="sex" value="女"&gt;&lt;/property&gt;
    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;
    &lt;property name="hobbies"&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name="teacherMap" ref="teacherMap"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!--map集合类型的bean--&gt;
&lt;util:map id="teacherMap"&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10010&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean="teacherOne"&gt;&lt;/ref&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10086&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean="teacherTwo"&gt;&lt;/ref&gt;
    &lt;/entry&gt;
&lt;/util:map&gt;</code></pre>

<blockquote>
<p>使用<code>util:list</code>、<code>util:map</code>标签必须引入相应的命名空间，可以通过idea的提示功能选择</p>
</blockquote>
<h3 id="2-2-9、实验九：p命名空间"><a href="#2-2-9、实验九：p命名空间" class="headerlink" title="2.2.9、实验九：p命名空间"></a>2.2.9、实验九：p命名空间</h3><p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentSix" class="com.atguigu.spring.bean.Student"
      p:id="1006" p:name="小明" p:clazz-ref="clazzOne" p:teacherMap-ref="teacherMap"&gt;&lt;/bean&gt;</code></pre>

<h3 id="2-2-10、实验十：引入外部属性文件"><a href="#2-2-10、实验十：引入外部属性文件" class="headerlink" title="2.2.10、实验十：引入外部属性文件"></a>2.2.10、实验十：引入外部属性文件</h3><h4 id="①加入依赖"><a href="#①加入依赖" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- MySQL驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.0.31&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<h4 id="②创建外部属性文件"><a href="#②创建外部属性文件" class="headerlink" title="②创建外部属性文件"></a>②创建外部属性文件</h4><p><img src="10.png" alt="10"></p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=root
jdbc.password=123456
jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.driver=com.mysql.cj.jdbc.Driver</code></pre>

<h4 id="③引入属性文件"><a href="#③引入属性文件" class="headerlink" title="③引入属性文件"></a>③引入属性文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 引入外部属性文件 --&gt;
&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>

<h4 id="④配置bean"><a href="#④配置bean" class="headerlink" title="④配置bean"></a>④配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;
    &lt;property name="username" value="${jdbc.user}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</code></pre>

<h4 id="⑤测试"><a href="#⑤测试" class="headerlink" title="⑤测试"></a>⑤测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testDataSource() throws SQLException {
    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-datasource.xml");
    DataSource dataSource = ioc.getBean(DruidDataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}</code></pre>

<h3 id="2-2-11、实验十一：bean的作用域"><a href="#2-2-11、实验十一：bean的作用域" class="headerlink" title="2.2.11、实验十一：bean的作用域"></a>2.2.11、实验十一：bean的作用域</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p>
<table>
<thead>
<tr>
<th><strong>取值</strong></th>
<th><strong>含义</strong></th>
<th><strong>创建对象的时机</strong></th>
</tr>
</thead>
<tbody><tr>
<td>singleton（默认）</td>
<td>在IOC容器中，这个bean的对象始终为单实例</td>
<td>IOC容器初始化时</td>
</tr>
<tr>
<td>prototype</td>
<td>这个bean在IOC容器中有多个实例</td>
<td>获取bean时</td>
</tr>
</tbody></table>
<p>如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：</p>
<table>
<thead>
<tr>
<th><strong>取值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>在一个请求范围内有效</td>
</tr>
<tr>
<td>session</td>
<td>在一个会话范围内有效</td>
</tr>
</tbody></table>
<h4 id="②创建类User"><a href="#②创建类User" class="headerlink" title="②创建类User"></a>②创建类User</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;
    
    public User() {
    }
    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "User{" +
            "id=" + id +
            ", username='" + username + '\'' +
            ", password='" + password + '\'' +
            ", age=" + age +
            '}';
    }
}</code></pre>

<h4 id="③配置bean"><a href="#③配置bean" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean class="com.atguigu.bean.User" scope="prototype"&gt;&lt;/bean&gt;</code></pre>

<h4 id="④测试"><a href="#④测试" class="headerlink" title="④测试"></a>④测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testBeanScope(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-scope.xml");
    User user1 = ioc.getBean(User.class);
    User user2 = ioc.getBean(User.class);
    System.out.println(user1==user2); // 单例时为true，多例时为false
}</code></pre>

<h3 id="2-2-12、实验十二：bean的生命周期"><a href="#2-2-12、实验十二：bean的生命周期" class="headerlink" title="2.2.12、实验十二：bean的生命周期"></a>2.2.12、实验十二：bean的生命周期</h3><h4 id="①具体的生命周期过程"><a href="#①具体的生命周期过程" class="headerlink" title="①具体的生命周期过程"></a>①具体的生命周期过程</h4><ul>
<li>bean对象创建（调用无参构造器）</li>
<li>给bean对象设置属性</li>
<li>bean对象初始化之前操作（由bean的后置处理器负责）</li>
<li>bean对象初始化（需在配置bean时指定初始化方法）</li>
<li>bean对象初始化之后操作（由bean的后置处理器负责）</li>
<li>bean对象就绪可以使用</li>
<li>bean对象销毁（需在配置bean时指定销毁方法）</li>
<li>IOC容器关闭</li>
</ul>
<h4 id="②修改类User"><a href="#②修改类User" class="headerlink" title="②修改类User"></a>②修改类User</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;
    public User() {
        System.out.println("生命周期：1、创建对象");
    }
    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        System.out.println("生命周期：2、依赖注入");
        this.id = id;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    public void initMethod(){
        System.out.println("生命周期：3、初始化");
    }
    public void destroyMethod(){
        System.out.println("生命周期：5、销毁");
    }
    @Override
    public String toString() {
        return "User{" +
            "id=" + id +
            ", username='" + username + '\'' +
            ", password='" + password + '\'' +
            ", age=" + age +
            '}';
    }
}</code></pre>

<blockquote>
<p>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法</p>
</blockquote>
<h4 id="③配置bean-1"><a href="#③配置bean-1" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 使用init-method属性指定初始化方法 --&gt;
&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;
&lt;bean class="com.atguigu.bean.User" scope="prototype" init-method="initMethod"destroy-method="destroyMethod"&gt;
    &lt;property name="id" value="1001"&gt;&lt;/property&gt;
    &lt;property name="username" value="admin"&gt;&lt;/property&gt;
    &lt;property name="password" value="123456"&gt;&lt;/property&gt;
    &lt;property name="age" value="23"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h4 id="④测试-1"><a href="#④测试-1" class="headerlink" title="④测试"></a>④测试</h4><p>注意：</p>
<ul>
<li>若bean的作用域为单例时，生命周期的前三个步骤（创建对象、依赖注入、初始化）会在获取IOC容器时执行</li>
<li>若bean的作用域为多例时，生命周期的前三个步骤会在获取bean时执行。且close ioc时，不会销毁bean</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testLife(){
    //ConfigurableApplicationContext是ApplicationContext的子接口，其中扩展了刷新和关闭容器的方法
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("spring-lifecycle.xml");
    User bean = ac.getBean(User.class);
    System.out.println("生命周期：4、通过IOC容器获取bean并使用");
    ac.close();
}</code></pre>

<h4 id="⑤bean的后置处理器"><a href="#⑤bean的后置处理器" class="headerlink" title="⑤bean的后置处理器"></a>⑤bean的后置处理器</h4><p>bean的后置处理器会在生命周期的<strong>初始化前后添加</strong>额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中。</p>
<p>==需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行==</p>
<p>创建bean的后置处理器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.spring.process;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    //此方法在bean的生命周期初始化之前执行
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("☆☆☆" + beanName + " = " + bean);
        return bean;
    }
    //此方法在bean的生命周期初始化之后执行
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("★★★" + beanName + " = " + bean);
        return bean;
    }
}</code></pre>

<p>在IOC容器中配置后置处理器：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;

&lt;bean id="myBeanProcessor" class="com.atguigu.spring.process.MyBeanProcessor"/&gt;</code></pre>

<h3 id="2-2-13、实验十三：FactoryBean"><a href="#2-2-13、实验十三：FactoryBean" class="headerlink" title="2.2.13、实验十三：FactoryBean"></a>2.2.13、实验十三：FactoryBean</h3><h4 id="①简介"><a href="#①简介" class="headerlink" title="①简介"></a>①简介</h4><p>FactoryBean是Spring提供的一种<strong>整合第三方框架</strong>的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是<code>getObject()方法的返回值</code>。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p>
<p>将来我们<strong>整合Mybatis</strong>时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/*
* Copyright 2002-2020 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package org.springframework.beans.factory;
import org.springframework.lang.Nullable;
/**
* Interface to be implemented by objects used within a {@link BeanFactory}
which
* are themselves factories for individual objects. If a bean implements this
* interface, it is used as a factory for an object to expose, not directly as a
* bean instance that will be exposed itself.
*
* &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal
bean.&lt;/b&gt;
* A FactoryBean is defined in a bean style, but the object exposed for bean
* references ({@link #getObject()}) is always the object that it creates.
*
* &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create
* objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
* interface allows for exposing more fine-grained behavioral metadata.
*
* &lt;p&gt;This interface is heavily used within the framework itself, for example
for
* the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the
* {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for
* custom components as well; however, this is only common for infrastructure
code.
*
* &lt;p&gt;&lt;b&gt;{@code FactoryBean} is a programmatic contract. Implementations are not
* supposed to rely on annotation-driven injection or other reflective
facilities.&lt;/b&gt;
* {@link #getObjectType()} {@link #getObject()} invocations may arrive early in
the
* bootstrap process, even ahead of any post-processor setup. If you need access
to
* other beans, implement {@link BeanFactoryAware} and obtain them
programmatically.
*
* &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the
FactoryBean
* instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt;
Therefore,
* a destroy method on an exposed bean object (such as {@link
java.io.Closeable#close()}
* will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should
implement
* {@link DisposableBean} and delegate any such close call to the underlying
object.
*
* &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory's
* synchronization of bean creation. There is usually no need for internal
* synchronization other than for purposes of lazy initialization within the
* FactoryBean itself (or the like).
*
* @author Rod Johnson
* @author Juergen Hoeller
* @since 08.03.2003
* @param &lt;T&gt; the bean type
* @see org.springframework.beans.factory.BeanFactory
* @see org.springframework.aop.framework.ProxyFactoryBean
* @see org.springframework.jndi.JndiObjectFactoryBean
*/
public interface FactoryBean&lt;T&gt; {
    /**
* The name of an attribute that can be
* {@link org.springframework.core.AttributeAccessor#setAttribute set} on a
* {@link org.springframework.beans.factory.config.BeanDefinition} so that
* factory beans can signal their object type when it can't be deduced from
* the factory bean class.
* @since 5.2
*/
    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";
    /**
* Return an instance (possibly shared or independent) of the object
* managed by this factory.
* &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the
* Singleton and Prototype design pattern.
* &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of
* the call (for example because it is involved in a circular reference),
* throw a corresponding {@link FactoryBeanNotInitializedException}.
* &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}
* objects. The factory will consider this as normal value to be used; it
* will not throw a FactoryBeanNotInitializedException in this case anymore.
* FactoryBean implementations are encouraged to throw
* FactoryBeanNotInitializedException themselves now, as appropriate.
* @return an instance of the bean (can be {@code null})
* @throws Exception in case of creation errors
* @see FactoryBeanNotInitializedException
*/
    @Nullable
    T getObject() throws Exception;
    /**
* Return the type of object that this FactoryBean creates,
* or {@code null} if not known in advance.
* &lt;p&gt;This allows one to check for specific types of beans without
* instantiating objects, for example on autowiring.
* &lt;p&gt;In the case of implementations that are creating a singleton object,
* this method should try to avoid singleton creation as far as possible;
* it should rather estimate the type in advance.
* For prototypes, returning a meaningful type here is advisable too.
* &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has
* been fully initialized. It must not rely on state created during
* initialization; of course, it can still use such state if available.
* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return
* {@code null} here. Therefore it is highly recommended to implement
* this method properly, using the current state of the FactoryBean.
* @return the type of object that this FactoryBean creates,
* or {@code null} if not known at the time of the call
* @see ListableBeanFactory#getBeansOfType
*/
    @Nullable
    Class&lt;?&gt; getObjectType();
    /**
* Is the object managed by this factory a singleton? That is,
* will {@link #getObject()} always return the same object
* (a reference that can be cached)?
* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,
* the object returned from {@code getObject()} might get cached
* by the owning BeanFactory. Hence, do not return {@code true}
* unless the FactoryBean always exposes the same reference.
* &lt;p&gt;The singleton status of the FactoryBean itself will generally
* be provided by the owning BeanFactory; usually, it has to be
* defined as singleton there.
* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning {@code false} does not
* necessarily indicate that returned objects are independent instances.
* An implementation of the extended {@link SmartFactoryBean} interface
* may explicitly indicate independent instances through its
* {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
* implementations which do not implement this extended interface are
* simply assumed to always return independent instances if the
* {@code isSingleton()} implementation returns {@code false}.
* &lt;p&gt;The default implementation returns {@code true}, since a
* {@code FactoryBean} typically manages a singleton instance.
* @return whether the exposed object is a singleton
* @see #getObject()
* @see SmartFactoryBean#isPrototype()
*/
    default boolean isSingleton() {
        return true;
    }
}</code></pre>

<h4 id="②创建类UserFactoryBean"><a href="#②创建类UserFactoryBean" class="headerlink" title="②创建类UserFactoryBean"></a>②创建类UserFactoryBean</h4><p>FactoryBean是一个接口，需要创建一个类实现该接口</p>
<p>其中有三个方法：</p>
<ul>
<li>getObject()：通过一个对象交给IOC容器管理</li>
<li>getObjectType()：设置所提供对象的类型</li>
<li>isSingleton()：所提供的对象是否单例</li>
</ul>
<p>当把FactoryBean的实现类配置为bean时，会<strong>将当前类中getObject()所返回的对象交给IOC容器管理</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserFactoryBean implements FactoryBean&lt;User&gt; {
    @Override
    public User getObject() throws Exception {
        return new User();
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return User.class;
    }
}</code></pre>

<h4 id="③配置bean-2"><a href="#③配置bean-2" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="user" class="com.atguigu.bean.UserFactoryBean"&gt;&lt;/bean&gt;</code></pre>

<h4 id="④测试-2"><a href="#④测试-2" class="headerlink" title="④测试"></a>④测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testUserFactoryBean(){
    //获取IOC容器
    ApplicationContext ac = new ClassPathXmlApplicationContext("spring-factorybean.xml");
    User user = (User) ac.getBean("user");
    System.out.println(user);
}</code></pre>

<h3 id="2-2-14、实验十四：基于xml的自动装配"><a href="#2-2-14、实验十四：基于xml的自动装配" class="headerlink" title="2.2.14、实验十四：基于xml的自动装配"></a>2.2.14、实验十四：基于xml的自动装配</h3><blockquote>
<p>自动装配：</p>
<p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型<strong>属性赋值</strong></p>
</blockquote>
<h4 id="①场景模拟"><a href="#①场景模拟" class="headerlink" title="①场景模拟"></a>①场景模拟</h4><ol>
<li>创建类UserController</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserController {
    // 原写法：private UserService userService = new UserServiceImpl();
    private UserService userService;
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    public void saveUser() {
        userService.saveUser();
    }
}</code></pre>

<ol start="2">
<li>创建接口UserService</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {
	void saveUser();
}</code></pre>

<p>创建类UserServiceImpl实现接口UserService</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService {
    // 原写法：private UserDao userDao = new UserDaoImpl();
    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}</code></pre>

<ol start="3">
<li>创建接口UserDao</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {
	void saveUser();
}</code></pre>

<p>创建类UserDaoImpl实现接口UserDao</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println("保存成功");
    }
}</code></pre>



<p><em>不使用自动装配：</em></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController" class="com.atguigu.spring.controller.UserController" autowire="byName"&gt;
    &lt;property name="userService" ref="userService"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="userService" class="com.atguigu.spring.service.impl.UserServiceImpl" autowire="byName"&gt;
    &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="userDao" class="com.atguigu.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre>

<blockquote>
<p>好处：</p>
<p>与<strong>JavaWeb原生</strong>在实现类中对对象属性进行赋值相比，在<strong>IOC中配置</strong>更灵活。若对象UserServiceImpl、UserDaoImpl更换为其他实现类，可以直接修改ref，不需要到原文件中修改。</p>
</blockquote>
<h4 id="②配置bean-2"><a href="#②配置bean-2" class="headerlink" title="②配置bean"></a>②配置bean</h4><p>使用bean标签的autowire属性设置自动装配效果</p>
<p>自动装配的策略：</p>
<ul>
<li>no，default：表示不装配，即bean中的属性不会自动匹配某个bean为属性赋值，此时属性使用默认值</li>
<li>byType：根据要赋值的属性的类型，在IOC容器中匹配某个bean，为属性赋值</li>
</ul>
<p><strong>1.自动装配方式：byType</strong></p>
<p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p>
<p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null</p>
<p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController"class="com.atguigu.autowire.xml.controller.UserController" autowire="byType"&gt;&lt;/bean&gt;
&lt;bean id="userService"class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byType"&gt;&lt;/bean&gt;
&lt;bean id="userDao" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre>

<p><strong>2.自动装配方式：byName</strong></p>
<p>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController" class="com.atguigu.autowire.xml.controller.UserController" autowire="byName"&gt;
	&lt;!-- 装配id="userService" --&gt;
&lt;/bean&gt;

&lt;bean id="userService" class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byName"&gt;&lt;/bean&gt;
&lt;bean id="userServiceImpl" class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byName"&gt;
	&lt;!-- 装配id="userDao" --&gt;
&lt;/bean&gt;

&lt;bean id="userDao" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;
&lt;bean id="userDaoImpl" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre>

<h4 id="③测试-2"><a href="#③测试-2" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testAutoWireByXML(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("autowire-xml.xml");
    UserController userController = ac.getBean(UserController.class);
    userController.saveUser();
}</code></pre>

<h2 id="2-3、基于注解管理bean"><a href="#2-3、基于注解管理bean" class="headerlink" title="2.3、基于注解管理bean"></a>2.3、基于注解管理bean</h2><h3 id="2-3-1、实验一：标记与扫描"><a href="#2-3-1、实验一：标记与扫描" class="headerlink" title="2.3.1、实验一：标记与扫描"></a>2.3.1、实验一：标记与扫描</h3><h4 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</p>
<p>本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p>
<p>举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</p>
<p><img src="11.png" alt="11"></p>
<p>班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。</p>
<h4 id="扫描的概念"><a href="#扫描的概念" class="headerlink" title="扫描的概念"></a>扫描的概念</h4><p>Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p>
<h4 id="①新建Maven-Module"><a href="#①新建Maven-Module" class="headerlink" title="①新建Maven Module"></a>①新建Maven Module</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

<h4 id="②创建Spring配置文件"><a href="#②创建Spring配置文件" class="headerlink" title="②创建Spring配置文件"></a>②创建Spring配置文件</h4><p><img src="12.png" alt="12"></p>
<h4 id="标识组件的常用注解"><a href="#标识组件的常用注解" class="headerlink" title="标识组件的常用注解"></a>标识组件的常用注解</h4><blockquote>
<p>@Component：将类标识为普通组件 </p>
<p>@Controller：将类标识为控制层组件 </p>
<p>@Service：将类标识为业务层组件 </p>
<p>@Repository：将类标识为持久层组件</p>
</blockquote>
<p>问：以上四个注解有什么关系和区别？</p>
<p><img src="13.png" alt="13"></p>
<p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是<strong>在@Component注解的基础上起了三个新的名字</strong>。</p>
<p>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p>
<p>注意：虽然它们<strong>本质上一样</strong>，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p>
<blockquote>
<h5 id="补充：组件所对应的bean的id"><a href="#补充：组件所对应的bean的id" class="headerlink" title="补充：组件所对应的bean的id"></a>补充：组件所对应的bean的id</h5><p>在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，<strong>每个组件仍然应该有一个唯一标识</strong>。</p>
<ol>
<li><p>默认情况：类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。</p>
</li>
<li><p>自定义bean的id：可通过标识组件的注解的value属性设置自定义的bean的id（不常用）</p>
</li>
</ol>
<p>​		<code>@Service("service")</code>// 默认为userServiceImpl   public class UserServiceImpl implements UserService {}</p>
</blockquote>
<h4 id="③创建组件"><a href="#③创建组件" class="headerlink" title="③创建组件"></a>③创建组件</h4><p>创建控制层组件</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController {
}</code></pre>

<p>创建接口UserService</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {
}</code></pre>

<p>创建业务层组件UserServiceImpl</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class UserServiceImpl implements UserService {
}</code></pre>

<p>创建接口UserDao</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {
}</code></pre>

<p>创建持久层组件UserDaoImpl</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {
}</code></pre>

<h4 id="④扫描组件"><a href="#④扫描组件" class="headerlink" title="④扫描组件"></a>④扫描组件</h4><p>情况一：最基本的扫描方式</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.spring"&gt;&lt;/context:component-scan&gt;</code></pre>

<p>情况二：指定要排除的组件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.spring"&gt;
    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;
    &lt;!--
        type：设置排除或包含的依据
        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
    --&gt;
    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;
    &lt;!--&lt;context:exclude-filter type="assignable"expression="com.atguigu.controller.UserController"/&gt;--&gt;
&lt;/context:component-scan&gt;</code></pre>

<p>情况三：仅扫描指定组件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
&lt;!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 --&gt;
&lt;context:component-scan base-package="com.atguigu.spring" use-default-filters="false"&gt;
    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;
    &lt;!--
        type：设置排除或包含的依据
        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
     --&gt;
    &lt;context:include-filter type="annotation"expression="org.springframework.stereotype.Controller"/&gt;
    &lt;!--&lt;context:include-filter type="assignable"expression="com.atguigu.controller.UserController"/&gt;--&gt;
&lt;/context:component-scan&gt;</code></pre>

<h4 id="⑤测试-1"><a href="#⑤测试-1" class="headerlink" title="⑤测试"></a>⑤测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testAutowireByAnnotation(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");
    UserController userController = ioc.getBean(UserController.class);
    System.out.println(userController);
    UserService userService = ioc.getBean(UserService.class);
    System.out.println(userService);
    UserDao userDao = ioc.getBean(UserDao.class);
    System.out.println(userDao);
}</code></pre>

<h3 id="2-3-2、实验二：基于注解的自动装配"><a href="#2-3-2、实验二：基于注解的自动装配" class="headerlink" title="2.3.2、实验二：基于注解的自动装配"></a>2.3.2、实验二：基于注解的自动装配</h3><h4 id="①场景模拟-1"><a href="#①场景模拟-1" class="headerlink" title="①场景模拟"></a>①场景模拟</h4><p>参考基于xml的自动装配：</p>
<p>在UserController中声明UserService对象</p>
<p>在UserServiceImpl中声明UserDao对象</p>
<h4 id="②-Autowired注解"><a href="#②-Autowired注解" class="headerlink" title="②@Autowired注解"></a>②@Autowired注解</h4><p>在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController {
    @Autowired
    private UserService userService;
    public void saveUser(){
        userService.saveUser();
    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {
    void saveUser();
}
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {
	void saveUser();
}	</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println("保存成功");
    }
}</code></pre>

<blockquote>
<p>@Autowired注解还可以标记在 构造器 和 set 方法上</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController {
 private UserService userService;
 @Autowired
 public UserController(UserService userService){
     this.userService = userService;
 }
 public void saveUser(){
     userService.saveUser();
 }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController {
 private UserService userService;
 @Autowired
 public void setUserService(UserService userService){
     this.userService = userService;
 }
 public void saveUser(){
     userService.saveUser();
 }
}</code></pre>
</blockquote>
<h4 id="③-Autowired工作流程"><a href="#③-Autowired工作流程" class="headerlink" title="③@Autowired工作流程"></a>③@Autowired工作流程</h4><p><img src="14.png" alt="14"></p>
<ul>
<li>首先根据所需要的组件类型到IOC容器中查找（默认使用byType方式）<ul>
<li>能够找到唯一的bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的bean：装配失败</li>
<li>和所需类型匹配的bean不止一个<ul>
<li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配（使用byName方式）<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController {
    @Autowired
    @Qualifier("userServiceImpl")
    private UserService userService;
    public void saveUser(){
        userService.saveUser();
    }
}</code></pre>

<blockquote>
<p>@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败。</p>
<p>可以将属性required的值设置为true，则表示能装就装，装不上就不装，自动装配的属性为默认值</p>
<p>但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。</p>
</blockquote>
<h1 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h1><h2 id="3-1、场景模拟"><a href="#3-1、场景模拟" class="headerlink" title="3.1、场景模拟"></a>3.1、场景模拟</h2><h3 id="3-1-1、声明接口"><a href="#3-1-1、声明接口" class="headerlink" title="3.1.1、声明接口"></a>3.1.1、声明接口</h3><p>声明计算器接口Calculator，包含加减乘除的抽象方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Calculator {
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
}</code></pre>

<h3 id="3-1-2、创建实现类"><a href="#3-1-2、创建实现类" class="headerlink" title="3.1.2、创建实现类"></a>3.1.2、创建实现类</h3><p><img src="15.png" alt="15"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorPureImpl implements Calculator {
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
}</code></pre>

<h3 id="3-1-3、创建带日志功能的实现类"><a href="#3-1-3、创建带日志功能的实现类" class="headerlink" title="3.1.3、创建带日志功能的实现类"></a>3.1.3、创建带日志功能的实现类</h3><p><img src="16.png" alt="16"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorLogImpl implements Calculator {
    @Override
    public int add(int i, int j) {
        System.out.println("[日志] add 方法开始了，参数是：" + i + "," + j);
        int result = i + j;
        System.out.println("方法内部 result = " + result);
        System.out.println("[日志] add 方法结束了，结果是：" + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        System.out.println("[日志] sub 方法开始了，参数是：" + i + "," + j);
        int result = i - j;
        System.out.println("方法内部 result = " + result);
        System.out.println("[日志] sub 方法结束了，结果是：" + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        System.out.println("[日志] mul 方法开始了，参数是：" + i + "," + j);
        int result = i * j;
        System.out.println("方法内部 result = " + result);
        System.out.println("[日志] mul 方法结束了，结果是：" + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        System.out.println("[日志] div 方法开始了，参数是：" + i + "," + j);
        int result = i / j;
        System.out.println("方法内部 result = " + result);
        System.out.println("[日志] div 方法结束了，结果是：" + result);
        return result;
    }
}</code></pre>

<h3 id="3-1-4、提出问题"><a href="#3-1-4、提出问题" class="headerlink" title="3.1.4、提出问题"></a>3.1.4、提出问题</h3><h4 id="①现有代码缺陷"><a href="#①现有代码缺陷" class="headerlink" title="①现有代码缺陷"></a>①现有代码缺陷</h4><p>针对带日志功能的实现类，我们发现有如下缺陷：</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能分散在各个业务功能方法中，不利于统一维护</li>
</ul>
<h4 id="②解决思路"><a href="#②解决思路" class="headerlink" title="②解决思路"></a>②解决思路</h4><p>解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<h4 id="③困难"><a href="#③困难" class="headerlink" title="③困难"></a>③困难</h4><p>解决问题的困难：要抽取的代码在方法内部且分散，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。</p>
<h2 id="3-2、代理模式"><a href="#3-2、代理模式" class="headerlink" title="3.2、代理模式"></a>3.2、代理模式</h2><h3 id="3-2-1、概念"><a href="#3-2-1、概念" class="headerlink" title="3.2.1、概念"></a>3.2.1、概念</h3><h4 id="①介绍"><a href="#①介绍" class="headerlink" title="①介绍"></a>①介绍</h4><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<p><img src="17.png" alt="17"></p>
<p>使用代理后：</p>
<p><img src="18.png" alt="18"></p>
<h4 id="②生活中的代理"><a href="#②生活中的代理" class="headerlink" title="②生活中的代理"></a>②生活中的代理</h4><ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
</ul>
<h4 id="③相关术语"><a href="#③相关术语" class="headerlink" title="③相关术语"></a>③相关术语</h4><ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li>
<li>目标：被代理“套用”了非核心逻辑代码的类、对象、方法。</li>
</ul>
<h3 id="3-2-2、静态代理"><a href="#3-2-2、静态代理" class="headerlink" title="3.2.2、静态代理"></a>3.2.2、静态代理</h3><p>创建静态代理类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorStaticProxy implements Calculator {
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
    public CalculatorStaticProxy(Calculator target) {
        this.target = target;
    }
    @Override
    public int add(int i, int j) {
        // 附加功能由代理类中的代理方法来实现
        System.out.println("[日志] add 方法开始了，参数是：" + i + "," + j);
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
        System.out.println("[日志] add 方法结束了，结果是：" + addResult);
        return addResult;
    }
}</code></pre>

<blockquote>
<p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p>
<p>提出进一步的需求：<strong>将日志功能集中到一个代理类</strong>中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p>
</blockquote>
<h3 id="3-2-3、动态代理"><a href="#3-2-3、动态代理" class="headerlink" title="3.2.3、动态代理"></a>3.2.3、动态代理</h3><p><img src="19.png" alt="19"></p>
<p>生产代理对象的工厂类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ProxyFactory {
    private Object target;
    public ProxyFactory(Object target) {
        this.target = target;
    }
    
    public Object getProxy(){
        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */
        ClassLoader classLoader = this.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try {
                    System.out.println("[动态代理][日志] "+method.getName()+"，参数："+ Arrays.toString(args));
                	result = method.invoke(target, args);
                	System.out.println("[动态代理][日志] "+method.getName()+"，结果："+ result);
                 } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println("[动态代理][日志] "+method.getName()+"，异常："+ e.getMessage());
                  } finally {
                     System.out.println("[动态代理][日志] "+method.getName()+"，方法执行完毕");
                  }
                  return result;
            }   
        };
        
        return Proxy.newProxyInstance(classLoader, interfaces,invocationHandler);
    }
}                                     </code></pre>

<blockquote>
<p>动态代理有两种：</p>
<ol>
<li><p>jdk动态代理，要求必须有接口，最终生成的代理类和目标类实现相同的接口。在com.sun.proxy包下，类名为$proxy2</p>
</li>
<li><p>cglib动态代理，最终生成的代理类会继承目标类，并且和目标类在相同的包下</p>
</li>
</ol>
<p>jdk动态代理无法很好的兼容组件扫描，但是cglib可以直接将动态代理类生成在目标类路径下，扫描包时可以直接一起扫描</p>
</blockquote>
<h3 id="3-2-4、测试"><a href="#3-2-4、测试" class="headerlink" title="3.2.4、测试"></a>3.2.4、测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testDynamicProxy(){
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1,0);
    //proxy.div(1,1);
}</code></pre>

<h2 id="3-3、AOP概念及相关术语"><a href="#3-3、AOP概念及相关术语" class="headerlink" title="3.3、AOP概念及相关术语"></a>3.3、AOP概念及相关术语</h2><h3 id="3-3-1、概述"><a href="#3-3-1、概述" class="headerlink" title="3.3.1、概述"></a>3.3.1、概述</h3><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在<strong>不修改源代码的情况下给程序动态统一添加额外功能</strong>的一种技术。</p>
<h3 id="3-3-2、相关术语"><a href="#3-3-2、相关术语" class="headerlink" title="3.3.2、相关术语"></a>3.3.2、相关术语</h3><h4 id="①横切关注点"><a href="#①横切关注点" class="headerlink" title="①横切关注点"></a>①横切关注点</h4><p>从每个方法中抽取出来的<strong>同一类非核心业务</strong>。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p>
<p>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<img src="20.png" alt="20"></p>
<h4 id="②通知"><a href="#②通知" class="headerlink" title="②通知"></a>②通知</h4><p>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p>
<ul>
<li>前置通知：在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li>
<li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li>
<li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li>
<li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所</li>
</ul>
<p>有位置<img src="21.png" alt="21"></p>
<h4 id="③切面"><a href="#③切面" class="headerlink" title="③切面"></a>③切面</h4><p>封装通知方法的类。<img src="22.png" alt="22"></p>
<h4 id="④目标"><a href="#④目标" class="headerlink" title="④目标"></a>④目标</h4><p>被代理的目标对象。</p>
<h4 id="⑤代理"><a href="#⑤代理" class="headerlink" title="⑤代理"></a>⑤代理</h4><p>向目标对象应用通知之后创建的代理对象。</p>
<h4 id="⑥连接点"><a href="#⑥连接点" class="headerlink" title="⑥连接点"></a>⑥连接点</h4><p>这也是一个纯逻辑概念，不是语法定义的。</p>
<p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</p>
<p><img src="23.png" alt="23"></p>
<h4 id="⑦切入点"><a href="#⑦切入点" class="headerlink" title="⑦切入点"></a>⑦切入点</h4><p>定位连接点的方式。</p>
<p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。</p>
<p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p>
<p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。</p>
<p>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<h3 id="3-3-3、作用"><a href="#3-3-3、作用" class="headerlink" title="3.3.3、作用"></a>3.3.3、作用</h3><ul>
<li><p>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</p>
</li>
<li><p>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</p>
</li>
</ul>
<h2 id="3-4、基于注解的AOP"><a href="#3-4、基于注解的AOP" class="headerlink" title="3.4、基于注解的AOP"></a>3.4、基于注解的AOP</h2><h3 id="3-4-1、技术说明"><a href="#3-4-1、技术说明" class="headerlink" title="3.4.1、技术说明"></a>3.4.1、技术说明</h3><p><img src="24.png" alt="24"></p>
<ul>
<li><p>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</p>
</li>
<li><p>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
</li>
<li><p>AspectJ：本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</p>
</li>
</ul>
<h3 id="3-4-2、准备工作"><a href="#3-4-2、准备工作" class="headerlink" title="3.4.2、准备工作"></a>3.4.2、准备工作</h3><h4 id="①添加依赖"><a href="#①添加依赖" class="headerlink" title="①添加依赖"></a>①添加依赖</h4><p>在IOC所需依赖基础上再加入下面依赖即可：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<h4 id="②准备被代理的目标资源"><a href="#②准备被代理的目标资源" class="headerlink" title="②准备被代理的目标资源"></a>②准备被代理的目标资源</h4><p>接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Calculator {
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
}</code></pre>

<p>实现类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
public class CalculatorPureImpl implements Calculator {
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
}</code></pre>

<h3 id="3-4-3、创建切面类并配置（总）"><a href="#3-4-3、创建切面类并配置（总）" class="headerlink" title="3.4.3、创建切面类并配置（总）"></a>3.4.3、创建切面类并配置（总）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {
    @Before("execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))")
    //@Before("execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))")
	public void beforeMethod(JoinPoint joinPoint){
        //获取连接点所对应方法的签名信息
        String signature = joinPoint.getSignature();
        //获取连接点所对应方法的参数
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println("Logger--&gt;前置通知，方法名："+signature.getName()+"，参数："+args);
	}
    
    @After("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
	public void afterMethod(JoinPoint joinPoint){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger--&gt;后置通知，方法名："+methodName);
	}
    
    @AfterReturning(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")
	public void afterReturningMethod(JoinPoint joinPoint, Object result){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger--&gt;返回通知，方法名："+methodName+"，结果："+result);
	} 
    
    @AfterThrowing(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")
	public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger--&gt;异常通知，方法名："+methodName+"，异常："+ex);
	}
    
    @Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
	public Object aroundMethod(ProceedingJoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
		String args = Arrays.toString(joinPoint.getArgs());
		Object result = null;
        try {
            System.out.println("环绕通知--&gt;目标对象方法执行之前");
            //目标对象（连接点）方法的执行
            result = joinPoint.proceed();
            System.out.println("环绕通知--&gt;目标对象方法返回值之后");
		} catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println("环绕通知--&gt;目标对象方法出现异常时");
		} finally {
			System.out.println("环绕通知--&gt;目标对象方法执行完毕");
		}
		return result;
	}
}</code></pre>

<p>在Spring的配置文件中配置：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">  &lt;!--
       基于注解的AOP的实现：
       1、将目标对象和切面交给IOC容器管理（注解+扫描）
       2、开启AspectJ的自动代理，为目标对象自动生成代理
       3、将切面类通过注解@Aspect标识
--&gt;
&lt;context:component-scan base-package="com.atguigu.aop.annotation"&gt;&lt;/context:component-scan&gt;
&lt;!-- 开启基于注解的AOP --&gt;
&lt;aop:aspectj-autoproxy /&gt;</code></pre>

<h3 id="3-4-4、各种通知"><a href="#3-4-4、各种通知" class="headerlink" title="3.4.4、各种通知"></a>3.4.4、各种通知</h3><ul>
<li>前置通知：使用@Before注解标识，在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：使用@AfterReturning注解标识，在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li>
<li>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li>
<li>后置通知：使用@After注解标识，在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）<code>finally字句中执行</code></li>
<li>环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<blockquote>
<p>各种通知的执行顺序：</p>
<ul>
<li>Spring版本5.3.x以前：<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>后置通知</li>
<li>返回通知或异常通知</li>
</ul>
</li>
<li>Spring版本5.3.x以后：<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>返回通知或异常通知</li>
<li>后置通知</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-4-5、切入点表达式语法"><a href="#3-4-5、切入点表达式语法" class="headerlink" title="3.4.5、切入点表达式语法"></a>3.4.5、切入点表达式语法</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><p><img src="25.png" alt="25"></p>
<h4 id="②语法细节"><a href="#②语法细节" class="headerlink" title="②语法细节"></a>②语法细节</h4><ul>
<li>用*号代替“权限修饰符”和“返回值”部分 表示“权限修饰符”和“返回值”不限</li>
<li>在包名的部分，一个“<em>”号只能代表包的层次结构中的一层，表示这一层是任意的。</em><ul>
<li><em>例如：</em>.Hello匹配com.Hello，不匹配com.atguigu.Hello</li>
</ul>
</li>
<li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意*</li>
<li><em>在类名的部分，类名部分整体用</em>号代替，表示类名任意</li>
<li>在类名的部分，可以使用<em>号代替类名的一部分</em><ul>
<li><em>例如：</em>Service匹配所有名称以Service结尾的类或接口</li>
</ul>
</li>
<li>在方法名部分，可以使用<em>号表示方法名任意</em></li>
<li><em>在方法名部分，可以使用</em>号代替方法名的一部分<ul>
<li>例如：*Operation匹配所有方法名以Operation结尾的方法</li>
</ul>
</li>
<li>​	在方法参数列表部分，使用(..)表示参数列表任意</li>
<li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li>
<li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的<ul>
<li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li>
</ul>
</li>
<li>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符<ul>
<li>例如：execution(public int <em>..<em>Service.</em>(.., int)) 正确</em></li>
<li><em>例如：execution(</em> int *..<em>Service.</em>(.., int)) 错误</li>
</ul>
</li>
</ul>
<p><img src="26.png" alt="26"></p>
<h3 id="3-4-6、复用切入点表达式"><a href="#3-4-6、复用切入点表达式" class="headerlink" title="3.4.6、复用切入点表达式"></a>3.4.6、复用切入点表达式</h3><h4 id="①声明"><a href="#①声明" class="headerlink" title="①声明"></a>①声明</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Pointcut("execution(* com.atguigu.aop.annotation.*.*(..))")
public void pointCut(){}</code></pre>

<h4 id="②在同一个切面中使用"><a href="#②在同一个切面中使用" class="headerlink" title="②在同一个切面中使用"></a>②在同一个切面中使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("pointCut()")
public void beforeMethod(JoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);
}</code></pre>

<h4 id="③在不同切面中使用"><a href="#③在不同切面中使用" class="headerlink" title="③在不同切面中使用"></a>③在不同切面中使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("com.atguigu.aop.CommonPointCut.pointCut()") // 使用在com.atguigu.aop.CommonPointCut包中的poinCut
public void beforeMethod(JoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);
}</code></pre>

<h3 id="3-4-7、获取通知的相关信息"><a href="#3-4-7、获取通知的相关信息" class="headerlink" title="3.4.7、获取通知的相关信息"></a>3.4.7、获取通知的相关信息</h3><h4 id="①获取连接点信息"><a href="#①获取连接点信息" class="headerlink" title="①获取连接点信息"></a>①获取连接点信息</h4><p>获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))")
public void beforeMethod(JoinPoint joinPoint){
    //获取连接点的签名信息
    String methodName = joinPoint.getSignature().getName();
    //获取目标方法到的实参信息
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);
}</code></pre>

<h4 id="②获取目标方法的返回值"><a href="#②获取目标方法的返回值" class="headerlink" title="②获取目标方法的返回值"></a>②获取目标方法的返回值</h4><p>@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterReturning(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")
    public void afterReturningMethod(JoinPoint joinPoint, Object result){
    String methodName = joinPoint.getSignature().getName();
    System.out.println("Logger--&gt;返回通知，方法名："+methodName+"，结果："+result);
}</code></pre>

<h4 id="③获取目标方法的异常"><a href="#③获取目标方法的异常" class="headerlink" title="③获取目标方法的异常"></a>③获取目标方法的异常</h4><p>@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterThrowing(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")
    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){
    String methodName = joinPoint.getSignature().getName();
    System.out.println("Logger--&gt;异常通知，方法名："+methodName+"，异常："+ex);
}</code></pre>

<h3 id="3-4-8、环绕通知"><a href="#3-4-8、环绕通知" class="headerlink" title="3.4.8、环绕通知"></a>3.4.8、环绕通知</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
public Object aroundMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    Object result = null;
    try {
        System.out.println("环绕通知--&gt;目标对象方法执行之前");
        //目标方法的执行，目标方法的返回值一定要返回给外界调用者
        result = joinPoint.proceed();
        System.out.println("环绕通知--&gt;目标对象方法返回值之后");
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        System.out.println("环绕通知--&gt;目标对象方法出现异常时");
    } finally {
        System.out.println("环绕通知--&gt;目标对象方法执行完毕");
    }
    return result;
}</code></pre>

<h3 id="3-4-9、切面的优先级"><a href="#3-4-9、切面的优先级" class="headerlink" title="3.4.9、切面的优先级"></a>3.4.9、切面的优先级</h3><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用@Order注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低</li>
</ul>
<p><img src="27.png" alt="27"></p>
<p>优先级高的先执行</p>
<h2 id="3-5、基于XML的AOP（了解）"><a href="#3-5、基于XML的AOP（了解）" class="headerlink" title="3.5、基于XML的AOP（了解）"></a>3.5、基于XML的AOP（了解）</h2><h3 id="3-5-1、准备工作"><a href="#3-5-1、准备工作" class="headerlink" title="3.5.1、准备工作"></a>3.5.1、准备工作</h3><p>参考基于注解的AOP环境</p>
<h3 id="3-5-2、实现"><a href="#3-5-2、实现" class="headerlink" title="3.5.2、实现"></a>3.5.2、实现</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.aop.xml"&gt;&lt;/context:componentscan&gt;
&lt;aop:config&gt;
    &lt;!--配置切面类--&gt;
    &lt;aop:aspect ref="loggerAspect"&gt;
        &lt;aop:pointcut id="pointCut" expression="execution(*com.atguigu.aop.xml.CalculatorImpl.*(..))"/&gt;
        &lt;aop:before method="beforeMethod" pointcut-ref="pointCut"&gt;&lt;/aop:before&gt;
        &lt;aop:after method="afterMethod" pointcut-ref="pointCut"&gt;&lt;/aop:after&gt;
        &lt;aop:after-returning method="afterReturningMethod" returning="result" pointcut-ref="pointCut"&gt;&lt;/aop:after-returning&gt;
        &lt;aop:after-throwing method="afterThrowingMethod" throwing="ex" pointcut-ref="pointCut"&gt;&lt;/aop:after-throwing&gt;
        &lt;aop:around method="aroundMethod" pointcut-ref="pointCut"&gt;&lt;/aop:around&gt;
    &lt;/aop:aspect&gt;
    &lt;aop:aspect ref="validateAspect" order="1"&gt;
        &lt;aop:before method="validateBeforeMethod" pointcut-ref="pointCut"&gt;
        &lt;/aop:before&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>

<h1 id="4、声明式事务"><a href="#4、声明式事务" class="headerlink" title="4、声明式事务"></a>4、声明式事务</h1><h2 id="4-1、JdbcTemplate"><a href="#4-1、JdbcTemplate" class="headerlink" title="4.1、JdbcTemplate"></a>4.1、JdbcTemplate</h2><h3 id="4-1-1、简介"><a href="#4-1-1、简介" class="headerlink" title="4.1.1、简介"></a>4.1.1、简介</h3><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<h3 id="4-1-2、准备工作"><a href="#4-1-2、准备工作" class="headerlink" title="4.1.2、准备工作"></a>4.1.2、准备工作</h3><h4 id="①加入依赖-1"><a href="#①加入依赖-1" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

<h4 id="②创建jdbc-properties"><a href="#②创建jdbc-properties" class="headerlink" title="②创建jdbc.properties"></a>②创建jdbc.properties</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=root
jdbc.password=atguigu
jdbc.url=jdbc:mysql://localhost:3306/ssm
jdbc.driver=com.mysql.cj.jdbc.Driver</code></pre>

<h4 id="③配置Spring的配置文件"><a href="#③配置Spring的配置文件" class="headerlink" title="③配置Spring的配置文件"></a>③配置Spring的配置文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;
&lt;!-- 配置数据源 --&gt;
&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
    &lt;property name="url" value="${atguigu.url}"/&gt;
    &lt;property name="driverClassName" value="${atguigu.driver}"/&gt;
    &lt;property name="username" value="${atguigu.username}"/&gt;
    &lt;property name="password" value="${atguigu.password}"/&gt;
&lt;/bean&gt;
&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;!-- 装配数据源 --&gt;
    &lt;property name="dataSource" ref="druidDataSource"/&gt;
&lt;/bean&gt;</code></pre>

<h3 id="4-1-3、测试"><a href="#4-1-3、测试" class="headerlink" title="4.1.3、测试"></a>4.1.3、测试</h3><h4 id="①在测试类装配-JdbcTemplate"><a href="#①在测试类装配-JdbcTemplate" class="headerlink" title="①在测试类装配 JdbcTemplate"></a>①在测试类装配 JdbcTemplate</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//指定当前测试类在Spring的测试环境中执行，此时就可以通过注入的方式直接获取IOC容器中bean
@RunWith(SpringJUnit4ClassRunner.class)
//设置Spring测试环境的配置文件
@ContextConfiguration("classpath:spring-jdbc.xml")
public class JDBCTemplateTest {
    @Autowired
    private JdbcTemplate jdbcTemplate;
}</code></pre>

<h4 id="②测试增删改功能"><a href="#②测试增删改功能" class="headerlink" title="②测试增删改功能"></a>②测试增删改功能</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
//测试增删改功能
public void testUpdate(){
    String sql = "insert into t_emp values(null,?,?,?)";
    int result = jdbcTemplate.update(sql, "张三", 23, "男");
    System.out.println(result);
}</code></pre>

<h4 id="③查询一条数据为实体类对象"><a href="#③查询一条数据为实体类对象" class="headerlink" title="③查询一条数据为实体类对象"></a>③查询一条数据为实体类对象</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
//查询一条数据为一个实体类对象
public void testSelectEmpById(){
    String sql = "select * from t_emp where id = ?";
    Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 1);
    System.out.println(emp);
}</code></pre>

<h4 id="④查询多条数据为一个list集合"><a href="#④查询多条数据为一个list集合" class="headerlink" title="④查询多条数据为一个list集合"></a>④查询多条数据为一个list集合</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
//查询多条数据为一个list集合
public void testSelectList(){
    String sql = "select * from t_emp";
    List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class));
    list.forEach(emp -&gt; System.out.println(emp));
}</code></pre>

<h4 id="⑤查询单行单列的值"><a href="#⑤查询单行单列的值" class="headerlink" title="⑤查询单行单列的值"></a>⑤查询单行单列的值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
//查询单行单列的值
public void selectCount(){
    String sql = "select count(id) from t_emp";
    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
    System.out.println(count);
}</code></pre>

<h2 id="4-2、声明式事务概念"><a href="#4-2、声明式事务概念" class="headerlink" title="4.2、声明式事务概念"></a>4.2、声明式事务概念</h2><h3 id="4-2-1、编程式事务"><a href="#4-2-1、编程式事务" class="headerlink" title="4.2.1、编程式事务"></a>4.2.1、编程式事务</h3><p>事务功能的相关操作全部通过自己编写代码来实现：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn = ...;
try {
    // 开启事务：关闭事务的自动提交
    conn.setAutoCommit(false);
    // 核心操作
    // 提交事务
    conn.commit();
}catch(Exception e){
    // 回滚事务
    conn.rollBack();
}finally{
    // 释放数据库连接
    conn.close();
}</code></pre>

<p>编程式的实现方式存在缺陷：</p>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<h3 id="4-2-2、声明式事务"><a href="#4-2-2、声明式事务" class="headerlink" title="4.2.2、声明式事务"></a>4.2.2、声明式事务</h3><p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p>
<p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p>
<ul>
<li>好处1：提高开发效率</li>
<li>好处2：消除了冗余的代码</li>
<li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性</li>
</ul>
<p>能等各个方面的优化</p>
<p>所以，我们可以总结下面两个概念：</p>
<ul>
<li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li>
<li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li>
</ul>
<h2 id="4-3、基于注解的声明式事务"><a href="#4-3、基于注解的声明式事务" class="headerlink" title="4.3、基于注解的声明式事务"></a>4.3、基于注解的声明式事务</h2><h3 id="4-3-1、准备工作"><a href="#4-3-1、准备工作" class="headerlink" title="4.3.1、准备工作"></a>4.3.1、准备工作</h3><h4 id="①加入依赖-2"><a href="#①加入依赖-2" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

<h4 id="②创建jdbc-properties-1"><a href="#②创建jdbc-properties-1" class="headerlink" title="②创建jdbc.properties"></a>②创建jdbc.properties</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=root
jdbc.password=atguigu
jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.driver=com.mysql.cj.jdbc.Driver</code></pre>

<h4 id="③配置Spring的配置文件-1"><a href="#③配置Spring的配置文件-1" class="headerlink" title="③配置Spring的配置文件"></a>③配置Spring的配置文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--扫描组件--&gt;
&lt;context:component-scan base-package="com.atguigu.spring.tx.annotation"&gt;&lt;/context:component-scan&gt;
&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;
&lt;!-- 配置数据源 --&gt;
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;
&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;!-- 装配数据源 --&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>

<h4 id="④创建表"><a href="#④创建表" class="headerlink" title="④创建表"></a>④创建表</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t_book` (
    `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
    `book_name` varchar(20) DEFAULT NULL COMMENT '图书名称',
    `price` int(11) DEFAULT NULL COMMENT '价格',
    `stock` int(10) unsigned DEFAULT NULL COMMENT '库存（无符号）',
    PRIMARY KEY (`book_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,'斗破苍穹',80,100),(2,'斗罗大陆',50,100);
CREATE TABLE `t_user` (
    `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
    `username` varchar(20) DEFAULT NULL COMMENT '用户名',
    `balance` int(10) unsigned DEFAULT NULL COMMENT '余额（无符号）',
    PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
insert into `t_user`(`user_id`,`username`,`balance`) values (1,'admin',50);</code></pre>

<h4 id="⑤创建组件"><a href="#⑤创建组件" class="headerlink" title="⑤创建组件"></a>⑤创建组件</h4><p>创建BookController：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class BookController {
    @Autowired
    private BookService bookService;
    public void buyBook(Integer bookId, Integer userId){
        bookService.buyBook(bookId, userId);
    }
}</code></pre>

<p>创建接口BookService：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookService {
	void buyBook(Integer bookId, Integer userId);
}</code></pre>

<p>创建实现类BookServiceImpl：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;
    @Override
    public void buyBook(Integer bookId, Integer userId) {
        //查询图书的价格
        Integer price = bookDao.getPriceByBookId(bookId);
        //更新图书的库存
        bookDao.updateStock(bookId);
        //更新用户的余额
        bookDao.updateBalance(userId, price);
    }
}</code></pre>

<p>创建接口BookDao：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookDao {
    Integer getPriceByBookId(Integer bookId);
    void updateStock(Integer bookId);
    void updateBalance(Integer userId, Integer price);
}</code></pre>

<p>创建实现类BookDaoImpl：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public Integer getPriceByBookId(Integer bookId) {
        String sql = "select price from t_book where book_id = ?";
        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);
    }
    @Override
    public void updateStock(Integer bookId) {
        String sql = "update t_book set stock = stock - 1 where book_id = ?";
        jdbcTemplate.update(sql, bookId);
    }
    @Override
    public void updateBalance(Integer userId, Integer price) {
        String sql = "update t_user set balance = balance - ? where user_id =?";
            jdbcTemplate.update(sql, price, userId);
    }
}</code></pre>

<h3 id="4-3-2、测试无事务情况"><a href="#4-3-2、测试无事务情况" class="headerlink" title="4.3.2、测试无事务情况"></a>4.3.2、测试无事务情况</h3><h4 id="①创建测试类"><a href="#①创建测试类" class="headerlink" title="①创建测试类"></a>①创建测试类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:tx-annotation.xml")
public class TxByAnnotationTest {
    // 直接通过注入方式获取IOC中的bean
    @Autowired
    private BookController bookController;
    
    @Test
    public void testBuyBook(){
        bookController.buyBook(1, 1);
    }
}</code></pre>

<h4 id="②模拟场景"><a href="#②模拟场景" class="headerlink" title="②模拟场景"></a>②模拟场景</h4><p>用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额</p>
<p>假设用户id为1的用户，购买id为1的图书</p>
<p>用户余额为50，而图书价格为80</p>
<p>购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段</p>
<p>此时执行sql语句会抛出SQLException</p>
<h4 id="③观察结果"><a href="#③观察结果" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>因为没有添加事务，图书的库存更新了，但是用户的余额没有更新</p>
<p>显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败</p>
<h3 id="4-3-3、加入事务"><a href="#4-3-3、加入事务" class="headerlink" title="4.3.3、加入事务"></a>4.3.3、加入事务</h3><h4 id="①添加事务配置"><a href="#①添加事务配置" class="headerlink" title="①添加事务配置"></a>①添加事务配置</h4><p>在Spring的配置文件中添加配置：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--配置事务管理器，事务需要数据源--&gt;
&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!--
    开启事务的注解驱动，相当于一个环绕通知
    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&gt;
&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;</code></pre>

<p>注意：导入的名称空间需要 <strong>tx</strong> <strong>结尾</strong>的那个。</p>
<p><img src="28.png" alt="28"></p>
<h4 id="②添加事务注解"><a href="#②添加事务注解" class="headerlink" title="②添加事务注解"></a>②添加事务注解</h4><p>因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此<strong>处理事务一般在service层处理</strong></p>
<p>在BookServiceImpl的buybook()添加注解@Transactional</p>
<h4 id="③观察结果-1"><a href="#③观察结果-1" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>由于使用了Spring的声明式事务，更新库存和更新余额都没有执行</p>
<h3 id="4-3-4、-Transactional注解标识的位置"><a href="#4-3-4、-Transactional注解标识的位置" class="headerlink" title="4.3.4、@Transactional注解标识的位置"></a>4.3.4、@Transactional注解标识的位置</h3><p>@Transactional标识在方法上，咋只会影响该方法</p>
<p>@Transactional标识的类上，咋会影响类中所有的方法</p>
<h3 id="4-3-5、事务属性：只读"><a href="#4-3-5、事务属性：只读" class="headerlink" title="4.3.5、事务属性：只读"></a>4.3.5、事务属性：只读</h3><h4 id="①介绍-1"><a href="#①介绍-1" class="headerlink" title="①介绍"></a>①介绍</h4><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p>
<h4 id="②使用方式"><a href="#②使用方式" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(readOnly = true)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}</code></pre>

<h4 id="③注意"><a href="#③注意" class="headerlink" title="③注意"></a>③注意</h4><p>对增删改操作设置只读会抛出下面异常：</p>
<p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification</p>
<p>are not allowed</p>
<h3 id="4-3-6、事务属性：超时"><a href="#4-3-6、事务属性：超时" class="headerlink" title="4.3.6、事务属性：超时"></a>4.3.6、事务属性：超时</h3><h4 id="①介绍-2"><a href="#①介绍-2" class="headerlink" title="①介绍"></a>①介绍</h4><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p>
<p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p>
<p>概括来说就是一句话：超时回滚，释放资源。</p>
<h4 id="②使用方式-1"><a href="#②使用方式-1" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(timeout = 3)
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}</code></pre>

<h4 id="③观察结果-2"><a href="#③观察结果-2" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>执行过程中抛出异常：</p>
<p>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out:</p>
<p>deadline was Fri Jun 04 16:25:39 CST 2022</p>
<h3 id="4-3-7、事务属性：回滚策略"><a href="#4-3-7、事务属性：回滚策略" class="headerlink" title="4.3.7、事务属性：回滚策略"></a>4.3.7、事务属性：回滚策略</h3><h4 id="①介绍-3"><a href="#①介绍-3" class="headerlink" title="①介绍"></a>①介绍</h4><p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。</p>
<p>可以通过@Transactional中相关属性设置回滚策略</p>
<ul>
<li>rollbackFor属性：需要设置一个Class类型的对象</li>
<li>rollbackForClassName属性：需要设置一个字符串类型的全类名</li>
<li>noRollbackFor属性：需要设置一个Class类型的对象</li>
<li>rollbackFor属性：需要设置一个字符串类型的全类名</li>
</ul>
<h4 id="②使用方式-2"><a href="#②使用方式-2" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(noRollbackFor = ArithmeticException.class)
//@Transactional(noRollbackForClassName = "java.lang.ArithmeticException")
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    System.out.println(1/0);
}</code></pre>

<h4 id="③观察结果-3"><a href="#③观察结果-3" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当</p>
<p>出现ArithmeticException不发生回滚，因此购买图书的操作正常执行</p>
<h3 id="4-3-8、事务属性：事务隔离级别"><a href="#4-3-8、事务属性：事务隔离级别" class="headerlink" title="4.3.8、事务属性：事务隔离级别"></a>4.3.8、事务属性：事务隔离级别</h3><h4 id="①介绍-4"><a href="#①介绍-4" class="headerlink" title="①介绍"></a>①介绍</h4><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事</p>
<p>务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同</p>
<p>的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<p>隔离级别一共有四种：</p>
<ul>
<li>读未提交：READ UNCOMMITTED</li>
</ul>
<p>允许Transaction01读取Transaction02未提交的修改。</p>
<ul>
<li>读已提交：READ COMMITTED、</li>
</ul>
<p>要求Transaction01只能读取Transaction02已提交的修改。</p>
<ul>
<li>可重复读：REPEATABLE READ</li>
</ul>
<p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它</p>
<p>事务对这个字段进行更新。</p>
<ul>
<li>串行化：SERIALIZABLE</li>
</ul>
<p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它</p>
<p>事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p>
<p>各个隔离级别解决并发问题的能力见下表：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>各种数据库产品对事务隔离级别的支持程度：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>Oracle</strong></th>
<th><strong>MySQL</strong></th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>√(默认)</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>×</td>
<td>√(默认)</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h4 id="②使用方式-3"><a href="#②使用方式-3" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化</code></pre>

<h3 id="4-3-9、事务属性：事务传播行为"><a href="#4-3-9、事务属性：事务传播行为" class="headerlink" title="4.3.9、事务属性：事务传播行为"></a>4.3.9、事务属性：事务传播行为</h3><h4 id="①介绍-5"><a href="#①介绍-5" class="headerlink" title="①介绍"></a>①介绍</h4><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<h4 id="②测试"><a href="#②测试" class="headerlink" title="②测试"></a>②测试</h4><p>创建接口CheckoutService：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CheckoutService {
	void checkout(Integer userId, Integer[] bookIds);
}</code></pre>

<p>创建实现类CheckoutServiceImpl：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class CheckoutServiceImpl implements CheckoutService {
    @Autowired
    private BookService bookService;
    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer userId, Integer[] bookIds) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(userId, bookId);
        }
    }
}</code></pre>

<p>在BookController中添加方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowired
private CheckoutService checkoutService;
public void checkout(Integer userId, Integer[] bookIds){
    checkoutService.checkout(userId, bookIds);
}</code></pre>

<p>在数据库中将用户的余额修改为100元</p>
<h4 id="③观察结果-4"><a href="#③观察结果-4" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>可以通过@Transactional中的<strong>propagation属性</strong>设置事务传播行为</p>
<p>修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性</p>
<ul>
<li><p><code>@Transactional(propagation = Propagation.REQUIRED)</code>，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。</p>
<ul>
<li>经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了</li>
</ul>
</li>
<li><p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>，表示不管当前线程上是否有已经开启的事务，<strong>都要开启新事务</strong>。</p>
<ul>
<li>同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本</li>
</ul>
</li>
</ul>
<h2 id="4-4、基于XML的声明式事务"><a href="#4-4、基于XML的声明式事务" class="headerlink" title="4.4、基于XML的声明式事务"></a>4.4、基于XML的声明式事务</h2><h3 id="4-3-1、场景模拟"><a href="#4-3-1、场景模拟" class="headerlink" title="4.3.1、场景模拟"></a>4.3.1、场景模拟</h3><p>参考基于注解的声明式事务</p>
<h3 id="4-3-2、修改Spring配置文件"><a href="#4-3-2、修改Spring配置文件" class="headerlink" title="4.3.2、修改Spring配置文件"></a>4.3.2、修改Spring配置文件</h3><p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:config&gt;
    &lt;!-- 配置事务通知和切入点表达式 --&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(*com.atguigu.spring.tx.xml.service.impl.*.*(..))"&gt;&lt;/aop:advisor&gt;
&lt;/aop:config&gt;
&lt;!-- tx:advice标签：配置事务通知 --&gt;
&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;
&lt;!-- transaction-manager属性：关联事务管理器 --&gt;
&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;
    &lt;tx:attributes&gt;
        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;
        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;
        &lt;tx:method name="get*" read-only="true"/&gt;
        &lt;tx:method name="query*" read-only="true"/&gt;
        &lt;tx:method name="find*" read-only="true"/&gt;
        &lt;!-- read-only属性：设置只读属性 --&gt;
        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;
        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;
        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;
        &lt;!-- timeout属性：设置事务的超时属性 --&gt;
        &lt;!-- propagation属性：设置事务的传播行为 --&gt;
        &lt;tx:method name="save*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;
        &lt;tx:method name="update*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;
        &lt;tx:method name="delete*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>

<blockquote>
<p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖(需要aop切面，aspectJ可以实现)</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
  &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</blockquote>
 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/07/10/Spring/">https://nan-ying.github.io/2023/07/10/Spring/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/Spring/">
              <span class="chip bg-color">Spring</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-07-10T19-23-55',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/20/SpringMVC/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="SpringMVC">
                        
                        <span class="card-title">SpringMVC</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SSM/" class="post-category">
                                    SSM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SpringMVC/">
                        <span class="chip bg-color">SpringMVC</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/02/MyBatis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="MyBatis">
                        
                        <span class="card-title">MyBatis</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SSM/" class="post-category">
                                    SSM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MyBatis/">
                        <span class="chip bg-color">MyBatis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2023</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >698.4k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
