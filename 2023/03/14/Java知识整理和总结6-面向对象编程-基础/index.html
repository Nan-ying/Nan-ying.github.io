<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java知识整理和总结6-面向对象编程-基础, Nan-ying&#39;s Blog">
    <meta name="description" content="第06章_面向对象编程（基础）本章专题与脉络

学习面向对象内容的三条主线

Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类
面向对象的特征：封装、继承、多态、（抽象）
其他关键字的使用：this、super、pa">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java知识整理和总结6-面向对象编程-基础 | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java知识整理和总结6-面向对象编程-基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/Java/">
              <span class="chip bg-color">Java</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/Java/" class="post-category">
              Java
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-03-14
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 16.5k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          66 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h1 id="第06章-面向对象编程（基础）"><a href="#第06章-面向对象编程（基础）" class="headerlink" title="第06章_面向对象编程（基础）"></a>第06章_面向对象编程（基础）</h1><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="%E7%AC%AC2%E9%98%B6%E6%AE%B5%EF%BC%9AJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%AC%AC06%E7%AB%A0.png" alt="第2阶段：Java面向对象编程-第06章"></p>
<hr>
<p><strong>学习面向对象内容的三条主线</strong></p>
<ul>
<li>Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类</li>
<li>面向对象的特征：封装、继承、多态、（抽象）</li>
<li>其他关键字的使用：this、super、package、import、static、final、interface、abstract等</li>
</ul>
<h2 id="1-面向对象编程概述-了解"><a href="#1-面向对象编程概述-了解" class="headerlink" title="1. 面向对象编程概述(了解)"></a>1. 面向对象编程概述(了解)</h2><h3 id="1-1-程序设计的思路"><a href="#1-1-程序设计的思路" class="headerlink" title="1.1 程序设计的思路"></a>1.1 程序设计的思路</h3><p>面向对象，是软件开发中的一类编程风格、开发范式。除了<code>面向对象</code>，还有<code>面向过程</code>、<code>指令式编程</code>和<code>函数式编程</code>。在所有的编程范式中，我们接触最多的还是面向过程和面向对象两种。</p>
<blockquote>
<p>类比：史书类型</p>
<ul>
<li>纪传体：以人物传记为中心，“本纪”叙述帝王，“世家”记叙王侯封国和特殊人物，“列传”记叙民间人物。</li>
<li>编年体：按年、月、日顺序编写。</li>
<li>国别体：是一部分国记事的历史散文，分载多国历史。</li>
</ul>
</blockquote>
<p>早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的<code>弊端</code>越来越明显，出现了面向对象思想并成为目前主流的方式。</p>
<p><strong>1. 面向过程的程序设计思想（Process-Oriented Programming）</strong>，简称<code>POP</code></p>
<ul>
<li>关注的焦点是<code>过程</code>：过程就是操作数据的步骤。如果某个过程的实现代码重复出现，那么就可以把这个过程抽取为一个<code>函数</code>。这样就可以大大简化冗余代码，便于维护。</li>
<li>典型的语言：C语言</li>
<li>代码结构：以<code>函数</code>为组织单位。</li>
<li>是一种“<code>执行者思维</code>”，适合解决简单问题。扩展能力差、后期维护难度较大。</li>
</ul>
<p><strong>2. 面向对象的程序设计思想（ Object Oriented Programming）</strong>，简称<code>OOP</code></p>
<ul>
<li>关注的焦点是<code>类</code>：在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，用类来表示。</li>
<li>典型的语言：Java、C#、C++、Python、Ruby和PHP等</li>
<li>代码结构：以<code>类</code>为组织单位。每种事物都具备自己的<code>属性</code>和<code>行为/功能</code>。</li>
<li>是一种“<code>设计者思维</code>”，适合解决复杂问题。代码扩展性强、可维护性高。</li>
</ul>
<h3 id="1-2-由实际问题考虑如何设计程序"><a href="#1-2-由实际问题考虑如何设计程序" class="headerlink" title="1.2 由实际问题考虑如何设计程序"></a>1.2 由实际问题考虑如何设计程序</h3><p><strong>思考1：如何开车？</strong></p>
<p>面向过程思想思考问题时，我们首先思考“<code>怎么按步骤实现？</code>”并将步骤对应成方法，一步一步，最终完成。 这个适合<code>简单任务</code>，不需要<code>过多协作</code>的情况。针对如何开车，可以列出步骤：</p>
<img src="%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83.png" alt="image-20220520154055429" style="zoom: 90%;">

<p>面向过程适合简单、不需要协作的事务，重点关注如何执行。 </p>
<p><strong>思考2：如何造车？</strong></p>
<p>造车太复杂，需要<code>很多协作</code>才能完成。此时我们思考的是“<code>车怎么设计？</code>”，而不是“怎么按特定步骤造车的问题”。这就是思维方式的转变，前者就是面向对象思想。所以，面向对象(Oriented-Object)思想更契合人的思维模式。</p>
<p>用面向对象思想思考“如何设计车”：</p>
<img src="a49bd1fc8152291f0c5b43ee3322672d.png" alt="a49bd1fc8152291f0c5b43ee3322672d" style="zoom: 25%;">

<p>自然地，我们就会从“车由什么组成”开始思考。发现，车由如下结构组成：</p>
<img src="image-20220520155357634.png" alt="image-20220520155357634" style="zoom: 67%;">

<p>我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤，…；这样，大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思维！</p>
<p>因此，<strong>面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。</strong> 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。</p>
<blockquote>
<p>注意：</p>
<p>我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！</p>
</blockquote>
<p><strong>类比举例1：</strong></p>
<p><img src="tuandui.jpg" alt="tuandui"></p>
<blockquote>
<p>当需求单一，或者简单时，我们一步步去操作没问题，并且效率也挺高。</p>
<p>可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，<strong>能不能把这些步骤和功能进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。</strong>这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</p>
</blockquote>
<p><strong>类比举例2：人把大象装进冰箱</strong></p>
<ul>
<li><p>面向过程</p>
<pre class="line-numbers language-none"><code class="language-none">1.打开冰箱

2.把大象装进冰箱

3.把冰箱门关住
</code></pre>

<p>面向对象</p>
<pre class="line-numbers language-none"><code class="language-none">人{
    打开（冰箱）{
		冰箱.开门();	
    }
    操作(大象){
             大象.进入(冰箱);
    }
    关闭(冰箱){   
          冰箱.关门();     
    }
}

冰箱{
     开门(){ }  
     关门(){ }
}

大象{
     进入(冰箱){  }
}
</code></pre></li>
</ul>
<p><strong>练习：</strong>抽象出下面系统中的“类”及其关系</p>
<img src="image-20220319180839009.png" alt="image-20220319180839009" style="zoom:80%;">

<h3 id="1-3-如何掌握这种思想？"><a href="#1-3-如何掌握这种思想？" class="headerlink" title="1.3 如何掌握这种思想？"></a>1.3 如何掌握这种思想？</h3><img src="image-20220319180301856.png" alt="image-20220319180301856" style="zoom: 67%;">

<h2 id="2-Java语言的基本元素：类和对象"><a href="#2-Java语言的基本元素：类和对象" class="headerlink" title="2. Java语言的基本元素：类和对象"></a>2. Java语言的基本元素：类和对象</h2><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p>人认识世界，其实就是面向对象的。比如，我们认识一下美人鱼（都没见过）</p>
<img src="image-20220520162643547.png" alt="image-20220520162643547" style="zoom:67%;">

<p>经过“仔细学习”，发现美人鱼通常具备一些特征：</p>
<ul>
<li>女孩</li>
<li>有鱼尾</li>
<li>美丽</li>
</ul>
<p>这个总结的过程，其实是<code>抽象化</code>的过程。抽象出来的美人鱼的特征，可以归纳为一个<code>美人鱼类</code>。而图片中的都是这个类呈现出来的<code>具体的对象</code>。</p>
<h3 id="2-2-类和对象概述"><a href="#2-2-类和对象概述" class="headerlink" title="2.2 类和对象概述"></a>2.2 类和对象概述</h3><p><code>类(Class)</code>和<code>对象(Object)</code>是面向对象的核心概念。</p>
<p><strong>1、什么是类</strong></p>
<p><strong>类</strong>：具有相同特征的事物的抽象描述，是<code>抽象的</code>、概念上的定义。</p>
<p><strong>2、什么是对象</strong></p>
<p><strong>对象</strong>：实际存在的该类事物的<code>每个个体</code>，是<code>具体的</code>，因而也称为<code>实例(instance)</code>。</p>
<p><img src="image-20220319210405983.png" alt="image-20220319210405983"></p>
<p>可以理解为：<code>类 =&gt; 抽象概念的人</code>；<code>对象 =&gt; 实实在在的某个人</code></p>
<hr>
<img src="iphone13promax.jpeg" style="zoom:85%;">

<hr>
<img src="image-20220503101940126.png" alt="image-20220503101940126" style="zoom:67%;">

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>3、类与对象的关系错误理解</strong></p>
<pre class="line-numbers language-none"><code class="language-none">曰：“白马非马，可乎？”
曰：“可。”
曰：“何哉？”
曰：“马者，所以命形也。白者，所以命色也。命色者，非命形也，故曰白马非马。”</code></pre>

<p><img src="image-20220319214213898.png" alt="image-20220319214213898"></p>
<h3 id="2-3-类的成员概述"><a href="#2-3-类的成员概述" class="headerlink" title="2.3 类的成员概述"></a>2.3 类的成员概述</h3><blockquote>
<p>面向对象程序设计的重点是<code>类的设计</code></p>
<p>类的设计，其实就是<code>类的成员的设计</code></p>
</blockquote>
<ul>
<li><p>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的<code>细胞</code>构成的。同理，Java代码世界是由诸多个不同功能的<code>类</code>构成的。</p>
<img src="image-20220319211527249.png" alt="image-20220319211527249" style="zoom:67%;">
</li>
<li><p>现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… </p>
<p>Java中用类class来描述事物也是如此。类，是一组相关<code>属性</code>和<code>行为</code>的集合，这也是类最基本的两个成员。</p>
<ul>
<li><strong>属性</strong>：该类事物的状态信息。对应类中的<code>成员变量</code><ul>
<li><strong>成员变量 &lt;=&gt; 属性 &lt;=&gt; Field</strong></li>
</ul>
</li>
<li><strong>行为</strong>：该类事物要做什么操作，或者基于事物的状态能做什么。对应类中的<code>成员方法</code><ul>
<li><strong>(成员)方法 &lt;=&gt; 函数 &lt;=&gt; Method</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="20220319_211611.jpg" alt="20220319_211611" style="zoom: 67%;">

<ul>
<li>举例：</li>
</ul>
<p><img src="image-20220319211859026.png" alt="image-20220319211859026"></p>
<h3 id="2-4-面向对象完成功能的三步骤（重要）"><a href="#2-4-面向对象完成功能的三步骤（重要）" class="headerlink" title="2.4 面向对象完成功能的三步骤（重要）"></a>2.4 面向对象完成功能的三步骤（重要）</h3><h4 id="步骤1：类的定义"><a href="#步骤1：类的定义" class="headerlink" title="步骤1：类的定义"></a>步骤1：类的定义</h4><p>类的定义使用关键字：class。格式如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符] class 类名{
	属性声明;
    方法声明;
}</code></pre>

<p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{
    //声明属性age
    int age ;	                   
    
    //声明方法showAge()
    public void eat() {        
	    System.out.println("人吃饭");
    }
}
</code></pre>

<p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Dog{
    //声明属性
	String type; //种类
	String nickName; //昵称
	String hostName; //主人名称
	
    //声明方法
	public void eat(){ //吃东西
		System.out.println("狗狗进食");		
	}
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{
    String name;
    char gender;
    Dog dog;
    
    //喂宠物
    public void feed(){
        dog.eat();
    }
}</code></pre>

<h4 id="步骤2：对象的创建"><a href="#步骤2：对象的创建" class="headerlink" title="步骤2：对象的创建"></a>步骤2：对象的创建</h4><img src="image-20220319213201568.png" alt="image-20220319213201568" style="zoom: 50%;">

<ul>
<li>创建对象，使用关键字：<strong>new</strong></li>
<li>创建对象语法：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//方式1：给创建的对象命名
//把创建的对象用一个引用数据类型的变量保存起来，这样就可以反复使用这个对象了
类名 对象名 = new 类名();

//方式2：
new 类名()//也称为匿名对象
</code></pre>

<ul>
<li>举例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class PersonTest{
	public static void main(String[] args){
		//创建Person类的对象
		Person per = new Person();
		//创建Dog类的对象
		Dog dog = new Dog();
	}
}</code></pre>

<h4 id="步骤3：对象调用属性或方法"><a href="#步骤3：对象调用属性或方法" class="headerlink" title="步骤3：对象调用属性或方法"></a>步骤3：对象调用属性或方法</h4><ul>
<li><p>对象是类的一个<strong>实例</strong>，必然具备该类事物的属性和行为（即方法）。</p>
</li>
<li><p>使用”<code>对象名.属性</code>“ 或 “<code>对象名.方法</code>“的方式访问对象成员（包括属性和方法）</p>
</li>
</ul>
<p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//声明Animal类
public class Animal { //动物类
    public int legs;

    public void eat() {
        System.out.println("Eating.");
    }

    public void move() {
        System.out.println("Move.");
    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">//声明测试类
public class AnimalTest {
    public static void main(String args[]) {
        //创建对象
        Animal xb = new Animal();
        xb.legs = 4;//访问属性
        System.out.println(xb.legs);
        xb.eat();//访问方法
        xb.move();//访问方法
    }
}</code></pre>

<p>图示理解：<img src="image-20220319213753668.png" alt="image-20220319213753668"></p>
<p>举例2：针对前面步骤1的举例2：类的实例化（创建类的对象）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Game{
    public static void main(String[] args){
        Person p = new Person();
        //通过Person对象调用属性
        p.name = "康师傅";
        p.gender = '男';
        p.dog = new Dog(); //给Person对象的dog属性赋值
        
        //给Person对象的dog属性的type、nickname属性赋值
        p.dog.type = "柯基犬";
        p.dog.nickName = "小白";
        
        //通过Person对象调用方法
        p.feed();
    }
}</code></pre>

<h3 id="2-5-匿名对象-anonymous-object"><a href="#2-5-匿名对象-anonymous-object" class="headerlink" title="2.5 匿名对象 (anonymous object)"></a>2.5 匿名对象 (anonymous object)</h3><ul>
<li><p>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</p>
<ul>
<li>如：new Person().shout();</li>
</ul>
</li>
<li><p>使用情况</p>
<ul>
<li>如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 </li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<h2 id="3-对象的内存解析"><a href="#3-对象的内存解析" class="headerlink" title="3. 对象的内存解析"></a>3. 对象的内存解析</h2><h3 id="3-1-JVM内存结构划分"><a href="#3-1-JVM内存结构划分" class="headerlink" title="3.1 JVM内存结构划分"></a>3.1 JVM内存结构划分</h3><p>HotSpot Java虚拟机的架构图如下。其中我们主要关心的是运行时数据区部分（Runtime Data Area）。</p>
<p><img src="JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.png" alt="JVM架构-简图"></p>
<p>其中：</p>
<p><code>堆（Heap）</code>：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>
<p><code>栈（Stack）</code>：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。</p>
<p><code>方法区（Method Area）</code>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="3-2-对象内存解析"><a href="#3-2-对象内存解析" class="headerlink" title="3.2 对象内存解析"></a>3.2 对象内存解析</h3><p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person { //类：人
    String name;
    int age;
    boolean isMale;
}

public class PersonTest { //测试类
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.name = "赵同学";
        p1.age = 20;
        p1.isMale = true;

        Person p2 = new Person();
        p2.age = 10;

        Person p3 = p1;
        p3.name = "郭同学";
    }
}</code></pre>

<p>内存解析图：</p>
<img src="image-20220319215723183.png" alt="image-20220319215723183" style="zoom:67%;">

<blockquote>
<p>说明：</p>
<ul>
<li>堆：凡是new出来的结构(对象、数组)都放在堆空间中。</li>
<li>对象的属性存放在堆空间中。</li>
<li>创建一个类的多个对象（比如p1、p2），则每个对象都拥有当前类的一套”副本”（即属性）。当通过一个对象修改其属性时，不会影响其它对象此属性的值。</li>
<li>当声明一个新的变量使用现有的对象进行赋值时（比如p3 = p1），此时并没有在堆空间中创建新的对象。而是两个变量共同指向了堆空间中同一个对象。当通过一个对象修改属性时，会影响另外一个对象对此属性的调用。</li>
</ul>
</blockquote>
<p><strong>面试题：对象名中存储的是什么呢？</strong></p>
<p>答：对象地址</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StudentTest{
    public static void main(String[] args){
        System.out.println(new Student());//Student@7852e922

        Student stu = new Student();
        System.out.println(stu);//Student@4e25154f
        
        int[] arr = new int[5];
		System.out.println(arr);//[I@70dea4e
    }
}</code></pre>

<p>直接打印对象名和数组名都是显示“类型@对象的hashCode值”，所以说<strong>类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。</strong></p>
<p><img src="1561597909862.png" alt="1561597909862"></p>
<h3 id="3-3-练习"><a href="#3-3-练习" class="headerlink" title="3.3 练习"></a>3.3 练习</h3><p>根据代码，画出内存图</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Car {
    String color = "red";
    int num = 4;

    void show() {
        System.out.println("color=" + color + ",num=" + num);
    }
}

class CarTest {
    public static void main(String[] args) {
        Car c1 = new Car();   //建立对象c1
        Car c2 = new Car();   //建立对象c2
        c1.color = "blue";   //对对象的属性进行修改
        c1.show();   //使用对象的方法
        c2.show();
    }
}</code></pre>

<h2 id="4-类的成员之一：成员变量-field"><a href="#4-类的成员之一：成员变量-field" class="headerlink" title="4. 类的成员之一：成员变量(field)"></a>4. 类的成员之一：成员变量(field)</h2><h3 id="4-1-如何声明成员变量"><a href="#4-1-如何声明成员变量" class="headerlink" title="4.1 如何声明成员变量"></a>4.1 如何声明成员变量</h3><ul>
<li>语法格式：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符1] class 类名{
    [修饰符2] 数据类型 成员变量名 [= 初始化值]; 
}</code></pre>

<ul>
<li>说明：<ul>
<li>位置要求：必须在类中，方法外</li>
<li>修饰符2(暂不考虑)<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final</li>
</ul>
</li>
<li>数据类型<ul>
<li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li>
</ul>
</li>
<li>成员变量名<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
<li>初始化值<ul>
<li>根据情况，可以显式赋值；也可以不赋值，使用默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{
	private int age;             //声明private变量 age
	public String name = “Lila”;    //声明public变量 name
}
</code></pre>

<h3 id="4-2-成员变量-vs-局部变量"><a href="#4-2-成员变量-vs-局部变量" class="headerlink" title="4.2 成员变量 vs 局部变量"></a>4.2 成员变量 vs 局部变量</h3><p><strong>1、变量的分类：成员变量与局部变量</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部等位置声明的变量称为局部变量。</li>
</ul>
<img src="image-20220511101608038.png" alt="image-20220511101608038" style="zoom:67%;">

<img src="image-20220319230744617.png" alt="image-20220319230744617" style="zoom:80%;">

<blockquote>
<p>其中，static可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。接下来先学习实例变量。</p>
</blockquote>
<p><strong>2、成员变量 与 局部变量 的对比</strong></p>
<ul>
<li><p>相同点</p>
<ul>
<li>变量声明的格式相同： 数据类型  变量名 = 初始化值</li>
</ul>
<ul>
<li><pre><code>        变量必须先声明、后初始化、再使用。
</code></pre>
</li>
</ul>
<ul>
<li>变量都有其对应的作用域。只在其作用域内是有效的</li>
</ul>
</li>
<li><p>不同点</p>
</li>
</ul>
<p>1、声明位置和方式<br>（1）实例变量：在类中方法外<br>（2）局部变量：在方法体{}中或方法的形参列表、代码块中</p>
<p>2、在内存中存储的位置不同<br>（1）实例变量：堆<br>（2）局部变量：栈</p>
<p>3、生命周期<br>（1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡，<br>            而且每一个对象的实例变量是独立的。<br>（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡，<br>            而且每一次方法调用都是独立。</p>
<p>4、作用域<br>（1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”<br>（2）局部变量：出了作用域就不能使用</p>
<p>5、修饰符（后面来讲）<br>（1）实例变量：public,protected,private,final,volatile,transient等<br>（2）局部变量：final</p>
<p>6、默认值<br>（1）实例变量：有默认值<br>（2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。</p>
<p><strong>3、对象属性的默认初始化赋值</strong></p>
<p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p>
<img src="image-20220319231821747.png" alt="image-20220319231821747" style="zoom:80%;">

<p><strong>4、举例</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person {//人类
    //1.属性
    String name;//姓名
    int age = 1;//年龄
    boolean isMale;//是否是男性

    public void show(String nation) {
        //nation:局部变量
        String color;//color:局部变量
        color = "yellow";
    }
}

//测试类
class PersonTest {
    public static void main(String[] args) {
        Person p = new Person();
        p.show("CHN");
    }
}</code></pre>

<img src="image-20220319231703240.png" alt="image-20220319231703240" style="zoom:80%;">

<h2 id="5-类的成员之二：方法-method"><a href="#5-类的成员之二：方法-method" class="headerlink" title="5. 类的成员之二：方法(method)"></a>5. 类的成员之二：方法(method)</h2><h3 id="5-1-方法的引入"><a href="#5-1-方法的引入" class="headerlink" title="5.1 方法的引入"></a>5.1 方法的引入</h3><img src="%E8%A1%97%E5%A4%B4%E9%9C%B8%E7%8E%8B&amp;%E8%B6%85%E7%BA%A7%E7%8E%9B%E4%B8%BD.jpg">

<p>《街霸》游戏中，每次人物出拳、出脚或跳跃等动作都需要编写50-80行的代码，在每次出拳、出脚或跳跃的地方都需要重复地编写这50-80行代码，这样程序会变得<code>很臃肿</code>，可读性也非常差。为了解决代码重复编写的问题，可以将出拳、出脚或跳跃的代码提取出来放在一个{}中，并为这段代码起个名字，这样在每次的出拳、出脚或跳跃的地方通过这个名字来调用这个{}的代码就可以了。</p>
<p>上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要出拳、出脚或跳跃时调用该方法即可。</p>
<h3 id="5-2-方法-method、函数-的理解"><a href="#5-2-方法-method、函数-的理解" class="headerlink" title="5.2 方法(method、函数)的理解"></a>5.2 方法(method、函数)的理解</h3><ul>
<li><p><code>方法</code>是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为<code>函数</code>或<code>过程</code>。 </p>
</li>
<li><p>将功能封装为方法的目的是，可以<code>实现代码重用，减少冗余，简化代码</code></p>
</li>
<li><p>Java里的方法<code>不能独立存在</code>，所有的方法必须定义在类里。</p>
</li>
<li><p>举例1：</p>
<ul>
<li>Math.random()的random()方法</li>
<li>Math.sqrt(x)的sqrt(x)方法</li>
<li>System.out.println(x)的println(x)方法</li>
<li>new Scanner(System.in).nextInt()的nextInt()方法</li>
<li>Arrays类中的binarySearch()方法、sort()方法、equals()方法</li>
</ul>
</li>
<li><p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{
    private int age;
    public int getAge()  {  //声明方法getAge()
		return age; 
    }
    public void setAge(int i) {  //声明方法setAge
		age = i;        //将参数i的值赋给类的成员变量age
    }
}
</code></pre></li>
</ul>
<h3 id="5-3-如何声明方法"><a href="#5-3-如何声明方法" class="headerlink" title="5.3 如何声明方法"></a>5.3 如何声明方法</h3><p><strong>1、声明方法的语法格式</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]{
        方法体的功能代码
}</code></pre>

<p>（1）一个完整的方法 = 方法头 + 方法体。</p>
<ul>
<li>方法头就是<code>[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]</code>，也称为<code>方法签名</code>。通常调用方法时只需要关注方法头就可以，从方法头可以看出这个方法的功能和调用格式。</li>
<li>方法体就是方法被调用后要执行的代码。对于调用者来说，不了解方法体如何实现的，并不影响方法的使用。</li>
</ul>
<p><strong>（2）方法头可能包含5个部分</strong></p>
<ul>
<li><p><strong>修饰符</strong>：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，后面会一一学习。</p>
<ul>
<li>其中，权限修饰符有public、protected、private。在讲封装性之前，我们先默认使用pulbic修饰方法。</li>
<li>其中，根据是否有static，可以将方法分为静态方法和非静态方法。其中静态方法又称为类方法，非静态方法又称为实例方法。咱们在讲static前先学习实例方法。</li>
</ul>
</li>
<li><p><strong>返回值类型</strong>： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。</p>
<ul>
<li>无返回值，则声明：void</li>
<li>有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“<code>return 返回值</code>”搭配使用</li>
</ul>
</li>
<li><p><strong>方法名</strong>：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”</p>
</li>
<li><p><strong>形参列表</strong>：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个参数。</p>
<ul>
<li>无论是否有参数，()不能省略</li>
<li>如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔，例如：<ul>
<li>一个参数： (数据类型  参数名)</li>
<li>二个参数： (数据类型1  参数1,  数据类型2  参数2)</li>
</ul>
</li>
<li>参数的类型可以是基本数据类型、引用数据类型</li>
</ul>
</li>
<li><p><strong>throws 异常列表</strong>：可选，在【第09章-异常处理】章节再讲</p>
</li>
</ul>
<p><strong>（3）方法体</strong>：方法体必须有{}括起来，在{}中编写完成方法功能的代码</p>
<p><strong>（4）关于方法体中return语句的说明：</strong></p>
<ul>
<li><p>return语句的作用是结束方法的执行，并将方法的结果返回去</p>
</li>
<li><p>如果返回值类型不是void，方法体中必须保证一定有 return 返回值; 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。</p>
</li>
<li><p>如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接写return ; 就可以。</p>
</li>
<li><p>return语句后面就不能再写其他代码了，否则会报错：Unreachable code</p>
</li>
</ul>
<p>补充：方法的分类：按照是否有形参及返回值</p>
<img src="image-20220320000047155.png" alt="image-20220320000047155" style="zoom: 50%;">

<p><strong>2、类比举例</strong></p>
<img src="image-20220503102323689.png" alt="image-20220503102323689" style="zoom:67%;">

<p><strong>3、代码示例：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.test04.method;

/**
 * 方法定义案例演示
 */
public class MethodDefineDemo {
    /**
     * 无参无返回值方法的演示
     */
    public void sayHello(){
        System.out.println("hello");
    }

    /**
     * 有参无返回值方法的演示
     * @param length int 第一个参数，表示矩形的长
     * @param width int 第二个参数，表示矩形的宽
     * @param sign char 第三个参数，表示填充矩形图形的符号
     */
    public void printRectangle(int length, int width, char sign){
        for (int i = 1; i &lt;= length ; i++) {
            for(int j=1; j &lt;= width; j++){
                System.out.print(sign);
            }
            System.out.println();
        }
    }

    /**
     * 无参有返回值方法的演示
     * @return
     */
    public int getIntBetweenOneToHundred(){
        return (int)(Math.random()*100+1);
    }
    
    /**
     * 有参有返回值方法的演示
     * @param a int 第一个参数，要比较大小的整数之一
     * @param b int 第二个参数，要比较大小的整数之二
     * @return int 比较大小的两个整数中较大者的值
     */
    public int max(int a, int b){
        return a &gt; b ? a : b;
    }
}
</code></pre>

<h3 id="5-4-如何调用实例方法"><a href="#5-4-如何调用实例方法" class="headerlink" title="5.4 如何调用实例方法"></a>5.4 如何调用实例方法</h3><p>方法通过方法名被调用，且只有被调用才会执行。</p>
<p><strong>1、方法调用语法格式</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">对象.方法名([实参列表])</code></pre>

<p><strong>2、示例</strong></p>
<p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.test04.method;

/**
 * 方法调用案例演示
 */
public class MethodInvokeDemo {
    public static void main(String[] args) {
        //创建对象
        MethodDefineDemo md = new MethodDefineDemo();

        System.out.println("-----------------------方法调用演示-------------------------");

        //调用MethodDefineDemo类中无参无返回值的方法sayHello
        md.sayHello();
        md.sayHello();
        md.sayHello();
        //调用一次，执行一次，不调用不执行

        System.out.println("------------------------------------------------");
        //调用MethodDefineDemo类中有参无返回值的方法printRectangle
        md.printRectangle(5,10,'@');

        System.out.println("------------------------------------------------");
        //调用MethodDefineDemo类中无参有返回值的方法getIntBetweenOneToHundred
        md.getIntBetweenOneToHundred();//语法没问题，就是结果丢失

        int num = md.getIntBetweenOneToHundred();
        System.out.println("num = " + num);

        System.out.println(md.getIntBetweenOneToHundred());
        //上面的代码调用了getIntBetweenOneToHundred三次，这个方法执行了三次

        System.out.println("------------------------------------------------");
        //调用MethodDefineDemo类中有参有返回值的方法max
        md.max(3,6);//语法没问题，就是结果丢失
        
        int bigger = md.max(5,6);
        System.out.println("bigger = " + bigger);

        System.out.println("8,3中较大者是：" + md.max(8,9));
    }
}
</code></pre>

<p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//1、创建Scanner的对象
Scanner input = new Scanner(System.in);//System.in默认代表键盘输入

//2、提示输入xx
System.out.print("请输入一个整数："); //对象.非静态方法(实参列表)

//3、接收输入内容
int num = input.nextInt();  //对象.非静态方法()</code></pre>

<h3 id="5-5-使用的注意点"><a href="#5-5-使用的注意点" class="headerlink" title="5.5  使用的注意点"></a>5.5  使用的注意点</h3><p>（1）必须先声明后使用，且方法必须定义在类的内部</p>
<p>（2）调用一次就执行一次，不调用不执行。</p>
<p>（3）方法中可以调用类中的方法或属性，不可以在方法内部定义方法。</p>
<p>正确示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">类{
    方法1(){
        
    }
    方法2(){
        
    }
}</code></pre>

<p>错误示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">类{
    方法1(){
        方法2(){  //位置错误
        
   		}
    }
}</code></pre>

<h3 id="5-6-关键字return的使用"><a href="#5-6-关键字return的使用" class="headerlink" title="5.6 关键字return的使用"></a>5.6 关键字return的使用</h3><ul>
<li>return在方法中的作用：<ul>
<li>作用1：结束一个方法</li>
<li>作用2：结束一个方法的同时，可以返回数据给方法的调用者</li>
</ul>
</li>
<li>注意点：在return关键字的直接后面不能声明执行语句</li>
</ul>
<h3 id="5-7-方法调用内存分析"><a href="#5-7-方法调用内存分析" class="headerlink" title="5.7 方法调用内存分析"></a>5.7 方法调用内存分析</h3><ul>
<li><p>方法<code>没有被调用</code>的时候，都在<code>方法区</code>中的字节码文件(.class)中存储。</p>
</li>
<li><p>方法<code>被调用</code>的时候，需要进入到<code>栈内存</code>中运行。方法每调用一次就会在栈中有一个<code>入栈</code>动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。</p>
</li>
<li><p>当方法执行结束后，会释放该内存，称为<code>出栈</code>，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。</p>
</li>
<li><p>栈结构：先进后出，后进先出。</p>
</li>
</ul>
<p>举例分析：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author 尚硅谷-宋红康
 * @create 9:21
 */
public class Person {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.eat();

    }
    public static void eat() {
        sleep();
        System.out.println("人：吃饭");
    }
    public static void sleep(){
        System.out.println("人：睡觉");
        doSport();
    }
    public static void doSport(){
        System.out.println("人：运动");
    }
}</code></pre>

<p>内存分析：</p>
<p><img src="image-20220524104951449.png" alt="image-20220524104951449"></p>
<h3 id="5-8-练习"><a href="#5-8-练习" class="headerlink" title="5.8 练习"></a>5.8 练习</h3><p><strong>练习1：</strong>创建一个Person类，其定义如下：</p>
<img src="image-20220320001337145.png" alt="image-20220320001337145" style="zoom:67%;">

<p>要求：</p>
<p>(1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法，输出字符串“studying”，调用showAge()方法显示age值，调用addAge()方法给对象的age属性值增加2岁。<br>(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。</p>
<p><strong>练习2：</strong>利用面向对象的编程方法，设计圆类Circle，包含属性（半径）和计算圆面积的方法。定义测试类，创建该Circle类的对象，并进行测试。</p>
<p><strong>练习3：</strong></p>
<p>3.1 编写程序，声明一个method方法，在方法中打印一个<code>10*8的*型矩形</code>，在main方法中调用该方法。</p>
<p>3.2 修改上一个程序，在method方法中，除打印一个<code>10*8的*型矩形</code>外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</p>
<p>3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个<code>m*n的*型矩形</code>，并计算该矩形的面积， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</p>
<p><strong>练习4：</strong>声明一个日期类型MyDate：有属性：年year,月month，日day。创建2个日期对象，分别赋值为：你的出生日期，你对象的出生日期，并显示信息。</p>
<p><strong>练习5（课下练习）：</strong>用面向对象的方式编写用户登录程序。</p>
<p>用户类：</p>
<ul>
<li>属性：用户名，密码</li>
<li>方法：登录</li>
</ul>
<p>界面类：</p>
<ul>
<li>在界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。<ul>
<li>输出：<ul>
<li>登录失败：用户名或密码错误！</li>
<li>登录成功：欢迎你，用户名！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {
    String name;
    String password;//密码

    /**
     * 实现用户登录的判断
     *
     * @param inputName 输入的用户名
     * @param inputPwd  输入的密码
     */
    public void login(String inputName,String inputPwd){
        if(name.equals(inputName) &amp;&amp; password.equals(inputPwd)){
            System.out.println("登录成功：欢迎你，" + name);
        }else{
            System.out.println("登录失败：用户名或密码错误！");
        }
    }

    /**
     *  实现用户登录的判断
     * @param inputName 输入的用户名
     * @param inputPwd 输入的密码
     * @return true:登录成功  false:登录失败
     */
    public boolean login1(String inputName,String inputPwd){
//        if(name.equals(inputName) &amp;&amp; password.equals(inputPwd)){
//            return true;
//        }else{
//            return false;
//        }

        //简化为：
        return name.equals(inputName) &amp;&amp; password.equals(inputPwd);
    }

}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 *
 * 用户界面类UserInterface：
 *
 * - 在用户界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。
 * - 输出：
 *     - 登录失败：用户名或密码错误！
 *     - 登录成功：欢迎你，用户名！
 *
 * @author 尚硅谷-宋红康
 * @create 9:58
 */
public class UserInterface {
    public static void main(String[] args) {

        User u1 = new User();
        u1.name = "Tom";
        u1.password = "abc123";


        Scanner scanner = new Scanner(System.in);
        System.out.print("请输入用户名：");
        String name = scanner.next();
        System.out.print("请输入密码：");
        String pwd = scanner.next();

        //演示1：
//        u1.login(name,pwd);

        //演示2：
        boolean isLogin = u1.login1(name, pwd);
        if(isLogin){
            System.out.println("登录成功：欢迎你，" + u1.name);
        }else{
            System.out.println("登录失败：用户名或密码错误！");
        }

        scanner.close();
    }
}</code></pre>

<h2 id="6-对象数组"><a href="#6-对象数组" class="headerlink" title="6. 对象数组"></a>6. 对象数组</h2><p>数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。</p>
<p><strong>1、案例</strong></p>
<p>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</p>
<p>问题一：打印出3年级(state值为3）的学生信息。</p>
<p>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</p>
<p>提示：</p>
<ol>
<li><p>生成随机数：Math.random()，返回值类型double; </p>
</li>
<li><p>四舍五入取整：Math.round(double d)，返回值类型long。</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/*
 * 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。
 */
public class Student {
	
	int number;//学号
	int state;//年级
	int score;//成绩
	
	
	public void info(){
		System.out.println("number : " + number 
				+ ",state : " + state + ",score : " + score);
	}
	
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StudentTest {

	public static void main(String[] args) {

		// Student s1 = new Student();
		// s1.number = 1;
		// s1.state = (int)(Math.random() * 6 + 1);//[1,6]
		// s1.score = (int)(Math.random() * 101);//[0,100]
		//
		// Student s2 = new Student();
		// s2.number = 2;
		// s2.state = (int)(Math.random() * 6 + 1);//[1,6]
		// s2.score = (int)(Math.random() * 101);//[0,100]
		//
		// //....
		// 对象数组
		// String[] arr = new String[10];
		// 数组的创建
		Student[] students = new Student[20];
		// 通过循环结构给数组的属性赋值
		for (int i = 0; i &lt; students.length; i++) {
			// 数组元素的赋值
			students[i] = new Student();
			// 数组元素是一个对象，给对象的各个属性赋值
			students[i].number = (i + 1);
			students[i].state = (int) (Math.random() * 6 + 1);// [1,6]
			students[i].score = (int) (Math.random() * 101);// [0,100]
		}

		// 问题一：打印出3年级(state值为3）的学生信息。
		for (int i = 0; i &lt; students.length; i++) {

			if (students[i].state == 3) {
//				System.out.println(
//						"number:" + students[i].number + ",state:" + students[i].state + ",score:" + students[i].score);
				students[i].info();
				
			}

		}
		System.out.println("******************************");
		// 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息
		// 排序前
		for (int i = 0; i &lt; students.length; i++) {
//			System.out.println(
//					"number:" + students[i].number + ",state:" + 
//							students[i].state + ",score:" + students[i].score);
			
			students[i].info();
		}

		System.out.println();
		// 排序：
		for (int i = 0; i &lt; students.length - 1; i++) {
			for (int j = 0; j &lt; students.length - 1 - i; j++) {
				if (students[j].score &gt; students[j + 1].score) {
					Student temp = students[j];
					students[j] = students[j + 1];
					students[j + 1] = temp;
				}
			}
		}

		// 排序后：
		for (int i = 0; i &lt; students.length; i++) {
//			System.out.println(
//					"number:" + students[i].number + ",state:" + 
//							students[i].state + ",score:" + students[i].score);
			
			students[i].info();
		}

	}

}</code></pre>

<p>内存解析：</p>
<p><img src="image-20220320001627445.png" alt="image-20220320001627445"></p>
<p><strong>2、注意点</strong></p>
<p>对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是<code>null</code>，所以很容易出现<code>空指针异常NullPointerException</code>。</p>
<p><strong>3、练习</strong></p>
<p>（1）定义矩形类Rectangle，包含长、宽属性，area()返回矩形面积的方法，perimeter()返回矩形周长的方法，String getInfo()返回圆对象的详细信息（如：长、宽、面积、周长等数据）的方法</p>
<p>（2）在测试类中创建长度为3的Rectangle[]数组，用来装3个矩形对象，并给3个矩形对象的长分别赋值为10,20,30，宽分别赋值为5,15,25，遍历输出</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.test08.array;

public class Rectangle {
    double length;
    double width;

    public double area(){//面积
        return length * width;
    }

    public double perimeter(){//周长
        return 2 * (length + width);
    }

    public String getInfo(){
        return "长：" + length +
                "，宽：" + width +
                "，面积：" + area() +
                "，周长：" + perimeter();
    }
}
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.test08.array;

public class ObjectArrayTest {
    public static void main(String[] args) {
        //声明并创建一个长度为3的矩形对象数组
        Rectangle[] array = new Rectangle[3];

        //创建3个矩形对象，并为对象的实例变量赋值，
        //3个矩形对象的长分别是10,20,30
        //3个矩形对象的宽分别是5,15,25
        //调用矩形对象的getInfo()返回对象信息后输出
        for (int i = 0; i &lt; array.length; i++) {
            //创建矩形对象
            array[i] = new Rectangle();

            //为矩形对象的成员变量赋值
            array[i].length = (i+1) * 10;
            array[i].width = (2*i+1) * 5;

            //获取并输出对象对象的信息
            System.out.println(array[i].getInfo());
        }
    }
}</code></pre>

<p>内存解析：</p>
<p><img src="image-20211228153827819.png" alt="image-20211228153827819"></p>
<h2 id="7-再谈方法"><a href="#7-再谈方法" class="headerlink" title="7. 再谈方法"></a>7. 再谈方法</h2><h3 id="7-1-方法的重载（overload）"><a href="#7-1-方法的重载（overload）" class="headerlink" title="7.1 方法的重载（overload）"></a>7.1 方法的重载（overload）</h3><h4 id="7-1-1-概念及特点"><a href="#7-1-1-概念及特点" class="headerlink" title="7.1.1 概念及特点"></a>7.1.1 概念及特点</h4><ul>
<li><strong>方法重载</strong>：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。<ul>
<li>参数列表不同，意味着参数个数或参数类型的不同</li>
</ul>
</li>
<li><strong>重载的特点</strong>：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li><strong>重载方法调用</strong>：JVM通过方法的参数列表，调用匹配的方法。<ul>
<li>先找个数、类型最匹配的</li>
<li>再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错</li>
</ul>
</li>
</ul>
<h4 id="7-1-2-示例"><a href="#7-1-2-示例" class="headerlink" title="7.1.2 示例"></a>7.1.2 示例</h4><p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//System.out.println()方法就是典型的重载方法，其内部的声明形式如下：
public class PrintStream {
    public void println(byte x)
	public void println(short x)
	public void println(int x)
	public void println(long x)
	public void println(float x)
	public void println(double x)
	public void println(char x)
	public void println(double x)
	public void println()

}

public class HelloWorld{
    public static void main(String[] args) {
        System.out.println(3);
        System.out.println(1.2f);
        System.out.println("hello!");
    }
}
</code></pre>

<p>​	举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//返回两个整数的和
public int add(int x,int y){
    return x+y;
}

//返回三个整数的和
public int add(int x,int y,int z){
    return x+y+z;
}
//返回两个小数的和
public double add(double x,double y){
    return x+y;
}
</code></pre>

<p>​	举例3：方法的重载和返回值类型无关</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MathTools {
    //以下方法不是重载，会报错
    public int getOneToHundred(){
    	return (int)(Math.random()*100);
    }
    
    public double getOneToHundred(){
    	return Math.random()*100;
    }
}
</code></pre>

<h4 id="7-1-3-练习"><a href="#7-1-3-练习" class="headerlink" title="7.1.3 练习"></a>7.1.3 练习</h4><p><strong>练习1：</strong>判 断与<code>void show(int a,char b,double c){}</code>构成重载的有：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">a)void show(int x,char y,double z){}     // no

b)int show(int a,double c,char b){}      // yes

c) void show(int a,double c,char b){}    // yes

d) boolean show(int c,char b){}          // yes

e) void show(double c){}                 // yes

f) double show(int x,char y,double z){}  // no

g) void shows(){double c}                // no</code></pre>

<p><strong>练习2</strong>：编写程序，定义三个重载方法并调用。</p>
<ul>
<li><p>方法名为mOL。</p>
</li>
<li><p>三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。</p>
</li>
<li><p>在主类的main ()方法中分别用参数区别调用三个方法。</p>
</li>
</ul>
<p><strong>练习3</strong>：定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，并分别调用三个方法。</p>
<h3 id="7-2-可变个数的形参"><a href="#7-2-可变个数的形参" class="headerlink" title="7.2 可变个数的形参"></a>7.2 可变个数的形参</h3><p>在**JDK 5.0 <strong>中提供了</strong>Varargs(<strong>variable number of arguments</strong>)**机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。</p>
<p><strong>格式：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">方法名(参数的类型名 ...参数名)</code></pre>

<p><strong>举例：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);

//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String...books);
</code></pre>

<p><strong>特点：</strong></p>
<ol>
<li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</p>
</li>
<li><p>可变个数形参的方法与同名的方法之间，彼此构成重载</p>
</li>
<li><p><strong>可变参数方法的使用与方法参数部分使用数组是一致的</strong>，二者不能同时声明，否则报错。</p>
</li>
<li><p>方法的参数部分有可变形参，需要<strong>放在形参声明的最后</strong></p>
</li>
<li><p>在一个方法的形参中，最多只能声明一个可变个数的形参</p>
</li>
</ol>
<p><strong>案例分析：</strong></p>
<p>案例1：n个字符串进行拼接，每一个字符串之间使用某字符进行分割，如果没有传入字符串，那么返回空字符串””</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringTools {
    String concat(char seperator, String... args){
        String str = "";
        for (int i = 0; i &lt; args.length; i++) {
            if(i==0){
                str += args[i];
            }else{
                str += seperator + args[i];
            }
        }
        return str;
    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.test05.param;

public class StringToolsTest {
    public static void main(String[] args) {
        StringTools tools = new StringTools();

        System.out.println(tools.concat('-'));
        System.out.println(tools.concat('-',"hello"));
        System.out.println(tools.concat('-',"hello","world"));
        System.out.println(tools.concat('-',"hello","world","java"));
    }
}</code></pre>

<p>案例2：求n个整数的和</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NumberTools {
    public int total(int[] nums){
        int sum = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            sum += nums[i];
        }
        return sum;
    }

    public int sum(int... nums){
        int sum = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            sum += nums[i];
        }
        return sum;
    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestVarParam {
    public static void main(String[] args) {
        NumberTools tools = new NumberTools();

        System.out.println(tools.sum());//0个实参
        System.out.println(tools.sum(5));//1个实参
        System.out.println(tools.sum(5,6,2,4));//4个实参
        System.out.println(tools.sum(new int[]{5,6,2,4}));//传入数组实参

        System.out.println("------------------------------------");
        System.out.println(tools.total(new int[]{}));//0个元素的数组
        System.out.println(tools.total(new int[]{5}));//1个元素的数组
        System.out.println(tools.total(new int[]{5,6,2,4}));//传入数组实参
    }
}</code></pre>

<p>案例3：如下的方法彼此构成重载</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MathTools {
    //求两个整数的最大值
    public int max(int a,int b){
        return a&gt;b?a:b;
    }

    //求两个小数的最大值
    public double max(double a, double b){
        return a&gt;b?a:b;
    }

    //求三个整数的最大值
    public int max(int a, int b, int c){
        return max(max(a,b),c);
    }
    
    //求n个整数的最大值
    public int max(int... nums){
        int max = nums[0];//如果没有传入整数，或者传入null，这句代码会报异常
        for (int i = 1; i &lt; nums.length; i++) {
            if(nums[i] &gt; max){
                max = nums[i];
            }
        }
        return max;
    }
    /*    //求n整数的最大值
    public int max(int[] nums){  //编译就报错，与(int... nums)无法区分
        int max = nums[0];//如果没有传入整数，或者传入null，这句代码会报异常
        for (int i = 1; i &lt; nums.length; i++) {
            if(nums[i] &gt; max){
                max = nums[i];
            }
        }
        return max;
    }*/

/*    //求n整数的最大值
    public int max(int first, int... nums){  //当前类不报错，但是调用时会引起多个方法同时匹配
        int max = first;
        for (int i = 0; i &lt; nums.length; i++) {
            if(nums[i] &gt; max){
                max = nums[i];
            }
        }
        return max;
    }*/
}</code></pre>

<h3 id="7-3-方法的参数传递机制"><a href="#7-3-方法的参数传递机制" class="headerlink" title="7.3 方法的参数传递机制"></a>7.3 方法的参数传递机制</h3><h4 id="7-3-1-形参和实参"><a href="#7-3-1-形参和实参" class="headerlink" title="7.3.1 形参和实参"></a>7.3.1 形参和实参</h4><ul>
<li>形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。</li>
<li>实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参。</li>
</ul>
<h4 id="7-3-2-参数传递机制：值传递"><a href="#7-3-2-参数传递机制：值传递" class="headerlink" title="7.3.2 参数传递机制：值传递"></a>7.3.2 参数传递机制：值传递</h4><p>Java里方法的参数传递方式只有一种：<code>值传递</code>。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p>
<ul>
<li><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p>
</li>
<li><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
</li>
</ul>
<h4 id="7-3-3-举例"><a href="#7-3-3-举例" class="headerlink" title="7.3.3 举例"></a>7.3.3 举例</h4><p><strong>1、形参是基本数据类型</strong></p>
<p>案例：编写方法，交换两个整型变量的值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {
	public static void main(String[] args) {
		int m = 10;
		int n = 20;
		
		System.out.println("m = " + m + ", n = " + n);
		//交换m和n的值
//		int temp = m;
//		m = n;
//		n = temp;
		
		ValueTransferTest1 test = new ValueTransferTest1();
		test.swap(m, n);
		
		System.out.println("m = " + m + ", n = " + n);// 10 20
	}
	
	public void swap(int m,int n){
		int temp = m;
		m = n;
		n = temp;
	}
	
}</code></pre>

<p>内存解析：</p>
<p><img src="image-20221120153322455.png" alt="image-20221120153322455"></p>
<p><strong>2、形参是引用数据类型</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {
	public static void main(String[] args) {
		
		Data d1 = new Data();
		d1.m = 10;
		d1.n = 20;
		
		System.out.println("m = " + d1.m + ", n = " + d1.n);
		
		//实现 换序
		
		ValueTransferTest2 test = new ValueTransferTest2();
		test.swap(d1);
		
		System.out.println("m = " + d1.m + ", n = " + d1.n);// 20 10
		
	}
	
	public void swap(Data data){
		int temp = data.m;
		data.m = data.n;
		data.n = temp;
	}
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Data{
	int m;
	int n;
}</code></pre>

<p>内存解析：</p>
<p><img src="image-20221120153442447.png" alt="image-20221120153442447"></p>
<h4 id="7-3-4-练习"><a href="#7-3-4-练习" class="headerlink" title="7.3.4 练习"></a>7.3.4 练习</h4><p>练习1：判断如下程序输出的结果</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AssignNewObject {
    public void swap(MyData my){
        my = new MyData(); //考虑堆空间此新创建的对象，和main中的data对象是否有关
        int temp = my.x;
        my.x = my.y;
        my.y = temp;
     
    }

    public static void main(String[] args) {
        AssignNewObject tools = new AssignNewObject();
        
        MyData data = new MyData();
        data.x = 1;
        data.y = 2;
        System.out.println("交换之前：x = " + data.x +",y = " + data.y);//
        tools.swap(data);//调用完之后，x与y的值交换？
        System.out.println("交换之后：x = " + data.x +",y = " + data.y);//
    }
}

class MyData{
    int x ;
    int y;
}</code></pre>

<p>练习2：如下操作是否可以实现数组排序</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayTypeParam {

    //冒泡排序，实现数组从小到大排序
    public void sort(int[] arr){
        for (int i = 0; i &lt; arr.length - 1; i++) {
            for (int j = 0; j &lt; arr.length - 1 - i; j++) {
                if(arr[j] &gt; arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }
    //打印数组的元素
    public void print(int[] arr){
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]+" ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        ArrayTypeParam tools = new ArrayTypeParam();

        int[] nums = {4,3,1,6,7};
        System.out.println("排序之前：");
        tools.print(nums);

        tools.sort(nums);//对nums数组进行排序

        System.out.println("排序之后：");
        tools.print(nums);//输出nums数组的元素

    }
}</code></pre>

<p>练习3：通过内存结构图，写出如下程序的输出结果</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//栈：每个方法在调用时，都会有以栈帧的方法压入栈中。栈帧中保存了当前方法中声明的变量：方法内声明的，形参
//堆：存放new出来的"东西"：对象（成员变量在对象中）、数组实体（数组元素）。 
//注意：变量前如果声明有类型，那么这就是一个新的刚要定义的变量。如果变量前没有声明类型，那就说明此变量在之前已经声明过。
public class TransferTest3 {
    public static void main(String args[]) {
        TransferTest3 test = new TransferTest3();
        test.first();
    }
    public void first() {
        int i = 5;
        Value v = new Value();
        v.i = 25;
        second(v, i);
        System.out.println(v.i);
    }
    public void second(Value v, int i) {
        i = 0;
        v.i = 20;
        Value val = new Value();
        v = val;
        System.out.println(v.i + " " + i);
    }
}

class Value {
    int i = 15;
}
</code></pre>

<p>内存解析：</p>
<img src="20220320_233145.jpg" alt="20220320_233145" style="zoom:80%;">

<p>练习4：<code>貌似是</code>考查方法的参数传递</p>
<p><img src="image-20220320233402122.png" alt="image-20220320233402122"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//法一：
   public static void method(int a, int b) {
       // 在不改变原本题目的前提下，如何写这个函数才能在main函数中输出a=100，b=200？ 
       a = a * 10;
       b = b * 20;
       System.out.println(a);
       System.out.println(b);
       System.exit(0);
   }

   //法二：
   public static void method(int a, int b) {

       PrintStream ps = new PrintStream(System.out) {
           @Override
           public void println(String x) {

               if ("a=10".equals(x)) {
                   x = "a=100";
               } else if ("b=10".equals(x)) {
                   x = "b=200";
               }
               super.println(x);
           }
       };

       System.setOut(ps);

   }</code></pre>

<p>练习5：将对象作为参数传递给方法</p>
<p>（1）定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。<br>（2）定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：public void printAreas(Circle c, int time)，在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。<br>（3）在main方法中调用printAreas()方法，调用完毕后输出当前半径值。程序运行结果如图所示。</p>
<p><img src="image-20220320233626003.png" alt="image-20220320233626003"></p>
<h3 id="7-4-递归-recursion-方法"><a href="#7-4-递归-recursion-方法" class="headerlink" title="7.4 递归(recursion)方法"></a>7.4 递归(recursion)方法</h3><p>举例1：</p>
<img src="image-20220521160246138.png" alt="image-20220521160246138" style="zoom: 67%;">

<p>举例2：</p>
<pre class="line-numbers language-none"><code class="language-none">从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?
      从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?
          从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?
              从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?...
    			...
老和尚没了,庙塌了,小和尚还俗结婚了。</code></pre>

<p><strong>递归方法调用</strong>：方法自己调用自己的现象就称为递归。</p>
<p>**递归的分类:**直接递归、间接递归。</p>
<ul>
<li><p>直接递归：方法自身调用自己。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void methodA(){
	methodA();
}</code></pre>
</li>
<li><p>间接递归：可以理解为A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void A(){
	B();
}

public static void B(){
	C();
}

public static void C(){
	A();
}</code></pre></li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>递归方法包含了一种<code>隐式的循环</code>。</li>
<li>递归方法会<code>重复执行</code>某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向<code>已知方向</code>递归，否则这种递归就变成了无穷递归，停不下来，类似于<code>死循环</code>。最终发生<code>栈内存溢出</code>。</li>
</ul>
<p><strong>举例：</strong></p>
<p>举例1：计算1 ~ n的和</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RecursionDemo {
	public static void main(String[] args) {
        RecursionDemo demo = new RecursionDemo();
		//计算1~num的和，使用递归完成
		int num = 5;
      	// 调用求和的方法
		int sum = demo.getSum(num);
      	// 输出结果
		System.out.println(sum);
		
	}
  	/*
  	  通过递归算法实现.
  	  参数列表:int 
  	  返回值类型: int 
  	*/
	public int getSum(int num) {
      	/* 
      	   num为1时,方法返回1,
      	   相当于是方法的出口,num总有是1的情况
      	*/
		if(num == 1){
			return 1;
		}
      	/*
          num不为1时,方法返回 num +(num-1)的累和
          递归调用getSum方法
        */
		return num + getSum(num-1);
	}
}</code></pre>

<p>代码执行图解：</p>
<p><img src="%E9%80%92%E5%BD%92.png"></p>
<p>举例2：递归方法计算n!</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int multiply(int num){
	if(num == 1){
		return 1;
	}else{
		return num * multiply(num - 1);
	}
}</code></pre>

<p><img src="image-20220520150018655.png" alt="image-20220520150018655"></p>
<p>举例3：已知有一个数列：f(0) = 1，f(1) = 4，f(n+2)=2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int f(int num){
	if(num == 0){
		return 1;
	}else if(num == 1){
		return 4;
	}else{
		return 2 * f(num - 1) + f(num - 2);
	}
}</code></pre>

<p>举例4：已知一个数列：f(20) = 1,f(21) = 4,f(n+2) = 2*f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int func(int num){
	if(num == 20){
		return 1;
	}else if(num == 21){
		return 4;
	}else{
		return func(num + 2) - 2 * func(num + 1);
	}
}</code></pre>

<p>举例5：计算斐波那契数列（Fibonacci）的第n个值，斐波那契数列满足如下规律，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">1,1,2,3,5,8,13,21,34,55,....</code></pre>

<p>即从第三个数开始，一个数等于前两个数之和。假设f(n)代表斐波那契数列的第n个值，那么f(n)满足：<br>f(n) = f(n-2) + f(n-1); </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用递归的写法
   int f(int n) {//计算斐波那契数列第n个值是多少
       if (n &lt; 1) {//负数是返回特殊值1，表示不计算负数情况
           return 1;
       }
       if (n == 1 || n == 2) {
           return 1;
       }
       return f(n - 2) + f(n - 1);
   }

   //不用递归
   int fValue(int n) {//计算斐波那契数列第n个值是多少
       if (n &lt; 1) {//负数是返回特殊值1，表示不计算负数情况
           return 1;
       }
       if (n == 1 || n == 2) {
           return 1;
       }
       //从第三个数开始，  等于 前两个整数相加
       int beforeBefore = 1; //相当于n=1时的值
       int before = 1;//相当于n=2时的值
       int current = beforeBefore + before; //相当于n=3的值
       //再完后
       for (int i = 4; i &lt;= n; i++) {
           beforeBefore = before;
           before = current;
           current = beforeBefore + before;
           /*
           假设i=4
               beforeBefore = before; //相当于n=2时的值
               before = current; //相当于n=3的值
               current = beforeBefore + before; //相当于n = 4的值
           假设i=5
               beforeBefore = before; //相当于n=3的值
               before = current; //相当于n = 4的值
               current = beforeBefore + before; //相当于n = 5的值
               ....
            */
       }
       return current;
   }</code></pre>

<p>举例6：面试题</p>
<blockquote>
<p>宋老师，我今天去百度面试，遇到一个一个双重递归调用的问题，我琢磨了一下，完全不知道为什么。打断点了，也还是没看懂为什么程序会那样走。您有空可以看一下，求指教。</p>
</blockquote>
<p><img src="image-20220320235105406.png" alt="image-20220320235105406"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private int count = 0;

   public int recursion(int k) {
       count++;
       System.out.println("count1:" + count + "  k:" + k);
       if (k &lt;= 0) {
           return 0;
       }
       return recursion(k - 1) + recursion(k - 2);//287
       //return recursion(k - 1);//11
       //return recursion(k - 1) + recursion(k - 1);//2047
   }</code></pre>

<p>剖析：</p>
<img src="image-20220320235229941.png" alt="image-20220320235229941" style="zoom:67%;">

<blockquote>
<p>最后说两句：</p>
<ol>
<li><p>递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环<code>慢的多</code>，所以在使用递归时要慎重。</p>
</li>
<li><p>在要求高性能的情况下尽量避免使用递归，递归调用既花时间又<code>耗内存</code>。考虑使用循环迭代</p>
</li>
</ol>
</blockquote>
<h2 id="8-关键字：package、import"><a href="#8-关键字：package、import" class="headerlink" title="8. 关键字：package、import"></a>8. 关键字：package、import</h2><h3 id="8-1-package-包"><a href="#8-1-package-包" class="headerlink" title="8.1 package(包)"></a>8.1 package(包)</h3><p>package，称为包，用于指明该文件中定义的类、接口等结构所在的包。</p>
<h4 id="8-1-1-语法格式"><a href="#8-1-1-语法格式" class="headerlink" title="8.1.1 语法格式"></a>8.1.1 语法格式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package 顶层包名.子包名 ;</code></pre>

<p>举例：pack1\pack2\PackageTest.java</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package pack1.pack2;    //指定类PackageTest属于包pack1.pack2

public class PackageTest{
	public void display(){
		System.out.println("in  method display()");
	}
}</code></pre>

<p>说明：</p>
<ul>
<li>一个源文件只能有一个声明包的package语句</li>
<li>package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。</li>
<li>包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意<ul>
<li>包通常使用所在公司域名的倒置：com.atguigu.xxx。</li>
<li>大家取包名时不要使用”<code>java.xx</code>“包</li>
</ul>
</li>
<li>包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。</li>
<li>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）</li>
</ul>
<h4 id="8-1-2-包的作用"><a href="#8-1-2-包的作用" class="headerlink" title="8.1.2 包的作用"></a>8.1.2 包的作用</h4><ul>
<li>包可以包含类和子包，划分<code>项目层次</code>，便于管理</li>
<li>帮助<code>管理大型软件</code>系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>解决<code>类命名冲突</code>的问题</li>
<li>控制<code>访问权限</code></li>
</ul>
<h4 id="8-1-3-应用举例"><a href="#8-1-3-应用举例" class="headerlink" title="8.1.3 应用举例"></a>8.1.3 应用举例</h4><p>举例1：某航运软件系统包括：一组域对象、GUI和reports子系统</p>
<p><img src="image-20220321233025157.png" alt="image-20220321233025157"></p>
<p><strong>举例2：MVC设计模式</strong></p>
<p>MVC是一种软件构件模式，目的是为了降低程序开发中代码业务的耦合度。</p>
<p>MVC设计模式将整个程序分为三个层次：<code>视图模型(Viewer)层</code>，<code>控制器(Controller)层</code>，与<code>数据模型(Model)层</code>。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">视图层viewer：显示数据,为用户提供使用界面，与用户直接进行交互。
 &gt;相关工具类 &nbsp; view.utils
 &gt;自定义view &nbsp;view.ui

控制层controller：解析用户请求，处理业务逻辑，给予用户响应
 &gt;应用界面相关 &nbsp;&nbsp; controller.activity
 &gt;存放fragment &nbsp; controller.fragment
 &gt;显示列表的适配器 controller.adapter
 &gt;服务相关的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controller.service
 &gt;抽取的基类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controller.base
    
模型层model：主要承载数据、处理数据
 &gt;数据对象封装 model.bean/domain
 &gt;数据库操作类 model.dao
 &gt;数据库 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model.db
</code></pre>

<p><img src="image-20220321233153448.png" alt="image-20220321233153448"></p>
<h4 id="8-1-4-JDK中主要的包介绍"><a href="#8-1-4-JDK中主要的包介绍" class="headerlink" title="8.1.4 JDK中主要的包介绍"></a>8.1.4 JDK中主要的包介绍</h4><p><code>java.lang</code>—-包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能<br><code>java.net</code>—-包含执行与网络相关的操作的类和接口。<br><code>java.io</code>   —-包含能提供多种输入/输出功能的类。<br><code>java.util</code>—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。<br><code>java.text</code>—-包含了一些java格式化相关的类<br><code>java.sql</code>—-包含了java进行JDBC数据库编程的相关类/接口<br><code>java.awt</code>—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。  </p>
<h3 id="8-2-import-导入"><a href="#8-2-import-导入" class="headerlink" title="8.2 import(导入)"></a>8.2 import(导入)</h3><p>为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类。相当于<code>import语句告诉编译器到哪里去寻找这个类</code>。</p>
<h4 id="8-2-1-语法格式"><a href="#8-2-1-语法格式" class="headerlink" title="8.2.1 语法格式"></a>8.2.1 语法格式</h4><pre class="line-numbers language-none"><code class="language-none">import 包名.类名;</code></pre>

<h4 id="8-2-2-应用举例"><a href="#8-2-2-应用举例" class="headerlink" title="8.2.2 应用举例"></a>8.2.2 应用举例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import pack1.pack2.Test;   //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构

public class PackTest{
	public static void main(String args[]){
		Test t = new Test();          //Test类在pack1.pack2包中定义
		t.display();
	}
}</code></pre>

<h4 id="8-2-3-注意事项"><a href="#8-2-3-注意事项" class="headerlink" title="8.2.3 注意事项"></a>8.2.3 注意事项</h4><ul>
<li><p>import语句，声明在包的声明和类的声明之间。</p>
</li>
<li><p>如果需要导入多个类或接口，那么就并列显式多个import语句即可</p>
</li>
<li><p>如果使用<code>a.*</code>导入结构，表示可以导入a包下的所有的结构。举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p>
</li>
<li><p>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</p>
</li>
<li><p>如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p>如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。</p>
</li>
<li><p>（了解）<code>import static</code>组合的使用：调用指定类或接口下的静态的属性或方法</p>
</li>
</ul>
<h2 id="9-面向对象特征一：封装性-encapsulation"><a href="#9-面向对象特征一：封装性-encapsulation" class="headerlink" title="9. 面向对象特征一：封装性(encapsulation)"></a>9. 面向对象特征一：封装性(encapsulation)</h2><h3 id="9-1-为什么需要封装？"><a href="#9-1-为什么需要封装？" class="headerlink" title="9.1 为什么需要封装？"></a>9.1 为什么需要封装？</h3><ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？</li>
<li>我要开车，我不需要懂离合、油门、制动等原理和维修也可以驾驶。</li>
</ul>
<ul>
<li>客观世界里每一个事物的内部信息都隐藏在其内部，外界无法直接操作和修改，只能通过指定的方式进行访问和修改。</li>
</ul>
<p>随着我们系统越来越复杂，类会越来越多，那么类之间的访问边界必须把握好，面向对象的开发原则要遵循“<code>高内聚、低耦合</code>”。</p>
<blockquote>
<p>高内聚、低耦合是软件工程中的概念，也是UNIX 操作系统设计的经典原则。</p>
<p>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p>
</blockquote>
<p>而“高内聚，低耦合”的体现之一：</p>
<ul>
<li><code>高内聚</code>：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li><code>低耦合</code>：仅暴露少量的方法给外部使用，尽量方便外部调用。</li>
</ul>
<h3 id="9-2-何为封装性？"><a href="#9-2-何为封装性？" class="headerlink" title="9.2 何为封装性？"></a>9.2 何为封装性？</h3><p>所谓封装，就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。</p>
<p><strong>通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</strong></p>
<h3 id="9-3-Java如何实现数据封装"><a href="#9-3-Java如何实现数据封装" class="headerlink" title="9.3 Java如何实现数据封装"></a>9.3 Java如何实现数据封装</h3><ul>
<li><p>实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。</p>
</li>
<li><p>权限修饰符：<code>public</code>、<code>protected</code>、<code>缺省</code>、<code>private</code>。具体访问范围如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类内部</th>
<th>本包内</th>
<th>其他包的子类</th>
<th>其他包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>缺省</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ul>
<li>具体修饰的结构：<ul>
<li>外部类：public、缺省</li>
<li>成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private</li>
</ul>
</li>
</ul>
<img src="image-20220321222327616.png" alt="image-20220321222327616" style="zoom:67%;">

<img src="image-20220617164042390.png" alt="image-20220617164042390" style="zoom:80%;">

<h3 id="9-4-封装性的体现"><a href="#9-4-封装性的体现" class="headerlink" title="9.4 封装性的体现"></a>9.4 封装性的体现</h3><h4 id="9-4-1-成员变量-属性私有化"><a href="#9-4-1-成员变量-属性私有化" class="headerlink" title="9.4.1 成员变量/属性私有化"></a>9.4.1 成员变量/属性私有化</h4><p><strong>概述：私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。</strong></p>
<p>实现步骤：</p>
<p><strong>①</strong> 使用 <code>private</code> 修饰成员变量</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private 数据类型 变量名 ；</code></pre>

<p>代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person {
    private String name;
  	private int age;
    private boolean marry;
}</code></pre>

<p><strong>②</strong> 提供 <code>getXxx</code>方法 / <code>setXxx</code> 方法，可以访问成员变量，代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person {
    private String name;
  	private int age;
    private boolean marry;

	public void setName(String n) {
		name = n;
    }

    public String getName() {
        return name;
	}

    public void setAge(int a) {
        age = a;
    }

    public int getAge() {
        return age;
    }
    
    public void setMarry(boolean m){
        marry = m;
    }
    
    public boolean isMarry(){
        return marry;
    }
}</code></pre>

<p><strong>③</strong> 测试：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PersonTest {
    public static void main(String[] args) {
        Person p = new Person();

        //实例变量私有化，跨类是无法直接使用的
		/* p.name = "张三";
        p.age = 23;
        p.marry = true;*/

        p.setName("张三");
        System.out.println("p.name = " + p.getName());

        p.setAge(23);
        System.out.println("p.age = " + p.getAge());

        p.setMarry(true);
        System.out.println("p.marry = " + p.isMarry());
    }
}</code></pre>

<p><strong>成员变量封装的好处：</strong></p>
<ul>
<li>让使用者只能通过事先预定的方法来<code>访问数据</code>，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。</li>
<li><code>便于修改</code>，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8-&gt;Java9，String从char[]转为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。</li>
</ul>
<p><strong>开心一笑：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">A man and woman are in a computer programming lecture. The man touches the woman's breasts.

"Hey!" she says. "Those are private!"

The man says, "But we're in the same class!"
</code></pre>

<h4 id="9-4-2-私有化方法"><a href="#9-4-2-私有化方法" class="headerlink" title="9.4.2 私有化方法"></a>9.4.2 私有化方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * 
 * @Description 自定义的操作数组的工具类
 * @author 尚硅谷-宋红康 Email:shkstart@126.com
 * @version
 *
 */
public class ArrayUtil {

	/**
	 * 
	 * @Description 求int型数组的最大值
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @return
	 */
	public int max(int[] arr) {
		int maxValue = arr[0];
		for(int i = 1;i &lt; arr.length;i++){
			if(maxValue &lt; arr[i]){
				maxValue = arr[i];
			}
		}
		return maxValue;
	}

	/**
	 * 
	 * @Description 求int型数组的最小值
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @return
	 */
	public int min(int[] arr){
		int minValue = arr[0];
		for(int i = 1;i &lt; arr.length;i++){
			if(minValue &gt; arr[i]){
				minValue = arr[i];
			}
		}
		return minValue;
	}

	/**
	 * 
	 * @Description 求int型数组的总和
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @return
	 */
	public int sum(int[] arr) {
		int sum = 0;
		for(int i = 0;i &lt; arr.length;i++){
			sum += arr[i];
		}
		return sum;
	}

	/**
	 * 
	 * @Description 求int型数组的元素的平均值
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @return
	 */
	public int avg(int[] arr) {
		int sumValue = sum(arr);
		return sumValue / arr.length;
	}

	// 创建一系列重载的上述方法
	// public double max(double[] arr){}
	// public float max(float[] arr){}
	// public byte max(byte[] arr){}

	/**
	 * 
	 * @Description 遍历数组
	 * @author 尚硅谷-宋红康
	 * @param arr
	 */
	public void print(int[] arr) {
		for(int i = 0;i &lt; arr.length;i++){
			System.out.print(arr[i] + "  ");
		}
		System.out.println();
	}

	/**
	 * 
	 * @Description 复制数组arr
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @return
	 */
	public int[] copy(int[] arr) {
		int[] arr1 = new int[arr.length];
		for(int i = 0;i &lt; arr.length;i++){
			arr1[i] = arr[i];
		}
		return arr1;
	}

	/**
	 * 
	 * @Description 反转数组
	 * @author 尚硅谷-宋红康
	 * @param arr
	 */
	public void reverse(int[] arr) {
		for(int i = 0,j = arr.length - 1;i &lt; j;i++,j--){
			int temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}

	/**
	 * 
	 * @Description 数组的排序
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @param desc 指明排序的方式。 ascend:升序    descend:降序
	 */
	public void sort(int[] arr,String desc) {
		
		if("ascend".equals(desc)){//if(desc.equals("ascend")){
			for (int i = 0; i &lt; arr.length - 1; i++) {
				for (int j = 0; j &lt; arr.length - 1 - i; j++) {
					if (arr[j] &gt; arr[j + 1]) {
//						int temp = arr[j];
//						arr[j] = arr[j + 1];
//						arr[j + 1] = temp;
						swap(arr,j,j+1);
					}
				}
			}
		}else if ("descend".equals(desc)){
			for (int i = 0; i &lt; arr.length - 1; i++) {
				for (int j = 0; j &lt; arr.length - 1 - i; j++) {
					if (arr[j] &lt; arr[j + 1]) {
//						int temp = arr[j];
//						arr[j] = arr[j + 1];
//						arr[j + 1] = temp;
						swap(arr,j,j+1);
					}
				}
			}
		}else{
			System.out.println("您输入的排序方式有误！");
		}
	}
	
	private void swap(int[] arr,int i,int j){
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}

	/**
	 * 
	 * @Description 查找指定的value值在arr数组中出现的位置
	 * @author 尚硅谷-宋红康
	 * @param arr
	 * @param value
	 * @return 返回value值出现的位置 或 -1：未找到
	 */
	public int getValue(int[] arr, int value) {
		//方法：线性查找
		for(int i = 0;i &lt; arr.length;i++){
			if(value == arr[i]){
				return i;
			}
		}
		
		return - 1;
	}
}
</code></pre>

<blockquote>
<p>注意：</p>
<p>开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问。</p>
<p>对于final的实例变量，不提供set()方法。（后面final关键字的时候讲）</p>
<p>对于static final的成员变量，习惯上使用public修饰。</p>
</blockquote>
<h3 id="9-5-练习"><a href="#9-5-练习" class="headerlink" title="9.5 练习"></a>9.5 练习</h3><p>练习1：</p>
<p>创建程序：在其中定义两个类：Person和PersonTest类。定义如下：</p>
<p>用setAge()设置人的合法年龄(0~130)，用getAge()返回人的年龄。在PersonTest类中实例化Person类的对象b，调用setAge()和getAge()方法，体会Java的封装性。</p>
<img src="image-20220321223633916.png" alt="image-20220321223633916" style="zoom:80%;">

<p>练习2：</p>
<p>自定义图书类。设定属性包括：书名bookName，作者author，出版社名publisher，价格price；方法包括：相应属性的get/set方法，图书信息介绍等。</p>
<h2 id="10-类的成员之三：构造器-Constructor"><a href="#10-类的成员之三：构造器-Constructor" class="headerlink" title="10. 类的成员之三：构造器(Constructor)"></a>10. 类的成员之三：构造器(Constructor)</h2><p>我们new完对象时，所有成员变量都是默认值，如果我们需要赋别的值，需要挨个为它们再赋值，太麻烦了。我们能不能在new对象时，直接为当前对象的某个或所有成员变量直接赋值呢？</p>
<p>可以，Java给我们提供了<code>构造器（Constructor)</code>，也称为<code>构造方法</code>。</p>
<h3 id="10-1-构造器的作用"><a href="#10-1-构造器的作用" class="headerlink" title="10.1 构造器的作用"></a>10.1 构造器的作用</h3><p>new对象，并在new对象的时候为实例变量赋值。</p>
<p>举例：Person p = new <code>Person(“Peter”,15)</code>;</p>
<p>解释：如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</p>
<h3 id="10-2-构造器的语法格式"><a href="#10-2-构造器的语法格式" class="headerlink" title="10.2 构造器的语法格式"></a>10.2 构造器的语法格式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符] class 类名{
    [修饰符] 构造器名(){
    	// 实例初始化代码
    }
    [修饰符] 构造器名(参数列表){
        // 实例初始化代码
    }
}</code></pre>

<p>说明：</p>
<ol>
<li>构造器名必须与它所在的类名必须相同。</li>
<li>它没有返回值，所以不需要返回值类型，也不需要void。</li>
<li>构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。</li>
</ol>
<p>代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student {
    private String name;
    private int age;

    // 无参构造
    public Student() {}

    // 有参构造
    public Student(String n,int a) {
        name = n;
        age = a;
    }

    public String getName() {
        return name;
    }
    public void setName(String n) {
        name = n;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int a) {
        age = a;
    }

    public String getInfo(){
        return "姓名：" + name +"，年龄：" + age;
    }
}
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestStudent {
    public static void main(String[] args) {
        //调用无参构造创建学生对象
        Student s1 = new Student();

        //调用有参构造创建学生对象
        Student s2 = new Student("张三",23);

        System.out.println(s1.getInfo());
        System.out.println(s2.getInfo());
    }
}</code></pre>

<h3 id="10-3-使用说明"><a href="#10-3-使用说明" class="headerlink" title="10.3 使用说明"></a>10.3 使用说明</h3><ol>
<li><p>当我们没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同</p>
<p><img src="image-20220524143937454.png" alt="image-20220524143937454"></p>
</li>
<li><p>当我们<strong>显式的定义类的构造器以后，系统就不再提供默认的无参的构造器</strong>了。</p>
</li>
<li><p>在类中，至少会存在一个构造器。</p>
</li>
<li><p>构造器是可以重载的。</p>
</li>
</ol>
<h3 id="10-4-练习"><a href="#10-4-练习" class="headerlink" title="10.4 练习"></a>10.4 练习</h3><p><strong>练习1：</strong>编写两个类，TriAngle和TriAngleTest，其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。此外，提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积。</p>
<p><strong>练习2：</strong></p>
<p>(1)定义Student类,有4个属性：<br>  String name;<br>  int age;<br>  String school;<br>  String major;</p>
<p>(2)定义Student类的3个构造器:</p>
<ul>
<li>第一个构造器Student(String n, int a)设置类的name和age属性；</li>
<li>第二个构造器Student(String n, int a, String s)设置类的name, age 和school属性；</li>
<li>第三个构造器Student(String n, int a, String s, String m)设置类的name, age ,school和major属性；</li>
</ul>
<p>(3)在main方法中分别调用不同的构造器创建的对象，并输出其属性值。</p>
<p><strong>练习3：</strong></p>
<p>1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。</p>
<p>该类包括的属性：账号id，余额balance，年利率annualInterestRate；</p>
<p>包含的方法：访问器方法（getter和setter方法），取款方法withdraw()，存款方法deposit()。</p>
<p> <img src="image-20220321235241752.png" alt="image-20220321235241752"></p>
<p><strong>提示：</strong>在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。</p>
<ol start="2">
<li>创建Customer类。</li>
</ol>
<p> <img src="image-20220321235324156.png" alt="image-20220321235324156"></p>
<p>a. 声明三个私有对象属性：firstName、lastName和account。<br>b. 声明一个公有构造器，这个构造器带有两个代表对象属性的参数（f和l）<br>c. 声明两个公有存取器来访问该对象属性，方法getFirstName和getLastName返回相应的属性。<br>d. 声明setAccount 方法来对account属性赋值。<br>e. 声明getAccount 方法以获取account属性。</p>
<p>3.写一个测试程序。</p>
<p>（1）创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。<br>（2）对Jane Smith操作。<br>存入 100 元，再取出960元。再取出2000元。<br>打印出Jane Smith 的基本信息</p>
<pre class="line-numbers language-none"><code class="language-none">成功存入 ：100.0
成功取出：960.0
余额不足，取款失败
Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0</code></pre>

<h2 id="11-阶段性知识补充"><a href="#11-阶段性知识补充" class="headerlink" title="11. 阶段性知识补充"></a>11. 阶段性知识补充</h2><h3 id="11-1-类中属性赋值过程"><a href="#11-1-类中属性赋值过程" class="headerlink" title="11.1 类中属性赋值过程"></a>11.1 类中属性赋值过程</h3><p><strong>1、在类的属性中，可以有哪些位置给属性赋值？</strong></p>
<p>① 默认初始化</p>
<p>② 显式初始化</p>
<p>③ 构造器中初始化</p>
<p>④ 通过”对象.属性”或”对象.方法”的方式，给属性赋值</p>
<p><strong>2、这些位置执行的先后顺序是怎样？</strong></p>
<p>顺序：① - ② - ③ - ④</p>
<p>3、说明：</p>
<ul>
<li>上述中的①、②、③在对象创建过程中，只执行一次。</li>
</ul>
<ul>
<li>④ 是在对象创建后执行的，可以根据需求多次执行。</li>
</ul>
<h3 id="11-2-JavaBean"><a href="#11-2-JavaBean" class="headerlink" title="11.2 JavaBean"></a>11.2 JavaBean</h3><ul>
<li><p>JavaBean是一种Java语言写成的可重用组件。</p>
<ul>
<li>好比你做了一个扳手，这个扳手会在很多地方被拿去用。这个扳手也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</li>
</ul>
</li>
<li><p>所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p>
</li>
<li><p>《Think in Java》中提到，JavaBean最初是为Java GUI的可视化编程实现的。你拖动IDE构建工具创建一个GUI 组件（如多选框），其实是工具给你创建Java类，并提供将类的属性暴露出来给你修改调整，将事件监听器暴露出来。</p>
</li>
<li><p>示例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JavaBean {
    private String name; // 属性一般定义为private
    private int age;
    public JavaBean() {
    }
    public int getAge() {
        return age;
    }
    public void setAge(int a) {
        age = a;
    }
    public String getName() {
        return name;
    }
    public void setName(String n) {
        name = n;
    }
}
</code></pre></li>
</ul>
<h3 id="11-3-UML类图"><a href="#11-3-UML类图" class="headerlink" title="11.3 UML类图"></a>11.3 UML类图</h3><ul>
<li><p>UML（Unified Modeling Language，统一建模语言），用来描述<code>软件模型</code>和<code>架构</code>的图形化语言。</p>
</li>
<li><p>常用的UML工具软件有<code>PowerDesinger</code>、<code>Rose</code>和<code>Enterprise Architect</code>。</p>
</li>
<li><p>UML工具软件不仅可以绘制软件开发中所需的各种图表，还可以生成对应的源代码。</p>
</li>
<li><p>在软件开发中，使用<code>UML类图</code>可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。</p>
<ul>
<li>+表示 public 类型， - 表示 private 类型，#表示protected类型</li>
<li>方法的写法:<br>方法的类型(+、-)  方法名(参数名： 参数类型)：返回值类型</li>
<li>斜体表示抽象方法或类。</li>
</ul>
</li>
</ul>
<img src="image-20220321232230831.png" alt="image-20220321232230831" style="zoom:80%;">

<p><img src="image-20220503111301602.png" alt="image-20220503111301602"></p>
 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/03/14/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%936-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/">https://nan-ying.github.io/2023/03/14/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%936-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/Java/">
              <span class="chip bg-color">Java</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-03-14T11-16-41',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03/14/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%937-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E8%BF%9B%E9%98%B6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="Java知识整理和总结7-面向对象编程-进阶">
                        
                        <span class="card-title">Java知识整理和总结7-面向对象编程-进阶</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/10/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%935-%E6%95%B0%E7%BB%84/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Java知识整理和总结5-数组">
                        
                        <span class="card-title">Java知识整理和总结5-数组</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2023</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >756.3k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
