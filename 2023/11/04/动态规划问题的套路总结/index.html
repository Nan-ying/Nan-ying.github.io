<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="动态规划问题的套路总结, Nan-ying&#39;s Blog">
    <meta name="description" content="1. 基础问题509. 斐波那契数斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n -">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>动态规划问题的套路总结 | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">动态规划问题的套路总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/%E7%AE%97%E6%B3%95/">
              <span class="chip bg-color">算法</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
              算法
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-11-04
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 21.6k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          92 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h2 id="1-基础问题"><a href="#1-基础问题" class="headerlink" title="1. 基础问题"></a>1. 基础问题</h2><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<pre class="line-numbers language-none"><code class="language-none">F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre>

<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1</code></pre>

<p><strong>解题：</strong></p>
<p>要用一个一维dp数组来保存递归的结果</p>
<p>==动规五部曲：==</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><strong>题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">dp[0] = 0;
dp[1] = 1;</code></pre>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2] 中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int fib(int n) {
        //特殊情况直接返回，节省时间
        if (n &lt;= 1) return n;
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }              
        return dp[n];
    }
}</code></pre>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<pre class="line-numbers language-none"><code class="language-none">输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶</code></pre>

<p><strong>解题：</strong></p>
<p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p>
<p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p>
<p>所以到第三层楼梯的状态可以<strong>由第二层楼梯 和 到第一层楼梯状态推导出来</strong>，那么就可以想到动态规划了。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>dp[1] = 1，dp[2] = 2</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例当n为5的时候，dp table（dp数组）应该是这样的</p>
<p><img src="20210105202546299.png" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int climbStairs(int n) {
        if (n &lt;= 2) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}</code></pre>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><p>**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。</p>
</li>
<li><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。选起跳点一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
</li>
<li><p>只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。dp[0] = 0，dp[1] = 0</p>
</li>
<li><p>从前到后遍历cost数组</p>
</li>
<li><p>拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：</p>
<p><img src="20221026175104.png" alt="img"></p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i &lt;= cost.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}</code></pre>

<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre>

<p><strong>解题：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; numRows; i++) {
            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt;= i; j++) {
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    row.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));
                }
            }
            res.add(row);
        }
        return res;
    }
}</code></pre>

<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向下</code></pre>

<p><img src="image-20231012204941287.png" alt="image-20231012204941287"></p>
<p><strong>解题：</strong></p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>想要求<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。</p>
<p>那么很自然，<code>dp[i][j]</code> = <code>dp[i - 1][j]</code> + <code>dp[i][j - 1]</code>，因为<code>dp[i][j]</code>只有这两个方向过来。</p>
<ol start="3">
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从左至右、从上至下。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p><img src="20201209113631392.png" alt="62.不同路径1"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
        for (int j = 0; j &lt; n; j++) dp[0][j] = 1;
        
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}</code></pre>

<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><img src="robot1.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以<code>dp[i][0]</code>一定为1，<code>dp[0][j]</code>也同理。</p>
<p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的<code>dp[i][0]</code>应该还是初始值0。</p>
<p><img src="20210104114513928.png" alt="img"></p>
<p>下标(0, j)的初始化情况同理。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        //初始化
        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) {
                dp[i][0] = 1;
        }
        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m -1][n -1];
    }
}</code></pre>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><img src="minpath.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><code>dp[i][j]</code>为 (0, 0) 到 (i, j) 位置的最小路径和</li>
<li>遍历一定是从左上到右下</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i - 1 &lt; 0 &amp;&amp; j - 1 &lt; 0) {
                    dp[0][0] = grid[0][0]; // 特殊情况初始化
                } else if (i - 1 &lt; 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j]; // 在第一排
                } else if (j - 1 &lt; 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j]; // 在第一列
                } else {
                    dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}</code></pre>

<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h3><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>可以从1遍历j，然后有两种渠道得到dp[i]：</p>
<ul>
<li><p>一个是j * (i - j) 直接相乘。</p>
</li>
<li><p>一个是j * dp[i - j]，相当于是拆分(i - j)。</p>
</li>
</ul>
<p><strong>那有同学问了，j怎么就不拆分呢？</strong></p>
<p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>;</p>
<p>也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以上的个数相乘。</p>
<ol start="3">
<li>dp的初始化</li>
</ol>
<p>dp[2] = 1</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从前向后</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例当n为10 的时候，dp数组里的数值，如下：</p>
<p><img src="20210104173021581.png" alt="343.整数拆分"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[] dp = new int[n+1];
        dp[2] = 1;
        
        //在本题中，我们分析 dp[0], dp[1]都是无意义的
        for(int i = 3; i &lt;= n; i++) {
            for(int j = 1; j &lt;= i-j; j++) {
                // 这里的 j 其实最大值为 i-j,后面再大得到的乘积是一样的
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i-j 再拆分成两个以及两个以上(k&gt;=2)的个数,再相乘。
            }
        }
        return dp[n];
    }
}</code></pre>

<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><img src="uniquebstn3.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n = 3
输出：5</code></pre>

<p><strong>解题：</strong></p>
<p><img src="20210107093106367.png" alt="96.不同的二叉搜索树"></p>
<p><img src="20210107093129889.png" alt="96.不同的二叉搜索树1"></p>
<p>来看看n为3的时候，有哪几种情况。</p>
<ul>
<li><p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p>
</li>
<li><p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p>
</li>
<li><p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p>
</li>
</ul>
<p>发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p>
<p>dp[3]，就是 <code>元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</code>：</p>
<ul>
<li><p><code>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</code></p>
</li>
<li><p><code>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</code></p>
</li>
<li><p><code>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</code></p>
</li>
</ul>
<p>所以<code>dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</code></p>
<p>如图所示：</p>
<p><img src="20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：由 i 个节点，可以构成 dp[i] 种二叉搜索树</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><code>dp[i] += dp[j - 1] * dp[i - j]</code></p>
<p>j 是头结点的元素，从1遍历到i为止。<strong>j-1 为 j 为头结点左子树节点数量，i-j 为以 j 为头结点右子树节点数量</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>dp[0] = 1，空节点也是一棵二叉树</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>遍历i里面每一个数作为头结点的状态，用j来遍历。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}</code></pre>

<h2 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. 背包问题</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>有<code>n</code>件物品和一个最多能背重量为<code>w</code> 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<pre class="line-numbers language-none"><code class="language-none">背包最大重量为4。
物品为：
|       | 重量 | 价值 |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

背包能背的物品最大价值是35。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即**<code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进重量为j的背包，价值总和最大是多少**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>可以有两个方向推出来<code>dp[i][j]</code>，</p>
<ul>
<li><strong>不放物品i</strong>：<code>dp[i - 1][j]</code>。即背包重量为j，里面不放物品i的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：<code>dp[i - 1][j - weight[i]]</code>。<code>dp[i - 1][j - weight[i]] </code>为背包重量为j - weight[i]的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>背包重量j为0的话，即<code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0</p>
<p><code>dp[0][j]</code>，即：i为0，存放编号0的物品的时候，各个重量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，<code>dp[0][j]</code> 应该是 0，因为背包重量比编号0的物品重量还小。</p>
<p>当j &gt;= weight[0]时，<code>dp[0][j]</code> 应该是value[0]，因为背包重量放足够放编号0物品。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int j = 0 ; j &lt; weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j &lt;= bagweight; j++) {
    dp[0][j] = value[0];
}</code></pre>

<p><img src="20210110103109140.png" alt="动态规划-背包问题7"></p>
<p>一开始就统一把dp数组统一初始为0</p>
<p><img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" alt="动态规划-背包问题10"></p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p>
<p>先遍历物品，然后遍历背包重量（其实都可以，因为都是左上角开始）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BagProblem {
    public static void main(String[] args) {
        int[] weight = {1,3,4};
        int[] value = {15,20,30};
        int bagSize = 4;
        testWeightBagProblem(weight,value,bagSize);
    }

    /**
     * 动态规划获得结果
     * @param weight  物品的重量
     * @param value   物品的价值
     * @param bagSize 背包的重量
     */
    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){

        // 创建dp数组
        int goods = weight.length;  // 获取物品的数量
        int[][] dp = new int[goods][bagSize + 1];

        // 初始化dp数组
        // 创建数组后，其中默认的值就是0
        for (int j = weight[0]; j &lt;= bagSize; j++) {
            dp[0][j] = value[0];
        }

        // 填充dp数组
        for (int i = 1; i &lt; weight.length; i++) {
            for (int j = 1; j &lt;= bagSize; j++) {
                if (j &lt; weight[i]) {
                    /**
                     * 当前背包的重量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的重量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
                }
            }
        }

        // 打印dp数组
        for (int i = 0; i &lt; goods; i++) {
            for (int j = 0; j &lt;= bagSize; j++) {
                System.out.print(dp[i][j] + "\t");
            }
            System.out.println("\n");
        }
    }
}</code></pre>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;</p>
<p><strong>其实可以发现，递推公式只依赖上一层的状态。因为可以只维护两层，不断覆盖。如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code>;</strong></p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：重量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol start="2">
<li>一维dp数组的递推公式</li>
</ol>
<p>此时dp[j]有两个选择：一个是不放物品i，取自己<code>dp[j]</code> 相当于 二维dp数组中的<code>dp[i-1][j]</code>；一个是放物品i，取<code>dp[j - weight[i]] + value[i]</code></p>
<p>所以递归公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></p>
<ol start="3">
<li>一维dp数组如何初始化</li>
</ol>
<p>dp[0] = 0，其他下标都初始化为0。即dp数组初始化时都为0</p>
<ol start="4">
<li>一维dp数组遍历顺序</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int i = 0; i &lt; weight.size(); i++) { // 先遍历物品，确定物品范围
    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 再倒序遍历背包重量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}</code></pre>

<ul>
<li>倒序遍历</li>
</ul>
<p>一维数组<strong>倒序遍历是为了保证物品i只被放入一次</strong>。</p>
<p>如：第二行的<code>dp[4]=max(dp[4], dp[4-weight[1]]+value[1])=max(dp[4],dp[1]+20)</code>。相当于<code>dp[1][4]=max(dp[0][4],dp[0][1]+20)</code></p>
<p>如果正序遍历，则此时的<code>dp[1]</code>不能取到<code>dp[0][1]</code>的值而是<code>dp[1][1]</code>的值</p>
<p>倒序可以取得。</p>
<p>对于二维dp，<code>dp[i][j]</code>都是通过上一层即<code>dp[i - 1][j]</code>计算而来，本层的<code>dp[i][j]</code>并不会被覆盖。</p>
<ul>
<li>先遍历物品再遍历背包重量</li>
</ul>
<p>因为一维dp的写法，背包重量一定是要倒序遍历。因此需先遍历物品</p>
<p>如：第二行的<code>dp[4]=max(dp[4], dp[4-weight[1]]+value[1])=max(dp[4],dp[1]+20)</code>。其中此时的<code>dp[4]</code>相当于<code>dp[0][4]</code>，<code>dp[1]</code>相当于<code>dp[0][1]</code>，即相当于把第一行的值拷贝用到第二行</p>
<p><img src="image-20231023195905587.png" alt="image-20231023195905587"></p>
<p><img src="20210110103614769.png" alt="动态规划-背包问题9"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWight = 4;
    testWeightBagProblem(weight, value, bagWight);
}

public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
    int wLen = weight.length;
    //定义dp数组：dp[j]表示背包重量为j时，能获得的最大价值
    int[] dp = new int[bagWeight + 1];
    //遍历顺序：先遍历物品，再遍历背包重量
    for (int i = 0; i &lt; wLen; i++){
        for (int j = bagWeight; j &gt;= weight[i]; j--){
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    //打印dp数组
    for (int j = 0; j &lt;= bagWeight; j++){
        System.out.print(dp[j] + " ");
    }
}</code></pre>

<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre>

<p><strong>解题：</strong></p>
<p>问题转化：<strong>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够</strong>==<strong>恰好</strong>==<strong>将背包装满</strong>（==0-1背包问题是求尽量装满后的背包价值==）</p>
<ul>
<li>背包的重量为sum / 2</li>
<li>背包中每一个元素是不可重复放入</li>
</ul>
<ol>
<li><strong>dp[j]表示 重量为j的背包，若dp[j]为true，则说明可以恰好将背包装满</strong>。</li>
<li>递推公式：<code>dp[j] = dp[j] || dp[j - nums[i]]</code></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum &gt;&gt; 1;
        int[] dp = new int[target + 1];
        dp[0] = true;
        
        for(int i = 0; i &lt; nums.length; i++) {
            for(int j = target; j &gt;= nums[i]; j--) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}</code></pre>

<h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre>

<p><strong>解题：</strong></p>
<p>二分：==<strong>尽量</strong>==让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。</p>
<p>问题转化：<strong>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>stones[i]</code>。现在让你装物品，</strong>==<strong>尽量</strong>==<strong>将背包装满</strong>（价值等于重量，因此等效于使背包价值最大）</p>
<ul>
<li>本题物品的重量为stones[i]，物品的价值也为stones[i]。</li>
<li>**dp[j]表示重量为j的背包，最多可以装最大重量为dp[j]**。<ul>
<li>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</li>
<li><strong>在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</li>
<li>那么相撞之后剩下的最小石头重量就是 <code>(sum - dp[target]) - dp[target]</code>。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum &gt;&gt; 1;
        //初始化dp数组
        int[] dp = new int[target + 1];
        
        for (int i = 0; i &lt; stones.length; i++) {
            //采用倒序
            for (int j = target; j &gt;= stones[i]; j--) {
                //两种情况，要么放，要么不放
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}</code></pre>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3</code></pre>

<p><strong>解题：</strong></p>
<p>二分：假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 x - (sum - x) = target 即 <code>x = (target + sum) / 2</code></p>
<p><strong>此时问题就转化为，装满限重量为x的背包，有几种方法</strong>。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[j] 表示：填满j重量的包，有dp[j]种方法</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>所以求组合类问题的公式，都是类似这种：</p>
<pre class="line-numbers language-none"><code class="language-none">dp[j] += dp[j - nums[i]]</code></pre>

<blockquote>
<p>也可以这样理解：</p>
<p>1、如果不选第i个数（nums[i]）的话，则方法数为dp[j]； </p>
<p>2、如果选第i个数（nums[i]）的话，则方法数为dp[j - nums[i]]； 所以方法总数为：dp[j] = dp[j] + dp[j - nums[i]]；（感觉这样拆开写比较容易理解） 可以对比其他01背包问题：dp[j] = max(dp[j], dp[j - nums[i]])，这种问题即是从选i与不选i里，选取最大值。</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findTargetSumWays(int[] nums, int target) {
      // 和之前遇到的背包问题不一样，之前都是求容量为j的背包，最多能装多少。
      // 本题则是装满有几种方法。也就是一个组合问题了。
      int sum = 0; // 记录整个nums数组的总和
      for (int num : nums) sum += num; // 遍历累加

      // 排除错误情况
      // 1、sum + target = 2 * left 必然为偶数
      // 2、如果sum已经比target小了，也就是所有组合的最大值比target小了，那也是不能实现的
      // 注意！这里，如果sum = 100, target = -200, 也是没有组合的
      if ((sum + target) % 2 != 0 || sum &lt; Math.abs(target)) return 0;

      // 设置背包大小
      int bagWeight = (sum + target) / 2;
      int[] dp = new int[bagWeight + 1];

      // 初始化dp数组
      // j = 0, 意味着此时 sum + target = 0, 只有一种，就是全是-（要想使x = (target + sum) / 2 = 0 有1种方法）
      dp[0] = 1;

      // 遍历物品
      for (int i = 0; i &lt; nums.length; ++i) {
        // 遍历背包
        for (int j = bagWeight; j &gt;= nums[i]; --j) {
          dp[j] += dp[j - nums[i]];
        }
      }
      return dp[bagWeight];
    }
}</code></pre>

<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**<code>dp[i][j]</code>：最多有i个0和j个1的strs的最大子集的大小为<code>dp[i][j]</code>**。（仍然是一维数组，只是背包重量有两个维度）</p>
<p>即重量为i个0和j个1的背包，可以装得下的最大价值（每个字符串价值视为1）</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code></p>
<ol start="3">
<li>初始化</li>
</ol>
<p>因为物品价值不会是负数，初始dp数组为0，保证递推的时候<code>dp[i][j]</code>不会被初始值覆盖。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        // 先遍历物品
        for (String str : strs) {
            int zero = 0;
            int one = 0;
            for (char c : str.toCharArray()) {
                if (c == '0') {
                    zero++;
                } else {
                    one++;
                }
            }
            // 再遍历背包重量
            for (int i = m; i &gt;= zero; i--) {
                for (int j = n; j &gt;= one; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);
                }
            }
        }
        return dp[m][n];
    }
}</code></pre>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><strong>每件商品都有无限个！</strong></p>
<pre class="line-numbers language-none"><code class="language-none">物品为：
|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

背包最大重量为4，问背包能背的物品最大价值是多少?</code></pre>

<p><strong>解题：</strong></p>
<p>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是<strong>可以添加多次</strong>的，所以要从小到大去遍历</p>
<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>
<p>因为<code>dp[j]</code>是根据下标j之前所对应的<code>dp[j]</code>计算出来的。 只要保证下标j之前的<code>dp[j]</code>都是已计算的就可以了。</p>
<p>遍历物品在外层循环，遍历背包重量在内层循环，状态如图：</p>
<p><img src="20210126104529605.jpg" alt="动态规划-完全背包1"></p>
<p>遍历背包重量在外层循环，遍历物品在内层循环，状态如图：</p>
<p><img src="20210729234011.png" alt="动态规划-完全背包2"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i &lt; weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j &lt;= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + " ");
    }
}</code></pre>

<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1</code></pre>

<p><strong>解题：</strong></p>
<p><strong>求组合</strong></p>
<ol>
<li><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p>
</li>
<li><p>递推公式：<code>dp[j] += dp[j - coins[i]];</code></p>
</li>
<li><p>dp[0] = 1  凑成总金额0的货币组合数为1</p>
</li>
<li><p>外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况</p>
</li>
</ol>
<p>假设：coins[0] = 1，coins[1] = 2，coins[2] = 3。</p>
<p>j=3时，遍历到i=0时，会包含{1，1，1}和{2，1}。遍历到i=1时，会包含{1，1，1}，{2，1}和{1，2}。重复了</p>
<p>正确的应该遍历到i=0时，不包含{2，1}还未出现面值为2的币。</p>
<p><img src="image-20231023205224361.png" alt="image-20231023205224361"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i &lt; coins.length; i++) {
            for (int j = coins[i]; j &lt;= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}</code></pre>

<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。</code></pre>

<p><strong>解题：</strong></p>
<p><strong>求排列</strong>，参照上一题，应该外遍历重量内遍历物品</p>
<p><img src="1697682295-pEvlhg-image.png" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int j = 0; j &lt;=target; j++) {
            for (int i = 0; i &lt; nums.length; i++) {
                if (j &gt;= nums[i]) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
}</code></pre>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></li>
<li>递推公式：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code>; 考虑coins[i]，凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]；不考虑coins[i]，则为dp[j]</li>
<li>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。两种 for 循环均可</li>
<li>dp[0] = 0，同时其他下标非0的元素必须初始化为一个比amount大的数（凑amount最多硬币就是amount个1），否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        // 初始化
        for (int i = 0; i &lt; dp.length; i++) {
            dp[i] = amount + 1;//设置成MAX_VALUE会有溢出的错误
        }
        dp[0] = 0;
        
        for (int i = 0; i &lt; coins.length; i++) {
            for (int j = coins[i]; j &lt;= amount; j++) {
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}</code></pre>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></li>
<li>递推公式：<code>dp[j] = min(dp[j - i * i] + 1, dp[j])</code>;</li>
<li>dp[0]=0完全是为了递推公式，其他下标非0元素初始化为大于最大数量的值</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        // 初始化
        for (int i = 0; i &lt;= n; i++) {
            dp[i] = n + 1;
        }
        dp[0] = 0;
        
        for (int i = 0; i * i &lt;= n; i++) {
            for (int j = i * i; j &lt;= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}</code></pre>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
     
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false</code></pre>

<p><strong>解题：</strong></p>
<p>等效于416.分割等和子集</p>
<ol>
<li><p><strong>dp[j] : 字符串长度为i的话，dp[j]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
</li>
<li><p>递推公式是 <code>dp[j] = dp[j] || dp[j-len]</code>。前提，len的子串在字典中有对应单词</p>
</li>
<li><p>dp[0]一定要为true，因为dp[j] 的状态依靠 dp[s]是否为true。下标非0的dp[j]初始化为false</p>
</li>
<li><p>本题<strong>求的是排列数</strong>。 拿 s = “applepenapple”, wordDict = [“apple”, “pen”] 举例。</p>
<p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p>
<p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 不可以组成，但会默认取这几个中的一个（组合认为这三种排列方式是一样的），会产生错误结果。</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;

        // 先遍历重量
        for (int j = 1; j &lt;= s.length(); j++) {
            // 再遍历物品
            for (String word : wordDict) {
                int len = word.length();
                if (j &gt;= len &amp;&amp; word.equals(s.substring(j- len, j))) { // 使dp[j - len]有意义
                    dp[j] = dp[j] || dp[j - len];
                }
            }
        }
        return dp[s.length()];
    }
}</code></pre>

<h2 id="3-打家劫舍"><a href="#3-打家劫舍" class="headerlink" title="3. 打家劫舍"></a>3. 打家劫舍</h2><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre>

<p><strong>解题：</strong></p>
<p>当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了</p>
<ol>
<li><p>**dp[i]：考虑下标i（包括i）==以内==的房屋，最多可以偷窃的金额为dp[i]**。</p>
</li>
<li><p>递推公式：决定dp[i]的因素就是第i房间偷还是不偷。</p>
<p>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<p>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p>
<p>然后dp[i]取最大值，即<code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</code>;</p>
</li>
<li><p>初始化：</p>
<pre class="line-numbers language-none"><code class="language-none">dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);</code></pre>
</li>
<li><p>从前到后遍历</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];//必须有，否则dp[1]赋值报错(不存在nums[1])
        
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i &lt; nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.length - 1];
    }
}</code></pre>

<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</code></pre>

<p><strong>解题：</strong></p>
<p>第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题<strong>简化为两个单排排列房间子问题</strong>：</p>
<ol>
<li><p>在不偷窃第一个房子的情况下（即 nums[1:]），最大金额是 p1</p>
</li>
<li><p>在不偷窃最后一个房子的情况下（即 nums[:n−1]），最大金额是 p2</p>
</li>
</ol>
<p>综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1, p2)。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        //Arrays.copyOfRange左闭右开
        return Math.max(myRob(Arrays.copyOfRange(nums, 0, nums.length - 1)), //情况2
                        myRob(Arrays.copyOfRange(nums, 1, nums.length))); //情况1
    }
    private int myRob(int[] nums) {
        //这里截取了，还需要再判断一下
        if (nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i &lt; nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.length - 1];
    }
}</code></pre>

<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><img src="rob2-tree.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p>二叉树不同于数组，不可通过遍历来确定前后及相邻顺序，因此需要多一个维度约束来判断是否可以偷</p>
</blockquote>
<p>我们使用一个大小为 2 的数组来表示 <code>int[] res = new int[2]</code>  0 代表不偷，1 代表偷。</p>
<p>任何一个节点能偷到的最大钱的状态可以定义为：</p>
<ul>
<li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱（不一定孩子一定要偷）</li>
<li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>
</ul>
<p>表示为公式如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">res[0] = Math.max(robInternal(root.left)[0], robInternal(root.left)[1]) + Math.max(robInternal(root.right)[0], robInternal(root.right)[1])
res[1] = robInternal(root.left)[0] + robInternal(root.right)[0] + root.val;</code></pre>

<p>最终代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int rob(TreeNode root) {
    int[] result = robInternal(root);
    return Math.max(result[0], result[1]);
}

// 返回当前节点偷与不偷两种情况可获得的最大钱
public int[] robInternal(TreeNode root) {
    if (root == null) return new int[2];
    int[] result = new int[2];

    int[] left = robInternal(root.left);
    int[] right = robInternal(root.right);

    result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    result[1] = left[0] + right[0] + root.val;

    return result;
}</code></pre>

<h2 id="4-买卖股票"><a href="#4-买卖股票" class="headerlink" title="4. 买卖股票"></a>4. 买卖股票</h2><h3 id="121-买卖股票的最佳时机（只能买卖一次）"><a href="#121-买卖股票的最佳时机（只能买卖一次）" class="headerlink" title="121. 买卖股票的最佳时机（只能买卖一次）"></a>121. 买卖股票的最佳时机（只能买卖一次）</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p>在基于前后天的动规上，还有是否持有股票的限制（若不持有无法售出），且无法像打家劫舍一样通过简单遍历判断是否相邻来判断，因此需要另一维度</p>
</blockquote>
<ol>
<li><p><code>dp[i][0]</code> 表示第i天持有股票所得最多现金</p>
<p><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
</li>
<li><p>确定递推公式</p>
</li>
</ol>
<p>如果第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么应该选所得现金最大的，所以<code>dp[i][0] = max(dp[i - 1][0], -prices[i])</code>;</p>
<p>如果第i天不持有股票即<code>dp[i][1]</code>， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></li>
</ul>
<p>同样取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code>;</p>
<ol start="3">
<li>初始化</li>
</ol>
<p><code>dp[0][0]</code>表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以<code>dp[0][0] -= prices[0];</code></p>
<p><code>dp[0][1]</code>表示第0天不持有股票，不持有股票那么现金就是0，所以<code>dp[0][1] = 0;</code></p>
<ol start="4">
<li>从前向后遍历</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.length - 1][1];
    }
}</code></pre>

<h3 id="122-买卖股票的最佳时机-II（可以买卖多次）"><a href="#122-买卖股票的最佳时机-II（可以买卖多次）" class="headerlink" title="122. 买卖股票的最佳时机 II（可以买卖多次）"></a>122. 买卖股票的最佳时机 II（可以买卖多次）</h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><p><code>dp[i][0]</code> 表示第i天持有股票所得现金。</p>
<p><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
</li>
<li><p>递推公式：</p>
</li>
</ol>
<ul>
<li><p>第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p>
<ul>
<li><p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></p>
</li>
<li><p>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></p>
</li>
</ul>
</li>
<li><p>第i天不持有股票即<code>dp[i][1]</code>的情况， 依然可以由两个状态推出来</p>
<ul>
<li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></p>
</li>
<li><p>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);//只有这里和121不一样
            // 因为本题的股票可以买卖多次！ 所以买入股票的时候，可能会有之前买卖的利润即：dp[i - 1][1]
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
}</code></pre>

<h3 id="123-买卖股票的最佳时机-III（最多买卖两次）"><a href="#123-买卖股票的最佳时机-III（最多买卖两次）" class="headerlink" title="123. 买卖股票的最佳时机 III（最多买卖两次）"></a>123. 买卖股票的最佳时机 III（最多买卖两次）</h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</code></pre>

<p><strong>解题：</strong></p>
<p>关键在于<strong>至多买卖两次</strong></p>
<ol>
<li><p><code>dp[i][j]</code>中 i表示第i天，j为 [0 - 4] 五个状态，<code>dp[i][j]</code>表示第i天状态j所剩最大现金。</p>
<ol start="0">
<li><p>没有操作 （其实我们也可以不设置这个状态）</p>
</li>
<li><p>第一次持有股票</p>
</li>
<li><p>第一次不持有股票</p>
</li>
<li><p>第二次持有股票</p>
</li>
<li><p>第二次不持有股票</p>
</li>
</ol>
</li>
<li><p>递推公式</p>
</li>
</ol>
<p>达到<code>dp[i][1]</code>状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么<code>dp[i][1] = dp[i-1][0] - prices[i]</code></li>
<li>操作二：第i天没有操作，而是沿用前一天持有的状态，即：<code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p>最后选最大的，所以 <code>dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1])</code>;</p>
<p>同理<code>dp[i][2]</code>也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code>(包含当天买入当天卖出)</li>
<li>操作二：第i天没有操作，沿用前一天不持有股票的状态，即：<code>dp[i][2] = dp[i - 1][2]</code>(包含当天买入当天卖出)</li>
</ul>
<p>所以<code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></p>
<p>同理可推出剩下状态部分：</p>
<p><code>dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])</code>;</p>
<p><code>dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])</code>;</p>
<ol start="3">
<li>初始化</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">dp[0][0] = 0
dp[0][1] = -prices[0]
dp[0][2] = 0 // 当天买入、当天卖出
dp[0][3] = -prices[0] // 第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入）
dp[0][4] = 0</code></pre>

<ol start="4">
<li>从前往后遍历</li>
</ol>
<p>最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以<code>dp[i][4]</code>已经包含了<code>dp[i][2]</code>的情况。也就是说第二次卖出手里所剩的钱一定是最多的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i &lt; prices.length; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] -prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.length - 1][4];
    }
}</code></pre>

<h3 id="188-买卖股票的最佳时机-IV（最多买卖k次）"><a href="#188-买卖股票的最佳时机-IV（最多买卖k次）" class="headerlink" title="188. 买卖股票的最佳时机 IV（最多买卖k次）"></a>188. 买卖股票的最佳时机 IV（最多买卖k次）</h3><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p><strong>注意：</strong>你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre>

<p><strong>解题：</strong></p>
<p>根据123题找规律</p>
<ol>
<li>有 2 * k + 1个状态</li>
<li>初始化时奇数状态为-prices[0]，偶数状态为0</li>
<li>递推公式：分奇数状态和偶数状态两种</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][] dp = new int[prices.length][2 * k + 1];
        // 初始化
        for (int  j= 1; j &lt; 2 * k + 1; j += 2) {
            dp[0][j] = -prices[0];
        }
        
        for (int i = 1; i &lt; prices.length; i++) {
            for (int j = 1; j &lt; 2 * k + 1; j++) {
                if (j % 2 == 1) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]);
                }
            }
        }
        return dp[prices.length - 1][2 * k];
    }
}</code></pre>

<h3 id="309-买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期）"><a href="#309-买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期）" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期）"></a>309. 买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期）</h3><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><code>dp[i][j]</code>，第i天状态为j，所剩的最多现金为<code>dp[i][j]</code>。j = 0, 1, 2, 3</li>
</ol>
<ul>
<li>0.状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li>
<li>不持有股票状态，这里就有两种卖出股票状态（==关键这里分为两种状态，这样好判定冷冻期==）<ul>
<li>1.状态二：非今天卖出、非冷冻（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li>
<li>2.状态三：今天卖出股票</li>
<li>3.状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
</li>
</ul>
<p><img src="518d5baaf33f4b2698064f8efb42edbf.png" alt="img"></p>
<ol start="2">
<li>递推公式</li>
</ol>
<p><strong>达到持有股票状态</strong>（状态一）即：<code>dp[i][0]</code>，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），<code>dp[i][0] = dp[i - 1][0]</code></li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li>
<li>前一天是保持卖出股票的状态（状态二），<code>dp[i - 1][1] - prices[i]</code></li>
</ul>
</li>
</ul>
<p>那么<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])</code>;</p>
<p><strong>达到不持有股票（非今天卖出）状态</strong>（状态二）即：<code>dp[i][1]</code>，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期（状态四）</li>
</ul>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])</code>;</p>
<p><strong>达到今天就卖出股票状态</strong>（状态三），即：<code>dp[i][2]</code> ，只有一个操作：</p>
<ul>
<li>昨天一定是持有股票状态（状态一），今天卖出</li>
</ul>
<p>即：<code>dp[i][2] = dp[i - 1][0] + prices[i]</code>;</p>
<p><strong>达到冷冻期状态</strong>（状态四），即：<code>dp[i][3]</code>，只有一个操作：</p>
<ul>
<li>昨天卖出了股票（状态三）</li>
</ul>
<p>即：<code>dp[i][3] = dp[i - 1][2]</code>;</p>
<ol start="3">
<li>初始化</li>
</ol>
<p><code>dp[0][0] = -prices[0]</code>，<code>dp[0][1]/dp[0][2]/dp[0][3] = 0</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i &lt; n; i++) {
            dp[i][0] = Math.max(Math.max(dp[i - 1][0], dp[i - 1][3] -prices[i]), dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(Math.max(dp[n - 1][1], dp[n - 1][2]), dp[n - 1][3]);
    }
}</code></pre>

<h3 id="714-买卖股票的最佳时机含手续费（买卖多次，每次有手续费）"><a href="#714-买卖股票的最佳时机含手续费（买卖多次，每次有手续费）" class="headerlink" title="714. 买卖股票的最佳时机含手续费（买卖多次，每次有手续费）"></a>714. 买卖股票的最佳时机含手续费（买卖多次，每次有手续费）</h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</code></pre>

<p><strong>解题：</strong></p>
<p>与题122的区别就是多一个手续费</p>
<p><code>dp[i][0]</code> 表示第i天持有股票所得最多现金。<code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
<p>如果第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></li>
<li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></li>
</ul>
<p>所以：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</code>;</p>
<p>在来看看如果第i天不持有股票即<code>dp[i][1]</code>的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>即：<code>dp[i - 1][0] + prices[i] - fee</code></li>
</ul>
<p>所以：<code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)</code>;</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i &lt; prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.length - 1][1];
    }
}</code></pre>

<h2 id="5-子序列问题"><a href="#5-子序列问题" class="headerlink" title="5. 子序列问题"></a>5. 子序列问题</h2><h3 id="子序列（不连续）"><a href="#子序列（不连续）" class="headerlink" title="子序列（不连续）"></a>子序列（不连续）</h3><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p>不好用滑动窗口法，因为包含满足条件子序列的数组中一段 可能有违反递增规则的数（不要求连续）</p>
<p>反而是递增这种情况<strong>子问题</strong>会对之后产生影响，比较适合用动规</p>
</blockquote>
<ol>
<li><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<p>一定需要 “==以nums[i]结尾的最长递增子序==” ，因为在做递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p>
</li>
<li><p>递推公式：位置i的最长升序子序列 = j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p><code>if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</code></p>
</li>
</ol>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
<ol start="3">
<li>初始化：每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1</li>
<li>从前向后遍历</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 1;
        Arrays.fill(dp, 1);
        for (int i = 1; i &lt; nums.length; i++) {
            for (int j = 0; j &lt; i; j++) {
                if (nums[i] &gt; nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
                if (dp[i] &gt; res) res = dp[i]; // 取长的子序列
            }
        }
        return res; // 不一定是dp[nums.length - 1]最长，只是遍历每一个不同结尾的序列，取其中最长的子序列
    }
}</code></pre>

<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h4><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。</code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p>与76题最小覆盖子串相比，76题只需要在一个字符串上采用滑动窗口即可。而本题需要同时考虑两个串，不方便</p>
</blockquote>
<ol>
<li><p><code>dp[i][j]</code>：长度为i的字符串text1[0, i - 1]与长度为j的字符串text2[0, j - 1]的最长公共子序列为<code>dp[i][j]</code></p>
</li>
<li><p>递推公式：</p>
<ul>
<li><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>;</p>
<ul>
<li>与300题取前i个中最长的子序列不同，因为300是找递增序列、本题是找公共序列，则此时最长一定在<code>dp[i - 1][j - 1]</code></li>
</ul>
</li>
<li><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code>;</p>
</li>
</ul>
</li>
<li><p>初始化：统一为0</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] c1 = text1.toCharArray();
        char[] c2 = text2.toCharArray();
        int[][] dp = new int[c1.length + 1][c2.length + 1];
        for (int i = 1; i &lt;= c1.length; i++) {
            for (int j = 1; j &lt;= c2.length; j++) {
                if (c1[i - 1] == c2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[c1.length][c2.length]; // 寻找公共子序列，则一定序列越长，子序列越长
    }
}</code></pre>

<h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a>1035. 不相交的线</h4><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><img src="142.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</code></pre>

<p><strong>解题：</strong></p>
<p>直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。</p>
<p>其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）</p>
<p>这么分析完之后，大家可以发现：<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = 1; i &lt;= nums1.length; i++) {
            for (int j = 1; j &lt;= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
}</code></pre>

<h3 id="子序列（连续）"><a href="#子序列（连续）" class="headerlink" title="子序列（连续）"></a>子序列（连续）</h3><h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h4><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p>也可以用滑动窗口</p>
</blockquote>
<ol>
<li>**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。</li>
</ol>
<p>注意这里的定义，<strong>一定是以下标i为结尾</strong>，并不是说一定以下标0为起始位置。</p>
<ol start="2">
<li>本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] &gt; nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
            if (dp[i] &gt; res) res = dp[i]; // 取长的子序列
        }
        return res;
    }
}</code></pre>

<h4 id="718-最长公共子数组"><a href="#718-最长公共子数组" class="headerlink" title="718. 最长公共子数组"></a>718. 最长公共子数组</h4><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。是连续的</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><p><code>dp[i][j]</code> ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为<code>dp[i][j]</code>。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明<strong>一定是 以A[i-1]为结尾的子数组</strong> ）。从1开始遍历</p>
</li>
<li><p>递推公式：当A[i - 1] 和B[j - 1]相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
</li>
<li><p>初始化：<code>dp[i][0]</code> 和<code>dp[0][j]</code>其实都是没有意义的。为方便递推定义为0。</p>
</li>
</ol>
<p>本题不定义<code>dp[i][j]</code>为 以下标i为结尾的A，和以下标j 为结尾的B最长重复子数组长度是因为这样初始化比较麻烦，还需要进行判断。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        int res = 0;
        for (int i = 1; i &lt;= nums1.length; i++) {
            for (int j = 1; j &lt;= nums2.length; j++) {
                if (nums1[i -1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] &gt; res) res = dp[i][j];
            }
        }
        // 不一定是dp[nums1.length][nums2.length]取到最长公共子数组
        return res;
    }
}</code></pre>

<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。</li>
<li>递推公式：<code>dp[i] = max(dp[i - 1] + nums[i], nums[i]);</code></li>
<li>初始化：dp[0] = nums[0]</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            if (dp[i] &gt; res) res = dp[i];
        }
        return res;
    }
}</code></pre>

<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h4><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>子数组</strong> 是数组的连续子序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><code>dpMax[i]</code> 表示以第 <code>i</code> 个元素的结尾的子数组，乘积最大的值</li>
<li><code>dpMax[i]</code> 的话有几种取值：<ul>
<li>当 <code>nums[i] &gt;= 0</code> 并且<code>dpMax[i-1] &gt; 0</code>，<code>dpMax[i] = dpMax[i-1] * nums[i]</code></li>
<li>当 <code>nums[i] &gt;= 0</code> 并且<code>dpMax[i-1] &lt; 0</code>，此时如果和前边的数累乘的话，会变成负数，所以<code>dpMax[i] = nums[i]</code></li>
<li>当 <code>nums[i] &lt; 0</code>，此时如果前边累乘结果是一个很大的负数，和当前负数累乘的话就会变成一个更大的数。所以我们还需要一个数组 dpMin 来<strong>记录以第 i - 1 个元素的结尾的子数组</strong>，乘积最小的值。<ul>
<li>当<code>dpMin[i-1] &lt; 0</code>，<code>dpMax[i] = dpMin[i-1] * nums[i]</code></li>
<li>当<code>dpMin[i-1] &gt;= 0</code>，<code>dpMax[i] = nums[i]</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        int[] dpMax = new int[n];
        int[] dpMin = new int[n];
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        int max = nums[0];
        for (int i = 1; i &lt; n; i++) {
            // dpMax[i] 的取值无非就是三种，无须区分当前是哪种情况，取最大即可
            dpMax[i] = Math.max(Math.max(dpMax[i - 1] * nums[i], nums[i]), dpMin[i - 1] * nums[i]);
            dpMin[i] = Math.min(Math.min(dpMin[i - 1] * nums[i], nums[i]), dpMax[i - 1] * nums[i]);
            max = Math.max(max, dpMax[i]);
        }
        return max;
    }
}</code></pre>

<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h4><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = "abc", t = "ahbgdc"
输出：true</code></pre>

<p><strong>解题：</strong></p>
<p>类比题1143</p>
<p><strong>t 要照着 s 来挑选</strong>，逐字符考察选或不选</p>
<p><code>dp[i][j]</code>：长度为i的字符串s[0, i - 1]与长度为j的字符串t[0, j - 1]的最长公共子序列为<code>dp[i][j]</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] c1 = s.toCharArray();
        char[] c2 = t.toCharArray();
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 1; i &lt;= c1.length; i++) {
            for (int j = 1; j &lt;= c2.length; j++) {
                if (c1[i - 1] == c2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1]; // 这里相比1143简化了一些
                }
            }
        }
        if (dp[c1.length][c2.length] == s.length()) {
            return true;
        }
        return false;
    }
}</code></pre>

<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a>115. 不同的子序列</h4><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 10^9 + 7 取模。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabb b it
rab b bit
ra b bbit</code></pre>

<p><strong>解题：</strong></p>
<p><strong>s 要照着 t 来挑选</strong>，逐字符考察选或不选</p>
<ol>
<li><code>dp[i][j]</code>：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</li>
<li>递推公式：</li>
</ol>
<ul>
<li><p>s[i - 1] 与 t[j - 1]相等</p>
<ul>
<li>让s[i - 1]参与匹配，匹配范围缩小，此时匹配值为 <code>dp[i - 1][j - 1]</code></li>
<li>不让s[i - 1]参与匹配，例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。那么个数为<code>dp[i - 1][j]</code>。</li>
</ul>
</li>
<li><p>s[i - 1] 与 t[j - 1] 不相等</p>
<ul>
<li>只能不选s[i - 1]来匹配，即：<code>dp[i - 1][j]</code></li>
</ul>
</li>
<li><pre><code class="java">if (s[i - 1] == t[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
} else {
    dp[i][j] = dp[i - 1][j];
}
<pre class="line-numbers language-none"><code class="language-none">
3. 初始化：

`dp[0][0]=1`

`dp[i][0]=1`：空集是所有字符串子集

`dp[0][j]=0`：空字符串s 无论如何也变成不了t

```java
class Solution {
    public int numDistinct(String s, String t) {
        char[] c1 = s.toCharArray();
        char[] c2 = t.toCharArray();
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i &lt;= s.length(); i++) dp[i][0] = 1;

        for (int i = 1; i &lt;= s.length(); i++) {
            for (int j = 1; j &lt;= t.length(); j++) {
                if (c1[i - 1] == c2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.length()][t.length()];
    }
}</code></pre>
</code></pre>
</li>
</ul>
<h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h4><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"</code></pre>

<p><strong>解题：</strong></p>
<p>题1143的变种</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        char[] c1 = word1.toCharArray();
        char[] c2 = word2.toCharArray();
        int[][] dp = new int[c1.length + 1][c2.length + 1];
        for (int i = 1; i &lt;= c1.length; i++) {
            for (int j = 1; j &lt;= c2.length; j++) {
                if (c1[i - 1] == c2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return c1.length + c2.length - dp[c1.length][c2.length] * 2; //用两个字符串的总长度减去两个最长公共子序列的长度
    }
}</code></pre>

<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h4><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>**<code>dp[i][j]</code> 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为<code>dp[i][j]</code>**。</li>
<li>递推公式</li>
</ol>
<ul>
<li>当 <code>word1[i - 1]==word2[j - 1]</code> 时，由于遍历到了i和j，说明word1的0<del>i-2和word2的0</del>j-2的匹配结果已经生成，由于当前两个字符相同,因此无需做任何操作,<code>dp[i][j]=dp[i-1][j-1]</code></li>
<li>当 <code>word1[i - 1]!=word2[j - 1]</code> 时,可以进行的操作有3个:<br>① 替换操作：可能word1的0<del>i-2位置与word2的0</del>j-2位置的字符都相同，只是当前位置的字符不匹配,进行替换操作后两者变得相同，所以此时<code>dp[i][j]=dp[i-1][j-1]+1</code>(这个加1代表执行替换操作)<br>②删除操作：若此时word1的0<del>i-2位置与word2的0</del>j-1位置已经匹配了，此时多出了word1的 i-1 位置字符,应把它删除掉,才能使此时word1的0<del>i-1(这个i-1是执行了删除操作后新的i-1)和word2的0</del>j-1位置匹配，因此此时<code>dp[i][j]=dp[i-1][j]+1</code>(这个加1代表执行删除操作)<br>③插入操作：若此时word1的0<del>i-1位置只是和word2的0</del>j-2位置匹配，此时只需要在原来的i位置后面插入一个和word2的j-1位置相同的字符使得此时的word1的0<del>i-1(这个i-1是执行了插入操作后新的i-1)和word2的0</del>j-1匹配得上，所以此时<code>dp[i][j]=dp[i][j-1]+1</code>(这个加1代表执行插入操作)<br>由于题目所要求的是要最少的操作数:所以当word1[i - 1] != word2[j - 1] 时，需要在这三个操作中选取一个最小的值</li>
</ul>
<ol start="3">
<li><p>初始化</p>
<p><code>dp[i][0]=i</code> ：对word1里的元素全部做删除操作</p>
<p>同理<code>dp[0][j] = j</code></p>
</li>
<li><p>遍历顺序</p>
</li>
</ol>
<p>​			从如下四个递推公式：</p>
<ul>
<li><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li><code>dp[i][j] = dp[i][j - 1] + 1</code></li>
<li><code>dp[i][j] = dp[i - 1][j] + 1</code></li>
</ul>
<p>可以看出<code>dp[i][j]</code>是依赖左方，上方和左上方元素的</p>
<p><img src="20210114162113131.jpg" alt="72.编辑距离"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        char[] c1 = word1.toCharArray();
        char[] c2 = word2.toCharArray();
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i &lt;= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j &lt;= word2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i &lt;= word1.length(); i++) {
            for (int j = 1; j &lt;= word2.length(); j++) {
                if (c1[i - 1] == c2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);
                }
            }
        }
        
        return dp[word1.length()][word2.length()];
    }
}</code></pre>

<h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"</code></pre>

<p><strong>解题：</strong></p>
<p>判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。</p>
<p><img src="20230102170752.png" alt="img"></p>
<ol>
<li><code>dp[i][j]</code>：表示<strong>区间范围[i,j]</strong> （注意是左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</li>
<li>递推公式</li>
</ol>
<ul>
<li><p>当s[i]与s[j]不相等，那没啥好说的了，<code>dp[i][j]</code>一定是false。</p>
</li>
<li><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li><p>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</p>
</li>
<li><p>情况二：下标i 与 j相差为1，例如aa，也是回文子串</p>
</li>
<li><p>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>初始化</li>
</ol>
<p><code>dp[i][j]</code>初始化为false</p>
<ol start="4">
<li>遍历顺序</li>
</ol>
<p>从递推公式中可以看出，情况三是根据<code>dp[i + 1][j - 1]</code>是否为true，再对<code>dp[i][j]</code>进行赋值true的。</p>
<p><code>dp[i + 1][j - 1]</code> 在 <code>dp[i][j]</code>的左下角，如图：</p>
<p><img src="20210121171032473-20230310132134822.jpg" alt="647.回文子串"></p>
<p><strong>一定要从下到上，从左到右遍历</strong>。<strong>保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int countSubstrings(String s) {
        char[] c = s.toCharArray();
        boolean[][] dp = new boolean[s.length()][s.length()];
        int res = 0;
        for (int i = c.length - 1; i &gt;= 0; i--) {
            for (int j = i; j &lt; c.length; j++) { // 注意这里j从i开始，因为区间为[i,j]
                if (c[i] == c[j]) {
                    if (j - i &lt;= 1) {
                        res++;
                        dp[i][j] = true;
                    } else if (dp[i][j] = dp[i + 1][j - 1]) {
                        res++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return res;
    }
}</code></pre>

<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h4><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>**<code>dp[i][j]</code>：字符串s在[i, j]范围内最长的回文子序列的长度为<code>dp[i][j]</code>**。</li>
<li>递推公式：</li>
</ol>
<ul>
<li><p>如果s[i]与s[j]相同，那么<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>;</p>
<p><img src="9d33e4c0a0f944d4a43e5b4a092cdfd83876af765920da77c18c72c52549c316.jpg" alt="img"></p>
</li>
<li><p>如果s[i]与s[j]不相同，说明它俩<strong>不可能同时</strong>出现在 [i,j] 的最长回文子序列中。那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p>
<ul>
<li>加入s[j]的回文子序列长度为<code>dp[i + 1][j]</code>。</li>
<li>加入s[i]的回文子序列长度为<code>dp[i][j - 1]</code>。</li>
<li>那么<code>dp[i][j]</code>一定是取最大的，即：<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>;</li>
</ul>
</li>
</ul>
<p><img src="20210127151420476.jpg" alt="516.最长回文子序列1"></p>
<ol start="3">
<li>初始化</li>
</ol>
<ul>
<li><p>如果只有一个字符 (i == j) ，显然最长回文子序列长度是 1，也就是 <code>dp[i][j] = 1</code>。</p>
</li>
<li><p>因为 <code>i</code> 肯定小于等于 <code>j</code>，所以对于那些 <code>i &gt; j</code> 的位置，根本不存在什么子序列，应该初始化为 0</p>
<p><img src="3e044efa067077b64cf08c393e29d4025f26aa46eba1727c8948f3c0035a03da.jpg" alt="img"></p>
</li>
</ul>
<ol start="4">
<li>遍历顺序</li>
</ol>
<p><code>dp[i][j]</code> 依赖于 <code>dp[i + 1][j - 1]</code> ，<code>dp[i + 1][j]</code> 和 <code>dp[i][j - 1]</code></p>
<p><img src="20230102172155.png" alt="img"></p>
<p><strong>为了保证每次计算 <code>dp[i][j]</code>，左下方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p>
<p><img src="1600677121-aGPcPu-file_1600677121456.jpeg" alt="img"></p>
<p>此处选择反着遍历：从下到上依次从左到右遍历</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int longestPalindromeSubseq(String s) {
        char[] c = s.toCharArray();
        int[][] dp = new int[s.length()][s.length()];
        for (int i = s.length() - 1; i &gt;= 0; i--) {
            dp[i][i] = 1; // 初始化
            for (int j = i + 1; j &lt; s.length(); j++) { // 从i+1开始，因为区间为[i,j]，且dp[i][i]已初始化
                if (c[i] == c[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }
        return dp[0][s.length() - 1];
    }
}</code></pre>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><code>dp[i][j]</code>代表s的以<code>i</code>为起点，<code>j</code>为终点的字符串，其是否为回文字符串。</li>
<li>转移方程：<code>dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]</code></li>
<li>初始化：如果为长度为1，肯定都是回文字符串<code>dp[i][i]=true</code>。对于<code>i&gt;j</code>的部分，<code>dp[i][j]=true</code></li>
<li>遍历顺序：<code>dp[i][j]</code>依赖左下方数据，因此从下到上依次从左到右遍历</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public String longestPalindrome(String s) {
        char[] c = s.toCharArray();
        int len = c.length;
        if (len &lt; 2) return s;

        boolean[][] dp = new boolean[len][len];
        int maxSize = 1;
        int begin = 0;
        
        // 初始化
        for (int i = 0; i &lt; len; i++) {
            dp[i][i] = true;
        }

        for (int i = len - 1; i &gt;= 0; i--) {
            for (int j = i + 1; j &lt; len; j++) {
                if (c[i] != c[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i + 1 == 2) { // （初始化）当字符串长度为2时，如s[2,3],此时dp[i + 1][j - 1]=dp[3,2]，不存在该值。
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxSize) {
                    maxSize = j - i + 1;
                    begin = i;
                }
            }
        }

        return s.substring(begin, begin + maxSize);
    }
}</code></pre>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>dp[i]：表示<strong>以下标为 i 的字符结尾</strong>的最长有效子串的长度<ol>
<li>dp[i] 不是一直累加的，可能i处还没取到导致前面的 <code>(</code> 不能配对</li>
</ol>
</li>
<li>初始条件：<code>dp[0]=0</code></li>
<li>边界情况：需要保证计算过程中：i−2&gt;=0 和 i−dp[i−1]−2&gt;=0</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int[] dp = new int[n];//dp是以i处括号结尾的有效括号长度
        int max_len = 0;
        
    	//i从1开始，一个是单括号无效，另一个是防i - 1索引越界
        for(int i = 1; i &lt; n; i++) {
            if(s.charAt(i) == ')') { //遇见右括号才开始判断
                if(s.charAt(i - 1) == '(') { //上一个是左括号
                    if(i &lt; 2) { //开头处
                        dp[i] = 2;
                    } else { //非开头处
                        dp[i] = dp[i - 2] + 2;
                    }
                }
                else { //上一个也是右括号
                // 此情况下，如果前面有和s[i]组成有效括号对的字符，即形如 ((....))，这样的话，就要求s[i−1]位置必然是有效的括号对，否则s[i]无法和前面对字符组成有效括号对。
                    if(dp[i - 1] &gt; 0) {//需为有效括号，否则无意义继续遍历
						//pre_left为i处右括号对应左括号下标，推导：(i-1)-dp[i-1]+1 - 1
                        int pre_left = i - dp[i - 1] - 1;
                        if(pre_left &gt;= 0 &amp;&amp; s.charAt(pre_left) == '(') {//左括号存在
                            dp[i] = dp[i - 1] + 2;
                            //左括号前还可能存在有效括号，因为左括号构成有效括号，其之前的也有机会加入连续有效括号中
                            if(pre_left &gt; 1) {
                                dp[i] += dp[pre_left - 1];
                            }
                        }
                    }
                }
            }
            max_len = Math.max(max_len, dp[i]);
        }
        return max_len;
    }
}</code></pre>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<p><img src="max1grid.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li><code>dp[i + 1][j + 1]</code> 表示 「以第 <code>i</code> 行、第 <code>j</code> 列为<strong>右下角的正方形的最大边长</strong>」<ul>
<li>第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 if 判断来处理</li>
<li>为了代码简洁，我们 假设补充 了多一行全 ‘0’、多一列全 ‘0’（哨兵）</li>
<li><img src="035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png" alt="image.png"></li>
<li>dp 数组的大小也明确为 <code>new dp[height + 1][width + 1]</code></li>
</ul>
</li>
<li>初始化：第一列 <code>dp[row][0]</code> 、第一行 <code>dp[0][col]</code> 都赋为 <code>0</code></li>
<li>递推公式</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">// 伪代码
if (matrix(i - 1, j - 1) == '1') {
    dp(i, j) = min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1;
}</code></pre>

<blockquote>
<p>若某格子值为 <code>1</code>，则以此为<strong>右下角</strong>的正方形的最大边长为：<strong>上面的正方形、左面的正方形或左上的正方形中，最小的那个</strong>，再加上此格。</p>
</blockquote>
<p>当前格、上、左、左上都不能受 <code>0</code> 的限制，才能成为正方形</p>
<ul>
<li>图 1：受限于左上的 0</li>
<li>图 2：受限于上边的 0</li>
<li>图 3：受限于左边的 0</li>
<li>数字表示：以此为正方形右下角的最大边长</li>
<li>黄色表示：格子 ? 作为右下角的正方形区域</li>
</ul>
<p><img src="8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length &lt; 1 || matrix[0].length &lt; 1) return 0;
        int row = matrix.length;
        int col = matrix[0].length;
        // 相当于已经预处理新增第一行、第一列均为0
        int[][] dp = new int[row + 1][col + 1];
        int maxSize = 0;

        for (int i = 0; i &lt; row; i++) {
            for (int j = 0; j &lt; col; j++) {
                if (matrix[i][j] == '1') {
                    dp[i + 1][j + 1] = Math.min(Math.min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]) + 1;
                    maxSize = Math.max(maxSize, dp[i + 1][j + 1]);
                }
            }
        }
        return maxSize * maxSize;
    }
}</code></pre>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1> 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/11/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/">https://nan-ying.github.io/2023/11/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/%E7%AE%97%E6%B3%95/">
              <span class="chip bg-color">算法</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-11-04T23-54-27',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/11/22/%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="数组问题的类型总结">
                        
                        <span class="card-title">数组问题的类型总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-11-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/10/27/JVM%E7%9F%A5%E8%AF%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="JVM知识">
                        
                        <span class="card-title">JVM知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-10-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JVM/" class="post-category">
                                    JVM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM/">
                        <span class="chip bg-color">JVM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2024</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >789k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
