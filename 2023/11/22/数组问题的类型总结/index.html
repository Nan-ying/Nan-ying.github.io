<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数组问题的类型总结, Nan-ying&#39;s Blog">
    <meta name="description" content="1. 双指针原地修改数组（快慢指针）27. 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数组问题的类型总结 | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数组问题的类型总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/%E7%AE%97%E6%B3%95/">
              <span class="chip bg-color">算法</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
              算法
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-11-22
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 8.8k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          37 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="原地修改数组（快慢指针）"><a href="#原地修改数组（快慢指针）" class="headerlink" title="原地修改数组（快慢指针）"></a>原地修改数组（快慢指针）</h3><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h4><p>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<ul>
<li><p><strong>不要使用额外的数组空间</strong>，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
</li>
<li><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre>

<p><strong>解题：</strong></p>
<p>==<strong>这题是一个隐形的快慢指针：for循环相当于一个快指针，idx慢指针</strong>==</p>
<p>设定变量 idx，指向待插入位置。idx 初始值为 0。<br>遍历数组：</p>
<ul>
<li>如果当前元素 x 与移除元素 val 相同，那么跳过该元素。</li>
<li>如果当前元素 x 与移除元素 val 不同，那么我们将其放到下标 idx 的位置，并让 idx 自增右移。<br>得到的结果则是全部不为val的元素</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int removeElement(int[] nums, int val) {
        int idx = 0;
        for(int x: nums) {
            if (x != val) nums[idx++] = x;
        }
        return idx;
    }
}</code></pre>



<h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h4><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 只出现 k 次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯k元素的个数。</p>
<p>考虑 nums 的唯k元素的数量为 n ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 nums ，使 nums 的前 n 个元素包含唯k元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。</li>
<li>返回 n 。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,1,2]，k = 1
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre>

<p><strong>解题：</strong></p>
<p>k表示保留k位重复数字<br>假设有样例：<code>[3,3,3,3,4,4,4,5,5,5]</code>，k=2</p>
<ul>
<li>设定变量 idx，指向待插入位置。idx 初始值为 0，目标数组为 []</li>
<li>首先我们先让前 2 位直接保留（<strong>idx &lt; k</strong>）。idx 变为 2，目标数组为 [3,3]</li>
<li>继续往后遍历，此时idx &lt; k不满足。nums[2-2] != 3不满足，跳过，继续遍历。</li>
<li>直到4，nums[2-2] != 4满足。idx=3，目标数组为 [3,3,4]</li>
<li>nums[3-2] != 4满足。idx=4，目标数组为 [3,3,4,4]</li>
<li>nums[4-2] != 4不满足。跳过<br>当整个数组被扫描完，最终我们得到了目标数组 [3,3,4,4,5,5] 和 答案 idx 为 6。</li>
</ul>
<p><strong>总结：</strong></p>
<p>==<strong>for循环快指针，idx慢指针</strong>==</p>
<p><code>idx &lt; k</code>：决定在数组<strong>前几位</strong>过滤掉多余的重复数字（因为此时idx=0或者&lt;k，idx-k得出的是负数）</p>
<p><code>nums[idx-k] != x</code>：使得数组中每个数字保持k个的最大重复率==（简化理解：假设k=1时，即为和前一个比较是否相等）==</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        return process(nums, 1);
    }
    public int process(int[] nums, int k) {
        int idx = 0;
        for(int x: nums) {
            if(idx &lt; k || nums[idx-k] != x) nums[idx++] = x;
        }
        return idx;
    }
}</code></pre>

<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]</code></pre>

<p><strong>解题：</strong></p>
<ul>
<li>创建快指针 i 和慢指针 j。<ul>
<li>i 负责往前遍历</li>
<li>j 用来<strong>记录当前有多少 非0 元素</strong>。即遍历的时候每遇到一个 非0 元素就将其往数组左边挪，第一次遍历完后，j 指针的下标就指向了最后一个 非0 元素下标。</li>
</ul>
</li>
<li>第二次遍历，起始位置就从 j 开始到结束，<strong>将剩下的这段区域内的元素全部置为 0</strong>。</li>
</ul>
<p><img src="9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif" alt="283_1.gif"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != 0) {
                nums[j] = nums[i];
                j++;
            }
        }
        for (int i = j; i &lt; nums.length; i++) {
            nums[i] = 0;
        }
    }
}</code></pre>

<h3 id="非原地修改（左右指针）"><a href="#非原地修改（左右指针）" class="headerlink" title="非原地修改（左右指针）"></a>非原地修改（左右指针）</h3><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h4><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]。排序后，数组变为 [0,1,9,16,100]</code></pre>

<p><strong>解题：</strong></p>
<p>使用两个指针i，j分别指向位置 0 和 n−1，每次比较两个指针对应的数。</p>
<p>创建一个新数组，选择较大的那个逆序放入数组并移动指针。</p>
<p>结束条件：i &lt;= j</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int[] sortedSquares(int[] nums) {
        int length = nums.length;
        int[] arrs = new int[length];
        for(int i = 0, j = length - 1, pos = length - 1; i &lt;= j; ) {
            if (nums[i] * nums[i] &gt; nums[j] * nums[j]) {
                arrs[pos] = nums[i] * nums[i];
                i++;
            } else {
                arrs[pos] = nums[j] * nums[j];
                j--;
            }
            pos--;
        }
        return arrs;
    }
}</code></pre>

<p>关键点：<strong>原数组中的元素平方最大值一定产生在原数组的最左边或者最右边。</strong></p>
<h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h4><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</code></pre>

<p><strong>解题：</strong></p>
<p>把这个数组分成三段，<code>左段</code>和<code>右段</code>是标准的升序数组，<code>中段</code>数组虽是无序的，但满足最小值大于<code>左段</code>的最大值，最大值小于<code>右段</code>的最小值。</p>
<p><img src="1600691648-ZCYlql-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200921203355.png" alt="微信截图_20200921203355.png"></p>
<p>目标找中段的左右边界，我们分别定义为<code>begin </code>和 <code>end</code>;</p>
<ul>
<li><code>nums[end]</code> 不可能是【begin，end】中的最大值（否则应该将 <code>nums[end]</code> 并入右端数组）</li>
<li><code>nums[begin]</code> 不可能是【begin，end】中的最小值（否则应该将 <code>nums[begin]</code> 并入左端数组）</li>
</ul>
<p>很明显:</p>
<ul>
<li>==【begin，end】中的最大值 <code>等于</code>【0，end】中的最大值，设其为 <code>max</code>==</li>
<li>==【begin，end】中的最小值 <code>等于</code> 【begin， nums.length-1】中的最小值，设其为 <code>min</code>==</li>
</ul>
<p>那么有：</p>
<ul>
<li><code>nums[end]</code> &lt; <code>max</code> &lt; <code>nums[end+1]</code> &lt; <code>nums[end+2]</code> &lt; … 所以说，<strong>从左往右</strong>遍历，最后一个小于<code>max</code>的为右边界</li>
<li><code>nums[begin]</code> &gt; <code>min</code> &gt; <code>nums[begin-1]</code> &gt; <code>nums[begin-2]</code> &gt; … 所以说，<strong>从右往左</strong>遍历，最后一个大于<code>min</code>的为左边界</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findUnsortedSubarray(int[] nums) {
        //初始化
        int len = nums.length;
        int min = nums[len-1];
        int max = nums[0];
        int begin = 0, end = -1;
        //遍历
        for(int i = 0; i &lt; len; i++){
            if(nums[i] &lt; max){      
                end = i; // 出现后续数字小于max，表明[max, i]向下走了，肯定不会在右段中，因此更新end
            }else{
                max = nums[i]; //从左到右维持最大值，max始终为已遍历过的数中最大值
            }
            
            if(nums[len-i-1] &gt; min){    
                begin = len-i-1; // 出现后续数字大于min，表明[i, min]向下走了，肯定不会在左段中，因此更新begin
            }else{
                min = nums[len-i-1]; //从右到左维持最小值，min始终为已遍历过的数中最小值
            }            
        }
        return end-begin+1;
    }
}</code></pre>

<h3 id="接水问题"><a href="#接水问题" class="headerlink" title="接水问题"></a>接水问题</h3><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="rainwatertrap.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</code></pre>

<p><strong>解题：</strong></p>
<p>每一列雨水的高度，取决于，该列 <strong>左侧最高的柱子和右侧最高的柱子中 最矮的那个柱子的高度</strong>。</p>
<p>例如求列4的雨水高度：</p>
<p><img src="20210223092732301.png" alt="42.接雨水3"></p>
<p>列4 左侧最高的柱子是列3，高度为2（以下用l_max表示）。列4 右侧最高的柱子是列7，高度为3（以下用r_max表示）。列4 柱子的高度为1（以下用height表示）</p>
<p>那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： <code>min(l_max, r_max) - height</code>。</p>
<p>==<strong>双指针法：边走边算</strong>==</p>
<p><strong><code>l_max</code> 是 <code>height[0..left]</code> 中最高柱子的高度，<code>r_max</code> 是 <code>height[right..end]</code> 的最高柱子的高度</strong>。</p>
<ul>
<li>计算 left 处的雨水高度</li>
</ul>
<p>此时的 <code>l_max</code> 是 <code>left</code> 指针左边的最高柱子，但是 <code>r_max</code> 并不一定是 <code>left</code> 指针右边最高的柱子。但<strong>已经知道 <code>l_max &lt; r_max</code> 了，至于这个 <code>r_max</code> 是不是右边最大的，不重要。</strong> </p>
<p><img src="image-20240121180339814.png" alt="image-20240121180339814"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int l_max = 0, r_max = 0;

        int res = 0;
        while (left &lt;= right) {
            l_max = Math.max(l_max, height[left]); // height[0..left] 中最高柱子的高度
            r_max = Math.max(r_max, height[right]); // height[right..end] 中最高柱子的高度

            // res += min(l_max, r_max) - height[i]
            if (l_max &lt; r_max) {
                res += l_max - height[left]; //只有在l_max &lt; r_max，才计算left，left才向前进
                left++;
            } else {
                res += r_max - height[right]; //只有在r_max &lt; l_max，才计算right，right才向后退
                right--;
            }
        }
        return res;
    }
}</code></pre>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂<strong>线</strong>，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><img src="question_11.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre>

<p><strong>解题：</strong></p>
<blockquote>
<p><strong>接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个横坐标是一条竖线，没有宽度</strong>。</p>
<p>即：若知道了 <code>height[left]</code> 和 <code>height[right]</code> 的高度，接雨水问题不能算出 <code>left</code> 和 <code>right</code> 之间能够盛下多少水。因为<code>left</code> 和 <code>right</code> 之间每个柱子有高度，影响能盛的水量，你得计算每个柱子的盛水量。</p>
<p>反过来，就本题而言，知道了 <code>height[left]</code> 和 <code>height[right]</code> 的高度，能算出 <code>left</code> 和 <code>right</code> 之间能够盛下多少水，因为本题中竖线没有宽度，所以 <code>left</code> 和 <code>right</code> 之间能够盛的水就是：<code>min(height[left], height[right]) * (right - left)</code></p>
<p>ex：上图中两个红线间为盛水量，而若是接雨水需要考虑中间那个突出的柱子</p>
</blockquote>
<p>可容纳水的高度由两板中的 短板 决定，因此可得如下 面积公式 ：</p>
<p><code>S(i,j)=min(h[i],h[j])×(j−i)</code></p>
<p>在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1 变短：</p>
<ul>
<li><p>若 短板 一侧向内移动，水槽的短板 min(h[i],h[j]) 可能变大，因此下个水槽的面积可能增大 。</p>
</li>
<li><p>若 长板 一侧向内移动，水槽的短板 min(h[i],h[j]) 不变或变小，因此下个水槽的面积 一定变小 。</p>
</li>
</ul>
<p>因此，初始化双指针分列水槽左右两端，循环<strong>每轮将短板一侧指针向内移动一格</strong>，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int maxArea(int[] height) {
        // 双指针
        int i = 0;
        int j = height.length - 1;

        int res = 0;
        while(i &lt;= j) {
            int area;
            if (height[i] &gt;= height[j]) {
                area = height[j] * (j - i);
                res = Math.max(res, area);
                j--;
            } else {
                area = height[i] * (j - i);
                res = Math.max(res, area);
                i++;
            }
        }

        return res;
    }
}</code></pre>

<h2 id="2-前缀和"><a href="#2-前缀和" class="headerlink" title="2. 前缀和"></a>2. 前缀和</h2><blockquote>
<p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询<strong>某个区间的累加和</strong>。</p>
</blockquote>
<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,1,1], k = 2
输出：2</code></pre>

<p><strong>解题：</strong></p>
<ul>
<li>使用<strong>前缀和</strong>的方法可以解决这个问题，因为我们需要找到和为k的连续子数组的个数。通过计算前缀和，我们可以<strong>将问题转化为求解两个前缀和之差等于k</strong>的情况。<ul>
<li>假设数组的前缀和数组为prefixSum，其中prefixSum[i]表示从数组起始位置到第i个位置的元素之和。那么对于任意的两个下标i和j（i &lt; j），如果<code>prefixSum[j] - prefixSum[i] = k</code>，即从<code>第i个位置到第j个位置的元素之和等于k</code>，那么说明从第i+1个位置到第j个位置的连续子数组的和为k。</li>
</ul>
</li>
</ul>
<ol>
<li>通过遍历数组，计算每个位置的前缀和，并使用一个<strong>哈希表</strong>来存储每个前缀和出现的次数。</li>
<li>在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。</li>
</ol>
<p>这样，通过遍历一次数组，我们可以统计出和为k的连续子数组的个数，并且时间复杂度为O(n)，其中n为数组的长度。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int subarraySum(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 1); // 初始化前缀和为0的次数为1
        int sum = 0;
        int res = 0;
        
        for (int i = 0; i &lt; nums.length; i++) {
            sum += nums[i];
            if (map.containsKey(sum - k)) {
                res += map.get(sum - k); // 将前缀和为sum - k的次数加入res
            }

            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }

        return res;
    }
}</code></pre>

<h2 id="3-二分法"><a href="#3-二分法" class="headerlink" title="3. 二分法"></a>3. 二分法</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>右边起点：<code>right = nums.length - 1</code>。表明数据范围为闭区间[left, right]</li>
<li>循环条件：<code>left &lt;= right</code>。因为取值范围为闭区间，若循环条件是<code>left &lt; right</code>，则当[2, 2]时，结束循环，此时会漏掉2。正确情况下，[3, 2]时结束循环，此时正确。</li>
<li>前进条件：<code>mid+1 mid-1</code>。因为是闭区间，已经判断过nums[mid]的值了。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while(left &lt;= right) {
            int mid = (left + right) &gt;&gt;&gt; 1;
            if (target &lt; nums[mid]) {
                right = mid - 1;
            } else if (target &gt; nums[mid]) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}</code></pre>

<h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><img src="mat.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true</code></pre>

<p><strong>解题：</strong></p>
<p>将二维数组映射为一维</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        // 把二维数组映射到一维
        int left = 0, right = m * n - 1;
        // 标准的二分搜索框架
        while(left &lt;= right) {
            int mid = left + (right - left) / 2;
            if(get(matrix, mid) == target)
                return true;
            else if (get(matrix, mid) &lt; target)
                left = mid + 1;
            else if (get(matrix, mid) &gt; target)
                right = mid - 1;
        }
        return false;
    }

    // 通过一维坐标访问二维数组中的元素
    int get(int[][] matrix, int index) {
        int m = matrix.length, n = matrix[0].length;
        // 计算二维中的横纵坐标
        int i = index / n, j = index % n;
        return matrix[i][j];
    }
}</code></pre>

<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h3><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><img src="searchgrid2.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true</code></pre>

<p><strong>解题：</strong></p>
<p>看到有序想到二分法。</p>
<p>本题有更巧妙的二分法：从右上角出发开始遍历。会发现每次都是<strong>向左数字会变小，向下数字会变大</strong></p>
<ul>
<li>如果 <code>target</code> 的值大于当前值，那么就向下走。</li>
<li>如果 <code>target</code> 的值小于当前值，那么就向左走。</li>
<li>如果相等的话，直接返回 <code>true</code> 。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]

如果 target  = 9，如果我们从 15 开始遍历, cur = 15
    
target &lt; 15, 去掉当前列, cur = 11
[1,   4,  7, 11],
[2,   5,  8, 12],
[3,   6,  9, 16],
[10, 13, 14, 17],
[18, 21, 23, 26]    
    
target &lt; 11, 去掉当前列, cur = 7  
[1,   4,  7],
[2,   5,  8],
[3,   6,  9],
[10, 13, 14],
[18, 21, 23]     

target &gt; 7, 去掉当前行, cur = 8   
[2,   5,  8],
[3,   6,  9],
[10, 13, 14],
[18, 21, 23]       

target &gt; 8, 去掉当前行, cur = 9, 遍历结束    
[3,   6,  9],
[10, 13, 14],
[18, 21, 23]   </code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) return false;

        int i = 0;
        int j = matrix[0].length - 1;
        while (i &lt; matrix.length &amp;&amp; j &gt;= 0) {
            if (target &gt; matrix[i][j]) {
                i++;
            } else if (target &lt; matrix[i][j]) {
                j--;
            } else {
                return true;
            }
        }
        return false;
    }
}</code></pre>

<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<ul>
<li>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</li>
</ul>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4</code></pre>

<p><strong>解题：</strong></p>
<p>将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也可能是部分有序。 </p>
<ul>
<li>在顺序区间内<strong>才可以通过区间两端的数值判断target是否在其中</strong>，如果在顺序区间，下次循环就直接取顺序区间</li>
<li>如果不在，那么下次循环就取乱序区间</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int search(int[] nums, int target) {
		int left = 0, right = nums.length - 1;
        // 特殊情况
        if (nums.length == 0) return -1;
        if (nums.length == 1) {
            if (nums[0] == target) {
                return 0;
            } else {
                return -1;
            }
        }
        
        while (left &lt;= right) {
            int mid = (left + right) &gt;&gt; 1;
            if (nums[mid] == target) {
                return mid;
            }
            
            if (nums[0] &lt;= nums[mid]) { // mid在左边那部分
                // [0,mid]区间有序，可以判断是否在区间内，因此判断一下（能判断就判断，缩小范围）
                if (nums[mid] &gt; target &amp;&amp; nums[0] &lt;= target) {
                    right = mid - 1;
                } else {
                    // 如果不在，就是在乱序区间
                    left = mid + 1;
                }
            } else { // mid在右边那部分
                // [mid,nums.length - 1]区间有序
                if (nums[mid] &lt; target &amp;&amp; nums[nums.length - 1] &gt;= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
}</code></pre>

<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h3><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</code></pre>

<p><strong>解题：</strong></p>
<ul>
<li>若前半段有序，则有序中的最小值是<code>nums[left]</code>; 然后后半段无序，还可能存在着最小值，所以移动左边指针，继续寻找</li>
<li>若后半段有序，则最小值可能是当前值<code>nums[mid]</code>，或者还有可能在其前半段无序的区间中，所以取一下后半段有序区间的最小值，然后就去前半段无序区间里面找</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        int res = Integer.MAX_VALUE;
        while (left &lt;= right) {
            int mid = (left + right) &gt;&gt; 1;
            if (nums[0] &lt;= nums[mid]) { // [0,mid]有序. 必须是&lt;=，因为nums[0]==nums[mid]时需要在此if区间处理
                res = Math.min(res, nums[left]);
                left = mid + 1;
            } else { // [mid,nums.length - 1]区间有序
                res = Math.min(res, nums[mid]);
                right = mid - 1;
            }
        }
        return res;
    }
}</code></pre>

<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2</code></pre>

<p><strong>解题：</strong></p>
<p>假设我们要找第 7 小的数字。</p>
<p><img src="735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png" alt="image.png"></p>
<p>比较两个数组的第 k/2 个数字，如果 k 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 1349 和 45678910 两个数组作为新的数组进行比较。</p>
<p><img src="09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png" alt="image.png"></p>
<p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。</p>
<p><img src="f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png" alt="image.png"></p>
<p>我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p>
<p><img src="3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png" alt="image.png"></p>
<p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p>
<p>所以第 7 小的数字是 4。</p>
<p><strong>特殊情况：</strong></p>
<p>可能会遇到数组长度小于 <code>k/2</code>的时候。</p>
<p><img src="ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png" alt="image.png"></p>
<p>此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p>
<p><img src="7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png" alt="image.png"></p>
<p>由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int m = nums2.length;
    //将偶数和奇数的情况合并
    //如有14个，则为7和8；15个则为8和8
    int left = (n + m + 1) / 2;
    int right = (n + m + 2) / 2;
    //偶数：（求第7小的数和第8小的数）* 0.5
    //奇数：（求第8小的数和第8小的数）* 0.5
    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5; // 这里要乘0.5不能/2，因为/2会取整
}

private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
    int len1 = end1 - start1 + 1;
    int len2 = end2 - start2 + 1;
    // 1.保证 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
    if (len1 &gt; len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
    
    // 2.两个边界条件
    //如果一个数组中没有了元素，那么即从剩余数组nums2的起始start2开始加k再-1
    if (len1 == 0) return nums2[start2 + k - 1];//k代表个数，而不是索引，从nums2后再找k个数，是start2 + k-1索引
    //如果k=1，表明最接近中位数了，即两个数组中start索引处，谁的值小，中位数就是谁(start索引之前表示经过迭代已经被排出的不合格的元素，即剩余数组的范围是nums[start]---&gt;nums[end])。
    if (k == 1) return Math.min(nums1[start1], nums2[start2]);

    // 3.实际逻辑（递归函数体）
    // 获取两数组各自的中位下标（对长度小于k/2的数组进行处理）
    int i = start1 + Math.min(len1, k / 2) - 1; //若数组长度len1小于k/2，为防止下标越界，会将当前数组长度和k/2作比较，取其中的小的
    int j = start2 + Math.min(len2, k / 2) - 1;
    //如果nums1[i] &gt; nums2[j]，表示nums2数组中j索引以及其之前的元素，逻辑上全部淘汰，即下次从j+1开始。
    //而k则变为k - (j - start2 + 1)，即减去已经确定比第k个数小的数字
    if (nums1[i] &gt; nums2[j]) {
        return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
    }
    else {
        return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
    }
}</code></pre>



<h2 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4. 技巧"></a>4. 技巧</h2><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]</code></pre>

<p><strong>解题：</strong></p>
<p><img src="image-20231124205141504.png" alt="image-20231124205141504"></p>
<p><img src="image-20231124205152308.png" alt="image-20231124205152308"></p>
<p><img src="image-20231124205209212.png" alt="image-20231124205209212"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    private void reverse(int[] nums, int start, int end) {
        while (start &lt; end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}</code></pre>

<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h3><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 <strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums = [1,2,3,4]
输出: [24,12,8,6]</code></pre>

<p><strong>解题：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">原数组：       [1       2       3       4]
左部分的乘积：   1       1      1*2    1*2*3
右部分的乘积： 2*3*4    3*4      4       1
结果：       1*2*3*4  1*3*4   1*2*4  1*2*3*1</code></pre>

<p>当前位置的结果就是它<strong>左部分的乘积再乘以它右部分的乘积</strong>。因此需要进行两次遍历，第一次遍历用于求左部分的乘积，第二次遍历在求右部分的乘积的同时，再将最后的计算结果一起求出来。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] ans = new int[nums.length];
        int[] left = new int[nums.length];
        int[] right = new int[nums.length];

        // left[i] 为索引 i 左侧所有元素的乘积
        // left[0]左侧没有元素，所以 left[0] = 1
        left[0] = 1;
        for (int i = 1; i &lt; nums.length; i++) {
            left[i] = nums[i - 1] * left[i - 1];
        }
        
        // right[i] 为索引 i 右侧所有元素的乘积
        // right[length-1]右侧没有元素，所以 right[length-1] = 1
        right[nums.length - 1] = 1;
        for (int i = nums.length - 2; i &gt;= 0; i--) {
            right[i] = nums[i + 1] * right[i + 1];
        }

        // 结果是左边部分与右边部分相乘
        for (int k = 0; k &lt; nums.length; k++) {
            ans[k] = right[k] * left[k];
        }
        return ans;
    }
}</code></pre>

<h3 id="原地标记"><a href="#原地标记" class="headerlink" title="原地标记"></a>原地标记</h3><h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,4,-1,1]
输出：2</code></pre>

<p><strong>解题：</strong></p>
<p>原地哈希：若使用哈希表，空间复杂度不满足常数级。<strong>考虑把原始的数组当做哈希表来使用</strong></p>
<p>要找的数一定在 <code>[1, N + 1]</code> （这里 <code>N</code> 是数组的长度）这个区间里。最后 <code>N + 1</code> 这个元素我们不用找。因为在极端情况前面的 <code>N</code> 个元素都出现在 nums 中的情况下，我们才返回 <code>N + 1</code></p>
<p><img src="image-20240114165556341.png" alt="image-20240114165556341"></p>
<p>==放数的规则：数<code>nums[i]</code>应该在数组下标为<code>nums[i] - 1</code>的位置==</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int firstMissingPositive(int[] nums) {
        // 遍历一遍数组，将所有数放在它应该在的位置
        for (int i = 0; i &lt; nums.length; i++) {
            // 如果数在[1, N] 范围内，并且它不在应该在的位置nums[i] - 1
            // 用while是因为调换位置后，i位置的数则是新的数，不可确定，需要继续判断
            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - 1]) {
                swap(nums, i, nums[i] - 1);
            }
        }

        // 再遍历一遍放好数的数组，如果某个位置数不对，则返回应该放的数。如果全部不满足，则是极端情况，此时返回N+1
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return nums.length + 1;
    }

    // 数组交换方法
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}</code></pre>

<h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h4><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]</code></pre>

<p><strong>解题：</strong></p>
<ul>
<li>遍历 nums，<strong>每遇到一个数 x，就让 nums[x−1] 增加 n</strong>。</li>
<li>由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</li>
</ul>
<p>注意：遍历到某个位置时，其中的数可能已经被增加过，因此需要<strong>对 n 取模</strong>来还原出它本来的值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {
        int len = nums.length;
        for (int i = 0; i &lt; len; i++) {
            int index = (nums[i] - 1) % len; // 用数组nums的索引来对应标记数组中的数
            nums[index] += len;
        }
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; len; i++) {
            if (nums[i] &lt;= len) {
                res.add(i + 1);
            }
        }

        return res;
    }
}</code></pre>

<h4 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h4><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p>
<p><img src="mat1.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]</code></pre>

<p><strong>解题：</strong></p>
<p>关键思想：<strong>用<code>matrix</code>第一行和第一列记录该行该列是否有<code>0</code>,作为标志位</strong></p>
<p>但是对于第一行和第一列要额外设置一个标志位，为了防止自己这一行(一列)也有<code>0</code>的情况.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        boolean row0_flag = false;
        boolean col0_flag = false;
        // 判断第一行是否有零
        for (int j = 0; j &lt; col; j++) {
            if (matrix[0][j] == 0) {
                row0_flag = true;
                break;
            }
        }
        // 判断第一列是否有零
        for (int i = 0; i &lt; row; i++) {
            if (matrix[i][0] == 0) {
                col0_flag = true;
                break;
            }
        }
        
        // 遍历数组中有0的位置，并把第一行第一列作为标志位
        for (int i = 1; i &lt; row; i++) {
            for (int j = 1; j &lt; col; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        
        // 置0
        for (int i = 1; i &lt; row; i++) {
            for (int j = 1; j &lt; col; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row0_flag) {
            for (int j = 0; j &lt; col; j++) {
                matrix[0][j] = 0;
            }
        }
        if (col0_flag) {
            for (int i = 0; i &lt; row; i++) {
                matrix[i][0] = 0;
            }
        } 
    }
}</code></pre>

<h3 id="二维数组的花式遍历"><a href="#二维数组的花式遍历" class="headerlink" title="二维数组的花式遍历"></a>二维数组的花式遍历</h3><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><img src="mat1-17011499316751.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]</code></pre>

<p><strong>解题：</strong></p>
<p><strong>先将 <code>n x n</code> 矩阵 <code>matrix</code> 按照左上到右下的对角线进行镜像对称</strong>：</p>
<p><img src="2-170522807027422.jpeg" alt="img"></p>
<p><strong>然后再对矩阵的每一行进行反转</strong>：</p>
<p><img src="3-170522807027524.jpeg" alt="img"></p>
<p><strong>发现结果就是 <code>matrix</code> 顺时针旋转 90 度的结果</strong>：</p>
<p><img src="4.jpeg" alt="img"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">// 将二维矩阵原地顺时针旋转 90 度
public void rotate(int[][] matrix) {
    int n = matrix.length;
    // 先沿对角线镜像对称二维矩阵
    // 只需要遍历matrix右上角（右下角直接由交换得到）
    for (int i = 0; i &lt; n; i++) {
        for (int j = i; j &lt; n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    // 然后反转二维矩阵的每一行
    for (int[] row : matrix) {
        reverse(row);
    }
}

// 反转一维数组
void reverse(int[] arr) {
    int i = 0, j = arr.length - 1;
    while (j &gt; i) {
        // swap(arr[i], arr[j]);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
}</code></pre>

<h4 id="59-螺旋矩阵-II（模拟）"><a href="#59-螺旋矩阵-II（模拟）" class="headerlink" title="59. 螺旋矩阵 II（模拟）"></a>59. 螺旋矩阵 II（模拟）</h4><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p> <img src="image-20230717221559290.png" alt="image-20230717221559290"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre>

<p><strong>解题：</strong></p>
<ol>
<li>需要一个二维矩阵 mat ，并定义左右上下边界 <code>l,r,t,b</code>。</li>
<li>当 <code>num &lt;= n^2</code> 时，始终按照 <code>从左到右</code> <code>从上到下</code> <code>从右到左</code> <code>从下到上</code> 填入顺序循环<ol>
<li>每一次填入后，num++得到下一次需填入的数字</li>
<li>每一次填完后，需要<strong>更新边界</strong></li>
</ol>
</li>
<li>循环结束条件：<code>num &lt;= n^2</code></li>
</ol>
<p><img src="image-20230717222221989.png" alt="image-20230717222221989"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public int[][] generateMatrix(int n) {
        int t = 0, b = n - 1, l = 0, r = n - 1;
        int[][] mat = new int[n][n];
        int num = 1;
        int max = n * n;
        while(num &lt;= max) {
            for(int i = l; i &lt;= r; i++) mat[t][i] = num++;// 从左至右
            t++;
            for(int i = t; i &lt;= b; i++) mat[i][r] = num++;// 从上至下
            r--;
            for(int i = r; i &gt;= l; i--) mat[b][i] = num++;// 从右至左
            b--;
            for(int i = b; i &gt;= t; i--) mat[i][l] = num++;// 从下至上
            l++;
        }
        return mat;
    }
}</code></pre>

<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><img src="spiral.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre>

<p><strong>解题：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
        int top = 0;
        int bottom = matrix.length - 1;
        int left = 0;
        int right = matrix[0].length - 1;
        int max = matrix.length * matrix[0].length;
        int num = 1;

        while (num &lt;= max) { // 一共有max个数，区间为[1,max]
            for (int i = left; i &lt;= right &amp;&amp; num &lt;= max; i++) {
                res.add(matrix[top][i]);
                num++;
            }
            top++;
            for (int i = top; i &lt;= bottom &amp;&amp; num &lt;= max; i++) {
                res.add(matrix[i][right]);
                num++;
            }
            right--;
            for (int i = right; i &gt;= left &amp;&amp; num &lt;= max; i--) {
                res.add(matrix[bottom][i]);
                num++;
            }
            bottom--;
            for (int i = bottom; i &gt;= top &amp;&amp; num &lt;= max; i--) {
                res.add(matrix[i][left]);
                num++;
            }
            left++;
        }

        return res;
    }
}</code></pre>

 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/11/22/%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/">https://nan-ying.github.io/2023/11/22/%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/%E7%AE%97%E6%B3%95/">
              <span class="chip bg-color">算法</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-11-22T23-57-35',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6xxl-job/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="分布式调度xxl-job">
                        
                        <span class="card-title">分布式调度xxl-job</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                    微服务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/xxl-job/">
                        <span class="chip bg-color">xxl-job</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/11/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="动态规划问题的套路总结">
                        
                        <span class="card-title">动态规划问题的套路总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2024</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >789k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
