<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java知识整理和总结18-JDK8-17新特性, Nan-ying&#39;s Blog">
    <meta name="description" content="第18章_JDK8-17新特性（上）本章专题与脉络

1. Java版本迭代概述1.1 发布特点（小步快跑，快速迭代）


发行版本
发行时间
备注



Java 1.0
1996.01.23
Sun公司发布了Java的第一个开发工具包
">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java知识整理和总结18-JDK8-17新特性 | Nan-ying&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


  <body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Nan-ying&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Nan-ying&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>
 



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java知识整理和总结18-JDK8-17新特性</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
  <div class="card">
    <div class="card-content article-info">
      <div class="row tag-cate">
        <div class="col s7">
          
          <div class="article-tag">
            
            <a href="/tags/Java/">
              <span class="chip bg-color">Java</span>
            </a>
            
          </div>
          
        </div>
        <div class="col s5 right-align">
          
          <div class="post-cate">
            <i class="fas fa-bookmark fa-fw icon-category"></i>
            
            <a href="/categories/Java/" class="post-category">
              Java
            </a>
            
          </div>
          
        </div>
      </div>

      <div class="post-info">
        
        <div class="post-date info-break-policy">
          <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-05-01
        </div>
          
        <div class="info-break-policy">
          <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 23.1k
        </div>
         
        <div class="info-break-policy">
          <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
          102 分
        </div>
         
        <span id="busuanzi_container_page_pv" class="info-break-policy"></span>
        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
        <span id="busuanzi_value_page_pv"></span>
        
      </div>
    </div>
    <hr class="clearfix" />

    
    <!-- 是否加载使用自带的 prismjs. -->
    <link
      rel="stylesheet"
      href="/libs/prism/prism.min.css"
    />
     

    <div class="card-content article-card-content">
      <div id="articleContent">
        <h1 id="第18章-JDK8-17新特性（上）"><a href="#第18章-JDK8-17新特性（上）" class="headerlink" title="第18章_JDK8-17新特性（上）"></a>第18章_JDK8-17新特性（上）</h1><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9AJava%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8-%E7%AC%AC18%E7%AB%A0.png" alt="第3阶段：Java高级应用-第18章"></p>
<hr>
<h2 id="1-Java版本迭代概述"><a href="#1-Java版本迭代概述" class="headerlink" title="1. Java版本迭代概述"></a>1. Java版本迭代概述</h2><h3 id="1-1-发布特点（小步快跑，快速迭代）"><a href="#1-1-发布特点（小步快跑，快速迭代）" class="headerlink" title="1.1 发布特点（小步快跑，快速迭代）"></a>1.1 发布特点（小步快跑，快速迭代）</h3><table>
<thead>
<tr>
<th align="center">发行版本</th>
<th align="center">发行时间</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java 1.0</td>
<td align="center">1996.01.23</td>
<td align="center">Sun公司发布了Java的第一个开发工具包</td>
</tr>
<tr>
<td align="center">Java 5.0</td>
<td align="center">2004.09.30</td>
<td align="center">①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</td>
</tr>
<tr>
<td align="center">Java 8.0</td>
<td align="center">2014.03.18</td>
<td align="center">此版本是继Java 5.0以来变化最大的版本。是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 9.0</td>
<td align="center">2017.09.22</td>
<td align="center"><strong>此版本开始，每半年更新一次</strong></td>
</tr>
<tr>
<td align="center">Java 10.0</td>
<td align="center">2018.03.21</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java 11.0</td>
<td align="center">2018.09.25</td>
<td align="center">JDK安装包取消独立JRE安装包，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 12.0</td>
<td align="center">2019.03.19</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java17.0</td>
<td align="center">2021.09</td>
<td align="center">发布Java 17.0，版本号也称为21.9，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java19.0</td>
<td align="center">2022.09</td>
<td align="center">发布Java19.0，版本号也称为22.9。</td>
</tr>
</tbody></table>
<p>从Java 9 这个版本开始，Java 的计划发布周期是 <code>6个月</code>。</p>
<p>这意味着Java的更新从传统的以<code>特性驱动</code>的发布周期，转变为以<code>时间驱动</code>的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。</p>
<p>针对企业客户的需求，Oracle 将以<code>三年</code>为周期发布长期支持版本（long term support）。</p>
<p>Oracle 的官方观点认为：<strong>与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。</strong></p>
<p>新模式下的 Java 版本发布都会包含许多变更，包括<code>语言变更</code>和 <code>JVM 变更</code>，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 <code>API被删除</code>（这在 Java 8 之前没有发生过）。</p>
<p>目前看这种发布策略是非常成功的，<strong>解开了 Java/JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。</strong>在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。</p>
<h3 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h3><h4 id="名词解释：Oracle-JDK和Open-JDK"><a href="#名词解释：Oracle-JDK和Open-JDK" class="headerlink" title="名词解释：Oracle JDK和Open JDK"></a>名词解释：Oracle JDK和Open JDK</h4><p>这两个JDK最大不同就是许可证不一样。<strong>但是对于个人用户来讲，没区别。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Oracle JDK</th>
<th>Open JDK</th>
</tr>
</thead>
<tbody><tr>
<td>来源</td>
<td>Oracle团队维护</td>
<td>Oracle和Open Java社区</td>
</tr>
<tr>
<td>授权协议</td>
<td>Java 17及更高版本 Oracle Java SE 许可证<br>Java16及更低版本甲骨文免费条款和条件 （NFTC） 许可协议</td>
<td>GPL v2许可证</td>
</tr>
<tr>
<td>关系</td>
<td>由Open JDK构建，增加了少许内容</td>
<td></td>
</tr>
<tr>
<td>是否收费</td>
<td>2021年9月起Java17及更高版本所有用户免费。 16及更低版本，个人用户、开发用户免费。</td>
<td>2017年9月起，所有版本免费</td>
</tr>
<tr>
<td>对语法的支持</td>
<td>一致</td>
<td>一致</td>
</tr>
</tbody></table>
<h4 id="名词解释：JEP"><a href="#名词解释：JEP" class="headerlink" title="名词解释：JEP"></a>名词解释：JEP</h4><p>JEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP可以提出非正式的规范(specification)，被正式认可的JEP正式写进JDK的发展路线图并分配版本号。</p>
<h4 id="名词解释：LTS"><a href="#名词解释：LTS" class="headerlink" title="名词解释：LTS"></a>名词解释：LTS</h4><p>LTS（Long-term Support）即长期支持。Oracle官网提供了对Oracle JDK个别版本的长期支持，即使发发行了新版本，比如目前最新的JDK19，在结束日期前，LTS版本都会被长期支持。（出了bug，会被修复，非LTS则不会再有补丁发布）所以，一定要选一个LTS版本，不然出了漏洞没人修复了。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>开始日期</th>
<th>结束日期</th>
<th>延期结束日期</th>
</tr>
</thead>
<tbody><tr>
<td>7（LTS）</td>
<td>2011年7月</td>
<td>2019年7月</td>
<td>2022年7月</td>
</tr>
<tr>
<td>8（LTS）</td>
<td>2014年3月</td>
<td>2022年3月</td>
<td>2030年12月</td>
</tr>
<tr>
<td>11（LTS）</td>
<td>2018年9月</td>
<td>2023年9月</td>
<td>2026年9月</td>
</tr>
<tr>
<td>17（LTS）</td>
<td>2021年9月</td>
<td>2026年9月</td>
<td>2029年9月</td>
</tr>
<tr>
<td>21（LTS）</td>
<td>2023年9月</td>
<td>2028年9月</td>
<td>2031年9月</td>
</tr>
</tbody></table>
<p>如果要选择Oracle JDK，目前可选的LTS版本为8、11、17三个。</p>
<h3 id="1-3-各版本支持时间路线图"><a href="#1-3-各版本支持时间路线图" class="headerlink" title="1.3 各版本支持时间路线图"></a>1.3 各版本支持时间路线图</h3><p><img src="4428b288361296048.png" alt="4428b288361296048"></p>
<h3 id="1-4-各版本介绍"><a href="#1-4-各版本介绍" class="headerlink" title="1.4 各版本介绍"></a>1.4 各版本介绍</h3><p><img src="jdkxintexing.jpg" alt="jdkxintexing"></p>
<h4 id="jdk-9"><a href="#jdk-9" class="headerlink" title="jdk 9"></a>jdk 9</h4><p>Java 9 提供了<code>超过150项</code>新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。</p>
<p>特性太多，查看链接：</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk9/">https://openjdk.java.net/projects/jdk9/</a></p>
<h4 id="jdk-10"><a href="#jdk-10" class="headerlink" title="jdk 10"></a>jdk 10</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/10/">https://openjdk.java.net/projects/jdk/10/</a></p>
<blockquote>
<p>286: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/286">Local-Variable Type Inference</a> 局部变量类型推断<br>296: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/296">Consolidate the JDK Forest into a Single Repository</a> JDK库的合并<br>304: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/304">Garbage-Collector Interface</a> 统一的垃圾回收接口<br>307: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/307">Parallel Full GC for G1</a> 为G1提供并行的Full GC<br>310: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/310">Application Class-Data Sharing</a> 应用程序类数据（AppCDS）共享<br>312: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/312">Thread-Local Handshakes</a> ThreadLocal握手交互<br>313: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/313">Remove the Native-Header Generation Tool (javah)</a> 移除JDK中附带的javah工具<br>314: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/314">Additional Unicode Language-Tag Extensions</a> 使用附加的Unicode语言标记扩展<br>316: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/316">Heap Allocation on Alternative Memory Devices</a> 能将堆内存占用分配给用户指定的备用内存设备<br>317: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/317">Experimental Java-Based JIT Compiler</a> 使用Graal基于Java的编译器</p>
<p>319: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/319">Root Certificates</a> 根证书<br>322: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/322">Time-Based Release Versioning</a> 基于时间定于的发布版本</p>
</blockquote>
<h4 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/11/">https://openjdk.java.net/projects/jdk/11/</a></p>
<blockquote>
<p>181: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/181">Nest-Based Access Control</a>  基于嵌套的访问控制<br>309: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/309">Dynamic Class-File Constants</a> 动态类文件常量<br>315: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/315">Improve Aarch64 Intrinsics</a> 改进 Aarch64 Intrinsics<br>318: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/318">Epsilon: A No-Op Garbage Collector</a> Epsilon — 一个No-Op（无操作）的垃圾收集器<br>320: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/320">Remove the Java EE and CORBA Modules</a> 删除 Java EE 和 CORBA 模块<br>321: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/321">HTTP Client (Standard)</a>  HTTPClient API<br>323: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>  用于 Lambda 参数的局部变量语法<br>324: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/324">Key Agreement with Curve25519 and Curve448</a> Curve25519 和 Curve448 算法的密钥协议<br>327: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/327">Unicode 10</a><br>328: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/328">Flight Recorder</a> 飞行记录仪<br>329: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/329">ChaCha20 and Poly1305 Cryptographic Algorithms</a> ChaCha20 和 Poly1305 加密算法<br>330: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/330">Launch Single-File Source-Code Programs</a> 启动单一文件的源代码程序<br>331: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/331">Low-Overhead Heap Profiling</a> 低开销的 Heap Profiling<br>332: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a> 支持 TLS 1.3<br>333: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector<br>   (Experimental)</a> 可伸缩低延迟垃圾收集器<br>335: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/335">Deprecate the Nashorn JavaScript Engine</a> 弃用 Nashorn JavaScript 引擎<br>336: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/336">Deprecate the Pack200 Tools and API</a>  弃用 Pack200 工具和 API</p>
</blockquote>
<h4 id="jdk-12"><a href="#jdk-12" class="headerlink" title="jdk 12"></a>jdk 12</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/12/">https://openjdk.java.net/projects/jdk/12/</a></p>
<blockquote>
<p>189：<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a> 低暂停时间的GC<br>230: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/230">Microbenchmark Suite</a> 微基准测试套件<br>325: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/325">Switch Expressions (Preview)</a> switch表达式<br>334: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/334">JVM Constants API </a> JVM常量API<br>340: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/340">One AArch64 Port, Not Two</a> 只保留一个AArch64实现<br>341: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/341">Default CDS Archives</a> 默认类数据共享归档文件<br>344: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/344">Abortable Mixed Collections for G1</a> 可中止的G1 Mixed GC<br>346: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/346">Promptly Return Unused Committed Memory from G1</a> G1及时返回未使用的已分配内存</p>
</blockquote>
<h4 id="jdk-13"><a href="#jdk-13" class="headerlink" title="jdk 13"></a>jdk 13</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/13/">https://openjdk.java.net/projects/jdk/13/</a></p>
<blockquote>
<p>350: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/350">Dynamic CDS Archives</a> 动态CDS档案<br>351: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/351">ZGC: Uncommit Unused Memory</a> ZGC:取消使用未使用的内存<br>353: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/353">Reimplement the Legacy Socket API</a> 重新实现旧版套接字API<br>354: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/354">Switch Expressions (Preview)</a> switch表达式（预览）<br>355: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/355">Text Blocks (Preview)</a> 文本块（预览）</p>
</blockquote>
<h4 id="jdk-14"><a href="#jdk-14" class="headerlink" title="jdk 14"></a>jdk 14</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/14/">https://openjdk.java.net/projects/jdk/14/</a></p>
<blockquote>
<p>305: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/305">Pattern Matching for instanceof (Preview)</a> instanceof的模式匹配<br>343: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/343">Packaging Tool (Incubator)</a> 打包工具<br>345: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/345">NUMA-Aware Memory Allocation for G1</a> G1的NUMA-Aware内存分配<br>349: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/349">JFR Event Streaming</a> JFR事件流<br>352: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/352">Non-Volatile Mapped Byte Buffers</a> 非易失性映射字节缓冲区<br>358: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/358">Helpful NullPointerExceptions</a> 实用的NullPointerExceptions<br>359: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/359">Records (Preview)</a><br>361: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/361">Switch Expressions (Standard)</a> Switch表达式<br>362: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/362">Deprecate the Solaris and SPARC Ports</a> 弃用Solaris和SPARC端口<br>363: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a> 删除并发标记扫描（CMS）垃圾回收器<br>364: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/364">ZGC on macOS</a><br>365: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/365">ZGC on Windows</a><br>366: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/366">Deprecate the ParallelScavenge + SerialOld GC Combination</a> 弃用ParallelScavenge + SerialOld GC组合<br>367: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/367">Remove the Pack200 Tools and API</a> 删除Pack200工具和API<br>368: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/368">Text Blocks (Second Preview)</a> 文本块<br>370: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/370">Foreign-Memory Access API (Incubator)</a> 外部存储器访问API</p>
</blockquote>
<h4 id="jdk-15"><a href="#jdk-15" class="headerlink" title="jdk 15"></a>jdk 15</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p>
<blockquote>
<p>339: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/339">Edwards-Curve Digital Signature Algorithm (EdDSA)</a> EdDSA 数字签名算法<br>360: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/360">Sealed Classes (Preview)</a> 密封类（预览）<br>371: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/371">Hidden Classes</a> 隐藏类<br>372: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/372">Remove the Nashorn JavaScript Engine</a> 移除 Nashorn JavaScript 引擎<br>373: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/373">Reimplement the Legacy DatagramSocket API</a> 重新实现 Legacy DatagramSocket API<br>374: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/374">Disable and Deprecate Biased Locking</a> 禁用偏向锁定<br>375: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/375">Pattern Matching for instanceof (Second Preview)</a> instanceof 模式匹配（第二次预览）<br>377: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/377">ZGC: A Scalable Low-Latency Garbage Collector</a> ZGC：一个可扩展的低延迟垃圾收集器<br>378: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/378">Text Blocks</a> 文本块<br>379: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/379">Shenandoah: A Low-Pause-Time Garbage Collector</a> Shenandoah:低暂停时间垃圾收集器<br>381: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/381">Remove the Solaris and SPARC Ports</a> 移除 Solaris 和 SPARC 端口<br>383: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/383">Foreign-Memory Access API (Second Incubator)</a> 外部存储器访问 API（第二次孵化版）<br>384: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/384">Records (Second Preview)</a> Records（第二次预览）<br>385: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/385">Deprecate RMI Activation for Removal</a> 废弃 RMI 激活机制</p>
</blockquote>
<h4 id="jdk-16"><a href="#jdk-16" class="headerlink" title="jdk 16"></a>jdk 16</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/16/">https://openjdk.java.net/projects/jdk/16/</a></p>
<blockquote>
<p>338: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/338">Vector API (Incubator)</a> Vector API（孵化器）<br>347: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/347">Enable C++14 Language Features</a> JDK C++的源码中允许使用C++14的语言特性<br>357: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/357">Migrate from Mercurial to Git</a> OpenJDK源码的版本控制从Mercurial (hg) 迁移到git<br>369: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/369">Migrate to GitHub</a> OpenJDK源码的版本控制迁移到github上<br>376: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/376">ZGC: Concurrent Thread-Stack Processing</a> ZGC：并发线程处理<br>380: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/380">Unix-Domain Socket Channels</a> Unix域套接字通道<br>386: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/386">Alpine Linux Port</a> 将glibc的jdk移植到使用musl的alpine linux上<br>387: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/387">Elastic Metaspace</a> 弹性元空间<br>388: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/388">Windows/AArch64 Port</a> 移植JDK到Windows/AArch64<br>389: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/389">Foreign Linker API (Incubator)</a> 提供jdk.incubator.foreign来简化native code的调用<br>390: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/390">Warnings for Value-Based Classes</a> 提供基于值的类的警告<br>392: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/392">Packaging Tool</a> jpackage打包工具转正<br>393: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/393">Foreign-Memory Access API (Third Incubator)</a><br>394: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">Pattern Matching for instanceof</a> Instanceof的模式匹配转正<br>395: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">Records</a> Records转正<br>396: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/396">Strongly Encapsulate JDK Internals by Default</a> 默认情况下，封装了JDK内部构件<br>397: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/397">Sealed Classes (Second Preview)</a> 密封类</p>
</blockquote>
<h4 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/17/">https://openjdk.java.net/projects/jdk/17/</a></p>
<blockquote>
<p>306: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/306">Restore Always-Strict Floating-Point Semantics</a> 恢复始终严格的浮点语义</p>
<p>356: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/356">Enhanced Pseudo-Random Number Generators</a> 增强型伪随机数生成器</p>
<p>382: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/382">New macOS Rendering Pipeline</a> 新的macOS渲染管道</p>
<p>391: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/391">macOS/AArch64 Port</a> macOS/AArch64端口</p>
<p>398: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/398">Deprecate the Applet API for Removal</a> 弃用Applet API后续将进行删除</p>
<p>403: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/403">Strongly Encapsulate JDK Internals</a> 强封装JDK的内部API</p>
<p>406: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/406">Pattern Matching for switch (Preview)</a> switch模式匹配（预览）</p>
<p>407: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/407">Remove RMI Activation</a> 删除RMI激活机制</p>
<p>409: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/409">Sealed Classes</a> 密封类转正</p>
<p>410: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/410">Remove the Experimental AOT and JIT Compiler</a> 删除实验性的AOT和JIT编译器</p>
<p>411: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/411">Deprecate the Security Manager for Removal</a> 弃用即将删除的安全管理器</p>
<p>412: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/412">Foreign Function &amp; Memory API (Incubator)</a> 外部函数和内存API（孵化特性）</p>
<p>414: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/414">Vector API (Second Incubator)</a> Vector API（第二次孵化特性）</p>
<p>415: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/415">Context-Specific Deserialization Filters</a> 上下文特定的反序列化过滤器</p>
</blockquote>
<h3 id="1-5-JDK各版本下载链接"><a href="#1-5-JDK各版本下载链接" class="headerlink" title="1.5 JDK各版本下载链接"></a>1.5 JDK各版本下载链接</h3><pre class="line-numbers language-http" data-language="http"><code class="language-http">https://www.oracle.com/java/technologies/downloads/archive/</code></pre>

<img src="image-20220525200441935.png" alt="image-20220525200441935" style="zoom:80%;">

<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg">https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg</a><br>提取码：yyds </p>
</blockquote>
<p><img src="image-20221213235332866.png" alt="image-20221213235332866"></p>
<h3 id="1-6-如何学习新特性"><a href="#1-6-如何学习新特性" class="headerlink" title="1.6 如何学习新特性"></a>1.6 如何学习新特性</h3><p>对于新特性，我们应该从哪几个角度学习新特性呢？</p>
<ul>
<li><p>语法层面：</p>
<ul>
<li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li>
<li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li>
<li>比如JDK10中局部变量的类型推断</li>
<li>比如JDK12中的switch</li>
<li>比如JDK13中的文本块</li>
</ul>
</li>
<li><p>API层面：</p>
<ul>
<li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li>
<li>比如JDK9中String的底层结构</li>
<li>新的 / 过时的 API</li>
</ul>
</li>
<li><p>底层优化</p>
<ul>
<li><p>比如JDK8中永久代被元空间替代、新的JS执行引擎</p>
</li>
<li><p>比如新的垃圾回收器、GC参数、JVM的优化</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-Java8新特性：Lambda表达式"><a href="#2-Java8新特性：Lambda表达式" class="headerlink" title="2. Java8新特性：Lambda表达式"></a>2. Java8新特性：Lambda表达式</h2><h3 id="2-1-关于Java8新特性简介"><a href="#2-1-关于Java8新特性简介" class="headerlink" title="2.1 关于Java8新特性简介"></a>2.1 关于Java8新特性简介</h3><p>Java 8 (又称为 JDK 8或JDK1.8) 是 Java 语言开发的一个主要版本。 Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<img src="image-20220525201653599.png" alt="image-20220525201653599" style="zoom:80%;">

<ul>
<li><p>速度更快</p>
</li>
<li><p>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</p>
</li>
<li><p>强大的 <strong>Stream API</strong></p>
</li>
<li><p>便于并行</p>
<ul>
<li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li>
</ul>
</li>
<li><p>最大化减少空指针异常：Optional</p>
</li>
<li><p>Nashorn引擎，允许在JVM上运行JS应用</p>
<ul>
<li>发音“nass-horn”，是德国二战时一个坦克的命名</li>
<li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li>
<li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li>
</ul>
</li>
</ul>
<h3 id="2-2-冗余的匿名内部类"><a href="#2-2-冗余的匿名内部类" class="headerlink" title="2.2 冗余的匿名内部类"></a>2.2 冗余的匿名内部类</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.fp;

public class UseFunctionalProgramming {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("多线程任务执行！");
            }
        }).start(); // 启动线程
    }
}</code></pre>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<p><strong>代码分析：</strong></p>
<p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h3 id="2-3-好用的lambda表达式"><a href="#2-3-好用的lambda表达式" class="headerlink" title="2.3 好用的lambda表达式"></a>2.3 好用的lambda表达式</h3><img src="lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt="lambda表达式" style="zoom:67%;">

<p><img src="image-20221111213355625.png" alt="image-20221111213355625"></p>
<h3 id="2-4-Lambda-及其使用举例"><a href="#2-4-Lambda-及其使用举例" class="headerlink" title="2.4 Lambda 及其使用举例"></a>2.4 Lambda 及其使用举例</h3><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<ul>
<li>从匿名类到 Lambda 的转换举例1</li>
</ul>
<img src="image-20220527101737072.png" alt="image-20220527101737072" style="zoom:67%;">

<ul>
<li>从匿名类到 Lambda 的转换举例2</li>
</ul>
<img src="image-20220527101814203.png" alt="image-20220527101814203" style="zoom:80%;">

<h3 id="2-5-语法"><a href="#2-5-语法" class="headerlink" title="2.5 语法"></a>2.5 语法</h3><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<code>-&gt;</code>” ， 该操作符被称为 <code>Lambda 操作符</code>或<code>箭头操作符</code>。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li>
</ul>
<p><strong>语法格式一：</strong>无参，无返回值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test1(){
    //未使用Lambda表达式
    Runnable r1 = new Runnable() {
        @Override
        public void run() {
            System.out.println("我爱北京天安门");
        }
    };

    r1.run();

    System.out.println("***********************");

    //使用Lambda表达式
    Runnable r2 = () -&gt; {
        System.out.println("我爱北京故宫");
    };

    r2.run();
}</code></pre>

<blockquote>
<p>适用于接口中<strong>只有一个抽象方法</strong>，否则无法区分是哪一个方法</p>
</blockquote>
<p><strong>语法格式二：</strong>Lambda 需要一个参数，但是没有返回值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test2(){
    //未使用Lambda表达式
    Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {
        @Override
        public void accept(String s) {
            System.out.println(s);
        }
    };
    con.accept("谎言和誓言的区别是什么？");

    System.out.println("*******************");

    //使用Lambda表达式
    Consumer&lt;String&gt; con1 = (String s) -&gt; {
        System.out.println(s);
    };
    con1.accept("一个是听得人当真了，一个是说的人当真了");

}</code></pre>



<p><strong>语法格式三：</strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test3(){
    //语法格式三使用前
    Consumer&lt;String&gt; con1 = (String s) -&gt; {
        System.out.println(s);
    };
    con1.accept("一个是听得人当真了，一个是说的人当真了");

    System.out.println("*******************");
    //语法格式三使用后
    Consumer&lt;String&gt; con2 = (s) -&gt; {
        System.out.println(s);
    };
    con2.accept("一个是听得人当真了，一个是说的人当真了");

}</code></pre>



<p><strong>语法格式四：</strong>Lambda 若只需要一个参数时，参数的小括号可以省略</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test4(){
    //语法格式四使用前
    Consumer&lt;String&gt; con1 = (s) -&gt; {
        System.out.println(s);
    };
    con1.accept("一个是听得人当真了，一个是说的人当真了");

    System.out.println("*******************");
    //语法格式四使用后
    Consumer&lt;String&gt; con2 = s -&gt; {
        System.out.println(s);
    };
    con2.accept("一个是听得人当真了，一个是说的人当真了");


}</code></pre>



<p><strong>语法格式五：</strong>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test5(){
    //语法格式五使用前
    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            System.out.println(o1);
            System.out.println(o2);
            return o1.compareTo(o2);
        }
    };

    System.out.println(com1.compare(12,21));
    System.out.println("*****************************");
    //语法格式五使用后
    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {
        System.out.println(o1);
        System.out.println(o2);
        return o1.compareTo(o2);
    };

    System.out.println(com2.compare(12,6));


}</code></pre>



<p><strong>语法格式六：</strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test6(){
    //语法格式六使用前
    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {
        return o1.compareTo(o2);
    };

    System.out.println(com1.compare(12,6));

    System.out.println("*****************************");
    //语法格式六使用后
    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);

    System.out.println(com2.compare(12,21));

}

@Test
public void test7(){
    //语法格式六使用前
    Consumer&lt;String&gt; con1 = s -&gt; {
        System.out.println(s);
    };
    con1.accept("一个是听得人当真了，一个是说的人当真了");

    System.out.println("*****************************");
    //语法格式六使用后
    Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);

    con2.accept("一个是听得人当真了，一个是说的人当真了");

}</code></pre>

<h3 id="2-6-关于类型推断"><a href="#2-6-关于类型推断" class="headerlink" title="2.6 关于类型推断"></a>2.6 关于类型推断</h3><p>在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<code>类型推断</code>”。</p>
<img src="image-20220527103215741.png" alt="image-20220527103215741" style="zoom:67%;">

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test() {
    //类型推断1
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    //类型推断2
    int[] arr = {1, 2, 3};

}</code></pre>



<h2 id="3-Java8新特性：函数式-Functional-接口"><a href="#3-Java8新特性：函数式-Functional-接口" class="headerlink" title="3. Java8新特性：函数式(Functional)接口"></a>3. Java8新特性：函数式(Functional)接口</h2><h3 id="3-1-什么是函数式接口"><a href="#3-1-什么是函数式接口" class="headerlink" title="3.1 什么是函数式接口"></a>3.1 什么是函数式接口</h3><ul>
<li>只包含<code>一个抽象方法</code>（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
<li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li>
</ul>
<h3 id="3-2-如何理解函数式接口"><a href="#3-2-如何理解函数式接口" class="headerlink" title="3.2 如何理解函数式接口"></a>3.2 如何理解函数式接口</h3><p><img src="03-Overview.png"></p>
<ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，即Java不但可以支持OOP还可以支持OOF（面向函数编程）<ul>
<li>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</li>
<li>Lambda表达式不是Java最早使用的。目前C++，C#，Python，Scala等均支持Lambda表达式。</li>
</ul>
</li>
<li>面向对象的思想：<ul>
<li>做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。</li>
</ul>
</li>
<li>函数式编程思想：<ul>
<li>只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</li>
</ul>
</li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，<strong>Lambda表达式是对象，而不是函数</strong>，它们必须依附于一类特别的对象类型——函数式接口。</li>
<li>简单的说，在Java8中，<strong>Lambda表达式就是一个函数式接口的实例</strong>。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>
</ul>
<h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><p>举例1：</p>
<img src="image-20220527111442115.png" alt="image-20220527111442115" style="zoom: 80%;">

<p>举例2：</p>
<img src="image-20220527111621424.png" alt="image-20220527111621424" style="zoom:80%;">

<p>作为参数传递 Lambda 表达式：</p>
<img src="image-20220527111751485.png" alt="image-20220527111751485" style="zoom:80%;">

<blockquote>
<p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p>
</blockquote>
<h3 id="3-4-Java-内置函数式接口"><a href="#3-4-Java-内置函数式接口" class="headerlink" title="3.4 Java 内置函数式接口"></a>3.4 Java 内置函数式接口</h3><h4 id="3-4-1-之前的函数式接口"><a href="#3-4-1-之前的函数式接口" class="headerlink" title="3.4.1 之前的函数式接口"></a>3.4.1 之前的函数式接口</h4><p>之前学过的接口，有些就是函数式接口，比如：</p>
<ul>
<li>java.lang.Runnable<ul>
<li>public void run()</li>
</ul>
</li>
<li>java.lang.Iterable<t><ul>
<li>public Iterator<t> iterate()</t></li>
</ul>
</t></li>
<li>java.lang.Comparable<t><ul>
<li>public int compareTo(T t)</li>
</ul>
</t></li>
<li>java.util.Comparator<t><ul>
<li>public int compare(T t1, T t2)</li>
</ul>
</t></li>
</ul>
<h4 id="3-4-2-四大核心函数式接口"><a href="#3-4-2-四大核心函数式接口" class="headerlink" title="3.4.2 四大核心函数式接口"></a>3.4.2 四大核心函数式接口</h4><table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>参数类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>Consumer&lt;T&gt;  </code></td>
<td>消费型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;  </code></td>
<td>供给型接口</td>
<td>无</td>
<td>返回类型为T的对象，包含方法：<code>T get()  </code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;  </code></td>
<td>函数型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;  </code></td>
<td>判断型接口</td>
<td>T</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td>
</tr>
</tbody></table>
<h4 id="3-4-3-其它接口"><a href="#3-4-3-其它接口" class="headerlink" title="3.4.3 其它接口"></a>3.4.3 其它接口</h4><p><strong>类型1：消费型接口</strong></p>
<p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>void accept(T t, U u)</td>
<td>接收两个对象用于完成功能</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>接收一个long值</td>
</tr>
<tr>
<td>ObjDoubleConsumer<t></t></td>
<td>void accept(T t, double value)</td>
<td>接收一个对象和一个double值</td>
</tr>
<tr>
<td>ObjIntConsumer<t></t></td>
<td>void accept(T t, int value)</td>
<td>接收一个对象和一个int值</td>
</tr>
<tr>
<td>ObjLongConsumer<t></t></td>
<td>void accept(T t, long value)</td>
<td>接收一个对象和一个long值</td>
</tr>
</tbody></table>
<p><strong>类型2：供给型接口</strong></p>
<p>这类接口的抽象方法特点：无参，但是有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>返回一个boolean值</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>返回一个double值</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>返回一个int值</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>返回一个long值</td>
</tr>
</tbody></table>
<p><strong>类型3：函数型接口</strong></p>
<p>这类接口的抽象方法特点：既有参数又有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator<t></t></td>
<td>T apply(T t)</td>
<td>接收一个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>DoubleFunction<r></r></td>
<td>R apply(double value)</td>
<td>接收一个double值，返回一个R类型对象</td>
</tr>
<tr>
<td>IntFunction<r></r></td>
<td>R apply(int value)</td>
<td>接收一个int值，返回一个R类型对象</td>
</tr>
<tr>
<td>LongFunction<r></r></td>
<td>R apply(long value)</td>
<td>接收一个long值，返回一个R类型对象</td>
</tr>
<tr>
<td>ToDoubleFunction<t></t></td>
<td>double applyAsDouble(T value)</td>
<td>接收一个T类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntFunction<t></t></td>
<td>int applyAsInt(T value)</td>
<td>接收一个T类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongFunction<t></t></td>
<td>long applyAsLong(T value)</td>
<td>接收一个T类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>接收一个double值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>接收一个double值，返回一个long结果</td>
</tr>
<tr>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>接收一个int值，返回一个double结果</td>
</tr>
<tr>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>接收一个int值，返回一个long结果</td>
</tr>
<tr>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>接收一个long值，返回一个double结果</td>
</tr>
<tr>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>接收一个long值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>接收一个double值，返回一个double</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>接收一个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>接收一个long值，返回一个long结果</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>R apply(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T apply(T t, T u)</td>
<td>接收两个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>ToDoubleBiFunction&lt;T,U&gt;</td>
<td>double applyAsDouble(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntBiFunction&lt;T,U&gt;</td>
<td>int applyAsInt(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongBiFunction&lt;T,U&gt;</td>
<td>long applyAsLong(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>接收两个double值，返回一个double结果</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>接收两个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>接收两个long值，返回一个long结果</td>
</tr>
</tbody></table>
<p><strong>类型4：判断型接口</strong></p>
<p>这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>boolean test(T t, U u)</td>
<td>接收两个对象</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>接收一个long值</td>
</tr>
</tbody></table>
<h4 id="3-4-4-内置接口代码演示"><a href="#3-4-4-内置接口代码演示" class="headerlink" title="3.4.4 内置接口代码演示"></a>3.4.4 内置接口代码演示</h4><p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.Arrays;
import java.util.List;

public class TestConsumer {
    public static void main(String[] args) {
        List&lt;String&gt; list = Arrays.asList("java","c","python","c++","VB","C#");
        //遍历Collection集合，并将传递给action参数的操作代码应用在每一个元素上。
        list.forEach(s -&gt; System.out.println(s));
    }
}</code></pre>

<p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.function.Supplier;

public class TestSupplier {
    public static void main(String[] args) {
        Supplier&lt;String&gt; supplier = () -&gt; "尚硅谷";
        System.out.println(supplier.get());
    }
}</code></pre>

<p>举例3：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.ArrayList;

public class TestPredicate {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("hello");
        list.add("java");
        list.add("atguigu");
        list.add("ok");
        list.add("yes");

        System.out.println("删除之前：");
        list.forEach(t-&gt; System.out.println(t));
		
        //用于删除集合中满足filter指定的条件判断的。
        //删除包含o字母的元素
        list.removeIf(s -&gt; s.contains("o"));

        System.out.println("删除包含o字母的元素之后：");
        list.forEach(t-&gt; System.out.println(t));
    }
}</code></pre>

<p>举例4：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.function.Function;

public class TestFunction {
    public static void main(String[] args) {
        //使用Lambda表达式实现Function&lt;T,R&gt;接口，可以实现将一个字符串首字母转为大写的功能。
        Function&lt;String,String&gt; fun = s -&gt; s.substring(0,1).toUpperCase() + s.substring(1);
        System.out.println(fun.apply("hello"));
    }
}
</code></pre>

<h4 id="3-4-5-练习"><a href="#3-4-5-练习" class="headerlink" title="3.4.5 练习"></a>3.4.5 练习</h4><p><strong>练习1：无参无返回值形式</strong></p>
<p>假如有自定义函数式接口Call如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Call {
    void shout();
}</code></pre>

<p>在测试类中声明一个如下方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void callSomething(Call call){
		call.shout();
}</code></pre>

<p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda {
	public static void main(String[] args) {
		callSomething(()-&gt;System.out.println("回家吃饭"));
		callSomething(()-&gt;System.out.println("我爱你"));
		callSomething(()-&gt;System.out.println("滚蛋"));
		callSomething(()-&gt;System.out.println("回来"));
	}
	public static void callSomething(Call call){
		call.shout();
	}
}
interface Call {
    void shout();
}</code></pre>

<p><strong>练习2：消费型接口</strong></p>
<p>代码示例：Consumer<t>接口</t></p>
<p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>在JDK1.8中Map集合接口中增加了一个默认方法：</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看</p>
<p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看</p>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test1(){
	List&lt;String&gt; list = Arrays.asList("hello","java","lambda","atguigu");
	list.forEach(s -&gt; System.out.println(s));
   }
@Test
public void test2(){
	HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();
	map.put(1, "hello");
	map.put(2, "java");
	map.put(3, "lambda");
	map.put(4, "atguigu");
	map.forEach((k,v) -&gt; System.out.println(k+"-&gt;"+v));
}</code></pre>

<p><strong>练习3：供给型接口</strong></p>
<p>代码示例：Supplier<t>接口</t></p>
<p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<t>是一个数据流。这个类型有一个静态方法：</t></p>
<p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p>
<p>案例：</p>
<p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test2(){
	Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));
}</code></pre>

<p><strong>练习4：功能型接口</strong></p>
<p>代码示例：Function&lt;T,R&gt;接口</p>
<p>在JDK1.8时Map接口增加了很多方法，例如：</p>
<p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) </code>按照function指定的操作替换map中的value。</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p>
<p>（2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。</p>
<p>（3）调用Map的forEach遍历集合</p>
<p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p>
<p>（5）再次调用Map的forEach遍历集合查看结果</p>
<p>Employee类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee{
	private int id;
	private String name;
	private double salary;
	public Employee(int id, String name, double salary) {
		super();
		this.id = id;
		this.name = name;
		this.salary = salary;
	}
	public Employee() {
		super();
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", salary=" + salary + "]";
	}
	
}</code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.HashMap;

public class TestLambda {
	public static void main(String[] args) {
		HashMap&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;();
		Employee e1 = new Employee(1, "张三", 8000);
		Employee e2 = new Employee(2, "李四", 9000);
		Employee e3 = new Employee(3, "王五", 10000);
		Employee e4 = new Employee(4, "赵六", 11000);
		Employee e5 = new Employee(5, "钱七", 12000);
		
		map.put(e1.getId(), e1);
		map.put(e2.getId(), e2);
		map.put(e3.getId(), e3);
		map.put(e4.getId(), e4);
		map.put(e5.getId(), e5);
		
		map.forEach((k,v) -&gt; System.out.println(k+"="+v));
		System.out.println();
		
		map.replaceAll((k,v)-&gt;{
			if(v.getSalary()&lt;10000){
				v.setSalary(10000);
			}
			return v;
		});
		map.forEach((k,v) -&gt; System.out.println(k+"="+v));
	}
}</code></pre>

<p><strong>练习5：判断型接口</strong></p>
<p>代码示例：Predicate<t>接口</t></p>
<p>JDK1.8时，Collecton<e>接口增加了一下方法，其中一个如下：</e></p>
<p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）添加一些字符串到一个Collection集合中</p>
<p>（2）调用forEach遍历集合</p>
<p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p>
<p>（4）再次调用forEach遍历集合</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;

public class TestLambda {
	public static void main(String[] args) {
		ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
		list.add("hello");
		list.add("java");
		list.add("atguigu");
		list.add("ok");
		list.add("yes");
		
		list.forEach(str-&gt;System.out.println(str));
		System.out.println();
		
		list.removeIf(str-&gt;str.length()&lt;5);
		list.forEach(str-&gt;System.out.println(str));
	}
}</code></pre>

<p><strong>练习6：判断型接口</strong></p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p>
<p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</employee></p>
<p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<employee> get(Predicate<employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<employee> 集合中返回。</employee></employee></employee></p>
<p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p>
<ul>
<li>所有员工对象</li>
<li>所有年龄超过35的员工</li>
<li>所有薪资高于15000的女员工</li>
<li>所有编号是偶数的员工</li>
<li>名字是“张三”的员工</li>
<li>年龄超过25，薪资低于10000的男员工</li>
</ul>
<p>示例代码：</p>
<p>Employee类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee{
	private int id;
	private String name;
	private char gender;
	private int age;
	private double salary;
	
	public Employee(int id, String name, char gender, int age, double salary) {
		super();
		this.id = id;
		this.name = name;
		this.gender = gender;
		this.age = age;
		this.salary = salary;
	}
	public Employee() {
		super();
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", gender=" + gender + ", age=" + age + ", salary=" + salary
				+ "]";
	}
}</code></pre>

<p>员工管理类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class EmployeeService{
	private ArrayList&lt;Employee&gt; all;
	public EmployeeService(){
		all = new ArrayList&lt;Employee&gt;();
		all.add(new Employee(1, "张三", '男', 33, 8000));
		all.add(new Employee(2, "翠花", '女', 23, 18000));
		all.add(new Employee(3, "无能", '男', 46, 8000));
		all.add(new Employee(4, "李四", '女', 23, 9000));
		all.add(new Employee(5, "老王", '男', 23, 15000));
		all.add(new Employee(6, "大嘴", '男', 23, 11000));
	}
	public ArrayList&lt;Employee&gt; get(Predicate&lt;Employee&gt; p){
		ArrayList&lt;Employee&gt; result = new ArrayList&lt;Employee&gt;();
		for (Employee emp : result) {
			if(p.test(emp)){
				result.add(emp);
			}
		}
		return result;
	}
}</code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda {
	public static void main(String[] args) {
		EmployeeService es = new EmployeeService();
		
		es.get(e -&gt; true).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getAge()&gt;35).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getSalary()&gt;15000 &amp;&amp; e.getGender()=='女').forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getId()%2==0).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; "张三".equals(e.getName())).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getAge()&gt;25 &amp;&amp; e.getSalary()&lt;10000 &amp;&amp; e.getGender()=='男').forEach(e-&gt;System.out.println(e));
	}
}</code></pre>

<h2 id="4-Java8新特性：方法引用与构造器引用"><a href="#4-Java8新特性：方法引用与构造器引用" class="headerlink" title="4. Java8新特性：方法引用与构造器引用"></a>4. Java8新特性：方法引用与构造器引用</h2><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。</p>
<h3 id="4-1-方法引用"><a href="#4-1-方法引用" class="headerlink" title="4.1 方法引用"></a>4.1 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
<p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>
<blockquote>
<p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法<code>对语言的功能并没有影响，但是更方便程序员使用</code>。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
</blockquote>
<h4 id="4-1-1-方法引用格式"><a href="#4-1-1-方法引用格式" class="headerlink" title="4.1.1 方法引用格式"></a>4.1.1 方法引用格式</h4><ul>
<li><p>格式：使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p>
<ul>
<li>两个:中间不能有空格，而且必须英文状态下半角输入</li>
</ul>
</li>
<li><p>如下三种主要使用情况：</p>
<ul>
<li>情况1：<code>对象 :: 实例方法名</code></li>
<li>情况2：<code>类 :: 静态方法名</code></li>
<li>情况3：<code>类 :: 实例方法名</code></li>
</ul>
</li>
</ul>
<h4 id="4-1-2-方法引用使用前提"><a href="#4-1-2-方法引用使用前提" class="headerlink" title="4.1.2 方法引用使用前提"></a>4.1.2 方法引用使用前提</h4><p><strong>要求1：</strong>Lambda体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的</p>
<p>例如：System.out对象，调用println()方法来完成Lambda体</p>
<p>​           Math类，调用random()静态方法来完成Lambda体</p>
<p><strong>要求2：</strong></p>
<p>针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以）</p>
<p>例如：t-&gt;System.out.println(t)</p>
<p>​        () -&gt; Math.random() 都是无参</p>
<h4 id="4-1-3-举例"><a href="#4-1-3-举例" class="headerlink" title="4.1.3 举例"></a>4.1.3 举例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodRefTest {

	// 情况一：对象 :: 实例方法
	//Consumer中的void accept(T t)
	//PrintStream中的void println(T t)
	@Test
	public void test1() {
		Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);
		con1.accept("北京");

		System.out.println("*******************");
		PrintStream ps = System.out;
		Consumer&lt;String&gt; con2 = ps::println;
		con2.accept("beijing");
	}
	
	//Supplier中的T get()
	//Employee中的String getName()
	@Test
	public void test2() {
		Employee emp = new Employee(1001,"Tom",23,5600);

		Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();
		System.out.println(sup1.get());

		System.out.println("*******************");
		Supplier&lt;String&gt; sup2 = emp::getName;
		System.out.println(sup2.get());

	}

	// 情况二：类 :: 静态方法
	//Comparator中的int compare(T t1,T t2)
	//Integer中的int compare(T t1,T t2)
	@Test
	public void test3() {
		Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);
		System.out.println(com1.compare(12,21));

		System.out.println("*******************");

		Comparator&lt;Integer&gt; com2 = Integer::compare;
		System.out.println(com2.compare(12,3));

	}
	
	//Function中的R apply(T t)
	//Math中的Long round(Double d)
	@Test
	public void test4() {
		Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() {
			@Override
			public Long apply(Double d) {
				return Math.round(d);
			}
		};

		System.out.println("*******************");

		Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);
		System.out.println(func1.apply(12.3));

		System.out.println("*******************");

		Function&lt;Double,Long&gt; func2 = Math::round;
		System.out.println(func2.apply(12.6));
	}

	// 情况三：类 :: 实例方法  (有难度)
	// Comparator中的int comapre(T t1,T t2)
	// String中的int t1.compareTo(t2)
	@Test
	public void test5() {
		Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);
		System.out.println(com1.compare("abc","abd"));

		System.out.println("*******************");

		Comparator&lt;String&gt; com2 = String :: compareTo;
		System.out.println(com2.compare("abd","abm"));
	}

	//BiPredicate中的boolean test(T t1, T t2);
	//String中的boolean t1.equals(t2)
	@Test
	public void test6() {
		BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);
		System.out.println(pre1.test("abc","abc"));

		System.out.println("*******************");
		BiPredicate&lt;String,String&gt; pre2 = String :: equals;
		System.out.println(pre2.test("abc","abd"));
	}
	
	// Function中的R apply(T t)
	// Employee中的String getName();
	@Test
	public void test7() {
		Employee employee = new Employee(1001, "Jerry", 23, 6000);


		Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();
		System.out.println(func1.apply(employee));

		System.out.println("*******************");
		Function&lt;Employee,String&gt; func2 = Employee::getName;
		System.out.println(func2.apply(employee));
	}

}</code></pre>

<h3 id="4-2-构造器引用"><a href="#4-2-构造器引用" class="headerlink" title="4.2 构造器引用"></a>4.2 构造器引用</h3><p>当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。</p>
<p>格式：<code>类名::new</code></p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConstructorRefTest {
	//构造器引用
    //Supplier中的T get()
    //Employee的空参构造器：Employee()
    @Test
    public void test1(){

        Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() {
            @Override
            public Employee get() {
                return new Employee();
            }
        };
        System.out.println("*******************");

        Supplier&lt;Employee&gt;  sup1 = () -&gt; new Employee();
        System.out.println(sup1.get());

        System.out.println("*******************");

        Supplier&lt;Employee&gt;  sup2 = Employee :: new;
        System.out.println(sup2.get());
    }

	//Function中的R apply(T t)
    @Test
    public void test2(){
        Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id);
        Employee employee = func1.apply(1001);
        System.out.println(employee);

        System.out.println("*******************");

        Function&lt;Integer,Employee&gt; func2 = Employee :: new;
        Employee employee1 = func2.apply(1002);
        System.out.println(employee1);

    }

	//BiFunction中的R apply(T t,U u)
    @Test
    public void test3(){
        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name);
        System.out.println(func1.apply(1001,"Tom"));

        System.out.println("*******************");

        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: new;
        System.out.println(func2.apply(1002,"Tom"));

    }

}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.java2;

/**
 * @author 尚硅谷-宋红康 邮箱：shkstart@126.com
 */
public class Employee {

	private int id;
	private String name;
	private int age;
	private double salary;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public double getSalary() {
		return salary;
	}

	public void setSalary(double salary) {
		this.salary = salary;
	}

	public Employee() {
		System.out.println("Employee().....");
	}

	public Employee(int id) {
		this.id = id;
		System.out.println("Employee(int id).....");
	}

	public Employee(int id, String name) {
		this.id = id;
		this.name = name;
	}

	public Employee(int id, String name, int age, double salary) {

		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Employee{" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + ", salary=" + salary + '}';
	}

}
</code></pre>

<h3 id="4-3-数组构造引用"><a href="#4-3-数组构造引用" class="headerlink" title="4.3 数组构造引用"></a>4.3 数组构造引用</h3><p>当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。</p>
<p>格式：<code>数组类型名::new</code></p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//数组引用
//Function中的R apply(T t)
@Test
public void test4(){
    Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length];
    String[] arr1 = func1.apply(5);
    System.out.println(Arrays.toString(arr1));

    System.out.println("*******************");

    Function&lt;Integer,String[]&gt; func2 = String[] :: new;
    String[] arr2 = func2.apply(10);
    System.out.println(Arrays.toString(arr2));

}</code></pre>

<h2 id="5-Java8新特性：强大的Stream-API"><a href="#5-Java8新特性：强大的Stream-API" class="headerlink" title="5. Java8新特性：强大的Stream API"></a>5. Java8新特性：强大的Stream API</h2><h3 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h3><ul>
<li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</li>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库<code>最好的补充</code>，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<h3 id="5-2-为什么要使用Stream-API"><a href="#5-2-为什么要使用Stream-API" class="headerlink" title="5.2 为什么要使用Stream API"></a>5.2 为什么要使用Stream API</h3><p>实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p>
<h3 id="5-3-什么是Stream"><a href="#5-3-什么是Stream" class="headerlink" title="5.3 什么是Stream"></a>5.3 什么是Stream</h3><p>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>注意：</p>
<p>①==Stream 自己不会存储元素。==</p>
<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p>
<p>④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。</p>
<h3 id="5-4-Stream的操作三个步骤"><a href="#5-4-Stream的操作三个步骤" class="headerlink" title="5.4 Stream的操作三个步骤"></a>5.4 Stream的操作三个步骤</h3><p><strong>1- 创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p>
<p><strong>2- 中间操作</strong><br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p>
<p><strong>3- 终止操作(终端操作)</strong><br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p>
<img src="image-20220514180803311.png" alt="image-20220514180803311" style="zoom: 50%;">

<h4 id="5-4-1-创建Stream实例"><a href="#5-4-1-创建Stream实例" class="headerlink" title="5.4.1 创建Stream实例"></a>5.4.1 创建Stream实例</h4><p><strong>方式一：通过集合</strong></p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<ul>
<li><p>default Stream<e> stream() : 返回一个顺序流</e></p>
</li>
<li><p>default Stream<e> parallelStream() : 返回一个并行流</e></p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test01(){
    List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5);

    //JDK1.8中，Collection系列集合增加了方法
    Stream&lt;Integer&gt; stream = list.stream();
}</code></pre>



<p><strong>方式二：通过数组</strong></p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static <t> Stream<t> stream(T[] array): 返回一个流</t></t></li>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test02(){
    String[] arr = {"hello","world"};
    Stream&lt;String&gt; stream = Arrays.stream(arr); 
}

@Test
public void test03(){
    int[] arr = {1,2,3,4,5};
    IntStream stream = Arrays.stream(arr);
}</code></pre>



<p><strong>方式三：通过Stream的of()</strong></p>
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收<strong>任意数量的参数</strong>。</p>
<ul>
<li>public static<t> Stream<t> of(T… values) : 返回一个流</t></t></li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test04(){
    Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5);
    stream.forEach(System.out::println);
}</code></pre>



<p><strong>方式四：创建无限流(了解)</strong></p>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<ul>
<li><p>迭代<br>public static<t> Stream<t> iterate(final T seed, final UnaryOperator<t> f) </t></t></t></p>
</li>
<li><p>生成<br>public static<t> Stream<t> generate(Supplier<t> s)</t></t></t></p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">// 方式四：创建无限流
@Test
public void test05() {
	// 迭代
	// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final
	// UnaryOperator&lt;T&gt; f)
	Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 2);
	stream.limit(10).forEach(System.out::println);

	// 生成
	// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
	Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);
	stream1.limit(10).forEach(System.out::println);
}
</code></pre>

<h4 id="5-4-2-一系列中间操作"><a href="#5-4-2-一系列中间操作" class="headerlink" title="5.4.2 一系列中间操作"></a>5.4.2 一系列中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>1-筛选与切片</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>filter(Predicatep)</strong></td>
<td>接收  Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td><strong>distinct()</strong></td>
<td>筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td><strong>limit(long maxSize)</strong></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><strong>skip(long n)</strong></td>
<td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<p>2-映 射</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td><strong>mapToInt(ToIntFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。</td>
</tr>
<tr>
<td><strong>mapToLong(ToLongFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function  f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>3-排序</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>sorted()</strong></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><strong>sorted(Comparator</strong> <strong>com)</strong></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<p>代码举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;

import org.junit.Test;

import java.util.Arrays;
import java.util.stream.Stream;

public class StreamMiddleOperate {
	@Test
    public void test01(){
        //1、创建Stream
        Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5,6);

        //2、加工处理
        //过滤：filter(Predicate&nbsp;p)
        //把里面的偶数拿出来
        /*
         * filter(Predicate&nbsp;p)
         * Predicate是函数式接口，抽象方法：boolean test(T t)
         */
        stream = stream.filter(t -&gt; t%2==0);

        //3、终结操作：例如：遍历
        stream.forEach(System.out::println);
    }
    @Test
    public void test02(){
        Stream.of(1,2,3,4,5,6)
                .filter(t -&gt; t%2==0)
                .forEach(System.out::println);
    }
    @Test
    public void test03(){
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .distinct()
                .forEach(System.out::println);
    }
    @Test
    public void test04(){
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .limit(3)
                .forEach(System.out::println);
    }
    @Test
    public void test05(){
        Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7)
                .distinct()  //(1,2,3,4,5,6,7)
                .filter(t -&gt; t%2!=0) //(1,3,5,7)
                .limit(3)
                .forEach(System.out::println);
    }
    @Test
    public void test06(){
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .skip(5)
                .forEach(System.out::println);
    }
    @Test
    public void test07(){
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .skip(5)
                .distinct()
                .filter(t -&gt; t%3==0)
                .forEach(System.out::println);
    }
    @Test
    public void test08(){
        long count = Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .distinct()
                .peek(System.out::println)  //Consumer接口的抽象方法  void accept(T t)
                .count();
        System.out.println("count="+count);
    }
    @Test
    public void test09(){
        //希望能够找出前三个最大值，前三名最大的，不重复
        Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54)
                .distinct()
                .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))//Comparator接口  int compare(T t1, T t2)
                .limit(3)
                .forEach(System.out::println);
    }
    @Test
    public void test10(){
        Stream.of(1,2,3,4,5)
                .map(t -&gt; t+=1)//Function&lt;T,R&gt;接口抽象方法 R apply(T t)
                .forEach(System.out::println);
    }
    @Test
    public void test11(){
        String[] arr = {"hello","world","java"};

        Arrays.stream(arr)
                .map(t-&gt;t.toUpperCase())
                .forEach(System.out::println);
    }
    @Test
    public void test12(){
        String[] arr = {"hello","world","java"};
        Arrays.stream(arr)
                .flatMap(t -&gt; Stream.of(t.split("|")))//Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream
                .forEach(System.out::println);
    } 
}
</code></pre>

<h4 id="5-4-3-终止操作"><a href="#5-4-3-终止操作" class="headerlink" title="5.4.3 终止操作"></a>5.4.3 终止操作</h4><ul>
<li><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
</li>
<li><p>流进行了终止操作后，不能再次使用。</p>
</li>
</ul>
<p>1-匹配与查找</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>**anyMatch(Predicate  p)  **</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-归约</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<t></t></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<p>3-收集</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
<p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toList</strong></td>
<td>Collector&lt;T, ?, List<t>&gt;</t></td>
<td>把流中元素收集到List</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toSet</strong></td>
<td>Collector&lt;T, ?, Set<t>&gt;</t></td>
<td>把流中元素收集到Set</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toCollection</strong></td>
<td>Collector&lt;T, ?, C&gt;</td>
<td>把流中元素收集到创建的集合</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>counting</strong></td>
<td>Collector&lt;T, ?, Long&gt;</td>
<td>计算流中元素的个数</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">long count = list.stream().collect(Collectors.counting());</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summingInt</strong></td>
<td>Collector&lt;T, ?, Integer&gt;</td>
<td>对流中元素的整数属性求和</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>averagingInt</strong></td>
<td>Collector&lt;T, ?, Double&gt;</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summarizingInt</strong></td>
<td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>joining</strong></td>
<td>Collector&lt;CharSequence, ?, String&gt;</td>
<td>连接流中每个字符串</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>maxBy</strong></td>
<td>Collector&lt;T, ?, Optional<t>&gt;</t></td>
<td>根据比较器选择最大值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>minBy</strong></td>
<td>Collector&lt;T, ?, Optional<t>&gt;</t></td>
<td>根据比较器选择最小值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reducing</strong></td>
<td>Collector&lt;T, ?, Optional<t>&gt;</t></td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector&lt;T,A,RR&gt;</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupingBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;K, List<t>&gt;&gt;</t></td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>partitioningBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;Boolean, List<t>&gt;&gt;</t></td>
<td>根据true或false进行分区</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</code></pre>

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.Test;

public class StreamEndding {
    @Test
    public void test01(){
        Stream.of(1,2,3,4,5)
                .forEach(System.out::println);
    }
    @Test
    public void test02(){
        long count = Stream.of(1,2,3,4,5)
                .count();
        System.out.println("count = " + count);
    }
    @Test
    public void test03(){
        boolean result = Stream.of(1,3,5,7,9)
                .allMatch(t -&gt; t%2!=0);
        System.out.println(result);
    }
	@Test
    public void test04(){
        boolean result = Stream.of(1,3,5,7,9)
                .anyMatch(t -&gt; t%2==0);
        System.out.println(result);
    }
	@Test
    public void test05(){
        Optional&lt;Integer&gt; opt = Stream.of(1,3,5,7,9).findFirst();
        System.out.println(opt);
    }
	@Test
    public void test06(){
        Optional&lt;Integer&gt; opt = Stream.of(1,2,3,4,5,7,9)
                .filter(t -&gt; t%3==0)
                .findFirst();
        System.out.println(opt);
    }
	@Test
    public void test07(){
        Optional&lt;Integer&gt; opt = Stream.of(1,2,4,5,7,8)
                .filter(t -&gt; t%3==0)
                .findFirst();
        System.out.println(opt);
    }
    @Test
    public void test08(){
        Optional&lt;Integer&gt; max = Stream.of(1,2,4,5,7,8)
                .max((t1,t2) -&gt; Integer.compare(t1, t2));
        System.out.println(max);
    }
    @Test
    public void test09(){
        Integer reduce = Stream.of(1,2,4,5,7,8)
                .reduce(0, (t1,t2) -&gt; t1+t2);//BinaryOperator接口   T apply(T t1, T t2)
        System.out.println(reduce);
    }
    @Test
    public void test10(){
        Optional&lt;Integer&gt; max = Stream.of(1,2,4,5,7,8)
                .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);//BinaryOperator接口   T apply(T t1, T t2)
        System.out.println(max);
    }
    @Test
    public void test11(){
        List&lt;Integer&gt; list = Stream.of(1,2,4,5,7,8)
                .filter(t -&gt; t%2==0)
                .collect(Collectors.toList());

        System.out.println(list);
    }   
}</code></pre>

<h3 id="5-5-Java9新增API"><a href="#5-5-Java9新增API" class="headerlink" title="5.5 Java9新增API"></a>5.5 Java9新增API</h3><p><strong>新增1：Stream实例化方法</strong></p>
<p>ofNullable()的使用：</p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//报NullPointerException
//Stream&lt;Object&gt; stream1 = Stream.of(null);
//System.out.println(stream1.count());

//不报异常，允许通过
Stream&lt;String&gt; stringStream = Stream.of("AA", "BB", null);
System.out.println(stringStream.count());//3

//不报异常，允许通过
List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("AA");
list.add(null);
System.out.println(list.stream().count());//2
//ofNullable()：允许值为null
Stream&lt;Object&gt; stream1 = Stream.ofNullable(null);
System.out.println(stream1.count());//0

Stream&lt;String&gt; stream = Stream.ofNullable("hello world");
System.out.println(stream.count());//1
</code></pre>

<p>iterator()重载的使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//原来的控制终止方式：
Stream.iterate(1,i -&gt; i + 1).limit(10).forEach(System.out::println);

//现在的终止方式：
Stream.iterate(1,i -&gt; i &lt; 100,i -&gt; i + 1).forEach(System.out::println);
</code></pre>

<h3 id="5-6-练习"><a href="#5-6-练习" class="headerlink" title="5.6 练习"></a>5.6 练习</h3><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p>
<ol>
<li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li>
<li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li>
<li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li>
<li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li>
<li>将两个队伍合并为一个队伍；存储到一个新集合中。</li>
<li>根据姓名创建 Person 对象；存储到一个新集合中。</li>
<li>打印整个队伍的Person对象信息。</li>
</ol>
<p>Person 类的代码为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public&nbsp;class&nbsp;Person&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person()&nbsp;{}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(String&nbsp;name)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setName(String&nbsp;name)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Person{name='"&nbsp;+&nbsp;name&nbsp;+&nbsp;"'}";
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre>

<p>两个队伍（集合）的代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第一支队伍
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;String&gt;&nbsp;one&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("迪丽热巴");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("宋远桥");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("苏星河");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("石破天");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("石中玉");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("老子");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("庄子");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("洪七公");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第二支队伍
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;String&gt;&nbsp;two&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("古力娜扎");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张无忌");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("赵丽颖");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张三丰");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("尼古拉斯赵四");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张天爱");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张二狗");
    
		//&nbsp;....编写代码完成题目要求&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>

<p>参考答案：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第一支队伍
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;String&gt;&nbsp;one&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("迪丽热巴");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("宋远桥");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("苏星河");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("石破天");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("石中玉");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("老子");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("庄子");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one.add("洪七公");
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第二支队伍
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;String&gt;&nbsp;two&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("古力娜扎");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张无忌");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("赵丽颖");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张三丰");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("尼古拉斯赵四");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张天爱");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two.add("张二狗");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		//&nbsp;第一个队伍只要名字为3个字的成员姓名；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;第一个队伍筛选之后只要前3个人；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream&lt;String&gt;&nbsp;streamOne&nbsp;=&nbsp;one.stream().filter(s&nbsp;‐&gt;&nbsp;s.length()&nbsp;==&nbsp;3).limit(3);
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;第二个队伍只要姓张的成员姓名；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;第二个队伍筛选之后不要前2个人；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream&lt;String&gt;&nbsp;streamTwo&nbsp;=&nbsp;two.stream().filter(s&nbsp;‐&gt;&nbsp;s.startsWith("张")).skip(2);
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将两个队伍合并为一个队伍；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据姓名创建Person对象；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;打印整个队伍的Person对象信息。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream.concat(streamOne,&nbsp;streamTwo).map(Person::new).forEach(System.out::println);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</code></pre>

<h1 id="第18章-JDK8-17新特性（下）"><a href="#第18章-JDK8-17新特性（下）" class="headerlink" title="第18章_JDK8-17新特性（下）"></a>第18章_JDK8-17新特性（下）</h1><h2 id="6-新语法结构"><a href="#6-新语法结构" class="headerlink" title="6. 新语法结构"></a>6. 新语法结构</h2><p>新的语法结构，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从<code>复杂、繁琐</code>的低层次抽象中逐渐解放出来，以更高层次、更优雅的抽象，既<code>降低代码量</code>，又避免意外编程错误的出现，进而提高代码质量和开发效率。</p>
<h3 id="6-1-Java的REPL工具：-jShell命令"><a href="#6-1-Java的REPL工具：-jShell命令" class="headerlink" title="6.1 Java的REPL工具： jShell命令"></a>6.1 Java的REPL工具： jShell命令</h3><p><strong>JDK9的新特性</strong></p>
<p>Java 终于拥有了像Python 和 Scala 之类语言的REPL工具（交互式编程环境，read - evaluate - print - loop）：<code>jShell</code>。以交互式的方式对语句和表达式进行求值。<code>即写即得</code>、<code>快速运行</code>。</p>
<p>利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。</p>
<p><strong>使用举例</strong></p>
<ul>
<li>调出jShell</li>
</ul>
<p> <img src="image-20220527205410620.png" alt="image-20220527205410620"></p>
<ul>
<li>获取帮助</li>
</ul>
<p> <img src="image-20220527205418073.png" alt="image-20220527205418073"></p>
<ul>
<li>基本使用</li>
</ul>
<p> <img src="image-20220527205429720.png" alt="image-20220527205429720"></p>
<ul>
<li>导入指定的包</li>
</ul>
<p> <img src="image-20220527205440068.png" alt="image-20220527205440068"></p>
<ul>
<li>默认已经导入如下的所有包：（包含java.lang包）</li>
</ul>
<p> <img src="image-20220527205445267.png" alt="image-20220527205445267"></p>
<ul>
<li>只需按下 Tab 键，就能自动补全代码</li>
</ul>
<p> <img src="image-20220527205451352.png" alt="image-20220527205451352"></p>
<ul>
<li>列出当前 session 里所有有效的代码片段</li>
</ul>
<p> <img src="image-20220527205458774.png" alt="image-20220527205458774"></p>
<ul>
<li>查看当前 session 下所有创建过的变量</li>
</ul>
<p> <img src="image-20220527205506632.png" alt="image-20220527205506632"></p>
<ul>
<li>查看当前 session 下所有创建过的方法</li>
</ul>
<p> <img src="image-20220527205513459.png" alt="image-20220527205513459"></p>
<blockquote>
<p>Tips：我们还可以重新定义相同方法名和参数列表的方法，即对现有方法的修改（或覆盖）。</p>
</blockquote>
<ul>
<li>使用外部代码编辑器来编写 Java 代码</li>
</ul>
<p> <img src="image-20220527205519915.png" alt="image-20220527205519915"></p>
<p>从外部文件加载源代码【HelloWorld.java】</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * Created by songhongkang
 */
public void printHello() {
    System.out.println("马上2023年了，尚硅谷祝所有的谷粉元旦快乐！");
}
printHello();
</code></pre>

<ul>
<li>使用/open命令调用</li>
</ul>
<p> <img src="image-20220527205827712.png" alt="image-20220527205827712"></p>
<ul>
<li>退出jShell</li>
</ul>
<p> <img src="image-20220527205904000.png" alt="image-20220527205904000"></p>
<h3 id="6-2-异常处理之try-catch资源关闭"><a href="#6-2-异常处理之try-catch资源关闭" class="headerlink" title="6.2 异常处理之try-catch资源关闭"></a>6.2 异常处理之try-catch资源关闭</h3><p>在JDK7 之前，我们这样处理资源的关闭：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test01() {
    FileWriter fw = null;
    BufferedWriter bw = null;
    try {
        fw = new FileWriter("d:/1.txt");
        bw = new BufferedWriter(fw);

        bw.write("hello");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (bw != null) {
                bw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            if (fw != null) {
                fw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}</code></pre>

<p><strong>JDK7的新特性</strong></p>
<p>在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。</p>
<p>格式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">try(资源对象的声明和初始化){
    业务逻辑代码,可能会产生异常
}catch(异常类型1 e){
    处理异常代码
}catch(异常类型2 e){
    处理异常代码
}</code></pre>

<p>说明：</p>
<p>1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。</p>
<p>2、这些资源实现类<strong>必须实现AutoCloseable或Closeable接口</strong>，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。</p>
<p>3、写到try()中的资源类的变量默认是final声明的，不能修改。</p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//举例1
@Test
public void test02() {
    try (
        FileWriter fw = new FileWriter("d:/1.txt");
        BufferedWriter bw = new BufferedWriter(fw);
    ) {
        bw.write("hello");
    } catch (IOException e) {
        e.printStackTrace();
    }
}

//举例2
@Test
public void test03() {
    //从d:/1.txt(utf-8)文件中，读取内容，写到项目根目录下1.txt(gbk)文件中
    try (
        FileInputStream fis = new FileInputStream("d:/1.txt");
        InputStreamReader isr = new InputStreamReader(fis, "utf-8");
        BufferedReader br = new BufferedReader(isr);

        FileOutputStream fos = new FileOutputStream("1.txt");
        OutputStreamWriter osw = new OutputStreamWriter(fos, "gbk");
        BufferedWriter bw = new BufferedWriter(osw);
    ) {
        String str;
        while ((str = br.readLine()) != null) {
            bw.write(str);
            bw.newLine();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>

<p><strong>JDK9的新特性</strong></p>
<p>try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。</p>
<p>格式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">A a = new A();
B b = new B();
try(a;b){
    可能产生的异常代码
}catch(异常类名 变量名){
    异常处理的逻辑
}</code></pre>

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test04() {
    InputStreamReader reader = new InputStreamReader(System.in);
    OutputStreamWriter writer = new OutputStreamWriter(System.out);
    try (reader; writer) {
        //reader是final的，不可再被赋值
        //   reader = null;

    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>

<h3 id="6-3-局部变量类型推断"><a href="#6-3-局部变量类型推断" class="headerlink" title="6.3 局部变量类型推断"></a>6.3 局部变量类型推断</h3><p><strong>JDK 10的新特性</strong></p>
<p>局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。</p>
<ul>
<li>使用举例</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//1.局部变量的实例化
var list = new ArrayList&lt;String&gt;();

var set = new LinkedHashSet&lt;Integer&gt;();

//2.增强for循环中的索引
for (var v : list) {
    System.out.println(v);
}

//3.传统for循环中
for (var i = 0; i &lt; 100; i++) {
    System.out.println(i);
}

//4. 返回值类型含复杂泛型结构
var iterator = set.iterator();
//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();
</code></pre>

<ul>
<li>不适用场景<ul>
<li>声明一个成员变量</li>
<li>声明一个数组变量，并为数组静态初始化（省略new的情况下）</li>
<li>方法的返回值类型</li>
<li>方法的参数类型</li>
<li>没有初始化的方法内的局部变量声明</li>
<li>作为catch块中异常类型</li>
<li>Lambda表达式中函数式接口的类型</li>
<li>方法引用中函数式接口的类型</li>
</ul>
</li>
</ul>
<p>代码举例：</p>
<p>声明一个成员变量，并初始化值为null</p>
<p> <img src="image-20220528155628337.png" alt="image-20220528155628337"></p>
<p>声明一个数组变量，并为数组静态初始化（省略new的情况下）</p>
<p> <img src="image-20220528155436304.png" alt="image-20220528155436304"></p>
<p>没有初始化的方法内的局部变量声明</p>
<p> <img src="image-20220528155525774.png" alt="image-20220528155525774"></p>
<p>方法的返回值类型</p>
<p> <img src="image-20220528155537713.png" alt="image-20220528155537713"></p>
<p>方法的参数类型</p>
<p> <img src="image-20220528155549303.png" alt="image-20220528155549303"></p>
<p>构造器的参数类型</p>
<p> <img src="image-20220528155614708.png" alt="image-20220528155614708"></p>
<p>作为catch块中异常类型</p>
<p> <img src="image-20220528155640498.png" alt="image-20220528155640498"></p>
<p>Lambda表达式中函数式接口的类型</p>
<p> <img src="image-20220528155423180.png" alt="image-20220528155423180"></p>
<p>方法引用中函数式接口的类型</p>
<p> <img src="image-20220528155429055.png" alt="image-20220528155429055"></p>
<p><strong>注意：</strong></p>
<ul>
<li><p>var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。</p>
</li>
<li><p>这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</p>
</li>
</ul>
<h3 id="6-4-instanceof的模式匹配"><a href="#6-4-instanceof的模式匹配" class="headerlink" title="6.4 instanceof的模式匹配"></a>6.4 instanceof的模式匹配</h3><p><strong>JDK14中预览特性：</strong></p>
<p>instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少Java程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。</p>
<p>Java 14之前旧写法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(obj instanceof String){
    String str = (String)obj; //需要强转
    .. str.contains(..)..
}else{
    ...
}</code></pre>

<p>Java 14新特性写法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(obj instanceof String str){
    .. str.contains(..)..
}else{
    ...
}</code></pre>

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * instanceof的模式匹配（预览）
 *
 * @author shkstart
 * @create 上午 11:32
 */
public class Feature01 {
    @Test
    public void test1(){

        Object obj = new String("hello,Java14");
        obj = null;//在使用null 匹配instanceof 时，返回都是false.
        if(obj instanceof String){
            String str = (String) obj;
            System.out.println(str.contains("Java"));
        }else{
            System.out.println("非String类型");
        }

        //举例1：
        if(obj instanceof String str){ //新特性：省去了强制类型转换的过程
            System.out.println(str.contains("Java"));
        }else{
            System.out.println("非String类型");
        }
    }
}

// 举例2
class InstanceOf{

    String str = "abc";

    public void test(Object obj){

        if(obj instanceof String str){//此时的str的作用域仅限于if结构内。
            System.out.println(str.toUpperCase());
        }else{
            System.out.println(str.toLowerCase());
        }

    }

}

//举例3：
class Monitor{
    private String model;
    private double price;

//    public boolean equals(Object o){
//        if(o instanceof Monitor other){
//            if(model.equals(other.model) &amp;&amp; price == other.price){
//                return true;
//            }
//        }
//        return false;
//    }


    public boolean equals(Object o){
        return o instanceof Monitor other &amp;&amp; model.equals(other.model) &amp;&amp; price == other.price;
    }

}</code></pre>

<p><strong>JDK15中第二次预览：</strong></p>
<p>没有任何更改。</p>
<p><strong>JDK16中转正特性：</strong></p>
<p>在Java16中转正。</p>
<h3 id="6-5-switch表达式"><a href="#6-5-switch表达式" class="headerlink" title="6.5 switch表达式"></a>6.5 switch表达式</h3><p>传统switch声明语句的弊端：</p>
<ul>
<li>匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透</li>
<li>所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；</li>
<li>不能在一个case里写多个执行结果一致的条件；</li>
<li>整个switch不能作为表达式返回值；</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//常见错误实现
switch(month){
    case 3|4|5://3|4|5 用了位运算符，11 | 100 | 101结果是 111是7
        System.out.println("春季");
        break;
    case 6|7|8://6|7|8用了位运算符，110 | 111 | 1000结果是1111是15
        System.out.println("夏季");
        break;
    case 9|10|11://9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11
        System.out.println("秋季");
        break;
    case 12|1|2://12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15
        System.out.println("冬季");
        break;
    default:
        System.out.println("输入有误");
}</code></pre>

<p><strong>JDK12中预览特性：</strong></p>
<ul>
<li><p>Java 12将会对switch声明语句进行扩展，使用<code>case L -&gt;</code>来替代以前的<code>break;</code>，省去了 break 语句，避免了因少写 break 而出错。</p>
</li>
<li><p>同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。</p>
</li>
<li><p>为了保持兼容性，case 条件语句中依然可以使用字符<code> :</code> ，但是同一个 switch 结构里不能混用<code> -&gt;</code> 和<code> :</code> ，否则编译错误。</p>
</li>
</ul>
<p>举例：</p>
<p>Java 12之前</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author shkstart
 * @create 下午 4:47
 */
public class SwitchTest {
    public static void main(String[] args) {
        int numberOfLetters;
        Fruit fruit = Fruit.APPLE;
        switch (fruit) {
            case PEAR:
                numberOfLetters = 4;
                break;
            case APPLE:
            case GRAPE:
            case MANGO:
                numberOfLetters = 5;
                break;
            case ORANGE:
            case PAPAYA:
                numberOfLetters = 6;
                break;
            default:
                throw new IllegalStateException("No Such Fruit:" + fruit);
        }
        System.out.println(numberOfLetters);

    }
}
enum Fruit {
    PEAR, APPLE, GRAPE, MANGO, ORANGE, PAPAYA;
}</code></pre>

<p>switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。</p>
<p>Java 12中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author shkstart
 * @create 下午 10:38
 */
public class SwitchTest1 {
    public static void main(String[] args) {
        Fruit fruit = Fruit.GRAPE;
        switch(fruit){
            case PEAR -&gt; System.out.println(4);
            case APPLE,MANGO,GRAPE -&gt; System.out.println(5);
            case ORANGE,PAPAYA -&gt; System.out.println(6);
            default -&gt; throw new IllegalStateException("No Such Fruit:" + fruit);
        };
    }
}</code></pre>

<p>更进一步：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author shkstart
 * @create 2019 下午 10:44
 */
public class SwitchTest2 {
    public static void main(String[] args) {
        Fruit fruit = Fruit.GRAPE;
        int numberOfLetters = switch(fruit){
            case PEAR -&gt; 4;
            case APPLE,MANGO,GRAPE -&gt; 5;
            case ORANGE,PAPAYA -&gt; 6;
            default -&gt; throw new IllegalStateException("No Such Fruit:" + fruit);
        };
        System.out.println(numberOfLetters);
    }
}</code></pre>

<p><strong>JDK13中二次预览特性：</strong></p>
<p>JDK13中引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。</p>
<p>yield和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。</p>
<p>在以前：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testSwitch1(){
    String x = "3";
    int i;
    switch (x) {
        case "1":
            i=1;
            break;
        case "2":
            i=2;
            break;
        default:
            i = x.length();
            break;
    }
    System.out.println(i);
}</code></pre>

<p>在JDK13中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testSwitch2(){
    String x = "3";
    int i = switch (x) {
        case "1" -&gt; 1;
        case "2" -&gt; 2;
        default -&gt; {
            yield 3;
        }
    };
    System.out.println(i);
}</code></pre>

<p>或者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void testSwitch3() {
    String x = "3";
    int i = switch (x) {
        case "1":
            yield 1;
        case "2":
            yield 2;
        default:
            yield 3;
    };
    System.out.println(i);
}</code></pre>

<p><strong>JDK14中转正特性：</strong></p>
<p>这是JDK 12和JDK 13中的预览特性，现在是正式特性了。</p>
<p><strong>JDK17的预览特性：switch的模式匹配</strong></p>
<p>旧写法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static String formatter(Object o) {
    String formatted = "unknown";
    if (o instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (o instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (o instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (o instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}</code></pre>

<p>模式匹配新写法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case Integer i -&gt; String.format("int %d", i);
        case Long l    -&gt; String.format("long %d", l);
        case Double d  -&gt; String.format("double %f", d);
        case String s  -&gt; String.format("String %s", s);
        default        -&gt; o.toString();
    };
}</code></pre>

<p>直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。</p>
<h3 id="6-6-文本块"><a href="#6-6-文本块" class="headerlink" title="6.6 文本块"></a>6.6 文本块</h3><p>现实问题：</p>
<p>在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。</p>
<p><strong>JDK13的新特性</strong></p>
<p>使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。</p>
<p>基本使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"""
line1
line2
line3
"""</code></pre>

<p>相当于：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"line1\nline2\nline3\n"</code></pre>

<p>或者一个连接的字符串：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"line1\n" +
"line2\n" +
"line3\n"</code></pre>

<p>如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"""
line1
line2
line3"""</code></pre>

<p>相当于</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"line1\nline2\nline3"</code></pre>

<p>文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String empty = """
""";</code></pre>

<p>举例1：普通文本</p>
<p>原有写法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> String text1 = "The Sound of silence\n" +
                "Hello darkness, my old friend\n" +
                "I've come to talk with you again\n" +
                "Because a vision softly creeping\n" +
                "Left its seeds while I was sleeping\n" +
                "And the vision that was planted in my brain\n" +
                "Still remains\n" +
                "Within the sound of silence";

System.out.println(text1);</code></pre>

<p>使用新特性：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String text2 = """
                The Sound of silence
                Hello darkness, my old friend
                I've come to talk with you again
                Because a vision softly creeping
                Left its seeds while I was sleeping
                And the vision that was planted in my brain
                Still remains
                Within the sound of silence
                """;
System.out.println(text2);</code></pre>

<p>举例2：HTML语句</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
      &lt;p&gt;Hello, 尚硅谷&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>将其复制到Java的字符串中，会展示成以下内容：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"&lt;html&gt;\n" +
"    &lt;body&gt;\n" +
"        &lt;p&gt;Hello, 尚硅谷&lt;/p&gt;\n" +
"    &lt;/body&gt;\n" +
"&lt;/html&gt;\n";</code></pre>

<p>即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">"""
&lt;html&gt;
  &lt;body&gt;
      &lt;p&gt;Hello, world&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
""";</code></pre>

<p>举例3：SQL语句</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select employee_id,last_name,salary,department_id
from employees
where department_id in (40,50,60)
order by department_id asc</code></pre>

<p>原有方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String sql = "SELECT id,NAME,email\n" +
                "FROM customers\n" +
                "WHERE id &gt; 4\n" +
                "ORDER BY email DESC";</code></pre>

<p>使用新特性：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String sql1 = """
                SELECT id,NAME,email
                FROM customers
                WHERE id &gt; 4
                ORDER BY email DESC
                """;</code></pre>

<p>举例4：JSON字符串</p>
<p>原有方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String myJson = "{\n" +
                "    \"name\":\"Song Hongkang\",\n" +
                "     \"address\":\"www.atguigu.com\",\n" +
                "    \"email\":\"shkstart@126.com\"\n" +
                "}";
System.out.println(myJson);</code></pre>

<p>使用新特性：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String myJson1 = """
                {
                    "name":"Song Hongkang",
                     "address":"www.atguigu.com",
                    "email":"shkstart@126.com"
                }""";
System.out.println(myJson1);</code></pre>

<p><strong>JDK14中二次预览特性</strong></p>
<p>JDK14的版本主要增加了两个escape sequences，分别是<code> \ &lt;line-terminator&gt;</code>与<code>\s  escape sequence</code>。</p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author shkstart
 * @create 下午 7:13
 */
public class Feature05 {
    //jdk14新特性
    @Test
    public void test5(){
        String sql1 = """
                SELECT id,NAME,email
                FROM customers
                WHERE id &gt; 4
                ORDER BY email DESC
                """;
        System.out.println(sql1);

        // \:取消换行操作
        // \s:表示一个空格
        String sql2 = """
                SELECT id,NAME,email \
                FROM customers\s\
                WHERE id &gt; 4 \
                ORDER BY email DESC
                """;
        System.out.println(sql2);
    }
}</code></pre>

<p><strong>JDK15中功能转正</strong></p>
<h3 id="6-7-Record"><a href="#6-7-Record" class="headerlink" title="6.7 Record"></a>6.7 Record</h3><p><code>背景</code></p>
<p>早在2019年2月份，Java 语言架构师 Brian Goetz，曾写文抱怨“<code>Java太啰嗦</code>”或有太多的“繁文缛节”。他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter/setter、equals()、hashCode()以及toString()等。</p>
<p>以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。</p>
<p><strong>JDK14中预览特性：神说要用record，于是就有了。</strong>实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。</p>
<p><code>record</code> 是一种全新的类型，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> 、<code>hashcode</code> 、<code>equals</code>、<code>toString</code>、构造器等结构，减少了代码编写量。</p>
<p>具体来说：当你用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p>
<ul>
<li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li>
<li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li>
<li>重写 hashCode() 方法。</li>
<li>一个可以打印该类所有成员属性的 toString() 方法。</li>
<li>只有一个构造方法。</li>
</ul>
<p>此外：</p>
<ul>
<li><p>还可以在record声明的类中定义静态字段、静态方法、构造器或实例方法。</p>
</li>
<li><p>不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。</p>
</li>
</ul>
<p>举例1（旧写法）：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Point {
    private final int x;
    private final int y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    int x() {
        return x;
    }

    int y() {
        return y;
    }

    public boolean equals(Object o) {
        if (!(o instanceof Point)) return false;
        Point other = (Point) o;
        return other.x == x &amp;&amp; other.y == y;
    }

    public int hashCode() {
        return Objects.hash(x, y);
    }

    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}</code></pre>

<p>举例1（新写法）：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">record Point(int x, int y) { }</code></pre>

<p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public record Dog(String name, Integer age) {
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Java14Record {

    public static void main(String[] args) {
        Dog dog1 = new Dog("牧羊犬", 1);
        Dog dog2 = new Dog("田园犬", 2);
        Dog dog3 = new Dog("哈士奇", 3);
        System.out.println(dog1);
        System.out.println(dog2);
        System.out.println(dog3);
    }
}</code></pre>

<p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 *  Record类型的演示
 *
 * @author shkstart
 * @create 下午 6:13
 */
public class Feature07 {
    @Test
    public void test1(){
        //测试构造器
        Person p1 = new Person("罗密欧",new Person("zhuliye",null));
        //测试toString()
        System.out.println(p1);
        //测试equals():
        Person p2 = new Person("罗密欧",new Person("zhuliye",null));
        System.out.println(p1.equals(p2));

        //测试hashCode()和equals()
        HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();
        set.add(p1);
        set.add(p2);

        for (Person person : set) {
            System.out.println(person);
        }

        //测试name()和partner():类似于getName()和getPartner()
        System.out.println(p1.name());
        System.out.println(p1.partner());

    }

    @Test
    public void test2(){
        Person p1 = new Person("zhuyingtai");

        System.out.println(p1.getNameInUpperCase());

        Person.nation = "CHN";
        System.out.println(Person.showNation());

    }
}</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * @author shkstart
 * @create 下午 6:20
 */
public record Person(String name,Person partner) {

    //还可以声明静态的属性、静态的方法、构造器、实例方法

    public static String nation;

    public static String showNation(){
        return nation;
    }

    public Person(String name){
        this(name,null);
    }

    public String getNameInUpperCase(){
        return name.toUpperCase();
    }
    //不可以声明非静态的属性
//    private int id;//报错
}

//不可以将record定义的类声明为abstract的
//abstract record Order(){
//
//}

//不可以给record定义的类声明显式的父类（非Record类）
//record Order() extends Thread{
//
//}</code></pre>

<p><strong>JDK15中第二次预览特性</strong></p>
<p><strong>JDK16中转正特性</strong></p>
<p>最终到JDK16中转正。</p>
<p><code>记录不适合哪些场景</code></p>
<p>record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。</p>
<h3 id="6-8-密封类"><a href="#6-8-密封类" class="headerlink" title="6.8 密封类"></a>6.8 密封类</h3><p>背景：</p>
<p>在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 <code>final</code> 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 <code>sealed</code> 类，被 <code>sealed</code> 修饰的类可以指定子类。这样这个类就只能被指定的类继承。</p>
<p><strong>JDK15的预览特性：</strong></p>
<p>通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。</p>
<p>具体使用：</p>
<ul>
<li><p>使用修饰符<code>sealed</code>，可以将一个类声明为密封类。密封的类使用保留关键字<code>permits</code>列出可以直接扩展（即extends）它的类。</p>
</li>
<li><p><code>sealed</code> 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 三者之一。</p>
</li>
</ul>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.java;
public abstract sealed class Shape permits Circle, Rectangle, Square {...}

public final class Circle extends Shape {...} //final表示Circle不能再被继承了

public sealed class Rectangle extends Shape permits TransparentRectangle, FilledRectangle {...}

public final class TransparentRectangle extends Rectangle {...}

public final class FilledRectangle extends Rectangle {...}

public non-sealed class Square extends Shape {...} //non-sealed表示可以允许任何类继承</code></pre>

<p><strong>JDK16二次预览特性</strong></p>
<p><strong>JDK17中转正特性</strong></p>
<h2 id="7-API的变化"><a href="#7-API的变化" class="headerlink" title="7. API的变化"></a>7. API的变化</h2><h3 id="7-1-Optional类"><a href="#7-1-Optional类" class="headerlink" title="7.1 Optional类"></a>7.1 Optional类</h3><p><strong>JDK8的新特性</strong></p>
<p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。</p>
<p><code>Optional&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<ul>
<li><p><code>创建Optional类对象的方法：</code></p>
</li>
<li><p>static <t> Optional<t> empty() ：用来创建一个空的Optional实例</t></t></p>
<ul>
<li>static <t> Optional<t> of(T value) ：用来创建一个Optional实例，value必须非空</t></t></li>
<li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> ：用来创建一个Optional实例，value可能是空，也可能非空</li>
</ul>
</li>
<li><p><code>判断Optional容器中是否包含对象：</code></p>
<ul>
<li>boolean isPresent() : 判断Optional容器中的值是否存在</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做</li>
</ul>
</li>
<li><p><code>获取Optional容器的对象：</code></p>
</li>
<li><p>T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用</p>
</li>
<li><p><code>T orElse(T other) </code>：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替</p>
</li>
<li><p>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替</p>
</li>
<li><p>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException</p>
</li>
</ul>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.optional;

import java.util.Optional;

import org.junit.Test;

public class TestOptional {
	@Test
    public void test1(){
        String str = "hello";
        Optional&lt;String&gt; opt = Optional.of(str);
        System.out.println(opt);
    }
    @Test
    public void test2(){
        Optional&lt;String&gt; opt = Optional.empty();
        System.out.println(opt);
    }
    @Test
    public void test3(){
        String str = null;
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
        System.out.println(opt);
    }
    @Test
    public void test4(){
        String str = "hello";
        Optional&lt;String&gt; opt = Optional.of(str);

        String string = opt.get();
        System.out.println(string);
    }
    @Test
    public void test5(){
        String str = null;
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
//		System.out.println(opt.get());//java.util.NoSuchElementException: No value present
    }
    @Test
    public void test6(){
        String str = "hello";
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
        String string = opt.orElse("atguigu");
        System.out.println(string);
    }
    @Test
    public void test7(){
        String str = null;
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
        String string = opt.orElseGet(String::new);
        System.out.println(string);
    }
    @Test
    public void test8(){
        String str = null;
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
        String string = opt.orElseThrow(()-&gt;new RuntimeException("值不存在"));
        System.out.println(string);
    }
    @Test
    public void test9(){
        String str = "Hello1";
        Optional&lt;String&gt; opt = Optional.ofNullable(str);
        //判断是否是纯字母单词，如果是，转为大写，否则保持不变
        String result = opt.filter(s-&gt;s.matches("[a-zA-Z]+"))
                .map(s -&gt; s.toUpperCase()).orElse(str);
        System.out.println(result);
    }
}
</code></pre>

<p><strong>这是JDK9-11的新特性</strong></p>
<table>
<thead>
<tr>
<th><strong>新增方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>新增的版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK  11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value为空，执行参数2功能</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</t></td>
<td>value非空，返回对应的Optional；value为空，返回形参封装的Optional</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Stream<t> stream()</t></td>
<td>value非空，返回仅包含此value的Stream；否则，返回一个空的Stream</td>
<td>JDK  9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常NoSuchElementException</td>
<td>JDK  10</td>
</tr>
</tbody></table>
<h3 id="7-2-String存储结构和API变更"><a href="#7-2-String存储结构和API变更" class="headerlink" title="7.2 String存储结构和API变更"></a>7.2 String存储结构和API变更</h3><p><strong>这是JDK9的新特性。</strong></p>
<p>产生背景：</p>
<blockquote>
<p>Motivation<br>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p>
</blockquote>
<p>使用说明：</p>
<blockquote>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>
</blockquote>
<p>结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    @Stable
    private final byte[] value;
	...
}</code></pre>

<p>拓展：StringBuffer 与 StringBuilder</p>
<p>那StringBuffer 和 StringBuilder 是否仍无动于衷呢？</p>
<blockquote>
<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
</blockquote>
<p><strong>JDK11新特性：新增了一系列字符串处理方法</strong></p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“  “.isBlank(); // true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“  Javastack “.strip(); // “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“  Javastack “.stripTrailing(); // “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“  Javastack “.stripLeading(); // “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);//  “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count();  // 3</td>
</tr>
</tbody></table>
<p><strong>JDK12新特性：String 实现了 Constable 接口</strong></p>
<p>String源码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc {</code></pre>

<p>java.lang.constant.Constable接口定义了抽象方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Constable {
	Optional&lt;? extends ConstantDesc&gt; describeConstable();
}</code></pre>

<p>Java 12 String 的实现源码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
 * Returns an {@link Optional} containing the nominal descriptor for this
 * instance, which is the instance itself.
 *
 * @return an {@link Optional} describing the {@linkplain String} instance
 * @since 12
 */
@Override
public Optional&lt;String&gt; describeConstable() {
	return Optional.of(this);
}</code></pre>

<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。</p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static void testDescribeConstable() {
	String name = "尚硅谷Java高级工程师";
	Optional&lt;String&gt; optional = name.describeConstable();
	System.out.println(optional.get());
}</code></pre>

<p>结果输出：</p>
<pre class="line-numbers language-none"><code class="language-none">尚硅谷Java高级工程师</code></pre>

<p><strong>JDK12新特性：String新增方法</strong></p>
<p>String的transform(Function)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">var result = "foo".transform(input -&gt; input + " bar");
System.out.println(result); //foo bar</code></pre>

<p>或者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">var result = "foo".transform(input -&gt; input + " bar").transform(String::toUpperCase)
System.out.println(result); //FOO BAR</code></pre>

<p>对应的源码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
* This method allows the application of a function to {@code this}
* string. The function should expect a single String argument
* and produce an {@code R} result.
* @since 12
*/
public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {
 return f.apply(this);
}</code></pre>

<p>在某种情况下，该方法应该被称为map()。</p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static void testTransform() {
	System.out.println("======test java 12 transform======");
	List&lt;String&gt; list1 = List.of("Java", " Python", " C++ ");
	List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
	list1.forEach(element -&gt; list2.add(element.transform(String::strip)
								  .transform(String::toUpperCase)
								  .transform((e) -&gt; "Hi," + e))
				 );
	list2.forEach(System.out::println);
}</code></pre>

<p>结果输出：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">======test java 12 transform======
Hi,JAVA
Hi,PYTHON
Hi,C++</code></pre>

<p>如果使用Java 8的Stream特性，可以如下实现：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static void testTransform1() {
        System.out.println("======test before java 12 ======");
        List&lt;String&gt; list1 = List.of("Java  ", " Python", " C++ ");

        Stream&lt;String&gt; stringStream = list1.stream().map(element -&gt; element.strip()).map(String::toUpperCase).map(element -&gt; "Hello," + element);
        List&lt;String&gt; list2 = stringStream.collect(Collectors.toList());
        list2.forEach(System.out::println);
    }</code></pre>

<h3 id="7-3-JDK17：标记删除Applet-API"><a href="#7-3-JDK17：标记删除Applet-API" class="headerlink" title="7.3 JDK17：标记删除Applet API"></a>7.3 JDK17：标记删除Applet API</h3><p>Applet API 提供了一种将 Java AWT/Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。</p>
<p>Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。</p>
<p>具体如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">java.applet.Applet
java.applet.AppletStub
java.applet.AppletContext
java.applet.AudioClip
javax.swing.JApplet
java.beans.AppletInitializer</code></pre>

<h2 id="8-其它结构变化"><a href="#8-其它结构变化" class="headerlink" title="8.  其它结构变化"></a>8.  其它结构变化</h2><h3 id="8-1-JDK9：UnderScore-下划线-使用的限制"><a href="#8-1-JDK9：UnderScore-下划线-使用的限制" class="headerlink" title="8.1 JDK9：UnderScore(下划线)使用的限制"></a>8.1 JDK9：UnderScore(下划线)使用的限制</h3><p>在java 8 中，标识符可以独立使用“_”来命名：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String _ = "hello";
System.out.println(_);</code></pre>

<p>但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错：</p>
<p><img src="image-20220527233322495.png" alt="image-20220527233322495"></p>
<h3 id="8-2-JDK11：更简化的编译运行程序"><a href="#8-2-JDK11：更简化的编译运行程序" class="headerlink" title="8.2 JDK11：更简化的编译运行程序"></a>8.2 JDK11：更简化的编译运行程序</h3><p>看下面的代码。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">// 编译
javac JavaStack.java

// 运行
java JavaStack</code></pre>

<p>我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">java JavaStack.java</code></pre>

<p>注意点：</p>
<ul>
<li>执行源文件中的第一个类，第一个类必须包含主方法。</li>
</ul>
<h3 id="8-3-GC方面新特性"><a href="#8-3-GC方面新特性" class="headerlink" title="8.3 GC方面新特性"></a>8.3 GC方面新特性</h3><p>GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。</p>
<h4 id="8-3-1-G1-GC"><a href="#8-3-1-G1-GC" class="headerlink" title="8.3.1 G1 GC"></a>8.3.1 G1 GC</h4><p>JDK9以后默认的垃圾回收器是G1GC。</p>
<p><strong>JDK10 : 为G1提供并行的Full GC</strong></p>
<p>G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。</p>
<p>在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。</p>
<p>你可以通过<code>-XX:ParallelGCThreads</code>参数来指定用于并行GC的线程数。</p>
<p><strong>JDK12：可中断的 G1 Mixed GC</strong></p>
<p><strong>JDK12：增强G1，自动返回未用堆内存给操作系统</strong></p>
<h4 id="8-3-2-Shenandoah-GC"><a href="#8-3-2-Shenandoah-GC" class="headerlink" title="8.3.2 Shenandoah GC"></a>8.3.2 Shenandoah GC</h4><p><strong>JDK12：Shenandoah GC：低停顿时间的GC</strong></p>
<p><img src="image-20220528212254705.png" alt="image-20220528212254705"></p>
<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在<strong>针对 JVM 上的内存收回实现低停顿的需求</strong>。</p>
<p>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p>Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。</p>
<p>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p>
<p>Shenandoah开发团队在实际应用中的测试数据：</p>
<p><img src="image-20220528212323729.png" alt="image-20220528212323729"></p>
<p><strong>JDK15：Shenandoah垃圾回收算法转正</strong></p>
<p>Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。</p>
<p>Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseShenandoahGC</code>来启用，现在只需要<code>-XX:+UseShenandoahGC</code>即可启用</p>
<h4 id="8-3-3-革命性的-ZGC"><a href="#8-3-3-革命性的-ZGC" class="headerlink" title="8.3.3 革命性的 ZGC"></a>8.3.3 革命性的 ZGC</h4><p><strong>JDK11：引入革命性的 ZGC</strong></p>
<p>ZGC，这应该是JDK11最为瞩目的特性，没有之一。 </p>
<p>ZGC是一个并发、基于region、压缩型的垃圾收集器。</p>
<p>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p>
<p><strong>JDK13：ZGC:将未使用的堆内存归还给操作系统</strong></p>
<p><strong>JDK14：ZGC on macOS和windows</strong></p>
<ul>
<li><p>JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre>
</li>
<li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在<code>十毫秒以内</code>的低延迟。</p>
</li>
</ul>
<p><img src="image-20220528212414676.png" alt="image-20220528212414676"></p>
<p><img src="image-20220528212421319.png" alt="image-20220528212421319"></p>
<p><strong>JDK15：ZGC 功能转正</strong></p>
<p>ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。</p>
<p>但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code>、<code> -XX:+UseZGC</code>来启用ZGC，现在只需要<code>-XX:+UseZGC</code>就可以。相信不久的将来它必将成为默认的垃圾回收器。</p>
<blockquote>
<p>ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</blockquote>
<p>怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：</p>
<ul>
<li>相同点：性能几乎可认为是相同的</li>
<li>不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<p><strong>JDK16：ZGC 并发线程处理</strong></p>
<p>在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。</p>
<blockquote>
<p>回顾：</p>
<p>我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 <strong>Stop The World</strong>。</p>
<p>而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做<strong>安全点（Safepoints）</strong>。</p>
</blockquote>
<p>而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。</p>
<h2 id="9-小结与展望"><a href="#9-小结与展望" class="headerlink" title="9. 小结与展望"></a>9. 小结与展望</h2><p>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。<strong>传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS， Function-as-a-Service)所替代。</strong></p>
<p><strong>Java 需要在新的计算场景下，改进开发效率。</strong>比如，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。</p>
<p>Java虽然标榜面向对象编程，却毫不顾忌的加入<code>面向接口编程思想</code>，又扯出<code>匿名对象</code>的概念，每增加一个新的东西，对Java的根本（面向对象思想）的一次冲击。</p>
 
      </div>
      <hr />

      

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Nanying</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://nan-ying.github.io/2023/05/01/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%9318-JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7/">https://nan-ying.github.io/2023/05/01/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%9318-JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Nanying</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



      <div class="tag_share" style="display: block">
        <div class="post-meta__tag-list" style="display: inline-block">
          
          <div class="article-tag">
            
            <a href="/tags/Java/">
              <span class="chip bg-color">Java</span>
            </a>
            
          </div>
          
        </div>
        <div
          class="post_share"
          style="
            zoom: 80%;
            width: fit-content;
            display: inline-block;
            float: right;
            margin: -0.15rem 0;
          "
        >
          <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

        </div>
      </div>
       <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
 
    </div>
  </div>

   <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'db88556d05226db24d16',
        clientSecret: '4981b218ad88ef98f3df857ee9ba26b05bb54051',
        repo: 'blog-comment',
        owner: 'Nan-ying',
        admin: "Nan-ying",
        id: '2023-05-01T12-27-24',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
         

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/05/11/JDBC/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="JDBC">
                        
                        <span class="card-title">JDBC</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-05-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaWeb/" class="post-category">
                                    JavaWeb
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JDBC/">
                        <span class="chip bg-color">JDBC</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/04/24/Java%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%9317-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="Java知识整理和总结17-反射机制">
                        
                        <span class="card-title">Java知识整理和总结17-反射机制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-04-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>

 <!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


 <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="896147692"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>
 

  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2022-2024</span
      >
      
      <a href="/about" target="_blank"
        >Nanying.
      </a>
      <span class="with-love" id="heart"
        ><i class="fa fa-heart" style="color: #ff71a8"></i>
      </span>
      &nbsp;|&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank"
        >Hexo</a
      >
      <!-- |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      > -->
      
      <br />

      <!-- 时间统计 -->
      
      <span id="sitetime"> Loading ...</span
      ><span class="my-face"> ღゝ◡╹)ノ♡</span>
      <script>
        var calcSiteTime = function () {
          window.setTimeout("calcSiteTime()", 1000);
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              daysTip =
                "本站已运行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              daysTip =
                "本站已運行 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days" +
              diffHours +
              " hours " +
              diffMinutes +
              " minutes " +
              diffSeconds +
              " seconds";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " +
                diffYears +
                " 年 " +
                diffDays +
                " 天" +
                diffHours +
                " 小时 " +
                diffMinutes +
                " 分钟 " +
                diffSeconds +
                " 秒";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script>
      
      <br />

      <!-- 字数、访客统计 -->
       &nbsp;<i
        class="fas fa-chart-area"
      ></i
      >&nbsp;站点总字数:&nbsp;<span class="white-color"
        >786.6k</span
      >
         
       
      <span id="busuanzi_container_site_pv"></span>
      &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
      <span id="busuanzi_value_site_pv" class="white-color"></span>

       
      <span id="busuanzi_container_site_uv"></span>
      &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
      <span id="busuanzi_value_site_uv" class="white-color"></span>

      
      <br />

      <!-- 运行天数提醒. -->
      <!--  -->
      <!-- <span id="sitetime"> Loading ...</span>
      <script>
        var calcSiteTime = function () {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2022";
          var startMonth = "12";
          var startDate = "10";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);

          // 区分是否有年份.
          var language = "zh-CN";
          if (startYear === String(todayYear)) {
            document.getElementById("year").innerHTML = todayYear;
            var daysTip =
              "This site has been running for " + diffDays + " days";
            if (language === "zh-CN") {
              daysTip = "本站已运行 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              daysTip = "本站已運行 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = daysTip;
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            var yearsAndDaysTip =
              "This site has been running for " +
              diffYears +
              " years and " +
              diffDays +
              " days";
            if (language === "zh-CN") {
              yearsAndDaysTip =
                "本站已运行 " + diffYears + " 年 " + diffDays + " 天";
            } else if (language === "zh-HK") {
              yearsAndDaysTip =
                "本站已運行 " + diffYears + " 年 " + diffDays + " 天";
            }
            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
          }
        };

        calcSiteTime();
      </script> -->
      <!--  -->
      <!-- <br /> -->
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/Nan-ying"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:wangxinwan_wy@163.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2442926123"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 2442926123"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
 
<a
  href="https://blog.csdn.net/weixin_42771853?type=blog"
  class="tooltipped"
  target="_blank"
  data-tooltip="关注我的csdn: https://blog.csdn.net/weixin_42771853?type=blog"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-rss"></i>
</a>
 
<a
  href="https://weibo.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到微博"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-weibo"></i>
</a>
 
<a
  href="https://www.zhihu.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="跳转到知乎"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-zhihu1">知</i>
</a>
 

    </div>
  </div>
</footer>

<div class="progress-bar"></div>
 <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
 <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>
 <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

      

    <!-- 雪花特效 -->
    
    <script type="text/javascript">
      // 只在桌面版网页启用特效
      var windowWidth = $(window).width();
      if (windowWidth > 768) {
        document.write(
          '<script type="text/javascript" src="/libs/others/snow.js"><\/script>'
        );
      }
    </script>
    

    <!-- 鼠标星星特效 -->
     
    <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
    <script src="/libs/others/TencentCaptcha.js"></script>
    <button
      id="TencentCaptcha"
      data-appid="xxxxxxxxxx"
      data-cbfn="callback"
      type="button"
      hidden
    ></button>
     <!-- Baidu Analytics -->
 <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
 
    <script
      src="/libs/others/clicklove.js"
      async="async"
    ></script>
     
    <script
      async
      src="/libs/others/busuanzi.pure.mini.js"
    ></script>
      

    <!--腾讯兔小巢-->
       
    <script
      type="text/javascript"
      src="/libs/background/ribbon-dynamic.js"
      async="async"
    ></script>
     
    <script
      src="/libs/instantpage/instantpage.js"
      type="module"
    ></script>
    

    <!-- 动态标签 -->
    <script type="text/javascript">
      var OriginTitile = document.title,
        st;
      document.addEventListener("visibilitychange", function () {
        document.hidden
          ? ((document.title = "看不见我🙈~看不见我🙈~"), clearTimeout(st))
          : ((document.title = "(๑•̀ㅂ•́) ✧被发现了～"),
            (st = setTimeout(function () {
              document.title = OriginTitile;
            }, 3e3)));
      });
    </script>
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"react":{"opacity":1}});</script></body>
</html>
