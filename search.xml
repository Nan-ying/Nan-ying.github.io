<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css 之预处理器 less 语法</title>
      <link href="/20232/12/24/css-%E4%B9%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less-%E8%AF%AD%E6%B3%95/"/>
      <url>/20232/12/24/css-%E4%B9%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>常见的预处理器：</p><ul><li>Sass/Scss：<ul><li>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分</li><li>目前受LESS影响，已经进化到了全面兼容CSS的SCSS</li></ul></li><li>Less:<ul><li>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手</li><li>比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用</li><li>另外反过来也影响了SASS演变到了SCSS的时代</li><li>著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括React的UI框架AntDesign。</li></ul></li><li>Stylus:<ul><li>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持</li><li>语法偏向于Python, 使用率相对于Sass/Less少很多</li></ul></li></ul><h1 id="1-less-语法"><a href="#1-less-语法" class="headerlink" title="1. less 语法"></a>1. less 语法</h1><p>less 代码如何被编译成CSS代码运行：</p><ul><li>方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译</li><li>方法二：通过VSCode插件来编译成CSS或者在线编译<ul><li><a href="https://lesscss.org/less-preview/">https://lesscss.org/less-preview/</a></li></ul></li><li>方式三：引入CDN的less编译代码，对less进行实时的处理<ul><li><code>&lt;script src="https://cdn.jsdelivr.net/npm/less@4" &gt;&lt;/script&gt;</code></li></ul></li><li>方式四：将less编译的js代码下载到本地，执行js代码对less进行编译</li></ul><h2 id="1-1-变量（Variables）"><a href="#1-1-变量（Variables）" class="headerlink" title="1.1 变量（Variables）"></a>1.1 变量（Variables）</h2><p>在Less中使用如下的格式来定义变量：</p><p><code>@变量名: 变量值;</code></p><h2 id="1-2-嵌套（Nesting）"><a href="#1-2-嵌套（Nesting）" class="headerlink" title="1.2 嵌套（Nesting）"></a>1.2 嵌套（Nesting）</h2><p>Less提供了选择器的嵌套</p><p>特殊符号：&amp; 表示当前选择器的父级</p><pre class="line-numbers language-less" data-language="less"><code class="language-less">// 1.定义变量@mainColor: #a40011;@smallFontSize: 12px;@normalFontSize: 14px;@bigFontSize: 18px;// 2.选择器的嵌套.box {.pel {color: @mainColor;font-size: @normalFontSize;}h1 {.keyword {color: @mainColor;font-size: @bigFontSize;}}p {a.link {color: @mainColor;font-size: @smallFontSize;background-color: #0f0;&amp;:hover {// 等于 a:hovercolor: #00f;}}}}</code></pre><h2 id="1-3-运算（Operations）"><a href="#1-3-运算（Operations）" class="headerlink" title="1.3 运算（Operations）"></a>1.3 运算（Operations）</h2><p>在Less中，算术运算符 +、-、 * 、/ 可以对任何数字、颜色或变量进行运算。</p><ul><li>算术运算符在加、减或比较之前会进行单位换算，计算的结果<strong>以最左侧操作数的单位类型</strong>为准</li><li>如果单位换算无效或失去意义，则忽略单位</li></ul><h2 id="1-4-混合（Mixins）和映射（Maps）"><a href="#1-4-混合（Mixins）和映射（Maps）" class="headerlink" title="1.4 混合（Mixins）和映射（Maps）"></a>1.4 混合（Mixins）和映射（Maps）</h2><p>混合是一种将一组属性<strong>从一个规则集（或混入）到另一个规则集</strong>的方法</p><ul><li>混入也可以传入变量</li></ul><p>映射是提取一组属性中的某个属性的方法</p><pre class="line-numbers language-less" data-language="less"><code class="language-less">// 1.运算// .box {//   font-size: 20px;//   width: 10% + 50px;//   height: 100px;//   background-color: #ff0000 + #00ff00;// }// 2.混入.nowrap_ellipsis {white-space: nowrap;text-overflow: ellipsis;overflow: hidden;}.box_border(@borderWidth: 5px, @borderColor: purple) {border: @borderWidth solid @borderColor;}  .box_size {width: 100px;height: 100px;}.box1 {// 2.3.混入和映射(Map)结合使用// 作用: 弥补less中不能自定义函数的缺陷width: .box_size()[width];background-color: #f00;// 2.1. 混入的基本使用.nowrap_ellipsis();.box_border();}.box2 {width: 150px;background-color: #0f0;.nowrap_ellipsis();// 2.2.混入是可以传递参数(定义变量)的.box_border(10px, orange);}</code></pre><h2 id="1-5-其他语法补充"><a href="#1-5-其他语法补充" class="headerlink" title="1.5 其他语法补充"></a>1.5 其他语法补充</h2><ul><li>extend继承：<ul><li>和mixins作用类似，用于复用代码</li><li>和mixins相比，继承代码最终会转化成并集选择器</li></ul></li><li>Less内置函数：<ul><li>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等</li><li><strong>内置函数手册</strong>：<a href="https://less.bootcss.com/functions/">https://less.bootcss.com/functions/</a></li></ul></li><li>作用域：<ul><li>在查找一个变量时，首先在本地查找变量和混合（mixins）</li><li>如果找不到，则从“父”级作用域继承</li></ul></li><li>导入：<ul><li><strong>导入的方式和CSS的用法是一致的</strong></li><li>导入一个 .less 文件，此文件中的所有变量就可以全部使用了</li><li>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````less// 1.extend// .box_border {//   border: 5px solid #f00;// }// .box {//   width: 100px;//   background-color: orange;//   .box_border();//   &amp;:extend(.box_border);// }// 2.内置函数// .box {//   color: color(skyblue);//   width: convert(100px, "in");//   font-size: ceil(18.5px);//   background-color: orange;// }// 3.作用域(scope)@mainColor: #f00;.box_mixin {@mainColor: orange;}.box {// @mainColor: #0f0;.item {span {color: @mainColor;.box_mixin();// @mainColor: #00f;}}}</code></pre><h1 id="2-认识-Sass-和-Scss"><a href="#2-认识-Sass-和-Scss" class="headerlink" title="2. 认识 Sass 和 Scss"></a>2. 认识 Sass 和 Scss</h1><p>Sass的语法使用的是类似于Ruby的语法，<strong>没有花括号，没有分号，具有严格的缩进</strong>；后来官方推出了全新的语法SCSS，意思是Sassy CSS，他是<strong>完全兼容CSS的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里iconfont的使用方法</title>
      <link href="/2023/11/15/%E9%98%BF%E9%87%8Ciconfont%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/15/%E9%98%BF%E9%87%8Ciconfont%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最近学习CSS中研究了一下阿里妈妈出品的阿里iconfont图标的引入方法。网页的各种常用图标引入不愁啦~</p><p>主要分为<strong>线上引用</strong>和<strong>本地引用</strong>（更稳定）。</p><h3 id="一、线上引用"><a href="#一、线上引用" class="headerlink" title="一、线上引用"></a>一、线上引用</h3><p>不足：线上引用比较依赖阿里iconfont图标平台的稳定性</p><p>优势：方便，不需下载文件至本地，推荐日常练习时使用</p><p><strong>1. 寻找图标</strong></p><p>打开网站<a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p><ul><li>图标管理-&gt;我的项目-&gt;然后<strong>新建项目</strong></li><li>选择图标添加到购物车-&gt;购物车中选择<strong>加入项目</strong>，将图标加入项目</li><li>打开项目<br><img src="8e92705d9346483e858e895c2cf63d38.png" alt="在这里插入图片描述"></li></ul><p> 此时可以看到我们将三个箭头图标添加进了项目中。</p><p><strong>2. 引入图标</strong></p><p>首先复制链接（点此复制代码）<br><img src="ac5dd43ab6504a9086f23f51cf70ebf3.png" alt="在这里插入图片描述"></p><p>然后在css中<code>&lt;head&gt;&lt;/head&gt;</code>内插入<code>&lt;link&gt;</code>，注意加上http:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;</code></pre><p>此时需要在html结构中引用这些图标</p><p>可以看到，红框中为三个图标各自对应的类名<br><img src="5daaadc1391e47c2a9e5fbe924ef206d.png" alt="在这里插入图片描述"></p><p>在引入时，分别引入这些类名即可</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;!-- 引入在线链接 --&gt;&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;&lt;style&gt;span {/* 图标颜色变为粉色 */color: pink;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 引入各图标，iconfont为图标字体类名，必写 --&gt;&lt;span class="iconfont icon-shangla1"&gt;&lt;/span&gt;&lt;span class="iconfont icon-jinrujiantou"&gt;&lt;/span&gt;&lt;span class="iconfont icon-xiala"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>3. 更改图标</strong></p><ul><li>更改颜色：可直接在文件样式style中更改</li><li>更改字体：需要复制.iconfont代码，在其中更改<code>font-size</code></li></ul><p>获取.iconfont：点击红框处，在弹出页面找到.iconfont</p><p><img src="4f0c5887f40a46ae8530bdbccaa43ab7.png" alt="在这里插入图片描述"><br><img src="13398e5109ae4a6eab6430294dd0233d.png" alt="在这里插入图片描述"></p><h3 id="二、本地引用"><a href="#二、本地引用" class="headerlink" title="二、本地引用"></a>二、本地引用</h3><p>不足：没有线上引用方便</p><p>优势：稳定</p><p><strong>1. 下载图标</strong></p><p>打开网站<a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p><ul><li>图标管理-&gt;我的项目-&gt;然后<strong>新建项目</strong></li><li>选择图标添加到购物车-&gt;购物车中选择<strong>加入项目</strong>，将图标加入项目</li><li>打开项目-&gt;下载到本地-&gt;放入本地项目的根目录下<br><img src="f0ea2af40dab4adb94c22caed4691aea.png" alt="在这里插入图片描述"></li></ul><p>fonts为下载的图标文件夹</p><p><strong>2. 引入图标</strong></p><p>在文件中引入iconfont.css，fonts为图标文件夹名称</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;link rel="stylesheet" href="fonts/iconfont.css"&gt;</code></pre><p>然后在html结构中引用这些图标，与线上引用类似</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!-- 引入图标文件 --&gt;    &lt;link rel="stylesheet" href="fonts/iconfont.css"&gt;    &lt;style&gt;        span {            /* 图标颜色变为粉色 */            color: pink;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 引入各图标，iconfont为图标字体类名，必写 --&gt;    &lt;span class="iconfont icon-shangla1"&gt;&lt;/span&gt;    &lt;span class="iconfont icon-jinrujiantou"&gt;&lt;/span&gt;    &lt;span class="iconfont icon-xiala"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="PS-添加-font-family-和-content-的引入方法"><a href="#PS-添加-font-family-和-content-的引入方法" class="headerlink" title="PS: 添加 font-family 和 content 的引入方法"></a>PS: 添加 font-family 和 content 的引入方法</h3><p>以上方法都是需要在元素中加入class属性。</p><p>在使用过程中，我发现了另一种引入方法：此方法不需要在元素中添加class属性，<strong>支持伪元素选择器添加图标</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;!-- 引入线上链接 --&gt;&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;&lt;style&gt;div::after {/* content中为下拉符 */content: '\e69a';/* 一定要添加font-family属性 */font-family: 'iconfont';}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;更多推荐&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>ps：content中的内容在此找<br><img src="d8391a0b2695468ba33cca66e1519154.png" alt="在这里插入图片描述"><br><img src="d3f00bd9c72d4cf682d1d8ed7a9088cc.png" alt="在这里插入图片描述"></p><p><strong>代码效果如下：</strong><br><img src="82c795b941f141f489f123f7de525ad8.png" alt="在这里插入图片描述"></p><p>此方法常用于<strong>使用伪元素选择器（<code>::before</code>,<code>::after</code>）添加图标时</strong>（此时无法在html结构中引入iconfont等class类名）</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/2023/10/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/"/>
      <url>/2023/10/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>先建表，然后创建一个SpringBoot的工程，勾选<code>Spring Web</code>，<code>MySQL</code>，然后在pom中引入其他</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.76&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-lang&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.20&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>导入前端资源，放在<code>resources</code>目录下。直接放在<code>resources</code>目录下，需要配置一下资源映射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        log.info("开始进行静态资源映射...");        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");    }}</code></pre><p>之后配置一下yml文件就能访问静态页面了</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8080spring:  application:    name: reggie_take_out  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true      username: root      password: 123456mybatis-plus:  configuration:    map-underscore-to-camel-case: true    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    db-config:      id-type: ASSIGN_ID</code></pre><p>打开浏览器，访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a> 可以看到登录页面，不过此时无法登录</p><h2 id="2-后台系统登录功能分析"><a href="#2-后台系统登录功能分析" class="headerlink" title="2. 后台系统登录功能分析"></a>2. 后台系统登录功能分析</h2><h3 id="2-1-创建对应的实体类"><a href="#2-1-创建对应的实体类" class="headerlink" title="2.1 创建对应的实体类"></a>2.1 创建对应的实体类</h3><p>创建一个Employee类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    private LocalDateTime createTime;    private LocalDateTime updateTime;    private Long createUser;    private Long updateUser;}</code></pre><h3 id="2-2-创建对应的Mapper和Service"><a href="#2-2-创建对应的Mapper和Service" class="headerlink" title="2.2 创建对应的Mapper和Service"></a>2.2 创建对应的Mapper和Service</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface EmployeeMapper extends BaseMapper&lt;Employee&gt; {}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EmployeeService extends IService&lt;Employee&gt; {}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper, Employee&gt; implements EmployeeService {}</code></pre><h3 id="2-3-统一结果封装"><a href="#2-3-统一结果封装" class="headerlink" title="2.3 统一结果封装"></a>2.3 统一结果封装</h3><p>编写一个Result类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Result&lt;T&gt; {    private Integer code;  // 编码：1成功。0和其他数字失败    private String errMsg;  // 错误信息    private T data; // 数据    private Map map = new HashMap();  // 动态数据    public static &lt;T&gt; Result&lt;T&gt; success(T data) {        Result&lt;T&gt; r = new Result&lt;&gt;();        r.code = 1;  //成功状态码        r.data = data;        return r;    }    public static &lt;T&gt; Result&lt;T&gt; error(String errMsg) {        Result&lt;T&gt; r = new Result&lt;&gt;();        r.errMsg = errMsg; //设置错误信息        r.code = 0;  //默认失败状态码，后期我们可以根据自己的需求来设置其他状态码        return r;    }    public Result&lt;T&gt; add(String msg, String value) {        this.map.put(msg, value);        return this;    }}</code></pre><h3 id="2-4-编写Controller"><a href="#2-4-编写Controller" class="headerlink" title="2.4 编写Controller"></a>2.4 编写Controller</h3><p>给EmployeeController类添加一个login方法</p><ul><li><code>@RequestBody</code> 主要用于接收前端传递给后端的json字符串（请求体中的数据）</li><li><code>HttpServletRequest</code> 作用：如果登录成功，将员工对应的id存到session一份，这样想获取一份登录用户的信息就可以随时获取出来</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/employee")public class EmployeeController {    @Autowired    private EmployeeService employeeService;    /**     * 登入功能     * @param request        * @param employee     * @return     */    //发送post请求    @PostMapping("/login")    public Result&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee) {        String password = employee.getPassword();        password = DigestUtils.md5DigestAsHex(password.getBytes());        //这部分就是MP        LambdaQueryWrapper&lt;Employee&gt; lqw = new LambdaQueryWrapper&lt;&gt;();        //相当于sql里面的where        lqw.eq(Employee::getUsername, employee.getUsername());        Employee emp = employeeService.getOne(lqw);        if (emp == null) {            return Result.error("登陆失败");        }        if (!emp.getPassword().equals(password)) {            return Result.error("登录失败");        }        if (emp.getStatus() == 0) {            return Result.error("该用户已被禁用");        }        //存个Session，只存个id就行了        request.getSession().setAttribute("employee",emp.getId());        return Result.success(emp);    }        /**     * 登出功能     * @param request     * @return     */    @PostMapping("/logout")    public Result&lt;String&gt; logout(HttpServletRequest request) {        request.getSession().removeAttribute("employee");        return Result.success("退出成功");    }}</code></pre><h3 id="2-5-登录测试"><a href="#2-5-登录测试" class="headerlink" title="2.5 登录测试"></a>2.5 登录测试</h3><p>数据库中目前只有一条用户信息，username为<code>admin</code>，password为<code>123456</code>（已经经过MD5加密了）<br>现在我们访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a><br>输入正确的用户名和密码，正常登录，并跳转至<code>http://localhost/backend/index.html</code><br>输入错误的用户名或密码，会显示登陆失败<br>对应的HTML代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">methods: {    async handleLogin() {        this.$refs.loginForm.validate(async (valid) =&gt; {        if (valid) {            this.loading = true            let res = await loginApi(this.loginForm)            if (String(res.code) === '1') {            localStorage.setItem('userInfo',JSON.stringify(res.data))            window.location.href= '/backend/index.html'            } else {            this.$message.error(res.msg)            this.loading = false            }        }        })    }}</code></pre><p>对应的JS代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function loginApi(data) {  return $axios({    'url': '/employee/login',    'method': 'post',    data  })}function logoutApi(){  return $axios({    'url': '/employee/logout',    'method': 'post',  })}</code></pre><h3 id="2-6-登出功能"><a href="#2-6-登出功能" class="headerlink" title="2.6 登出功能"></a>2.6 登出功能</h3><p>先·简单分析一下前端代码<br>登出的功能是在index页面的，右上角有一个按钮，点击就能登出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div class="right-menu"&gt;    &lt;!--这里动态的显示登录的用户名--&gt;    &lt;div class="avatar-wrapper"&gt;{{ userInfo.name }}&lt;/div&gt;    &lt;!--这里就是登出的按钮--&gt;    &lt;img src="images/icons/btn_close@2x.png" class="outLogin" alt="退出" @click="logout" /&gt;&lt;/div&gt;</code></pre><p>对应的函数如下，这里的logoutApi是用来发送post请求的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">logout() {    logoutApi().then((res)=&gt;{        if(res.code === 1){        localStorage.removeItem('userInfo')        window.location.href = '/backend/page/login/login.html'        }    })}function logoutApi(){  return $axios({    'url': '/employee/logout',    'method': 'post',  })}</code></pre><p>登出功能的后端操作很简单，只要删除session就好了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * 登出功能    * @param request    * @return    */@PostMapping("/logout")public Result&lt;String&gt; logout(HttpServletRequest request) {    request.getSession().removeAttribute("employee");    return Result.success("退出成功");}</code></pre><h3 id="2-7-完善登录功能"><a href="#2-7-完善登录功能" class="headerlink" title="2.7 完善登录功能"></a>2.7 完善登录功能</h3><p>问题分析：</p><ul><li>之前的登录功能，我们不登录，直接访问 <a href="http://localhost/backend/index.html">http://localhost/backend/index.html</a> 也可以正常访问，这显然是不合理的</li><li>我们希望看到的效果是，只有登录成功才能看到页面，未登录状态则跳转到登录页面</li><li>那么具体改如何实现呢？使用过滤器或拦截器，在过滤器或拦截器中判断用户是否登录，然后在选择是否跳转到对应页面</li></ul><h4 id="2-7-1-测试Filter拦截路径"><a href="#2-7-1-测试Filter拦截路径" class="headerlink" title="2.7.1 测试Filter拦截路径"></a>2.7.1 测试Filter拦截路径</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")public class LoginCheckFilter implements Filter {    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        //将拦截到的URI输出到日志，{}是占位符，将自动填充request.getRequestURI()的内容        log.info("拦截到的URI：{}", request.getRequestURI());        //放行        filterChain.doFilter(request, response);    }}</code></pre><p>并在启动类上加入注解<code>@ServletComponentScan</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ServletComponentScanpublic class ReggieApplication {public static void main(String[] args) {SpringApplication.run(ReggieApplication.class, args);}}</code></pre><p>启动服务器，访问index页面，查看日志，现在可以拦截到URI了</p><blockquote><p>2022-09-29 18:05:53.190 …… : 拦截到的URI：/backend/index.html<br>2022-09-29 18:06:01.174 …… : 拦截到的URI：/employee/page</p></blockquote><h4 id="2-7-2-编写Filter逻辑"><a href="#2-7-2-编写Filter逻辑" class="headerlink" title="2.7.2 编写Filter逻辑"></a>2.7.2 编写Filter逻辑</h4><p>首先看一下JS代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 响应拦截器service.interceptors.response.use(res =&gt; {    if (res.data.code === 0 &amp;&amp; res.data.msg === 'NOTLOGIN') { // 返回登录页面格式    console.log('---/backend/page/login/login.html---')    localStorage.removeItem('userInfo')    window.top.location.href = '/backend/page/login/login.html'    } else {    return res.data    }}</code></pre><p>知道了拦截的返回格式后，开始编写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName = "LoginCheckFilter", urlPatterns = "/*")public class LoginCheckFilter implements Filter {    //路径匹配器，支持通配符    private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        // 1.获取本次请求的URI        String uri = request.getRequestURI();        // 定义不需要处理的请求路径        String[] urls = new String[]{                "/employee/login",                "/employee/logout",                // /** 拦截所有的文件夹及里面的子文件夹                // 即所有静态页面可以访问（只有骨架没有数据）                "/backend/**",                "/front/**"        };        // 2.判断本次请求是否需要拦截处理        boolean check = check(urls, uri);        // 3.如果不需要处理直接放行        if (check) {            log.info("本次请求：{}，不需要处理",uri);            filterChain.doFilter(request, response);            return;        }        // 4.如果需要处理，判定登录状态，若登录则放行        if (request.getSession().getAttribute("employee") != null) {            log.info("用户已登录，id为{}",request.getSession().getAttribute("employee"));            filterChain.doFilter(request, response);            return;        }        // 5.如果未登录则返回未登录结果,通过输出流方式向客户端页面响应数据        log.info("本次请求：{}",uri);        log.info("用户未登录");        log.info("用户id{}",request.getSession().getAttribute("employee"));        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));    }    //检查是否匹配    private boolean check(String[] urls, String uri) {        for (String url : urls) {            boolean match = PATH_MATCHER.match(url, uri);            if (match) return true;        }        return false;    }}</code></pre><h4 id="2-7-3-测试登录"><a href="#2-7-3-测试登录" class="headerlink" title="2.7.3 测试登录"></a>2.7.3 测试登录</h4><p>当我们直接访问 <a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a> 时，日志输出如下</p><pre class="line-numbers language-none"><code class="language-none">：拦截到请求：/employee/page: 用户未登录: 用户id为：null</code></pre><p>随后将自动跳转至登录页面</p><pre class="line-numbers language-none"><code class="language-none">: 拦截到请求：/employee/login: 本次请求：/employee/login，不需要处理</code></pre><blockquote><p>自动跳转是因为：访问<a href="http://localhost:8080/backend/index.html%E6%97%B6%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AEpage/member/list.html%EF%BC%8Clist.html%E5%8F%88%E8%AE%BF%E9%97%AE/employee/page">http://localhost:8080/backend/index.html时会默认访问page/member/list.html，list.html又访问/employee/page</a></p></blockquote><h1 id="员工管理"><a href="#员工管理" class="headerlink" title="员工管理"></a>员工管理</h1><h2 id="3-添加员工"><a href="#3-添加员工" class="headerlink" title="3. 添加员工"></a>3. 添加员工</h2><h3 id="3-1-流程分析"><a href="#3-1-流程分析" class="headerlink" title="3.1 流程分析"></a>3.1 流程分析</h3><p>实现功能之前，我们先梳理一下整个执行流程</p><ol><li>页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据进行保存</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231002125855639.png"></p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>新增的员工信息只有部分数据，id，password，status，createTime等都还没有指定。</p><ul><li><code>id</code> 这个就用自动生成的就好了（雪花算法/自动递增）</li><li><code>password</code> 当你注册某些教育网站的时候，一般都会给你默认指定一个密码（身份证后六位，123456等），所以我们这里的解决策略就直接指定一个123456了，但是这个密码不能直接在数据库中设为默认值，因为数据库设置的默认值无法加密</li><li><code>status</code> 设定员工的状态，1表示启用，0表示禁用，这个表里直接设置了默认值</li><li><code>createTime</code> 创建时间，这个就指定当前时间就好了</li><li><code>updateTime</code> 作用同上</li><li><code>createUser</code> 这个是创建人的ID，我们首先需要一个管理员账号登录到后台管理界面，然后才能添加员工信息，所以我们也需要对这个员工信息的创建人，进行设置，避免出现莫名的员工账号，依靠这个可以溯源</li><li><code>updateUser</code> 作用同上</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic R&lt;String&gt; save(HttpServletRequest request, @RequestBody Employee employee) {    // 设置员工的password，createTime，updateTime,createUser,updateUser    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));    employee.setCreateTime(LocalDateTime.now());    employee.setUpdateTime(LocalDateTime.now());    // 从session获取当前登录用户    Long employee1 = (Long) request.getSession().getAttribute("employee");    employee.setCreateUser(employee1);    employee.setUpdateUser(employee1);    employeeService.save(employee);    return R.success("添加员工成功");}</code></pre><blockquote><p>值得注意的一点是，username不能重复，因为在建表的时候设定了unique，只能存在唯一的username，如果存入相同的username则会报错。</p><p>这个报错目前也不太人性化，咱也不知道具体为啥添加失败了，所以我们还得继续完善一下，那么具体该怎么完善呢？可以使用全局统一异常处理</p></blockquote><h3 id="3-3-完善全局异常处理器并测试"><a href="#3-3-完善全局异常处理器并测试" class="headerlink" title="3.3 完善全局异常处理器并测试"></a>3.3 完善全局异常处理器并测试</h3><p>在<code>com.blog.common</code>包下创建一个全局异常处理类<code>GlobalExceptionHandler</code>，并添加exceptionHandler方法用来捕获异常，并返回结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ControllerAdvice(annotations = {RestController.class, Controller.class})@ResponseBody@Slf4jpublic class GlobalExceptionHandler {    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex) {        log.error(ex.getMessage());        //如果包含Duplicate entry，则说明有条目重复        if (ex.getMessage().contains("Duplicate entry")) {            //对字符串切片            String[] s = ex.getMessage().split(" ");            //报错字符串格式是固定的，s[2]这个位置必然是username            return R.error("用户名" + s[2] + "已存在");        }        return R.error("未知错误");    }}</code></pre><h2 id="4-员工信息分页查询"><a href="#4-员工信息分页查询" class="headerlink" title="4. 员工信息分页查询"></a>4. 员工信息分页查询</h2><p><img src="image-20231002163302249.png" alt="image-20231002163302249"></p><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p><ol><li>页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务</li><li>服务端Controller接收页面提交的数据并调用Service查询数据</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收到分页数据并通过ElementUI的Table组件展示到页面上</li></ol><h3 id="4-1-前端代码分析"><a href="#4-1-前端代码分析" class="headerlink" title="4.1 前端代码分析"></a>4.1 前端代码分析</h3><p><img src="image-20231002163457504.png" alt="image-20231002163457504"></p><p>关于数据显示的功能，就是由这部分代码完成的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () {    const params = {        page: this.page,        pageSize: this.pageSize,        name: this.input ? this.input : undefined    }    await getMemberList(params).then(res =&gt; {        if (String(res.code) === '1') {        this.tableData = res.data.records || [] // 返回的列表数据在这里        this.counts = res.data.total        }    }).catch(err =&gt; {        this.$message.error('请求出错了：' + err)    })}function getMemberList (params) {  return $axios({    url: '/employee/page',    method: 'get',    params  })}</code></pre><h3 id="4-2-配置MyBatisPlus分页插件"><a href="#4-2-配置MyBatisPlus分页插件" class="headerlink" title="4.2 配置MyBatisPlus分页插件"></a>4.2 配置MyBatisPlus分页插件</h3><p>新建<code>com.itheima.config</code>包，并在其中新建<code>MybatisPlusConfig</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() {        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mybatisPlusInterceptor;    }}</code></pre><h3 id="4-3-编写具体的业务逻辑"><a href="#4-3-编写具体的业务逻辑" class="headerlink" title="4.3 编写具体的业务逻辑"></a>4.3 编写具体的业务逻辑</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    log.info("page={},pageSize={},name={}", page, pageSize, name);        //构造分页构造器    Page&lt;Employee&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //构造条件构造器    LambdaQueryWrapper&lt;Employee&gt; lqw = new LambdaQueryWrapper&lt;&gt;();    //添加过滤条件（当我们没有输入name时，就相当于查询所有了）    lqw.like(!(name == null || "".equals(name)), Employee::getName, name);    //并对查询的结果进行降序排序，根据更新时间    lqw.orderByDesc(Employee::getUpdateTime);        //执行查询    employeeService.page(pageInfo, wrapper);    return Result.success(pageInfo);}</code></pre><h2 id="5-启用-禁用员工账号"><a href="#5-启用-禁用员工账号" class="headerlink" title="5. 启用/禁用员工账号"></a>5. 启用/禁用员工账号</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><ol><li>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。</li><li>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。</li><li>管理员admin登录系统可以对所有员工账号进行启用、禁用操作。</li><li>如果某个员工账号状态为正常，则按钮显示为“禁用”，如果员工账号状态为已禁用，则按钮显示为“启用”</li></ol><p><img src="20230412044305_357.jpg" alt="img"></p><h3 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h3><ol><li><p>页面发送ajax请求，将参数(id、status)提交到服务端</p><p><img src="image-20231002182702506.png" alt="image-20231002182702506"></p></li><li><p>服务端Controller接收页面提交的数据并调用Service更新数据</p></li><li><p>Service调用Mapper操作数据库</p></li></ol><p><img src="image-20231002182232130.png" alt="image-20231002182232130"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) {    log.info(employee.toString());    Long id = (Long) request.getSession().getAttribute("employee");    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success("员工信息修改成功");}</code></pre><p>查看数据库，我们发现status并没有被修改<br>通过查看日志，我们发现更新操作并没有完成，这是怎么回事呢？</p><blockquote><p>==&gt; Preparing: UPDATE employee SET status=?, update_time=?, update_user=? WHERE id=?<br>==&gt; Parameters: 0(Integer), 2022-10-04T09:37:21.459(LocalDateTime), 1(Long), 1575840690817011700(Long)<br>==&gt; Updates: 0</p><ul><li>仔细观察这里的id值为<code>1575840690817011700</code>，而实际的id值为<code>1575840690817011713</code></li><li>问题的原因：</li><li>JS对Long型数据进行处理时丢失精度，导致提交的id和数据库中的id不一致。</li><li>如何解决这个问题?</li><li>我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串</li></ul></blockquote><h3 id="5-3-配置状态转换器"><a href="#5-3-配置状态转换器" class="headerlink" title="5.3 配置状态转换器"></a>5.3 配置状态转换器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import java.math.BigInteger;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper {    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";    public JacksonObjectMapper() {        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(BigInteger.class, ToStringSerializer.instance)                .addSerializer(Long.class, ToStringSerializer.instance)                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    }}</code></pre><p>扩展Mvc框架的消息转换器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");    }    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();        //设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        //将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    }}</code></pre><p>此时可以修改成功</p><h2 id="6-编辑员工信息"><a href="#6-编辑员工信息" class="headerlink" title="6. 编辑员工信息"></a>6. 编辑员工信息</h2><p>在开发代码之前，我们先来梳理一下整个操作流程与对应程序的执行顺序</p><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code></li><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li><li>服务端接受请求，并根据<code>员工id</code>查询员工信息，并将员工信息以<code>json</code>形式响应给页面</li><li>页面接收服务端响应的<code>json</code>数据，并通过Vue的<code>双向绑定</code>进行员工信息回显</li><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li><li>服务端接受员工信息，并进行处理，完成后给页面响应</li><li>页面接收到服务端响应信息后进行相应处理</li></ol><h3 id="6-1-页面根据id回显功能实现"><a href="#6-1-页面根据id回显功能实现" class="headerlink" title="6.1 页面根据id回显功能实现"></a>6.1 页面根据id回显功能实现</h3><h4 id="6-1-1-前端分析"><a href="#6-1-1-前端分析" class="headerlink" title="6.1.1 前端分析"></a>6.1.1 前端分析</h4><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code><br>编辑按钮绑定的点击事件为<code>addMemberHandle(scope.row.id)</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="text"    size="small"    class="blueBug"    @click="addMemberHandle(scope.row.id)"    :class="{notAdmin:user !== 'admin'}"&gt;    编辑&lt;/el-button&gt;addMemberHandle (st) {    if (st === 'add'){        window.parent.menuHandle({        id: '2',        url: '/backend/page/member/add.html',        name: '添加员工'        },true)    } else {        window.parent.menuHandle({        id: '2',        url: '/backend/page/member/add.html?id='+st, //这里        name: '修改员工'        },true)    }}</code></pre><ol start="2"><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() {    this.id = requestUrlParam('id')    this.actionType = this.id ? 'edit' : 'add'    if (this.id) {    this.init()    }}//获取url地址上面的参数function requestUrlParam(argname){  var url = location.href  var arrStr = url.substring(url.indexOf("?")+1).split("&amp;")  for(var i =0;i&lt;arrStr.length;i++)  {      var loc = arrStr[i].indexOf(argname+"=")      if(loc!=-1){          return arrStr[i].replace(argname+"=","").replace("?","")      }  }  return ""}</code></pre><ol start="3"><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () {    queryEmployeeById(this.id).then(res =&gt; {        console.log(res)        if (String(res.code) === '1') {            console.log(res.data)            this.ruleForm = res.data            this.ruleForm.sex = res.data.sex === '0' ? '女' : '男'            // this.ruleForm.password = ''        } else {            this.$message.error(res.msg || '操作失败')        }    })}// 修改页面反查详情接口function queryEmployeeById (id) {  return $axios({    url: `/employee/${id}`,    method: 'get'  })}</code></pre><h4 id="6-1-2-具体实现"><a href="#6-1-2-具体实现" class="headerlink" title="6.1.2 具体实现"></a>6.1.2 具体实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/{id}")public R&lt;Employee&gt; getById(@PathVariable Long id) {    log.info("根据id查询员工信息...");    Employee employee = employeeService.getById(id);    if (employee != null) {        return R.success(employee);    }    return R.error("没有查询到对应员工信息");}</code></pre><h3 id="6-2-保存功能实现"><a href="#6-2-保存功能实现" class="headerlink" title="6.2 保存功能实现"></a>6.2 保存功能实现</h3><ol><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="primary"    @click="submitForm('ruleForm', false)"&gt;    保存&lt;/el-button&gt;submitForm (formName, st) {    this.$refs[formName].validate((valid) =&gt; {        if (valid) {        if (this.actionType === 'add') {            const params = {            ...this.ruleForm,            sex: this.ruleForm.sex === '女' ? '0' : '1'            }            addEmployee(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('员工添加成功！')                if (!st) {                this.goBack()                } else {                this.ruleForm = {                    username: '',                    'name': '',                    'phone': '',                    // 'password': '',                    // 'rePassword': '',/                    'sex': '男',                    'idNumber': ''                }                }            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        } else {            const params = {            ...this.ruleForm,            sex: this.ruleForm.sex === '女' ? '0' : '1'            }            editEmployee(params).then(res =&gt; { // 这里            if (res.code === 1) {                this.$message.success('员工信息修改成功！')                this.goBack()            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        }        } else {        console.log('error submit!!')        return false        }    })}// 修改---添加员工function editEmployee (params) {  return $axios({    url: '/employee',    method: 'put',    data: { ...params }  })}</code></pre><p>由于修改员工信息也是发送的PUT请求，与之前启用/禁用员工账号是一致的，而且前面我们已经写过了PUT请求的Controller层<br>所以当我们点击保存按钮时，调用<code>submitForm</code>函数，而在<code>submitForm</code>函数中我们又调用了<code>editEmployee</code>函数，发送PUT请求，实现修改功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) {    log.info(employee.toString());    Long id = (Long) request.getSession().getAttribute("employee");    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success("员工信息修改成功");}</code></pre><h1 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h1><p><img src="image-20231003152635364.png" alt="image-20231003152635364"></p><h2 id="7-公共字段自动填充"><a href="#7-公共字段自动填充" class="headerlink" title="7. 公共字段自动填充"></a>7. 公共字段自动填充</h2><h3 id="7-1-问题分析"><a href="#7-1-问题分析" class="headerlink" title="7.1 问题分析"></a>7.1 问题分析</h3><ul><li>前面我们已经完成了对员工数据的添加与修改，在添加/修改员工数据的时候，都需要指定一下创建人、创建时间、修改人、修改时间等字段，而这些字段又属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。</li><li>那我们有没有办法让这些字段在一个地方统一管理呢？这样可以简化我们的开发<ul><li>答案就是使用<code>MybatisPlus</code>给我们提供的公共字段自动填充功能</li></ul></li></ul><h3 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h3><ol><li>在实体类的属性上方加入<code>@TableFiled</code>注解，指定自动填充的策略</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    @TableField(fill = FieldFill.INSERT)//插入时填充字段值    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段值    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)//插入时填充字段值    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段值    private Long updateUser;}</code></pre><ol start="2"><li>按照框架要求编写元数据对象处理器，在此类中统一对公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口<br>实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充<br>关于字段填充方式，使用metaObject的<code>setValue</code>来实现</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        log.info("公共字段自动填充(insert)...");        log.info(metaObject.toString());        metaObject.setValue("createTime", LocalDateTime.now());        metaObject.setValue("updateTime", LocalDateTime.now());    }    @Override    public void updateFill(MetaObject metaObject) {        log.info("公共字段自动填充(update)...");        log.info(metaObject.toString());        metaObject.setValue("updateTime", LocalDateTime.now());    }}</code></pre><h3 id="7-3-功能完善"><a href="#7-3-功能完善" class="headerlink" title="7.3 功能完善"></a>7.3 功能完善</h3><ul><li><p>关于id的获取，我们之前是存到session里的，但在<code>MyMetaObjectHandler</code>类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户Id。</p><ul><li>可以使用<code>ThreadLocal</code>来解决这个问题</li></ul></li><li><p>在学习ThreadLocal之前，我们需要先确认一个事情，就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程:</p><ol><li><code>LocalCheekFilter</code>中的<code>doFilter</code>方法</li><li><code>EmployeeController</code>中的<code>update</code>方法</li><li><code>MyMetaObjectHandler</code>中的<code>updateFill</code>方法</li></ol></li></ul><p>那么什么是ThreadLocal?</p><ul><li>ThreadLocal并不是一个Thread，而是<strong>Thread的局部变量</strong></li><li>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本</li><li>所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li></ul><p>ThreadLocal常用方法:</p><ul><li><code>public void set(T value)</code> 设置当前线程的线程局部变量的值</li><li><code>public T get()</code> 返回当前线程所对应的线程局部变量的值</li></ul><p>那么我们如何用ThreadLocal来解决我们上述的问题呢？</p><ul><li>我们可以在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中获取当前登录用户id，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值（用户id)，然后在<code>MyMetaObjectHandler</code>的<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值（用户id)。</li></ul><p>具体实现</p><ul><li>在com.blog.common包下新建BaseContext类</li><li>作用：基于ThreadLocal的封装工具类，用于保护和获取当前用户id</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BaseContext {    // 用户保存、获取当前登录用户id    private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) {        threadLocal.set(id);    }    public static Long getCurrentId() {        return threadLocal.get();    }}</code></pre><ul><li>随后在LoginCheckFilter类中添加代码<br>使用<code>request.getSession</code>来获取当前登录用户的id值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//4.判断登录状态，如果已登录，则直接放行if (request.getSession().getAttribute("employee") != null) {    log.info("用户已登录，id为{}", request.getSession().getAttribute("employee"));        //根据session来获取之前我们存的id值    Long empId = (Long) request.getSession().getAttribute("employee");    //使用BaseContext封装id    BaseContext.setCurrentId(empId);        filterChain.doFilter(request, response);    return;}</code></pre><ul><li>在MyMetaObjectHandler类中，添加设置id的代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        log.info("公共字段填充（create）...");        metaObject.setValue("createTime", LocalDateTime.now());        metaObject.setValue("updateTime", LocalDateTime.now());        //设置创建人id        metaObject.setValue("createUser", BaseContext.getCurrentId());        metaObject.setValue("updateUser", BaseContext.getCurrentId());    }    @Override    public void updateFill(MetaObject metaObject) {        log.info("公共字段填充（insert）...");        metaObject.setValue("updateTime", LocalDateTime.now());        //设置更新人id        metaObject.setValue("updateUser", BaseContext.getCurrentId());    }}</code></pre><h2 id="8-新增菜品分类"><a href="#8-新增菜品分类" class="headerlink" title="8. 新增菜品分类"></a>8. 新增菜品分类</h2><h3 id="8-1-需求分析"><a href="#8-1-需求分析" class="headerlink" title="8.1 需求分析"></a>8.1 需求分析</h3><ul><li>后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类</li><li>当我们在后台系统中添加菜品时，需要选择一个菜品分类</li><li>当我们在后台系统中天啊及一个套餐时，需要选择一个套餐分类</li><li>在移动端也会按照菜品分类和套餐分类来战士对应的菜品和套餐</li></ul><p>可以在后台系统的分类管理页面分别添加菜品分类和套餐分类，如下:</p><p>分类管理页面</p><p><img src="image-20231003171449686.png" alt="image-20231003171449686"></p><p>新增菜品分类表单</p><p><img src="image-20231003171506896.png" alt="image-20231003171506896"></p><p>新增套餐分类表单</p><p><img src="image-20231003171539212.png" alt="image-20231003171539212"></p><h3 id="8-2-数据模型"><a href="#8-2-数据模型" class="headerlink" title="8.2 数据模型"></a>8.2 数据模型</h3><p>简单浏览一下category表中的数据</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center">类型 1 菜品分类 2 套餐分类</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">分类名称</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr></tbody></table><p>id是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类</p><h3 id="8-3-准备工作"><a href="#8-3-准备工作" class="headerlink" title="8.3 准备工作"></a>8.3 准备工作</h3><p>在开发业务之前，先将需要用到的类和接口的基本结构先创建好</p><ol><li>实体类Category，对应上表来创建<br>菜品分类也有<code>createUser</code>和<code>createTime</code>等字段，也可以用上面的公共字段自动填充</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Category implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //类型 1 菜品分类 2 套餐分类    private Integer type;    //分类名称    private String name;    //顺序    private Integer sort;    //创建时间    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    //更新时间    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    //创建人    @TableField(fill = FieldFill.INSERT)    private Long createUser;    //修改人    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><ol start="2"><li>Mapper接口CategoryMapper</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface CategoryMapper extends BaseMapper&lt;Category&gt; {}</code></pre><ol start="3"><li>业务层接口CategoryService</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; {}</code></pre><ol start="4"><li>业务层实现类CatrgoryServiceImpl</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService {}</code></pre><ol start="5"><li>控制层CategoryController</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Slf4j@RestController@RequestMapping("/category")public class CategoryController {    @Autowired    private CategoryService categoryService;}</code></pre><h3 id="8-4-流程分析"><a href="#8-4-流程分析" class="headerlink" title="8.4 流程分析"></a>8.4 流程分析</h3><p>在编写代码之前，我们还是先来分析一下整个流程</p><ol><li>页面发送ajax请求，将新增分类窗口输入的数据以json形式提交给服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据存储到数据库</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231003173637383.png" alt="image-20231003173637383"></p><h3 id="8-5-代码实现"><a href="#8-5-代码实现" class="headerlink" title="8.5 代码实现"></a>8.5 代码实现</h3><p>服务端只需要将接收到的json数据添加到数据库中，并响应一个成功的提示信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody Category category) {    log.info("category:{}", category);    categoryService.save(category);    return Result.success("新增分类成功");}</code></pre><h2 id="9-分类信息分页查询"><a href="#9-分类信息分页查询" class="headerlink" title="9. 分类信息分页查询"></a>9. 分类信息分页查询</h2><p>与之前的员工信息分页查询类似</p><h3 id="9-1-流程分析"><a href="#9-1-流程分析" class="headerlink" title="9.1 流程分析"></a>9.1 流程分析</h3><p>按照惯例，我们还是先来分析一下流程</p><ol><li>页面发送Ajax请求，将分页查询的参数（page、pageSize）提交到服务端</li><li>服务端Controller接受到页面提交的数据之后，调用Service进行查询</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收分页数据，并通过ElementUI的Table组件战士到页面上</li></ol><p><img src="image-20231003174931272.png" alt="image-20231003174931272"></p><h3 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h3><p>在CategoryController类中编写page方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize) {    //分页构造器    Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //条件查询器    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加排序条件    queryWrapper.orderByDesc(Category::getSort);    //分页查询    categoryService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);}</code></pre><h2 id="10-删除分类"><a href="#10-删除分类" class="headerlink" title="10. 删除分类"></a>10. 删除分类</h2><h3 id="10-1-需求分析"><a href="#10-1-需求分析" class="headerlink" title="10.1 需求分析"></a>10.1 需求分析</h3><ul><li>在分类管理列表页面，可以对某个分类进行删除操作</li><li>需要注意的是：当分类关联了菜品或者套餐时，此分类将不允许被删除</li></ul><h3 id="10-2-流程分析"><a href="#10-2-流程分析" class="headerlink" title="10.2 流程分析"></a>10.2 流程分析</h3><p>按照惯例，继续分析一遍流程</p><ol><li>页面发送ajax请求，将参数(id)提交给服务端</li><li>服务端Controller接收页面提交的数据，并调用Service删除数据</li><li>Service调用Mapper操作数据库</li></ol><p><img src="image-20231003181059718.png" alt="image-20231003181059718"></p><h3 id="10-3-前端代码分析"><a href="#10-3-前端代码分析" class="headerlink" title="10.3 前端代码分析"></a>10.3 前端代码分析</h3><p>删除按钮绑定了<code>deleteHandle</code>函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">HTML&lt;el-button    type="text"    size="small"    class="delBut non"    @click="deleteHandle(scope.row.id)"&gt;    删除&lt;/el-button&gt;deleteHandle(id) {    this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {        'confirmButtonText': '确定',        'cancelButtonText': '取消',        'type': 'warning'    }).then(() =&gt; {        deleCategory(id).then(res =&gt; {        if (res.code === 1) {            this.$message.success('删除成功！')            this.handleQuery()        } else {            this.$message.error(res.msg || '操作失败')        }        }).catch(err =&gt; {        this.$message.error('请求出错了：' + err)        })    })}// 删除当前列的接口const deleCategory = (id) =&gt; {  return $axios({    url: '/category',    method: 'delete',    params: {id}  })}</code></pre><h3 id="10-4-代码实现"><a href="#10-4-代码实现" class="headerlink" title="10.4 代码实现"></a>10.4 代码实现</h3><p>在CategoryController类上添加delete方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingprivate Result&lt;String&gt; delete(Long id) {    log.info("将被删除的id：{}", id);    categoryService.removeById(id);    return Result.success("分类信息删除成功");}</code></pre><h3 id="10-5-功能完善"><a href="#10-5-功能完善" class="headerlink" title="10.5 功能完善"></a>10.5 功能完善</h3><p>当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除</p><ul><li>那么我们如何实现这个功能呢？<ul><li>其实也很简单，我们只需要在删除的时候，拿着当前分类的id值，去对应的菜品/套餐表中进行查询，如果能查询到数据，则说明该分类关联了菜品，不允许被删除，否则则可以删除</li></ul></li></ul><p>那么明确了思路之后，我们就来写代码</p><ul><li>首先我们需要根据数据表创建菜品和套餐对应的模型类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** 菜品 */@Datapublic class Dish implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //商品码    private String code;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //顺序    private Integer sort;    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 套餐 */@Datapublic class Setmeal implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //分类id    private Long categoryId;    //套餐名称    private String name;    //套餐价格    private BigDecimal price;    //状态 0:停用 1:启用    private Integer status;    //编码    private String code;    //描述信息    private String description;    //图片    private String image;    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><ul><li><p>随后编写对应的Mapper接口</p></li><li><p>编写对应的Service接口及Impl实现类</p></li><li><p>在common包下新增<code>CustomException</code>类<br>该类用于<strong>封装我们的自定义异常</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CustomException extends RuntimeException{    public CustomException(String msg){        super(msg);    }}</code></pre><ul><li>在我们的全局异常处理器类中，使用<code>exceptionHandler</code>处理<code>CustomerException</code>异常</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ExceptionHandler(CustomException.class)public Result&lt;String&gt; exceptionHandler(CustomException ex) {    log.error(ex.getMessage());    return Result.error(ex.getMessage());}</code></pre><ul><li>在CategoryService接口中自己写一个<code>remove</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; {    void remove(Long id);}</code></pre><ul><li>在CategoryServiceImpl中来写具体业务逻辑<br>我们需要在删除数据之前，根据<code>id</code>值，去<code>Dish</code>表和<code>Setmeal</code>表中查询是否关联了数据<br>如果存在关联数据，则不能删除，并抛一个异常<br>如果不存在关联数据（也就是查询到的数据条数为0），正常删除即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service@Slf4jpublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService {    @Autowired    DishService dishService;    @Autowired    SetmealService setmealService;    /**     * 根据id删除分类，删除之前需要进行判断     * @param id     */    @Override    public void remove(Long id) {        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //添加dish查询条件，根据分类id进行查询        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);        int count1 = dishService.count(dishLambdaQueryWrapper);        //方便Debug用的        log.info("dish查询条件，查询到的条目数为：{}",count1);        //查看当前分类是否关联了菜品，如果已经关联，则抛出异常        if (count1 &gt; 0){            //已关联菜品，抛出一个业务异常            throw new CustomException("当前分类下关联了菜品，不能删除");        }        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //添加dish查询条件，根据分类id进行查询        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);        int count2 = setmealService.count(setmealLambdaQueryWrapper);        //方便Debug用的        log.info("setmeal查询条件，查询到的条目数为：{}",count2);        //查看当前分类是否关联了套餐，如果已经关联，则抛出异常        if (count2 &gt; 0){            //已关联套餐，抛出一个业务异常            throw new CustomException("当前分类下关联了套餐，不能删除");        }                //正常删除        super.removeById(id);    }}</code></pre><ul><li>最后记得在controller中调用我们新写的remove方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; delete(Long id){    log.info("将要删除的分类id:{}",id);    categoryService.remove(id);    return Result.success("分类信息删除成功");}</code></pre><h2 id="11-修改分类"><a href="#11-修改分类" class="headerlink" title="11. 修改分类"></a>11. 修改分类</h2><h3 id="11-1-需求分析"><a href="#11-1-需求分析" class="headerlink" title="11.1 需求分析"></a>11.1 需求分析</h3><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p><p><img src="20230412035047_459.jpg" alt="img"></p><h3 id="11-2-前端分析"><a href="#11-2-前端分析" class="headerlink" title="11.2 前端分析"></a>11.2 前端分析</h3><p>数据回显</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="text"    size="small"    class="blueBug"    @click="editHandle(scope.row)"&gt;    修改&lt;/el-button&gt;        editHandle(dat) {    this.classData.title = '修改分类'    this.action = 'edit'    this.classData.name = dat.name    this.classData.sort = dat.sort    this.classData.id = dat.id    this.classData.dialogVisible = true}classData: {    'title': '添加菜品分类',    'dialogVisible': false,    'categoryId': '',    'name': '',    sort: ''}// 数据双向绑定，回显&lt;el-form    class="demo-form-inline"    label-width="100px"    &gt;    &lt;el-form-item label="分类名称："&gt;        &lt;el-input            v-model="classData.name" //这里            placeholder="请输入分类名称"            maxlength="14"        /&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label="排序："&gt;        &lt;el-input v-model="classData.sort"  type="number" placeholder="请输入排序" /&gt; //这里    &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><p>数据提交是采用的一个通用的<code>submitForm</code>函数，由于我们是修改操作，所以直接从<code>else</code>开始往后看就行了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//数据提交submitForm(st) {    const classData = this.classData    const valid = (classData.name === 0 ||classData.name)  &amp;&amp; (classData.sort === 0 || classData.sort)    if (this.action === 'add') {        if (valid) {            const reg = /^\d+$/            if (reg.test(classData.sort)) {            addCategory({'name': classData.name,'type':this.type, sort: classData.sort}).then(res =&gt; {                console.log(res)                if (res.code === 1) {                this.$message.success('分类添加成功！')                if (!st) {                    this.classData.dialogVisible = false                } else {                    this.classData.name = ''                    this.classData.sort = ''                }                this.handleQuery()                } else {                this.$message.error(res.msg || '操作失败')                }            }).catch(err =&gt; {                this.$message.error('请求出错了：' + err)            })            } else {            this.$message.error('排序只能输入数字类型')            }        } else {            this.$message.error('请输入分类名称或排序')        }    } else if (valid) {        const reg = /^\d+$/        if (reg.test(this.classData.sort)) {            editCategory({'id':this.classData.id,'name': this.classData.name, sort: this.classData.sort}).then(res =&gt; {                if (res.code === 1) {                    this.$message.success('分类修改成功！')                    this.classData.dialogVisible = false                    this.handleQuery()                } else {                    this.$message.error(res.msg || '操作失败')                }            }).catch(err =&gt; {                    this.$message.error('请求出错了：' + err)            })        } else {            this.$message.error('排序只能输入数字类型')        }    } else {        this.$message.error('请输入分类名称或排序')    }}// 修改接口const editCategory = (params) =&gt; {  return $axios({    url: '/category',    method: 'put',    data: { ...params }  })}</code></pre><h3 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Category category) {    log.info("修改分类信息为：{}", category);    categoryService.updateById(category);    return Result.success("修改分类信息成功");}</code></pre><h1 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h1><p><img src="image-20231004112854643.png" alt="image-20231004112854643"></p><h2 id="12-文件上传与下载"><a href="#12-文件上传与下载" class="headerlink" title="12. 文件上传与下载"></a>12. 文件上传与下载</h2><h3 id="12-1-文件上传简介"><a href="#12-1-文件上传简介" class="headerlink" title="12.1 文件上传简介"></a>12.1 文件上传简介</h3><ul><li><p>文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程</p></li><li><p>文件上传时，对页面的form表单有如下要求：</p><ol><li><code>method="post"</code>，采用post方式提交数据</li><li><code>enctype="multipart/form-data"</code>，采用multipart格式上传文件</li><li><code>type="file"</code>，使用input的file控件上传</li></ol></li><li><p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传，这里我们就用提供好的组件就行了<br>我们把这段代码放在<code>backend/demo</code>目录下，命名为<code>upload.html</code></p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;文件上传&lt;/title&gt;  &lt;!-- 引入样式 --&gt;  &lt;link rel="stylesheet" href="../../plugins/element-ui/index.css" /&gt;  &lt;link rel="stylesheet" href="../../styles/common.css" /&gt;  &lt;link rel="stylesheet" href="../../styles/page.css" /&gt;&lt;/head&gt;&lt;body&gt;   &lt;div class="addBrand-container" id="food-add-app"&gt;    &lt;div class="container"&gt;        &lt;el-upload class="avatar-uploader"                action="/common/upload"                :show-file-list="false"                :on-success="handleAvatarSuccess"                :before-upload="beforeUpload"                ref="upload"&gt;            &lt;img v-if="imageUrl" :src="imageUrl" class="avatar"&gt;&lt;/img&gt;            &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt;        &lt;/el-upload&gt;    &lt;/div&gt;  &lt;/div&gt;    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;    &lt;script src="../../plugins/vue/vue.js"&gt;&lt;/script&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src="../../plugins/element-ui/index.js"&gt;&lt;/script&gt;    &lt;!-- 引入axios --&gt;    &lt;script src="../../plugins/axios/axios.min.js"&gt;&lt;/script&gt;    &lt;script src="../../js/index.js"&gt;&lt;/script&gt;    &lt;script&gt;      new Vue({        el: '#food-add-app',        data() {          return {            imageUrl: ''          }        },        methods: {          handleAvatarSuccess (response, file, fileList) {              this.imageUrl = `/common/download?name=${response.data}`          },          beforeUpload (file) {            if(file){              const suffix = file.name.split('.')[1]              const size = file.size / 1024 / 1024 &lt; 2              if(['png','jpeg','jpg'].indexOf(suffix) &lt; 0){                this.$message.error('上传图片只支持 png、jpeg、jpg 格式！')                this.$refs.upload.clearFiles()                return false              }              if(!size){                this.$message.error('上传文件大小不能超过 2MB!')                return false              }              return file            }          }        }      })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:<ul><li><code>commons-fileupload</code></li><li><code>commons-io</code></li></ul></li><li>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中<strong>声明一个MultipartFile类型的参数</strong>即可接收上传的文件，例如</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/common")@Slf4jpublic class CommonController {    @PostMapping("/upload")    public Result&lt;String&gt; upload(MultipartFile file) {        log.info("获取文件：{}", file.toString());        return null;    }}</code></pre><h3 id="12-2-文件下载简介"><a href="#12-2-文件下载简介" class="headerlink" title="12.2 文件下载简介"></a>12.2 文件下载简介</h3><ul><li>文件下载，也成为了download，是指将文件从服务器传输到本地计算机的过程</li><li>通过浏览器进行文件下载，通常有两种表现形式<ol><li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li><li>直接在浏览器中打开</li></ol></li><li>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程</li></ul><h3 id="12-3-文件上传代码实现"><a href="#12-3-文件上传代码实现" class="headerlink" title="12.3 文件上传代码实现"></a>12.3 文件上传代码实现</h3><p>将我们上传的临时文件<strong>转存到指定位置</strong></p><ul><li><p>文件转存的位置改为动态可配置的，通过配置文件的方式指定，我们在application.yml文件中加入以下内容</p><ul><li><pre><code class="yml">reggie:  path: D:\\reggie\\imgs\\<pre class="line-numbers language-none"><code class="language-none">- 使用 @Value(“${reggie.path}”)读取到配置文件中的动态转存位置- 使用uuid方式重新生成文件名，避免文件名重复造成文件覆盖- 通过获取原文件名来截取文件后缀```java@RestController@RequestMapping("/common")@Slf4jpublic class CommonController {    //导入yml中配置的属性    @Value("${reggie.path}")    private String basepath;    @PostMapping("/upload")    //file是个临时文件，我们在断点调试的时候可以看到，但是执行完整个方法之后就消失了    public Result&lt;String&gt; upload(MultipartFile file) {        log.info("获取文件：{}", file.toString());        //判断一下当前目录是否存在，不存在则创建        File dir = new File(basepath);        if (!dir.exists()) {            dir.mkdirs();        }        //获取一下传入的原文件名        String originalFilename = file.getOriginalFilename();        //我们只需要获取一下格式后缀，取子串，起始点为最后一个.        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));        //为了防止出现重复的文件名，我们需要使用UUID        String fileName = UUID.randomUUID() + suffix;        try {            //我们将其转存到我们的指定目录下            file.transferTo(new File(basepath + fileName));        } catch (IOException e) {            throw new RuntimeException(e);        }        //将文件名返回给前端，便于后期的开发        return Result.success(fileName);    }}</code></pre></code></pre></li></ul></li></ul><h3 id="12-4-文件下载代码实现"><a href="#12-4-文件下载代码实现" class="headerlink" title="12.4 文件下载代码实现"></a>12.4 文件下载代码实现</h3><ul><li>前端页面的ElementUI的upload组件会在上传完图片后，触发img组件发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;el-upload class="avatar-uploader"        action="/common/upload"        :show-file-list="false"        :on-success="handleAvatarSuccess"        :before-upload="beforeUpload"        ref="upload"&gt;    &lt;img v-if="imageUrl" :src="imageUrl" class="avatar"&gt;&lt;/img&gt;    &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt;&lt;/el-upload&gt;</code></pre><ul><li>定义前端发送回显图片请求的地址<br>通过这个url我们可以看出，请求路径为<code>/common/download</code>，且发送的是GET请求</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">handleAvatarSuccess (response, file, fileList) {    this.imageUrl = `/common/download?name=${response.data}`}</code></pre><h2 id="13-新增菜品"><a href="#13-新增菜品" class="headerlink" title="13. 新增菜品"></a>13. 新增菜品</h2><h3 id="13-1-需求分析"><a href="#13-1-需求分析" class="headerlink" title="13.1 需求分析"></a>13.1 需求分析</h3><ol><li>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品</li><li>在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传当前的菜品图片</li><li>在移动端会按照菜品分类来展示对应的菜品信息（前端的活儿，跟咱没啥太大关系）</li></ol><p><img src="image-20231004164529518.png" alt="image-20231004164529518"></p><h3 id="13-2-数据模型"><a href="#13-2-数据模型" class="headerlink" title="13.2 数据模型"></a>13.2 数据模型</h3><p>dish表，最后一条字段is_deleted是逻辑删除</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">菜品名称</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品价格</td></tr><tr><td align="center">code</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">商品码</td></tr><tr><td align="center">image</td><td align="center">varchar(200)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">description</td><td align="center">varchar(400)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">0 停售 1 起售</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><p>dish_flavor表</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味名称</td></tr><tr><td align="center">value</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味数据list</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="13-3-代码开发"><a href="#13-3-代码开发" class="headerlink" title="13.3 代码开发"></a>13.3 代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>按照惯例，在开发代码之前，我们先来梳理一下整个流程</p><ol><li>页面（backend/page/food/add.html）发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器</li><li>页面发送请求进行图片下载，并回显上传的图片</li><li>点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</li></ol><p>所以开发新增菜品功能，其实就是在服务端编写代码去处理前端发送的这4次请求即可</p><h4 id="查询菜品分类数据"><a href="#查询菜品分类数据" class="headerlink" title="查询菜品分类数据"></a>查询菜品分类数据</h4><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() {    this.getDishList()    // 口味临时数据    this.getFlavorListHand()    this.id = requestUrlParam('id')    this.actionType = this.id ? 'edit' : 'add'    if (this.id) {    this.init()    }}getDishList () {    getCategoryList({ 'type': 1 }).then(res =&gt; {        if (res.code === 1) {        this.dishList = res.data        } else {        this.$message.error(res.msg || '操作失败')        }    })}// 获取菜品分类列表const getCategoryList = (params) =&gt; {  return $axios({    url: '/category/list',    method: 'get',    params  })}//下拉框&lt;el-select    v-model="ruleForm.categoryId"    placeholder="请选择菜品分类"&gt;    &lt;el-option v-for="(item,index) in dishList" :key="index" :label="item.name" :value="item.id" /&gt;&lt;/el-select&gt;</code></pre><ul><li>后端实现</li></ul><p>在<code>CategoryController</code>类中，添加list方法<br>我们只需要发送get请求，将数据返回给前端即可，操作很简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Category&gt;&gt; list(Category category) {    //条件构造器    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件，这里只需要判断是否为菜品（type为1是菜品，type为2是套餐）    queryWrapper.eq(category.getType() != null,Category::getType,category.getType());    //添加排序条件    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);    //查询数据    List&lt;Category&gt; list = categoryService.list(queryWrapper);    //返回数据    return Result.success(list);}</code></pre><h4 id="接收与回显图片"><a href="#接收与回显图片" class="headerlink" title="接收与回显图片"></a>接收与回显图片</h4><p>这个功能再刚刚我们已经实现了，到现在可以直接用</p><h4 id="提交数据到服务端"><a href="#提交数据到服务端" class="headerlink" title="提交数据到服务端"></a>提交数据到服务端</h4><p><img src="20230412045403_688.jpg" alt="img"></p><ul><li>接收数据分析</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">{name: "啊", price: 32100, code: "", image: "1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg",…}categoryId:"1397844263642378242"code:""description:"好吃的彩虹"flavors:[{name: "甜味", value: "["无糖","少糖","半糖","多糖","全糖"]", showOption: false},…]0:{name: "甜味", value: "["无糖","少糖","半糖","多糖","全糖"]", showOption: false}1:{name: "温度", value: "["热饮","常温","去冰","少冰","多冰"]", showOption: false}image:"1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg"name:"啊"price:32100status:1</code></pre><ul><li>因为Dish实体类无法接收flavor参数，即需要导入DishDto，用于封装页面提交的数据</li><li>DTO，全称为<code>Data Transfer Object</code>，即数据传输对象，一般用于展示层与服务层之间的数据传输。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class DishDto extends Dish {    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();    //后面这两条属性暂时没用，这里只需要用第一条属性    private String categoryName;    private Integer copies;}</code></pre><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">submitForm(formName, st) {    this.$refs[formName].validate((valid) =&gt; {        if (valid) {        let params = {...this.ruleForm}        // params.flavors = this.dishFlavors        params.status = this.ruleForm ? 1 : 0        params.price *= 100        params.categoryId = this.ruleForm.categoryId        params.flavors = this.dishFlavors.map(obj =&gt; ({ ...obj, value: JSON.stringify(obj.value) }))        delete params.dishFlavors        if(!this.imageUrl){            this.$message.error('请上传菜品图片')            return         }        if (this.actionType == 'add') {            delete params.id            addDish(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('菜品添加成功！') //这里                if (!st) {                this.goBack()                } else {                this.dishFlavors = []                // this.dishFlavorsData = []                this.imageUrl = ''                this.ruleForm = {                    'name': '',                    'id': '',                    'price': '',                    'code': '',                    'image': '',                    'description': '',                    'dishFlavors': [],                    'status': true,                    categoryId: ''                }                }            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        } else {            delete params.updateTime            editDish(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('菜品修改成功！')                this.goBack()            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        }        } else {        return false        }    })}// 新增接口const addDish = (params) =&gt; {  return $axios({    url: '/dish',    method: 'post',    data: { ...params }  })}</code></pre><ul><li>后端实现</li></ul><p>在<code>DishController</code>类中添加<code>save</code>方法，重启服务器，断点调试一下看看是否封装好了数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}",dishDto);    return null;}</code></pre><p><img src="20230412063714_358.jpg" alt="img"></p><p>从图中我们可以看出，DishFlavor 中的 dishId 为 null<br>但是我们需要对 DishFlavor 中的 dishId 进行赋值<br>所以我们要取出 dishDto 的 dishId，然后对每一组 flavor 的 dishId 赋值</p><ul><li>这里进行一下小结，我们需要做的有以下几点<ul><li>将菜品数据保存到<code>dish</code>表</li><li>将菜品口味数据保存到<code>dish_flavor </code>表<ul><li>但是<code>dish_flavor</code>表中需要一个<code>dishId</code>字段值，这个字段值需要我们从<code>dishDto</code>中获取</li><li>获取方式为：取出<code>dishDto</code>的<code>dishId</code>，对每一组<code>flavor</code>的<code>dishId</code>赋值</li></ul></li></ul></li><li>梳理完毕之后，那么我们就在<code>DishFlavorService</code>中编写一个<code>saveWithFlavor</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface DishService extends IService&lt;Dish&gt; {    void saveWithFlavor(DishDto dishDto);}</code></pre><ul><li>同时在<code>DishFlavorServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService {    @Autowired    private DishFlavorService dishFlavorService;    @Override    @Transactional // 涉及多表联查，开启事务管理，同时需要在启动类上加入@EnableTransactionManagement    public void saveWithFlavor(DishDto dishDto) {        //将菜品数据保存到dish表        this.save(dishDto);        //获取dishId        Long dishId = dishDto.getId();        //将获取到的dishId赋值给dishFlavor的dishId属性        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();        for (DishFlavor dishFlavor : flavors) {            dishFlavor.setDishId(dishId);        }        //同时将菜品口味数据保存到dish_flavor表        dishFlavorService.saveBatch(flavors);    }}</code></pre><h2 id="14-菜品信息分页查询"><a href="#14-菜品信息分页查询" class="headerlink" title="14. 菜品信息分页查询"></a>14. 菜品信息分页查询</h2><h3 id="14-1-需求分析"><a href="#14-1-需求分析" class="headerlink" title="14.1 需求分析"></a>14.1 需求分析</h3><ul><li>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>所以一般的系统中都会以分页的方式来展示列表数据。</li><li>其中图片列和菜品分类列比较特殊<ul><li>图片列：会用到文件的下载功能</li><li>菜品分类列：由于我们的菜品表只保存了category_id，所以我们需要查询category_id对应的菜品分类名称，从而回显数据</li></ul></li></ul><p><img src="20230412065920_105.jpg" alt="img"></p><h3 id="14-2-梳理交互过程"><a href="#14-2-梳理交互过程" class="headerlink" title="14.2 梳理交互过程"></a>14.2 梳理交互过程</h3><p>按照惯例，我们还是先来梳理一遍流程</p><ol><li>页面(backend/page/food/list.html)发送ajax请求，将分页查询参数(<code>page</code>、<code>pageSize</code>、<code>name</code>)，提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示</li></ol><p>那么开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p><h3 id="14-3-代码开发"><a href="#14-3-代码开发" class="headerlink" title="14.3 代码开发"></a>14.3 代码开发</h3><ul><li>在<code>DishController</code>下添加<code>page</code>方法，进行分页查询</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    //构造分页构造器对象    Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.like(name != null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    //执行分页查询    dishService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);}</code></pre><ul><li>由于有菜品分类数据<ul><li>我们传递的是一个Dish对象，dish对象没有菜品分类名称属性，但是有菜品分类id</li><li>那我们就可以根据这个菜品分类id，去菜品分类表中查询对应的菜品分类名称</li></ul></li><li>所以我们之前的DishDto类中的另外一个属性就派上用场了，我们返回一个DishDto对象就有菜品分类名称数据了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    //构造分页构造器对象    Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //这个就是我们到时候返回的结果    Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;(page, pageSize);        //条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.like(name != null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    //执行分页查询    dishService.page(pageInfo, queryWrapper);//结果为pageInfo    //对象拷贝，这里只需要拷贝一下查询到的条目数    BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");// 忽略结果数据集records    //获取原records数据    List&lt;Dish&gt; records = pageInfo.getRecords();    //遍历records的每一条Dish数据，为categoryName赋值，封装成DishDto数据    List&lt;DishDto&gt; list = records.stream().map((item) -&gt; {        DishDto dishDto = new DishDto();        //将数据赋给dishDto对象        BeanUtils.copyProperties(item, dishDto);        //然后获取一下dish对象的category_id属性        Long categoryId = item.getCategoryId();  //分类id        //根据这个属性，获取到Category对象（这里需要用@Autowired注入一个CategoryService对象）        Category category = categoryService.getById(categoryId);        //随后获取Category对象的name属性，也就是菜品分类名称        String categoryName = category.getName();        //最后将菜品分类名称赋给dishDto对象就好了        dishDto.setCategoryName(categoryName);        //结果返回一个dishDto对象        return dishDto;        //并将dishDto对象封装成一个集合，作为我们的最终结果    }).collect(Collectors.toList());    dishDtoPage.setRecords(list);    return Result.success(dishDtoPage);}</code></pre><h2 id="15-修改菜品"><a href="#15-修改菜品" class="headerlink" title="15. 修改菜品"></a>15. 修改菜品</h2><h3 id="15-1-梳理交互过程"><a href="#15-1-梳理交互过程" class="headerlink" title="15.1 梳理交互过程"></a>15.1 梳理交互过程</h3><p>按照惯例，还是先来梳理一下整个流程</p><ol><li>页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前我们已经实现过了）</li><li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前我们已经实现过了）</li><li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li></ol><p><img src="20230412030551_672.jpg" alt="img"></p><h3 id="15-2-查询菜品信息"><a href="#15-2-查询菜品信息" class="headerlink" title="15.2 查询菜品信息"></a>15.2 查询菜品信息</h3><ul><li>菜品信息回显功能，需要我们先根据id来查询到对应的菜品信息才能回显</li><li>但修改表单中有一个菜品口味属性，普通的Dish类没有这个属性，所以还是要用到DishDto</li><li>那我们这里先在 DishServiceImpl 中编写一个<code>getByIdWithFlavor</code>方法</li><li>菜品口味需要根据<code>dish_id</code>去<code>dish_flavor</code>表中查询，将查询到的菜品口味数据赋给我们的<code>DishDto</code>对象即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic DishDto getByIdWithFlavor(Long id) {    //先根据id查询到对应的dish对象    Dish dish = this.getById(id);    //创建一个dishDao对象    DishDto dishDto = new DishDto();    //拷贝对象    BeanUtils.copyProperties(dish, dishDto);    //条件构造器，对DishFlavor表查询    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据dish_id来查询对应的菜品口味数据    queryWrapper.eq(DishFlavor::getDishId, id);    //获取查询的结果    List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);    //并将其赋给dishDto    dishDto.setFlavors(flavors);    //作为结果返回给前端    return dishDto;}</code></pre><ul><li>在<code>DishController</code>中添加get方法，实现添加在<code>DishServicelmpl</code>中的逻辑代码，返回查询到的数据信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/{id}")public Result&lt;DishDto&gt; getByIdWithFlavor(@PathVariable Long id) {    DishDto dishDto = dishService.getByIdWithFlavor(id);    log.info("查询到的数据为：{}", dishDto);    return Result.success(dishDto);}</code></pre><h3 id="15-3-修改菜品信息"><a href="#15-3-修改菜品信息" class="headerlink" title="15.3 修改菜品信息"></a>15.3 修改菜品信息</h3><p>由于Dish表中没有Flavor这个属性，所以修改的时候，我们也是需要修改两张表</p><p>首先去DishService中创建<code>updateWithFlavor</code>方法，然后在<code>DishServiceImpl</code>中重写方法</p><ul><li>根据<code>id</code>修改菜品的基本信息</li><li>通过<code>dish_id</code>,删除菜品的<code>flavor</code></li><li>获取前端提交的<code>flavor</code>数据</li><li>为条<code>flavor</code>的<code>dishId</code>属性赋值</li><li>将数据批量保存到<code>dish_flavor</code>数据库</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void updateWithFlavor(DishDto dishDto) {    //更新当前菜品数据（dish表）    this.updateById(dishDto);    //下面是更新当前菜品的口味数据    //条件构造器    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //条件是当前菜品id    queryWrapper.eq(DishFlavor::getDishId, dishDto.getId());    //将其删除掉    dishFlavorService.remove(queryWrapper);    //获取传入的新的口味数据    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();    //这些口味数据还是没有dish_id，所以需要赋予其dishId    flavors = flavors.stream().map((item) -&gt; {        item.setDishId(dishDto.getId());        return item;    }).collect(Collectors.toList());    //再重新加入到表中    dishFlavorService.saveBatch(flavors);}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.updateWithFlavor(dishDto);    return Result.success("修改菜品成功");}</code></pre><h1 id="套餐管理"><a href="#套餐管理" class="headerlink" title="套餐管理"></a>套餐管理</h1><h2 id="16-新增套餐"><a href="#16-新增套餐" class="headerlink" title="16. 新增套餐"></a>16. 新增套餐</h2><h3 id="16-1-需求分析"><a href="#16-1-需求分析" class="headerlink" title="16.1 需求分析"></a>16.1 需求分析</h3><ul><li>套餐就是菜品的集合</li><li>后台系统中可以管理套餐信息，通过新增套餐来添加一个新的套餐</li><li>在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片</li></ul><h3 id="16-2-数据模型"><a href="#16-2-数据模型" class="headerlink" title="16.2 数据模型"></a>16.2 数据模型</h3><ul><li>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表中，而且还要向setmeal_dish表中插入套餐和菜品关联数据</li><li>所以在新增套餐时，需要对两张表进行操作<ol><li>setmeal表 –&gt; 套餐表</li><li>setmeal_dish表 –&gt; 套餐菜品关系表</li></ol></li><li>setmeal表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">套餐名称</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐价格</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">状态 0:停用 1:启用</td></tr><tr><td align="center">code</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">编码</td></tr><tr><td align="center">description</td><td align="center">varchar(512)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">image</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><ul><li>setmeal_dish表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">setmeal_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">name</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品名称 （冗余字段）</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品原价（冗余字段）</td></tr><tr><td align="center">copies</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">份数</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">排序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="16-3-梳理交互过程"><a href="#16-3-梳理交互过程" class="headerlink" title="16.3 梳理交互过程"></a>16.3 梳理交互过程</h3><p>在开发代码之前，我们先来梳理一下新增套餐时前端页面与服务端的交互过程</p><ol><li>页面发送ajax请求，请求服务端，获取套餐分类数据并展示到下拉框中（这个之前做过）</li><li>页面发送ajax请求，请求服务端，获取菜品分类数据并展示到添加菜品窗口中</li><li>页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器（已完成）</li><li>页面发送请求进行图片下载，将上传的图片进行回显（已完成）</li><li>点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</li></ol><p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求</p><h3 id="16-4-代码开发"><a href="#16-4-代码开发" class="headerlink" title="16.4 代码开发"></a>16.4 代码开发</h3><p>新增套餐页面，现在的套餐分类下拉框中已经能显示套餐分类了，这个功能在之前我们已经实现过了</p><p><img src="20230412050217_118.jpg" alt="img"></p><ul><li>添加菜品页面，这个页面是发送的GET请求，且路径为<code>dish/list?categoryId=xxx</code></li></ul><p><img src="20230412063516_850.jpg" alt="img"></p><ul><li>所以我们先去DishController中编写对应的get方法来正确显示菜品数据</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Dish&gt;&gt; get(Dish dish) {    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（启售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    return Result.success(list);}</code></pre><ul><li>编写save方法<br>我们先打个断点，看看提交的数据是啥样的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    return Result.success("套餐添加成功");}</code></pre><p><img src="6342946616f2c2beb19f11db.jpg" alt="img"></p><p>需要注意的是这个setmealId为null，我们具体的代码中，要对其进行赋值</p><ul><li>具体业务逻辑如下</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success("套餐添加成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService {    @Autowired    protected SetmealDishService setmealDishService;    @Override    public void saveWithDish(SetmealDto setmealDto) {        //保存套餐setmeal基本信息        this.save(setmealDto);                List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();        setmealDishes = setmealDishes.stream().map((item) -&gt; {            item.setSetmealId(setmealDto.getId());            return item;        }).collect(Collectors.toList());        //保存套餐和菜品关联信息到setmeal_dish        setmealDishService.saveBatch(setmealDishes);    }}</code></pre><h2 id="17-套餐信息分页查询"><a href="#17-套餐信息分页查询" class="headerlink" title="17. 套餐信息分页查询"></a>17. 套餐信息分页查询</h2><h3 id="17-1-需求分析"><a href="#17-1-需求分析" class="headerlink" title="17.1 需求分析"></a>17.1 需求分析</h3><ul><li>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>一般的系统中都会以分页的方式来展示列表数据</li></ul><p><img src="image-20231006174357620.png" alt="image-20231006174357620"></p><h3 id="17-2-梳理交互过程"><a href="#17-2-梳理交互过程" class="headerlink" title="17.2 梳理交互过程"></a>17.2 梳理交互过程</h3><ol><li>页面发送ajax请求，将分页查询参数（page，pageSize，name）提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示（已完成）</li></ol><p><img src="image-20231006174558812.png" alt="image-20231006174558812"></p><h3 id="17-3-代码开发"><a href="#17-3-代码开发" class="headerlink" title="17.3 代码开发"></a>17.3 代码开发</h3><ul><li>SetmealController类中，添加list方法<br>其实跟前面的菜品信息分页查询代码几乎一模一样，这遍就当review了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;(page, pageSize);        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(name != null, Setmeal::getName, name);    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    setmealService.page(pageInfo, queryWrapper);        // 通过categoryId查询categoryName    BeanUtils.copyProperties(pageInfo, dtoPage, "records");    List&lt;Setmeal&gt; records = pageInfo.getRecords();    List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; {        SetmealDto setmealDto = new SetmealDto();        BeanUtils.copyProperties(item, setmealDto);        Long categoryId = item.getCategoryId();        Category category = categoryService.getById(categoryId);        if (category != null) {            setmealDto.setCategoryName(category.getName());        }        return setmealDto;    }).collect(Collectors.toList());    dtoPage.setRecords(list);    return Result.success(dtoPage);}</code></pre><h2 id="18-删除套餐"><a href="#18-删除套餐" class="headerlink" title="18. 删除套餐"></a>18. 删除套餐</h2><h3 id="18-1-需求分析"><a href="#18-1-需求分析" class="headerlink" title="18.1 需求分析"></a>18.1 需求分析</h3><ul><li>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息</li><li>也可以通过复选框选择多个套餐，选择批量删除一次性删除多个套餐</li></ul><p>注意：对于<code>在售</code>中的套餐不能删除，需要先<code>停售</code>，然后才能删除</p><h3 id="18-2-梳理交互过程"><a href="#18-2-梳理交互过程" class="headerlink" title="18.2 梳理交互过程"></a>18.2 梳理交互过程</h3><ol><li>删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</li><li>删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐开发删除套餐功能<ul><li>请求网址: <a href="http://localhost/setmeal?ids=1579044544635232258,1415580119015145474">http://localhost/setmeal?ids=1579044544635232258,1415580119015145474</a></li><li>请求方法: DELETE</li></ul></li></ol><ul><li>删除单个套餐和批量删除这两种请求的地址和请求方式都是相同的</li><li>不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</li></ul><h3 id="18-3-代码开发"><a href="#18-3-代码开发" class="headerlink" title="18.3 代码开发"></a>18.3 代码开发</h3><ul><li>在SetmealController中添加delete方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; deleteByIds(@RequestParam List&lt;Long&gt; ids) {    log.info("要删除的套餐id为：{}",ids);    setmealService.removeWithDish(ids);    return Result.success("删除成功");}</code></pre><ul><li>在<code>SetmealServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void removeWithDish(List&lt;Long&gt; ids) {    //先判断一下能不能删，如果status为1，则套餐在售，不能删    //select * from setmeal where id in (ids) and status = 1    LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();    setmealLambdaQueryWrapper.in(Setmeal::getId, ids);    setmealLambdaQueryWrapper.eq(Setmeal::getStatus, 1);        int count = this.count(setmealLambdaQueryWrapper);    if (count &gt; 0) {        throw new CustomException("套餐正在售卖中，请先停售再进行删除");    }    //如果没有在售套餐，则直接删除    this.removeByIds(ids);        //继续删除    LambdaQueryWrapper&lt;SetmealDish&gt; setmealDishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();    setmealDishLambdaQueryWrapper.in(SetmealDish::getSetmealId, ids);    setmealDishService.remove(setmealDishLambdaQueryWrapper);}</code></pre><h1 id="用户端操作"><a href="#用户端操作" class="headerlink" title="用户端操作"></a>用户端操作</h1><h2 id="19-邮件发送（替换手机验证）"><a href="#19-邮件发送（替换手机验证）" class="headerlink" title="19. 邮件发送（替换手机验证）"></a>19. 邮件发送（替换手机验证）</h2><p>其实黑马这里用的是短信业务，但咱也没那条件，所以我只能自己换成QQ邮箱验证码了，这个简单，具体操作我们也只需要开启POP3/STMP服务，获取一个16位的授权码：oblbemkgmircebfj</p><p><img src="20230412053436_681.jpg" alt="img"></p><h3 id="19-1-需求分析"><a href="#19-1-需求分析" class="headerlink" title="19.1 需求分析"></a>19.1 需求分析</h3><ul><li>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能(咱平替成邮箱验证码)</li><li>手机（邮箱）验证码登录的优点：<ul><li>方便快捷，无需注册，直接登录</li><li>使用短信验证码作为登录凭证，无需记忆密码</li><li>安全</li></ul></li><li>登录流程:<ul><li>输入手机号（邮箱） &gt; 获取验证码 &gt; 输入验证码 &gt; 点击登录 &gt; 登录成功</li></ul></li><li>用户登录界面</li></ul><p><img src="20230412034549_543.jpg" alt="img"></p><h3 id="19-2-数据模型"><a href="#19-2-数据模型" class="headerlink" title="19.2 数据模型"></a>19.2 数据模型</h3><p>这里的手机号也是varchar类型，所以我们就不用动它了，咱就用它存咱自己邮箱号就行（动手能力强的自己改一下也无所谓，大不了改出BUG再自己修）</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">sex</td><td align="center">varchar(2)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别</td></tr><tr><td align="center">id_number</td><td align="center">varchar(18)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">身份证号</td></tr><tr><td align="center">avatar</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">头像</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">0</td><td align="center">状态 0:禁用，1:正常</td></tr></tbody></table><ul><li>手机号（邮箱）是区分不同用户的标识，在用户登录的时候判断所输入的手机号（邮箱）是否存储在表中</li><li>如果不在表中，说明该用户为一个新的用户，将该用户自动保在user表中</li></ul><h3 id="19-3-准备工作"><a href="#19-3-准备工作" class="headerlink" title="19.3 准备工作"></a>19.3 准备工作</h3><p>在开发业务功能之前，我们先将要用到的类和接口的基本结构都创建好</p><ul><li><p>实体类User</p></li><li><p>Mapper接口UserMapper</p></li><li><p>业务层接口UserService</p></li><li><p>业务层实现类UserServiceImpl</p></li><li><p>控制层UserController</p></li><li><p>工具类（我们自己造自己的邮箱工具类）</p><ul><li>首先导入坐标</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.activation&lt;/groupId&gt;    &lt;artifactId&gt;activation&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.mail&lt;/groupId&gt;    &lt;artifactId&gt;mail&lt;/artifactId&gt;    &lt;version&gt;1.4.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-email&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li><ul><li>然后编写一个工具类，用于发送邮件验证码</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Properties;import javax.mail.Authenticator;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class MailUtils {    public static void main(String[] args) throws MessagingException {        //可以在这里直接测试方法，填自己的邮箱即可        sendTestMail("2442926123@qq.com", new MailUtils().achieveCode());    }    public static void sendTestMail(String email, String code) throws MessagingException {        // 创建Properties 类用于记录邮箱的一些属性        Properties props = new Properties();        // 表示SMTP发送邮件，必须进行身份验证        props.put("mail.smtp.auth", "true");        //此处填写SMTP服务器        props.put("mail.smtp.host", "smtp.qq.com");        //端口号，QQ邮箱端口587        props.put("mail.smtp.port", "587");        // 此处填写，写信人的账号        props.put("mail.user", "2442926123@qq.com");        // 此处填写16位STMP口令        props.put("mail.password", "oblbemkgmircebfj");        // 构建授权信息，用于进行SMTP进行身份验证        Authenticator authenticator = new Authenticator() {            protected PasswordAuthentication getPasswordAuthentication() {                // 用户名、密码                String userName = props.getProperty("mail.user");                String password = props.getProperty("mail.password");                return new PasswordAuthentication(userName, password);            }        };        // 使用环境属性和授权信息，创建邮件会话        Session mailSession = Session.getInstance(props, authenticator);        // 创建邮件消息        MimeMessage message = new MimeMessage(mailSession);        // 设置发件人        InternetAddress form = new InternetAddress(props.getProperty("mail.user"));        message.setFrom(form);        // 设置收件人的邮箱        InternetAddress to = new InternetAddress(email);        message.setRecipient(RecipientType.TO, to);        // 设置邮件标题        message.setSubject("【瑞吉外卖】验证码");        // 设置邮件的内容体        message.setContent("尊敬的用户:你好!\n注册验证码为:" + code + "(有效期为一分钟,请勿告知他人)", "text/html;charset=UTF-8");        // 最后当然就是发送邮件啦        Transport.send(message);    }    // 生成验证码    public static String achieveCode() {  //由于数字 1 、 0 和字母 O 、l 有时分不清楚，所以，没有数字 1 、 0        String[] beforeShuffle = new String[]{"2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F","G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a","b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v","w", "x", "y", "z"};        List&lt;String&gt; list = Arrays.asList(beforeShuffle);//将数组转换为集合        Collections.shuffle(list);  //打乱集合顺序        StringBuilder sb = new StringBuilder();        for (String s : list) {            sb.append(s); //将集合转化为字符串        }        return sb.substring(3, 8);    }}</code></pre><h3 id="19-4-修改拦截器"><a href="#19-4-修改拦截器" class="headerlink" title="19.4 修改拦截器"></a>19.4 修改拦截器</h3><ul><li>对用户登录操作放行</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义不需要处理的请求String[] urls = new String[]{        "/employee/login",        "/employee/logout",        "/backend/**",        "/front/**",        "/common/**",        //对用户登陆操作放行        "/user/login",        "/user/sendMsg"};</code></pre><ul><li>判断用户是否登录</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断用户是否登录if(request.getSession().getAttribute("user") != null){    log.info("用户已登录，用户id为：{}",request.getSession().getAttribute("user"));    Long userId = (Long)request.getSession().getAttribute("user");    BaseContext.setCurrentId(userId);    filterChain.doFilter(request,response);    return;}</code></pre><h3 id="19-5-发送验证码"><a href="#19-5-发送验证码" class="headerlink" title="19.5 发送验证码"></a>19.5 发送验证码</h3><ul><li>发送验证码的请求方式是POST，路径为<code>/user/sendMsg</code></li><li>那么我们在UserController控制层中，添加sendMsg方法<br>这个是真滴能发送的奥，邮箱里可以收到的，待会儿我就写校验功能了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/sendMsg")public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException {    String phone = user.getPhone();    if (!phone.isEmpty()) {        //随机生成一个验证码        String code = MailUtils.achieveCode();        log.info(code);        //这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        //验证码存session，方便后面拿出来比对        session.setAttribute(phone, code);        return Result.success("验证码发送成功");    }    return Result.error("验证码发送失败");}</code></pre><h3 id="19-6-登录功能"><a href="#19-6-登录功能" class="headerlink" title="19.6 登录功能"></a>19.6 登录功能</h3><ul><li>输入验证码，点击登录</li></ul><p> 请求路径为:<code>/user/login</code>，数据以json格式返回给服务端</p><p><img src="image-20231013165753060.png" alt="image-20231013165753060"></p><p><img src="image-20231013165802147.png" alt="image-20231013165802147"></p><ul><li>在UserController控制层中，添加<code>login</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/login")public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {    log.info(map.toString());    //获取邮箱    String phone = map.get("phone").toString();    //获取验证码    String code = map.get("code").toString();    //从session中获取验证码    String codeInSession = session.getAttribute(phone).toString();    //比较这用户输入的验证码和session中存的验证码是否一致    if (code != null &amp;&amp; code.equals(codeInSession)) {        //如果输入正确，判断一下当前用户是否存在        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        //判断依据是从数据库中查询是否有其邮箱        queryWrapper.eq(User::getPhone, phone);        User user = userService.getOne(queryWrapper);        //如果不存在，则创建一个，存入数据库        if (user == null) {            user = new User();            user.setPhone(phone);            userService.save(user);            user.setName("用户" + codeInSession);        }        //存个session，表示登录状态        session.setAttribute("user",user.getId());        //并将其作为结果返回        return Result.success(user);    }    return Result.error("登录失败");}</code></pre><h2 id="20-地址簿"><a href="#20-地址簿" class="headerlink" title="20. 地址簿"></a>20. 地址簿</h2><h3 id="20-1-需求分析"><a href="#20-1-需求分析" class="headerlink" title="20.1 需求分析"></a>20.1 需求分析</h3><ul><li>地址簿，指的是移动端消费者用户的地址信息（外卖快递的收货地址）</li><li>用户登录成功后可以维护自己的地址信息（自己修改删除新增等）</li><li>同一个用户可以有多个地址信息，但是只能有一个默认地址。（有默认地址的话会很方便）</li></ul><p><img src="image-20231014115207776.png" alt="image-20231014115207776"></p><h3 id="20-2-数据模型"><a href="#20-2-数据模型" class="headerlink" title="20.2 数据模型"></a>20.2 数据模型</h3><p>注意这里的phone类型为varchar(11)，这显然不够我们邮箱用的，所以我们自己改一下这里，改大一点，不然做到新增地址的时候，会报错<br><code>com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column 'phone' at row 1</code></p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户id</td></tr><tr><td align="center">consignee</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr><tr><td align="center">sex</td><td align="center">tinyint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别 0 女 1 男</td></tr><tr><td align="center">phone</td><td align="center">varchar(11)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">province_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级区划编号</td></tr><tr><td align="center">province_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级名称</td></tr><tr><td align="center">city_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级区划编号</td></tr><tr><td align="center">city_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级名称</td></tr><tr><td align="center">district_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级区划编号</td></tr><tr><td align="center">district_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级名称</td></tr><tr><td align="center">detail</td><td align="center">varchar(200)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">详细地址</td></tr><tr><td align="center">label</td><td align="center">varchar(100)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">标签</td></tr><tr><td align="center">is_default</td><td align="center">tinyint(1)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">默认 0 否 1是</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="20-3-准备工作"><a href="#20-3-准备工作" class="headerlink" title="20.3 准备工作"></a>20.3 准备工作</h3><ol><li>创建对应的实体类<code>AddressBook</code></li><li><code>Mapper</code>接口<code>AddressBookMapper</code></li><li>业务层接口<code>AddressBookService</code></li><li>业务层实现类<code>AddressBookServicelmpl</code></li><li>控制层<code>AddressBookController</code></li></ol><h3 id="20-4-新增收货地址"><a href="#20-4-新增收货地址" class="headerlink" title="20.4 新增收货地址"></a>20.4 新增收货地址</h3><p><img src="20230412055617_809.jpg" alt="img"></p><ul><li>修改前端代码<br>这段代码是新增地址的前端代码 address-edit.html ，我们将其中的手机号全部替换成邮箱，判断手机号的正则也换成判断邮箱的正则，懒人就直接Copy我这段代码就好了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=no,minimal-ui"&gt;        &lt;title&gt;菩提阁&lt;/title&gt;        &lt;link rel="icon" href="./../images/favico.ico"&gt;        &lt;!--不同屏幕尺寸根字体设置--&gt;        &lt;script src="./../js/base.js"&gt;&lt;/script&gt;        &lt;!--element-ui的样式--&gt;        &lt;link rel="stylesheet" href="../../backend/plugins/element-ui/index.css" /&gt;        &lt;!--引入vant样式--&gt;        &lt;link rel="stylesheet" href="../styles/vant.min.css"/&gt;        &lt;!-- 引入样式  --&gt;        &lt;link rel="stylesheet" href="../styles/index.css" /&gt;        &lt;!--本页面内容的样式--&gt;        &lt;link rel="stylesheet" href="./../styles/address-edit.css" /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="address_edit" class="app"&gt;            &lt;div class="divHead"&gt;                &lt;div class="divTitle"&gt;                    &lt;i class="el-icon-arrow-left" @click="goBack"&gt;&lt;/i&gt;{{title}}                &lt;/div&gt;            &lt;/div&gt;            &lt;div class="divContent"&gt;                &lt;div class="divItem"&gt;                   &lt;span&gt;联系人：&lt;/span&gt;                    &lt;el-input placeholder=" 请填写收货人的姓名" v-model="form.consignee"  maxlength='10' class="inputUser"/&gt;&lt;/el-input&gt;                   &lt;span class="spanChecked" @click="form.sex = '1'"&gt;                    &lt;i :class="{iActive:form.sex === '1'}"&gt;&lt;/i&gt;                    先生                   &lt;/span&gt;                   &lt;span class="spanChecked" @click="form.sex = '0'"&gt;                    &lt;i :class="{iActive:form.sex === '0'}"&gt;&lt;/i&gt;                    女士                &lt;/span&gt;                &lt;/div&gt;                &lt;div class="divItem"&gt;                    &lt;span&gt;邮箱：&lt;/span&gt;                    &lt;el-input placeholder=" 请填写收货人邮箱" v-model="form.phone"  maxlength='20' style="width: calc(100% - 80rem);"/&gt;&lt;/el-input&gt;                &lt;/div&gt;                &lt;div class="divItem"&gt;                    &lt;span&gt;收货地址：&lt;/span&gt;                     &lt;el-input placeholder=" 请输入收货地址" v-model="form.detail"  maxlength='140'/&gt;&lt;/el-input&gt;                &lt;/div&gt;                &lt;div class="divItem "&gt;                    &lt;span&gt;标签：&lt;/span&gt;                     &lt;span v-for="(item,index) in labelList" :key="index" @click="form.label = item;activeIndex = index" :class="{spanItem:true,spanActiveSchool:activeIndex === index}"&gt;{{item}}&lt;/span&gt;                &lt;/div&gt;                &lt;div class="divSave" @click="saveAddress"&gt;保存地址&lt;/div&gt;                &lt;div class="divDelete" @click="deleteAddress" v-if="id"&gt;删除地址&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 开发环境版本,包含了有帮助的命令行警告 --&gt;        &lt;script src="../../backend/plugins/vue/vue.js"&gt;&lt;/script&gt;        &lt;!-- 引入组件库 --&gt;        &lt;script src="../../backend/plugins/element-ui/index.js"&gt;&lt;/script&gt;        &lt;!-- 引入vant样式 --&gt;        &lt;script src="./../js/vant.min.js"&gt;&lt;/script&gt;               &lt;script src="./../js/common.js"&gt;&lt;/script&gt;        &lt;script src="./../api/address.js"&gt;&lt;/script&gt;        &lt;!-- 引入axios --&gt;        &lt;script src="../../backend/plugins/axios/axios.min.js"&gt;&lt;/script&gt;        &lt;script src="./../js/request.js"&gt;&lt;/script&gt;        &lt;script&gt;            new Vue({                el:"#address_edit",                data(){                    return {                        title:'新增收货地址',                        form:{                            consignee:'',//联系人                            phone:undefined,//手机号                            sex:'1',//0表示女 1 表示男                            detail:'',//收货地址                            label:'公司',//标签                        },                        labelList:[                            '无','公司','家','学校'                        ],                        id:undefined,                        activeIndex :0                    }                },                computed:{},                created(){                    this.initData()                },                mounted(){                },                methods:{                    goBack(){                        history.go(-1)                    },                    async initData(){                        const params = parseUrl(window.location.search)                        this.id = params.id                        if(params.id){                            this.title = '编辑收货地址'                            const res = await addressFindOneApi(params.id)                            if(res.code === 1){                                this.form = res.data                            }else{                                this.$notify({ type:'warning', message:res.msg});                            }                        }                    },                    async saveAddress(){                        const form = this.form                        if(!form.consignee){                            this.$notify({ type:'warning', message:'请输入联系人'});                            return                         }                        if(!form.phone){                            this.$notify({ type:'warning', message:'请输入邮箱'});                            return                         }                        if(!form.detail){                            this.$notify({ type:'warning', message:'请输入收货地址'});                            return                         }                        const reg = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/                        if(!reg.test(form.phone)){                            this.$notify({ type:'warning', message:'邮箱不合法'});                            return                          }                        let res= {}                        if(this.id){                            res = await updateAddressApi(this.form)                        }else{                            res = await addAddressApi(this.form)                        }                                                if(res.code === 1){                            window.requestAnimationFrame(()=&gt;{                                window.location.replace('/front/page/address.html')                            })                        }else{                            this.$notify({ type:'warning', message:res.msg});                        }                    },                    deleteAddress(){                        this.$dialog.confirm({                            title: '确认删除',                            message: '确认要删除当前地址吗？',                        })                        .then( async () =&gt; {                            const res = await deleteAddressApi({ids:this.id })                            if(res.code === 1){                                window.requestAnimationFrame(()=&gt;{                                    window.location.replace('/front/page/address.html')                                })                            }else{                                this.$notify({ type:'warning', message:res.msg});                            }                        })                        .catch(() =&gt; {                        });                    },                }            })            &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>请求路径</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//新增地址function  addAddressApi(data){    return $axios({        'url': '/addressBook',        'method': 'post',        data      })}</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; addAddress(@RequestBody AddressBook addressBook) {    addressBook.setUserId(BaseContext.getCurrentId());    log.info("addressBook:{}", addressBook);    addressBookService.save(addressBook);    return Result.success("添加地址成功");}</code></pre><h3 id="20-5-修改收货地址"><a href="#20-5-修改收货地址" class="headerlink" title="20.5 修改收货地址"></a>20.5 修改收货地址</h3><p><img src="image-20231014131340422.png" alt="image-20231014131340422"></p><ul><li>前端代码分析</li></ul><p>首先点击编辑按钮，回显数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//查询单个地址function addressFindOneApi(id) {  return $axios({    'url': `/addressBook/${id}`,    'method': 'get',  })}</code></pre><p>修改数据之后，点击保存，发送请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//修改地址function  updateAddressApi(data){    return $axios({        'url': '/addressBook',        'method': 'put',        data      })}</code></pre><ul><li>代码实现</li></ul><h3 id="20-6-查询地址"><a href="#20-6-查询地址" class="headerlink" title="20.6 查询地址"></a>20.6 查询地址</h3><ul><li>点击地址管理，查看请求方式与地址</li></ul><p><img src="20230412045510_417.jpg" alt="img"></p><ul><li>请求路径为<code>/addressBook/list</code>，请求方式为GET，那么我们现在来<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public R&lt;List&lt;AddressBook&gt;&gt; list() {    AddressBook addressBook = new AddressBook();    addressBook.setUserId(BaseContext.getCurrentId());    LambdaQueryWrapper&lt;AddressBook&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();    wrapper.eq(addressBook.getUserId() != null, AddressBook::getUserId, addressBook.getUserId());    wrapper.orderByDesc(AddressBook::getUpdateTime);        //SQL:select * from address_book where user_id = ? order by update_time desc    List&lt;AddressBook&gt; list = addressBookService.list(wrapper);    return R.success(list);}</code></pre><h3 id="20-7-设置默认地址"><a href="#20-7-设置默认地址" class="headerlink" title="20.7 设置默认地址"></a>20.7 设置默认地址</h3><ul><li><p>先来想想怎么设置默认地址</p><ul><li><p>默认地址，按理说数据库中，有且仅有一条数据为默认地址，也就是<code>is_default</code>字段为1</p></li><li><p>如何保证整个表中的</p><pre class="line-numbers language-none"><code class="language-none">is_default</code></pre><p>字段只有一条为1</p><ul><li>每次设置默认地址的时候，将当前用户所有地址的<code>is_default</code>字段设为0，随后将当前地址的<code>is_default</code>字段设为1</li></ul></li></ul></li><li><p>当我们点击上图的设为默认按钮的时候，会发送请求</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//设置默认地址function  setDefaultAddressApi(data){  return $axios({      'url': '/addressBook/default',      'method': 'put',      data    })}</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping("/default")public R&lt;String&gt; setDefault(@RequestBody AddressBook addressBook) {    LambdaUpdateWrapper&lt;AddressBook&gt; lambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;();    lambdaUpdateWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());    lambdaUpdateWrapper.set(AddressBook::getIsDefault, 0);    //SQL:update address_book set is_default = 0 where user_id = ?    addressBookService.update(lambdaUpdateWrapper);    addressBook.setIsDefault(1);    //SQL:update address_book set is_default = 1 where id = ?    addressBookService.updateById(addressBook);    return R.success("设置默认地址成功");}</code></pre><h2 id="21-菜品展示"><a href="#21-菜品展示" class="headerlink" title="21. 菜品展示"></a>21. 菜品展示</h2><h3 id="21-1-需求分析"><a href="#21-1-需求分析" class="headerlink" title="21.1 需求分析"></a>21.1 需求分析</h3><ul><li>用户登陆成功之后，跳转到菜品页面，根据菜品分类来展示菜品和套餐</li><li>如果菜品设置了口味信息，则需要展示选择规格按钮，否则只展示+按钮（这部分是前端实现的）</li></ul><p><img src="image-20231014135711064.png" alt="image-20231014135711064"></p><h3 id="21-2-梳理交互过程"><a href="#21-2-梳理交互过程" class="headerlink" title="21.2 梳理交互过程"></a>21.2 梳理交互过程</h3><ol><li>页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类）（已完成）</li><li>页面发送ajax请求，根据具体的菜品/套餐分类，展示对应分类中的具体菜品（已完成）</li></ol><h3 id="21-3-前端分析"><a href="#21-3-前端分析" class="headerlink" title="21.3 前端分析"></a>21.3 前端分析</h3><ul><li><p>启动服务器，登录账号，监测Network选项卡，发现登录到首页会发送两个请求</p><ul><li>分类</li></ul><blockquote><p>请求网址: <a href="http://localhost/category/list">http://localhost/category/list</a><br>请求方法: GET</p></blockquote><ul><li>购物车</li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/list">http://localhost/shoppingCart/list</a><br>请求方法: GET</p></blockquote></li><li><p>其中分类请求我们之前写过了，但是当我们访问页面的时候，并没有加载出来</p><ul><li><p>原因是购物车相关功能还没写，所以这里我们用一个写死了的json数据骗骗它<br>将url换成我们注释掉的那个就好了</p></li><li><pre><code class="js">//获取购物车内商品的集合function cartListApi(data) {    return $axios({        'url': '/shoppingCart/list',        //'url': '/front/cartData.json',        'method': 'get',        params: {...data}    })}<pre class="line-numbers language-none"><code class="language-none">- 那我们再次重启服务器，此时首页已经可以显示分类数据![image-20231014141230596](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/image-20231014141230596.png)获取分类数据：http://localhost/category/list ，之前在分类管理中已完成展示菜品分类中的具体菜品：http://localhost/dish/list ，之前在套餐管理中已完成（新增套餐时需要选择相应的菜品）展示套餐分类中的具体套餐在后面开发![image-20231014151254220](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/image-20231014151254220.png)### 21.4 选择规格- 但是现在还存在一个问题，我们的菜品是有口味数据的，那么这里的按钮不该是一个`+`，而应该是`选择规格````html&lt;div class="divTypes" v-if="detailsDialog.item.flavors &amp;&amp; detailsDialog.item.flavors.length &gt; 0 &amp;&amp; !detailsDialog.item.number " @click ="chooseFlavorClick(detailsDialog.item)"&gt;选择规格&lt;/div&gt;               </code></pre></code></pre></li></ul></li><li><p>通过代码我们可以看出，选择规格按钮，是根据服务端返回数据中是否有flavors字段来决定的，但我们返回的是一个<code>List&lt;Dish&gt;</code>，其中并没有<code>flavors</code>属性，所以我们需要修改前面的方法返回值为<code>DishDto</code>，<code>DishDto</code>继承了<code>Dish</code>，且新增了<code>flavors</code>属性</p></li><li><p>那么现在我们直接来修改原本的list方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) {    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    log.info("查询到的菜品信息list:{}",list);    //item就是list中的每一条数据，相当于遍历了    List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; {        //创建一个dishDto对象        DishDto dishDto = new DishDto();        //将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);                //然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId = item.getId();        //条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //条件就是菜品id        lambdaQueryWrapper.eq(itemId != null, DishFlavor::getDishId, itemId);        //根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(lambdaQueryWrapper);        //赋给dishDto的对应属性        dishDto.setFlavors(flavors);        //并将dishDto作为结果返回        return dishDto;        //将所有返回结果收集起来，封装成List    }).collect(Collectors.toList());    return Result.success(dishDtoList);}</code></pre><h2 id="22-套餐展示"><a href="#22-套餐展示" class="headerlink" title="22. 套餐展示"></a>22. 套餐展示</h2><ul><li>关于菜品的展示我们就完成了，但是套餐和菜品用的并不是同一个controller，所以我们还需要来完善套餐展示</li></ul><blockquote><p>请求网址: <a href="http://localhost/setmeal/list?categoryId=1413342269393674242&amp;status=1">http://localhost/setmeal/list?categoryId=1413342269393674242&amp;status=1</a><br>请求方法: GET</p></blockquote><ul><li>那么我们现在就在<code>SetmealController</code>中编写对应的方法<br>由于套餐没有口味数据，所以开发起来还是比较简单的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) {    //条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.eq(setmeal.getCategoryId() != null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() != null, Setmeal::getStatus, 1);    //排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList = setmealService.list(queryWrapper);    return Result.success(setmealList);}</code></pre><h2 id="23-购物车"><a href="#23-购物车" class="headerlink" title="23. 购物车"></a>23. 购物车</h2><h3 id="23-1-需求分析"><a href="#23-1-需求分析" class="headerlink" title="23.1 需求分析"></a>23.1 需求分析</h3><ul><li>移动端用户可以将菜品/套餐添加到购物车</li><li>对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现）</li><li>对于套餐来说，可以直接点击当前套餐加入购物车</li><li>在购物车中可以修改菜品/套餐的数量，也可以清空购物车</li></ul><p><img src="image-20231014172121854.png" alt="image-20231014172121854"></p><h3 id="23-2-数据模型"><a href="#23-2-数据模型" class="headerlink" title="23.2 数据模型"></a>23.2 数据模型</h3><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名称</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr></tbody></table><h3 id="23-3-梳理交互过程"><a href="#23-3-梳理交互过程" class="headerlink" title="23.3 梳理交互过程"></a>23.3 梳理交互过程</h3><ol><li>点击加入购物车按钮，页面发送ajax请求，请求服务端，将菜品/套餐添加到购物车</li><li>点击购物车图标，页面发送ajax请求，请求服务端，查询购物车中的菜品和套餐</li><li>点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</li></ol><h3 id="23-4-准备工作"><a href="#23-4-准备工作" class="headerlink" title="23.4 准备工作"></a>23.4 准备工作</h3><p>在开发业务功能之前，先将需要用到的类和接口的基本结构都创建好</p><ol><li>实体类<code>ShoppingCart</code></li><li><code>Mapper</code>接口<code>ShoppingCartMapper</code></li><li>业务层接口<code>ShoppingCartService</code></li><li>业务层实现类<code>ShoppingCartServiceImpl</code></li><li>控制层<code>ShoppingCartController</code></li></ol><h3 id="23-5-代码开发"><a href="#23-5-代码开发" class="headerlink" title="23.5 代码开发"></a>23.5 代码开发</h3><h4 id="加入购物车"><a href="#加入购物车" class="headerlink" title="加入购物车"></a>加入购物车</h4><ul><li>点击<code>加入购物车</code>，页面发送请求，请求路径<code>/shoppingCart/add</code>，请求方式<code>POST</code></li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/add">http://localhost/shoppingCart/add</a><br>请求方法: POST</p></blockquote><ul><li>页面将数据以json格式发送给服务端</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/add")public Result&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart) {    log.info("shoppingCart={}", shoppingCart);    //获取当前用户id    Long currentId = BaseContext.getCurrentId();    //设置当前用户id    shoppingCart.setUserId(currentId);    //条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(ShoppingCart::getUserId, currentId);        //获取当前菜品id    Long dishId = shoppingCart.getDishId();    //判断添加的是菜品还是套餐    if (dishId != null) {        queryWrapper.eq(ShoppingCart::getDishId, dishId);    } else {        queryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());    }    //查询当前菜品或者套餐是否在购物车中    ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);    if (cartServiceOne != null) {        //如果已存在就在当前的数量上加1        Integer number = cartServiceOne.getNumber();        cartServiceOne.setNumber(number + 1);        shoppingCartService.updateById(cartServiceOne);    } else {        //如果不存在，则还需设置一下创建时间        shoppingCart.setCreateTime(LocalDateTime.now());        //如果不存在，则添加到购物车，数量默认为1        shoppingCartService.save(shoppingCart);        //这里是为了统一结果，最后都返回cartServiceOne会比较方便        cartServiceOne = shoppingCart;    }    return Result.success(cartServiceOne);}</code></pre><h4 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h4><ul><li>之前为了不报错，我们将查看购物车的地址换成了一个死数据<br>那现在我们要做的就是换成真数据</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//获取购物车内商品的集合function cartListApi(data) {    return $axios({        'url': '/shoppingCart/list',        //'url': '/front/cartData.json',        'method': 'get',        params: {...data}    })}</code></pre><ul><li>请求路径为<code>/shoppingCart/list</code>，请求方式为<code>GET</code><br>直接来<code>ShoppingCartController</code>中添加对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;ShoppingCart&gt;&gt; list() {    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    Long userId = BaseContext.getCurrentId();    queryWrapper.eq(ShoppingCart::getUserId, userId);    List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(queryWrapper);    return Result.success(shoppingCarts);}</code></pre><h4 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h4><ul><li><p>我们点击上图中的清空按钮，请求路径为<code>/shoppingCart/clean</code>，请求方式为<code>DELETE</code></p></li><li><p>清空购物车的逻辑倒是比较简单，获取用户id，然后去<code>shopping__cart</code>表中删除对应id的数据即可<br>那么我们现在就来<code>ShoppingCartController</code>中编写对应的方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMapping("/clean")public Result&lt;String&gt; clean() {    //条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //获取当前用户id    Long userId = BaseContext.getCurrentId();    queryWrapper.eq(userId != null, ShoppingCart::getUserId, userId);    //删除当前用户id的所有购物车数据    shoppingCartService.remove(queryWrapper);    return Result.success("成功清空购物车");}</code></pre><h2 id="24-用户下单"><a href="#24-用户下单" class="headerlink" title="24. 用户下单"></a>24. 用户下单</h2><h3 id="24-1-需求分析"><a href="#24-1-需求分析" class="headerlink" title="24.1 需求分析"></a>24.1 需求分析</h3><ul><li>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的<code>去结算</code>按钮，页面跳转到订单确认页面，点击<code>去支付</code>按钮，完成下单操作</li></ul><p><img src="image-20231015113216825.png" alt="image-20231015113216825"></p><h3 id="24-2-数据模型"><a href="#24-2-数据模型" class="headerlink" title="24.2 数据模型"></a>24.2 数据模型</h3><p>户下单业务对应的数据表为<code>orders</code>表和<code>order_detail</code>表</p><ul><li><code>orders</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">number</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单号</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">订单状态 1待付款，2待派送，3已派送，4已完成，5已取消</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单用户</td></tr><tr><td align="center">address_book_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址id</td></tr><tr><td align="center">order_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单时间</td></tr><tr><td align="center">checkout_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">结账时间</td></tr><tr><td align="center">pay_method</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">支付方式 1微信,2支付宝</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">实收金额</td></tr><tr><td align="center">remark</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">备注</td></tr><tr><td align="center">phone</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">address</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址</td></tr><tr><td align="center">user_name</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户名</td></tr><tr><td align="center">consignee</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr></tbody></table><ul><li><code>order_detail</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名字</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">order_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单id</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr></tbody></table><h3 id="24-3-梳理交互过程"><a href="#24-3-梳理交互过程" class="headerlink" title="24.3 梳理交互过程"></a>24.3 梳理交互过程</h3><ol><li>在购物车中点击<code>去结算</code>按钮，页面跳转到订单确认页面</li><li>在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址</li><li>在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据（已完成）</li><li>在订单确认页面点击<code>去支付</code>按钮，发送ajax请求，请求服务端，完成下单操作</li></ol><h3 id="24-4-准备工作"><a href="#24-4-准备工作" class="headerlink" title="24.4 准备工作"></a>24.4 准备工作</h3><ol><li><p>实体类<code>Orders</code>和<code>OrderDetail</code></p></li><li><p><code>Mapper</code>接口<code>OrderMapper</code>、<code>OrderDetailMapper</code></p></li><li><p>业务层接口<code>OrderService</code>、<code>OrderDetailService</code></p></li><li><p>业务层接口实现类<code>OrderServiceImpl</code>、<code>OrderDetailServiceImpl</code></p></li><li><p>控制层<code>OrderController</code>、<code>OrderDetailController</code></p></li></ol><h3 id="24-5-获取默认地址"><a href="#24-5-获取默认地址" class="headerlink" title="24.5 获取默认地址"></a>24.5 获取默认地址</h3><ul><li>我们点击去结算按钮，然后查看发送的请求url和方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/addressBook/default">http://localhost/addressBook/default</a><br>请求方法: GET</p></blockquote><ul><li>我们根据请求路径<code>/addressBook/default</code>，请求方式<code>GET</code>自己来编写方法，进入到<code>AddressBookController</code>编写</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/default")public Result&lt;AddressBook&gt; defaultAddress() {    //条件构造器    LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //当前用户    queryWrapper.eq(userId != null, AddressBook::getUserId, BaseContext.getCurrentId());    //默认地址    queryWrapper.eq(AddressBook::getIsDefault, 1);        AddressBook addressBook = addressBookService.getOne(queryWrapper);    return Result.success(addressBook);}</code></pre><h3 id="24-6-结算"><a href="#24-6-结算" class="headerlink" title="24.6 结算"></a>24.6 结算</h3><ul><li>点击上图中的去结算按钮，查看发送的请求url与请求方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/order/submit">http://localhost/order/submit</a><br>请求方法: POST</p></blockquote><ul><li>提交给服务端的数据格式为JSON</li></ul><pre class="line-numbers language-none"><code class="language-none">AVRASMaddressBookId: "1579828298672885762",payMethod: 1,remark: ""</code></pre><ul><li><p>请求路径<code>/order/submit</code>，请求方式<code>POST</code>，那么我们现在就去<code>OrderController</code>中开发对应的功能<br>具体的<code>submit</code>方法我们放在<code>OrderService</code>写，<code>OrderController</code>调用写好的<code>submit</code>方法就好了</p></li><li><p>编写具体的submit方法的逻辑代码，我们先来分析一下下单功能，都需要做什么事情</p><ul><li><p>获取当前用户id</p></li><li><p>根据用户id查询其购物车数据</p></li><li><p>根据查询到的购物车数据，对订单表插入数据（1条）</p></li><li><p>根据查询到的购物车数据，对订单明细表插入数据（多条）</p></li><li><p>清空购物车数据</p></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService {    @Autowired    private ShoppingCartService shoppingCartService;    @Autowired    private UserService userService;    @Autowired    private AddressBookService addressBookService;    @Autowired    private OrderDetailService orderDetailService;    @Override    public void submit(Orders orders) {        //获取当前用户id        Long userId = BaseContext.getCurrentId();        //条件构造器        LambdaQueryWrapper&lt;ShoppingCart&gt; shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //根据当前用户id查询其购物车数据        shoppingCartLambdaQueryWrapper.eq(userId != null, ShoppingCart::getUserId, userId);        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(shoppingCartLambdaQueryWrapper);        //判断一下购物车是否为空        if (shoppingCarts == null) {            throw new CustomException("购物车数据为空，不能下单");        }        //判断一下地址是否有误        Long addressBookId = orders.getAddressBookId();        AddressBook addressBook = addressBookService.getById(addressBookId);        if (addressBookId == null) {            throw new CustomException("地址信息有误，不能下单");        }        //获取用户信息，为了后面赋值        User user = userService.getById(userId);        long orderId = IdWorker.getId();        //原子数，更精细计算        AtomicInteger amount = new AtomicInteger(0);        //向订单细节表设置属性        List&lt;OrderDetail&gt; orderDetailList= shoppingCarts.stream().map((item) -&gt; {            OrderDetail orderDetail = new OrderDetail();            orderDetail.setOrderId(orderId);            orderDetail.setName(item.getName());            orderDetail.setImage(item.getImage());            orderDetail.setDishId(item.getDishId());            orderDetail.setSetmealId(item.getSetmealId());            orderDetail.setDishFlavor(item.getDishFlavor());            orderDetail.setNumber(item.getNumber());            orderDetail.setAmount(item.getAmount());            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());            return orderDetail;        }).collect(Collectors.toList());        //向订单表设置属性        orders.setId(orderId);        orders.setNumber(String.valueOf(orderId));        orders.setStatus(2);        orders.setUserId(userId);        orders.setAddressBookId(addressBookId);        orders.setOrderTime(LocalDateTime.now());        orders.setCheckoutTime(LocalDateTime.now());        orders.setAmount(new BigDecimal(amount.get()));        orders.setPhone(addressBook.getPhone());        orders.setUserName(user.getName());        orders.setConsignee(addressBook.getConsignee());        orders.setAddress(                (addressBook.getProvinceName() == null ? "":addressBook.getProvinceName())+                        (addressBook.getCityName() == null ? "":addressBook.getCityName())+                        (addressBook.getDistrictName() == null ? "":addressBook.getDistrictName())+                        (addressBook.getDetail() == null ? "":addressBook.getDetail())        );        //根据查询到的购物车数据，对订单表插入数据（1条）        this.save(orders);        //根据查询到的购物车数据，对订单明细表插入数据（多条）        orderDetailService.saveBatch(orderDetailList);        //清空购物车数据        shoppingCartService.remove(shoppingCartLambdaQueryWrapper);    }}</code></pre><h1 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h1><ul><li>问题说明：<ul><li>当用户数量足够多的时候，系统访问量大</li><li>频繁的访问数据库，系统性能下降，用户体验差</li><li>所以一些通用、常用的数据，我们可以使用Redis来缓存，避免用户频繁访问数据库</li></ul></li></ul><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><h4 id="1-1-导入SpringDataRedis的maven坐标"><a href="#1-1-导入SpringDataRedis的maven坐标" class="headerlink" title="1.1 导入SpringDataRedis的maven坐标"></a>1.1 导入SpringDataRedis的maven坐标</h4><ul><li>这里我们就还是用SpringDataRedis来开发了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h4><ul><li>配置连接redis的数据，我这里配置的是我的云服务器上装的Redis</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0</code></pre><h4 id="1-3-配置类"><a href="#1-3-配置类" class="headerlink" title="1.3 配置类"></a>1.3 配置类</h4><ul><li>配置一下序列化器，方便我们在图形化界面中查看我们存入的数据，在config包下新建RedisConfig类</li><li>但是也可以不配置RedisConfig，而是直接用<code>SpringRedisConfig</code>，它的默认序列化器就是<code>StringRedisSerializer</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfig extends CachingConfigurerSupport {    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        //默认key序列化器为：JdkSerializationRedisSerializer        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setConnectionFactory(connectionFactory);        return redisTemplate;    }}</code></pre><h3 id="2-缓存短信验证码"><a href="#2-缓存短信验证码" class="headerlink" title="2. 缓存短信验证码"></a>2. 缓存短信验证码</h3><h4 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h4><ul><li>先来回顾一下我们之前的邮件验证码是储存在哪儿的<ul><li>之前我们是存的Session，session的有效期是30分钟</li></ul></li><li>那现在我们学了Redis的基础应用，我们现在就可以把它缓存在Redis里</li><li>具体实现思路如下<ol><li>在服务端UserController中注入RedisTemplate对象，用于操作Redis;</li><li>在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟;</li><li>在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码;</li></ol></li></ul><h4 id="2-2-代码改造"><a href="#2-2-代码改造" class="headerlink" title="2.2 代码改造"></a>2.2 代码改造</h4><ol><li>在UserController中注入RedisTemplate或StringRedisTemplate对象，用于操作Redis</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改UserController中的sendMsg方法，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/sendMsg")public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException {    String phone = user.getPhone();    if (!phone.isEmpty()) {        //随机生成一个验证码        String code = MailUtils.achieveCode();        log.info(code);        //这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        //验证码缓存到Redis，设置存活时间5分钟        redisTemplate.opsForValue().set("code", code,5, TimeUnit.MINUTES);        return Result.success("验证码发送成功");    }    return Result.error("验证码发送失败");}</code></pre><ol start="3"><li>在服务端的UserController的login方法中，从Redis获取验证码，如果登录成功则删除Redis中的验证码</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/login")public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {    log.info(map.toString());    String phone = map.get("phone").toString();    String code = map.get("code").toString();    //把Redis中缓存的code拿出来    Object codeInRedis = redisTemplate.opsForValue().get(phone);    //看看接收到用户输入的验证码是否和redis中的验证码相同    log.info("你输入的code{}，redis中的code{}，计算结果为{}", code, codeInRedis, (code != null &amp;&amp; code.equals(codeInRedis)));    if (code != null &amp;&amp; code.equals(codeInRedis)) {        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getPhone, phone);        User user = userService.getOne(queryWrapper);        if (user == null) {            user = new User();            user.setPhone(phone);            user.setName("用户" + codeInRedis);            userService.save(user);        }        session.setAttribute("user", user.getId());        //如果登陆成功，则删除Redis中的验证码        redisTemplate.delete(phone);        return Result.success(user);    }    return Result.error("登录失败");}</code></pre><h3 id="3-缓存菜品数据"><a href="#3-缓存菜品数据" class="headerlink" title="3. 缓存菜品数据"></a>3. 缓存菜品数据</h3><ul><li>菜品数据是我们登录移动端之后的展示页面</li><li>所以每当我们访问首页的时候，都会调用数据库查询一遍菜品数据</li><li>对于这种需要频繁访问的数据，我们可以将其缓存到Redis中以减轻服务器的压力</li></ul><h4 id="3-1-实现思路"><a href="#3-1-实现思路" class="headerlink" title="3.1 实现思路"></a>3.1 实现思路</h4><ul><li>移动端对应的菜品查看功能，是DishController中的list方法，此方法会根据前端提交的查询条件进行数据库查询操作（用户选择不同的菜品分类）。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。所以现在我们需要对此方法进行缓存优化，提高系统性能</li><li>但是还有存在一个问题，我们是将所有的菜品缓存一份，还是按照菜品/套餐分类，来进行缓存数据呢？</li><li>答案是后者，当我们点击某一个分类时，只需展示当前分类下的菜品，而其他分类的菜品数据并不需要展示，所以我们在缓存的时候，根据菜品的分类，缓存多分数据，页面在查询时，点击某个分类，则查询对应分类下的菜品的缓存数据</li><li>具体实现思路如下<ol><li>修改DishController中的list方法，先从Redis中获取分类对应的菜品数据，如果有，则直接返回；如果无，则查询数据库，并将查询到的菜品数据存入Redis</li><li>修改DishController的save、update和delete方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改/更新/删除了某些菜品，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="3-2-代码改造"><a href="#3-2-代码改造" class="headerlink" title="3.2 代码改造"></a>3.2 代码改造</h4><ol><li>先在DishController中注入RedisTemplate</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改DishController的list方法，先从Redis中获取菜品数据</li></ol><ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的菜品数据让Redis缓存</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) {    List&lt;DishDto&gt; dishDtoList;    String key = "dish_" + dish.getCategoryId() + "_" + dish.getStatus();    dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);    //如果有，则直接返回    if (dishDtoList != null){        return Result.success(dishDtoList);    }    //如果无，则查询    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    log.info("查询到的菜品信息list:{}", list);    //item就是list中的每一条数据，相当于遍历了    dishDtoList = list.stream().map((item) -&gt; {        //创建一个dishDto对象        DishDto dishDto = new DishDto();        //将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);        //由于dish表中没有categoryName属性，只存了categoryId        Long categoryId = item.getCategoryId();        //所以我们要根据categoryId查询对应的category        Category category = categoryService.getById(categoryId);        if (category != null) {            //然后取出categoryName，赋值给dishDto            dishDto.setCategoryName(category.getName());        }        //然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId = item.getId();        //条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //条件就是菜品id        lambdaQueryWrapper.eq(itemId != null, DishFlavor::getDishId, itemId);        //根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(lambdaQueryWrapper);        //赋给dishDto的对应属性        dishDto.setFlavors(flavors);        //并将dishDto作为结果返回        return dishDto;        //将所有返回结果收集起来，封装成List    }).collect(Collectors.toList());    //将查询的结果让Redis缓存，设置存活时间为60分钟    redisTemplate.opsForValue().set(key,dishDtoList,60, TimeUnit.MINUTES);    return Result.success(dishDtoList);}</code></pre><ol start="3"><li>修改DishController里的save、update和批量修改方法(status)，加入清理缓存的逻辑</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.saveWithFlavor(dishDto);    String key = "dish_" + dishDto.getCategoryId() + "_1";    redisTemplate.delete(key);    return Result.success("添加菜品成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.updateWithFlavor(dishDto);    String key = "dish_" + dishDto.getCategoryId() + "_1";    redisTemplate.delete(key);    return Result.success("修改菜品成功");}</code></pre><blockquote><p>注意：这里并不需要我们对删除操作也进行缓存清理，因为删除操作执行之前，必须先将菜品状态修改为<code>停售</code>，而停售状态也会帮我们清理缓存，同时也看不到菜品，随后将菜品删除，仍然看不到菜品，故删除操作不需要进行缓存清理</p></blockquote><h3 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4. SpringCache"></a>4. SpringCache</h3><h4 id="4-1-SpringCache介绍"><a href="#4-1-SpringCache介绍" class="headerlink" title="4.1 SpringCache介绍"></a>4.1 SpringCache介绍</h4><ul><li>SpringCache是一个框架，实现了基本注解的缓存功能，只需要简单的添加一个注解，就能实现缓存功能</li><li>SpringCache提供了一层抽象，底层可以切换不同的cache实现，具体就是通过CacheManager接口来统一不同的缓存技术</li><li>针对不同的缓存技术，需要实现不同的CacheManager</li></ul><table><thead><tr><th align="center">CacheManger</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">EhCacheCacheManager</td><td align="center">使用EhCache作为缓存技术</td></tr><tr><td align="center">GuavaCacheManager</td><td align="center">使用Googke的GuavaCache作为缓存技术</td></tr><tr><td align="center">RedisCacheManager</td><td align="center">使用Redis作为缓存技术</td></tr></tbody></table><h4 id="4-2-SpringCache常用注解"><a href="#4-2-SpringCache常用注解" class="headerlink" title="4.2 SpringCache常用注解"></a>4.2 SpringCache常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能</td></tr><tr><td align="center">@Cacheable</td><td align="center">在方法执行前spring先查看缓存中是否有数据。如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict</td><td align="center">将一条或者多条数据从缓存中删除</td></tr></tbody></table><p> @Cacheable<br><code>@Cacheable</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，其主要参数说明如下</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value=(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“setmealCache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr><tr><td align="center">unless</td><td align="center">满足条件则不缓存</td><td align="center">例如:@Cacheable(value=“testcache”,unless=“#result = =null”)</td></tr></tbody></table><blockquote><p><code>@Cacheable(value=“setmealCache”,key=“#setmeal.categoryId + '_' + #setmeal.status”) </code>在redis中会以<code>setmealCache::setmealCache::1413342269393674242_1</code>的方式存储</p><p><img src="image-20231018170050126.png" alt="image-20231018170050126"></p></blockquote><p>@CachePut<br><code>@CachePut</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和@Cacheable不同的是，它每次都会触发真实方法的调用，其主要参数说明如下（其实跟@Cacheable一样）</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value=(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“testcache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr></tbody></table><p>@CachEvict<br><code>@CachEvict</code>的作用主要针对方法配置，能够根据一定的条件对缓存进行清空</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value={“cache1”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“testcache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr><tr><td align="center">allEntries</td><td align="center">是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存</td><td align="center">例如:@CachEvict(value=“testcache”,allEntries=true)</td></tr><tr><td align="center">beforelnvocation</td><td align="center">是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td align="center">例如:@CachEvict(value=“testcache”, beforelnvocation=true)</td></tr></tbody></table><h4 id="4-3-SpringCache使用方式"><a href="#4-3-SpringCache使用方式" class="headerlink" title="4.3 SpringCache使用方式"></a>4.3 SpringCache使用方式</h4><ul><li>在SpringBoot项目中，使用缓存技术只需要在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存技术支持即可。</li><li>这里我们使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>随后配置application.yml</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0  cache:    redis:      time-to-live: 3600000 #设置存活时间为一小时，如果不设置，则一直存活</code></pre><h3 id="5-缓存套餐数据"><a href="#5-缓存套餐数据" class="headerlink" title="5. 缓存套餐数据"></a>5. 缓存套餐数据</h3><h4 id="5-1-实现思路"><a href="#5-1-实现思路" class="headerlink" title="5.1 实现思路"></a>5.1 实现思路</h4><ul><li>前面我们已经实现了移动端查看套餐的功能，对应SetmealController中的list方法</li><li>此方法会根据前端提交的查询条件进行数据库查询操作</li><li>在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增强</li><li>现在需要对此方法进行缓存优化，提高系统性能</li><li>具体实现思路如下<ol><li>修改SetmealController中的list方法，先从Redis缓存中获取套餐数据<ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的套餐数据存入Redis</li></ul></li><li>修改SetmealController的save、update方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改/更新/删除了某些套餐，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="5-2-代码修改"><a href="#5-2-代码修改" class="headerlink" title="5.2 代码修改"></a>5.2 代码修改</h4><ol><li><p>导入SpringCache和Redis相关的maven坐标</p></li><li><p>在appilcation.yml中配置缓存数据的过期时间</p></li><li><p>在启动类上加上<code>@EnableCaching</code>注解，开启缓存注解功能</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@ServletComponentScan@EnableTransactionManagement@EnableCaching  //开启缓存注解功能public class ReggieApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ReggieApplication.class,args);        log.info("项目启动成功...");    }}</code></pre><ol start="4"><li>在SetmealController的list方法上加上<code>@Cacheable</code>注解<br>该注解的功能是：在方法执行前，Spring先查看缓存中是否有数据；如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")@Cacheable(value = "setmealCache", key = "#setmeal.categoryId + '_' + #setmeal.status")public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) {    //条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.eq(setmeal.getCategoryId() != null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() != null, Setmeal::getStatus, 1);    //排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList = setmealService.list(queryWrapper);    return Result.success(setmealList);}</code></pre><ol start="5"><li>修改SetmealController的save、update和status方法，加入清理缓存的逻辑</li></ol><p>不用修改delete方法，因为只需要编辑status即可，前面有说过</p><p>实现手段也只需要加上<code>@CacheEvict</code>注解，该注解的功能是：将一条或者多条数据从缓存中删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success("套餐添加成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;Setmeal&gt; updateWithDish(@RequestBody SetmealDto setmealDto) {    List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();    Long setmealId = setmealDto.getId();    //先根据id把setmealDish表中对应套餐的数据删了    LambdaQueryWrapper&lt;SetmealDish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(SetmealDish::getSetmealId, setmealId);    setmealDishService.remove(queryWrapper);    //然后在重新添加    setmealDishes = setmealDishes.stream().map((item) -&gt; {        item.setSetmealId(setmealId);        return item;    }).collect(Collectors.toList());    //更新套餐数据    setmealService.updateById(setmealDto);    //更新套餐对应菜品数据    setmealDishService.saveBatch(setmealDishes);    return Result.success(setmealDto);}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/status/{status}")//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;String&gt; status(@PathVariable String status, @RequestParam List&lt;Long&gt; ids) {    LambdaUpdateWrapper&lt;Setmeal&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();    updateWrapper.in(Setmeal::getId, ids);    updateWrapper.set(Setmeal::getStatus, status);    setmealService.update(updateWrapper);    return Result.success("批量操作成功");}</code></pre><blockquote><ul><li>在做完这一步之后，会发现报错:<code>DefaultSerializer requires a Serializable payload but received an object of type</code></li><li>这是因为要缓存的JAVA对象必须实现<code>Serializable</code>接口，因为Spring会先将对象序列化再存入Redis，将缓存实体类继承<code>Serializable</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Result&lt;T&gt; implements Serializable</code></pre></blockquote><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h3><ul><li>目前我们所有的读和写的压力都是由一台数据库来承担，</li><li>如果数据库服务器磁盘损坏，则数据会丢失（没有备份）</li><li>解决这个问题，就可以用MySQL的主从复制，写操作交给主库，读操作交给从库</li><li>同时将主库写入的内容，同步到从库中</li></ul><p><img src="7d9f6630j00rjzmok002gd0017r00mjp.jpg" alt="img"></p><h3 id="2-MySQL主从复制"><a href="#2-MySQL主从复制" class="headerlink" title="2. MySQL主从复制"></a>2. MySQL主从复制</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的二进制日志功能。就是一台或多台NysQL数据库（slave，即从库）从另一台MySQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。</li><li>MySQL复制过程分成三步:<ol><li><code>maste</code>r将改变记录到二进制日志(<code>binary log</code>)</li><li><code>slave</code>将<code>master</code>的<code>binary log</code>拷贝到它的中继日志(<code>relay log</code>)</li><li><code>slave</code>重做中继日志中的事件，将改变应用到自己的数据库中</li></ol></li></ul><p><img src="2ee25861j00rjzn78000yd000lf00emp.jpg" alt="img"></p><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><ul><li><p>前置条件<br>准备好两台服务器，分别安装MySQL并启动服务成功，我这里用的两台虚拟机（另一台是克隆的，记得修改克隆虚拟机的MySQL的UUID）</p></li><li><p>修改克隆机的MySQL的uuid</p><ol><li>登录克隆机的MySQL</li><li>执行SQL语句，记住生成的uuid，待会需要用</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; select uuid();+--------------------------------------+| uuid()                               |+--------------------------------------+| aaa9efc9-6e25-11ee-9d03-000c294093b6 |+--------------------------------------+</code></pre><ol start="3"><li>查看配置文件目录</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; show variables like 'datadir';+---------------+-----------------+| Variable_name | Value           |+---------------+-----------------+| datadir       | /var/lib/mysql/ |+---------------+-----------------+</code></pre><ol start="4"><li>编辑配置文件目录，修改uuid为刚刚我们生成的uuid</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi /var/lib/mysql/auto.cnf</code></pre><ol start="5"><li>重启服务</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service mysqld restart</code></pre></li><li><p>配置主库，我这里就用虚拟机上的mysql当主库了</p><ol><li><p>修改MySQL数据库的配置文件，虚拟机是</p><pre class="line-numbers language-none"><code class="language-none">/etc/my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入两行</li></ul><pre class="line-numbers language-none"><code class="language-none">log_bin=mysql-bin #[必须]启用二进制日志server-id=100 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</code></pre></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create user nanying identified by 'Root@123456';grant replication slave on *.* to nanying;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show master status;</code></pre><p>记录下结果中File和Position的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      694 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+</code></pre></li><li><p>配置从库，我这里就用我的另一台克隆的虚拟机了</p><ol><li><p>修改MySQL数据库的配置文件</p><pre class="line-numbers language-none"><code class="language-none">/etc/my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入一行</li></ul><blockquote><p>server-id=130 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</p></blockquote></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL，将参数修改为你自己的</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">change master to master_host='192.168.71.100',master_user='nanying',master_password='Root@123456',master_log_file='mysql-bin.000001',master_log_pos=694;CHANGE MASTER TO GET_MASTER_PUBLIC_KEY=1; # 修改mysql 8.0之后默认的认证方式start slave;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行SQL，查看从库的状态</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show slave status\G</code></pre></li></ul><p>看到如下如下三行配置相同，则主从连接成功</p><blockquote><p>Slave_IO_State: Waiting for master to send event<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes</p></blockquote><h3 id="3-读写分离案例"><a href="#3-读写分离案例" class="headerlink" title="3. 读写分离案例"></a>3. 读写分离案例</h3><h4 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h4><ul><li>面对日益增加的系统访问量，数据库的吞吐量面临着巨大的瓶颈。</li><li>对于同一时刻有<code>大量并发读操作</code>和<code>较少的写操作</code>类型的应用系统来说，将数据库拆分为<code>主库</code>和<code>从库</code></li><li><code>主库</code>主要负责处理事务性的增删改操作</li><li><code>从库</code>主要负责查询操作</li><li>这样就能有效避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善</li></ul><h4 id="3-2-Sharding-JDBC介绍"><a href="#3-2-Sharding-JDBC介绍" class="headerlink" title="3.2 Sharding-JDBC介绍"></a>3.2 Sharding-JDBC介绍</h4><ul><li>Sharding-JDBC定位为轻量级的JAVA框架，在JAVA的JDBC层提供额外的服务，它使得客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</li><li>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离<ul><li>适用于任何基于JDBC的ORM框架</li><li>支持任何第三方的数据库连接池</li><li>支持任意实现JDBC规范的数据库</li></ul></li><li>使用Sharding-JDBC框架的步骤<ol><li>导入对应的maven坐标</li><li>在配置文件中配置读写分离规则</li><li>在配置文件中配置允许bean定义覆盖配置项</li></ol></li></ul><h3 id="4-项目实现读写分离"><a href="#4-项目实现读写分离" class="headerlink" title="4. 项目实现读写分离"></a>4. 项目实现读写分离</h3><ul><li><p>前面我们已经配置好了主从数据库，那么我们现在就用瑞吉外卖试试读写分离</p><ol><li>导入瑞吉外卖的SQL数据</li><li>Git创建一个新分支<code>v1.1</code>，便于我们提交维护</li><li>导入<code>Sharding-JDBC</code>的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="4"><li>在配置文件中配置读写分离规则,配置允许bean定义覆盖配置项<br>配置项可能会爆红，但是不影响影响项目启动，是IDEA的问题</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  shardingsphere:    datasource:      names:        master,slave      master:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql://192.168.71.100:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true        username: root        password: 123456      slave:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql://192.168.71.130:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true        username: root        password: 123456    masterslave:      load-balance-algorithm-type: round_robin      name: dataSource      master-data-source-name: master      slave-data-source-names: slave    props:      sql:        show: true  main:    allow-bean-definition-overriding: true</code></pre></li></ul><blockquote><p>可能遇到的问题</p><ul><li>启动时不报错，但是登陆功能报<code>500</code>异常</li><li>查看控制台出现<code>SQLFeatureNotSupportedException</code>异常</li></ul><p>解决方案</p><ul><li><p>修改pom.xml中druid的maven坐标为</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul></blockquote><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li>Nginx是一款轻量级的<code>Web</code>/<code>反向代理</code>服务器以及电子邮件(IMAP/POP3)代理服务器，其特点是占有内存少，并发能力强。</li><li>事实上Nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用Nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</li><li>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Pam6nep）开发的，第一个公开版本0.1.0发布于2004年10月4日。</li><li>官网：<a href="https://nginx.org/">https://nginx.org/</a></li></ul><h3 id="2-Nginx的下载和安装"><a href="#2-Nginx的下载和安装" class="headerlink" title="2. Nginx的下载和安装"></a>2. Nginx的下载和安装</h3><ul><li><p>官网下载链接：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p></li><li><p>安装过程：</p><ol><li>Nginx是C语言开发的，所以需要先安装依赖</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</code></pre><ol start="2"><li>下载Nginx安装包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wgetwget https://nginx.org/download/nginx-1.24.0.tar.gz</code></pre><ol start="3"><li>解压，我习惯放在<code>/usr/local</code>目录下</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf nginx-1.24.0.tar.gz -C /usr/local/</code></pre><ol start="4"><li>进入到我们解压完毕后的文件夹内</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx-1.24.0/</code></pre><ol start="5"><li>建安装路径文件夹</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/nginx</code></pre><ol start="6"><li>安装前检查工作</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --prefix=/usr/local/nginx</code></pre><ol start="7"><li>编译并安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make &amp;&amp; make install</code></pre></li></ul><h3 id="3-Nginx目录结构"><a href="#3-Nginx目录结构" class="headerlink" title="3. Nginx目录结构"></a>3. Nginx目录结构</h3><ul><li><p>安装完Nginx后，我们先来熟悉一下Nginx的目录结构</p></li><li><p>重点目录/文件:</p><ul><li>conf/nginx.conf<ul><li>nginx配置文件</li></ul></li><li>html<ul><li>存放静态文件(html、css、Js等)</li></ul></li><li>logs<ul><li>日志目录，存放日志文件</li></ul></li><li>sbin/nginx<ul><li>二进制文件，用于启动、停止Nginx服务</li></ul></li></ul></li><li><p>文件目录树状图如下</p></li><li><p>文件目录树状图如下</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── conf                        &lt;-- Nginx配置文件│   ├── fastcgi.conf│   ├── fastcgi.conf.default│   ├── fastcgi_params│   ├── fastcgi_params.default│   ├── koi-utf│   ├── koi-win│   ├── mime.types│   ├── mime.types.default│   ├── nginx.conf              &lt;-- 这个文件我们经常操作│   ├── nginx.conf.default│   ├── scgi_params│   ├── scgi_params.default│   ├── uwsgi_params│   ├── uwsgi_params.default│   └── win-utf├── html                        &lt;-- 存放静态文件，我们后期部署项目，就要将静态文件放在这│   ├── 50x.html        │   └── index.html              &lt;-- 提供的默认的页面├── logs                        &lt;-- 日志目录，由于我们新装的Nginx，所以现在还没有日志文件└── sbin                        └── nginx                       &lt;-- 这个文件我们也经常操作</code></pre><h3 id="4-Nginx配置文件结构"><a href="#4-Nginx配置文件结构" class="headerlink" title="4. Nginx配置文件结构"></a>4. Nginx配置文件结构</h3><ul><li>Nginx配置文件(conf/nginx.conf)整体分为三部分<ul><li>全局块 和Nginx运行相关的全局配置</li><li>events块 和网络连接相关的配置</li><li>http块 代理、缓存、日志记录、虚拟主机配置<ul><li>http全局块</li><li>Server块<ul><li>Server全局块</li><li>location块</li></ul></li></ul></li></ul></li></ul><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">worker_processes  1;                              &lt;-- 全局块  events {                                          &lt;-- events块    worker_connections  1024;  }    http {                                            &lt;-- http块    include       mime.types;                     &lt;-- http全局块    default_type  application/octet-stream;      sendfile        on;      keepalive_timeout  65;        server {                                      &lt;-- Server块        listen       80;                          &lt;-- Server全局块        server_name  localhost;          location / {                              &lt;-- location块            root   html;            index  index.html index.htm;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><p>注意：http块中可以配置多个Server块，每个Server块中可以配置多个location块</p><h3 id="5-Nginx命令"><a href="#5-Nginx命令" class="headerlink" title="5. Nginx命令"></a>5. Nginx命令</h3><ul><li><p>查看版本</p><ul><li>进入sbin目录，输入<code>./nginx -v</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -vnginx version: nginx/1.22.1</code></pre></li><li><p>检查配置文件正确性</p><ul><li>进入sbin目录，输入<code>./nginx -t</code>，如果有错误会报错，而且也会记日志</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</code></pre></li><li><p>启动与停止</p><ul><li>进入sbin目录，输入<code>./nginx</code>，启动完成后查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx [root@localhost sbin]## ps -ef | grep nginxroot      89623      1  0 22:08 ?        00:00:00 nginx: master process ./nginxnobody    89624  89623  0 22:08 ?        00:00:00 nginx: worker processroot      89921   1696  0 22:08 pts/0    00:00:00 grep --color=auto nginx</code></pre><ul><li>如果想停止Nginx服务，输入<code>./nginx -s stop</code>，停止服务后再次查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -s stop[root@localhost sbin]## ps -ef | grep nginxroot      93772   1696  0 22:11 pts/0    00:00:00 grep --color=auto nginx</code></pre></li><li><p>重新加载配置文件</p><ul><li>当修改Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：<code>./nginx -s reload</code>。</li></ul></li></ul><blockquote><ul><li><p>上面的所有命令，都需要我们在sbin目录下才能运行，比较麻烦，所以我们可以将Nginx的二进制文件配置到环境变量中，这样无论我们在哪个目录下，都能使用上面的命令</p></li><li><p>使用<code>vim /etc/profile</code>命令打开配置文件，并配置环境变量，保存并退出</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- PATH=$JAVA_HOME/bin:$PATH+ PATH=/usr/local/nginx/sbin:$JAVA_HOME/bin:$PATH</code></pre></li><li><p>之后重新加载配置文件，使用<code>source /etc/profile</code>命令，然后我们在任意位置输入<code>nginx</code>即可启动服务，<code>nginx -s stop</code>即可停止服务</p></li></ul></blockquote><ul><li>查看自己IP，启动服务后，浏览器输入ip地址就可以访问Nginx的默认页面<ul><li><code>ip addr</code></li></ul></li></ul><h3 id="6-Nginx具体应用"><a href="#6-Nginx具体应用" class="headerlink" title="6. Nginx具体应用"></a>6. Nginx具体应用</h3><h4 id="6-1-部署静态资源"><a href="#6-1-部署静态资源" class="headerlink" title="6.1 部署静态资源"></a>6.1 部署静态资源</h4><ul><li>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</li><li><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效</strong>，所以在生产环境下，一般都会将静态资源部署到Nginx中。</li><li>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</li></ul><h4 id="6-2-反向代理"><a href="#6-2-反向代理" class="headerlink" title="6.2 反向代理"></a>6.2 反向代理</h4><ul><li><code>正向代理</code><ul><li>正向代理是一个位于客户端和原始服务器（origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</li><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。</li><li>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。（梯子）</li></ul></li></ul><p><img src="b7a9bc05j00rk13jv000id000ld008bp.jpg" alt="img"></p><ul><li><p><code>反向代理</code></p><ul><li><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，<strong>反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。</p><ul><li>便于统一管理多台web服务器</li><li>web服务器可能在公司内网，无法直接访问</li></ul></li><li><p><strong>用户不需要知道目标服务器的地址</strong>，也无须在用户端作任何设定。</p></li></ul></li></ul><p><img src="220be961j00rk13nz000rd000q600avp.jpg" alt="img"></p><ul><li><p><code>举个例子</code></p><ul><li>正向代理：你让舍友去给你带三楼卖的煎饼（你最终会得到一个三楼的煎饼）</li><li>反向代理：你让舍友去给你买煎饼（你最终只会得到一个煎饼，但你不知道煎饼是哪儿卖的）</li><li>和正向代理不同，反向代理相当于是为目标服务器工作的，当你去访问某个网站时，你以为你访问问的是目标服务器，其实不然，当你访问时，其实是由一个代理服务器去接收你的请求，正向代理与反向代理最简单的区别： 正向代理隐藏的是用户（卖煎饼的不知道是你要买），反向代理隐藏的是服务器（你不知道煎饼是谁卖的）。</li><li>正向代理侧重的是用户，用户知道可以通过代理访问无法访问的资源，而反向代理侧重点在服务器这边，用户压根不知道自己访问的是资源时通过代理人去转发的。</li></ul></li><li><p><code>配置反向代理</code><br>这里是在<code>192.168.138.100</code>上配置的，那么访问流程如下<br>客户端 –&gt; <code>192.168.138.100:82</code> –&gt; <code>192.168.138.101/50x.html</code><br>客户端访问反向代理服务器的82端口，而82端口又将请求转发给web服务器的<code>50x.html</code>资源<br>注意这里需要开启反向代理服务器的82端口</p></li></ul><p><img src="image-20231019192535504.png" alt="image-20231019192535504"></p><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">server {    listen       82;    server_name  localhost;    location / {        proxy_pass http://http://192.168.138.101/50x.html;    }}</code></pre><h4 id="6-3-负载均衡"><a href="#6-3-负载均衡" class="headerlink" title="6.3 负载均衡"></a>6.3 负载均衡</h4><ul><li>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</li><li>应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据。</li><li>负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理。</li></ul><p><img src="7bec0435j00rk16la000pd000rd0090p.jpg" alt="img"></p><ul><li>配置负载均衡<br>默认是轮询算法，第一次访问是<code>192.168.138.101</code>，第二次访问是<code>101.XXX.XXX.160</code><br>也可以改用权重方式，权重越大，几率越大，现在的访问三分之二是第一台服务器接收，三分之一是第二台服务器接收<br><code>server 192.168.138.101 weight=10</code><br><code>server 101.XXX.XXX.160 weight=5</code></li></ul><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">upstream targetServer{    server 192.168.138.101;    server 101.XXX.XXX.160;}server {    listen       82;    server_name  localhost;    location / {        proxy_pass http://targetServer;    }}</code></pre><ul><li>负载均衡策略</li></ul><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">默认方式</td></tr><tr><td align="center">weight</td><td align="center">权重方式</td></tr><tr><td align="center">ip_hash</td><td align="center">依据ip分配方式</td></tr><tr><td align="center">least_conn</td><td align="center">依据最少连接方式</td></tr><tr><td align="center">url_hash</td><td align="center">依据url分配方式</td></tr><tr><td align="center">fair</td><td align="center">依据响应时间方式</td></tr></tbody></table><h3 id="7-Nginx的特点"><a href="#7-Nginx的特点" class="headerlink" title="7. Nginx的特点"></a>7. Nginx的特点</h3><ol><li>跨平台：Nginx可以在大多数操作系统中运行，而且也有Windows的移植版本</li><li>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置</li><li>非阻塞、高并发：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2-3万并发连接数（这得益于Nginx使用了最新的epoll模型）</li><li>事件驱动：通信机制采用epoll模式，支持更大的并发连接数</li><li>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx进程才消耗150M内存（15M*10=150M）</li><li>成本低廉：Nginx作为开源软件，可以免费试用。而购买F5 BIG-IP、NetScaler等硬件负载均衡交换机则需要十多万至几十万人民币</li><li>内置健康检查功能：如果Nginx Proxy后端的某台Web服务器宕机了，不会影响前端访问。</li><li>节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头。</li><li>稳定性高：用于反向代理，宕机的概率微乎其微。</li></ol><h2 id="前后端分离开发"><a href="#前后端分离开发" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h2><ul><li>开发人员同时负责前端和后端代码开发，分工不明确，开发效率低</li><li>前后端代码混合在一个工程中，不便于管理</li><li>对开发人员要求高，人员招聘困难</li><li>所以衍生出了一种前后端分离开发</li></ul><h3 id="1-前后端分离开发"><a href="#1-前后端分离开发" class="headerlink" title="1. 前后端分离开发"></a>1. 前后端分离开发</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li><code>前后端分离开发</code>，就是在项目开发过程中，对前端代码的开发，专门由<code>前端开发人员</code>负责，后端代码由<code>后端开发人员</code>负责，这样可以做到分工明确，各司其职，提高开发效率，前后端代码并行开发，可以加快项目的开发速度。目前，前后端分离开发方式已经被越来越多的公司采用了，成为现在项目开发的主流开发方式。</li><li>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为<code>前端工程和后端工程</code></li></ul><p><img src="74b098faj00rk1epy000md000r80093p.jpg" alt="img"></p><h4 id="1-2-开发流程"><a href="#1-2-开发流程" class="headerlink" title="1.2 开发流程"></a>1.2 开发流程</h4><ul><li>前后端开发人员都参照接口API文档进行开发</li><li>接口（API接口） 就是一个http的请求地址，主要就是去定义：请求路径、请求方式、请求参数、响应参数等内容。</li></ul><p><img src="2583d817j00rk1era000md000oj00byp.jpg" alt="img"></p><h3 id="2-YApi"><a href="#2-YApi" class="headerlink" title="2. YApi"></a>2. YApi</h3><h4 id="2-1-介绍-1"><a href="#2-1-介绍-1" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护API，YApi还为用户提供了优秀的交互体验，开发人员只需要利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</li><li>YApi让接口开发更简单高效，让接口的管理更具有可读性、可维护性，让团队协作更合理。</li><li>Git仓库：<a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></li></ul><h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><p>需要首先在本地配置</p><ul><li>使用YApi，可以执行下面操作：<ul><li>添加项目</li><li>添加分类</li><li>添加接口</li><li>编辑接口</li><li>查看接口</li></ul></li></ul><h3 id="3-Swagger"><a href="#3-Swagger" class="headerlink" title="3. Swagger"></a>3. Swagger</h3><h4 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h4><ul><li>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做成各种格式的接口文档，以及在线接口调试页面等。</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><h4 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h4><ol><li>导入对应的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>导入knife4j相关配置，并配置静态资源映射，否则接口文档页面无法访问，注意将controller的包路径修改为你自己的</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4j@EnableSwagger2 //+@EnableKnife4j //+public class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        log.info("开始进行静态资源映射...");        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");        // 设置静态资源映射        registry.addResourceHandler("doc.html").addResourceLocations("classpath:/META-INF/resources/");//+        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");//+    }    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();        //设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        //将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    }    //+    @Bean    public Docket createRestApi() {        //文档类型        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage("com.blog.controller"))                .paths(PathSelectors.any())                .build();    }    //+    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title("瑞吉外卖")                .version("1.0")                .description("瑞吉外卖接口文档")                .build();    }}</code></pre><ol start="3"><li>在拦截器在中设置不需要处理的请求路径</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义不需要处理的请求String[] urls = new String[]{        "/employee/login",        "/employee/logout",        "/backend/**",        "/front/**",        "/common/**",        //对用户登陆操作放行        "/user/login",        "/user/sendMsg",        "/doc.html",        "/webjars/**",        "/swagger-resources",        "/v2/api-docs"};</code></pre><ol start="4"><li>启动服务，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 即可看到生成的接口文档，我这里的端口号用的80，根据自己的需求改</li></ol><p><img src="image-20231020105144839.png" alt="image-20231020105144839"></p><h4 id="3-3-常用注解"><a href="#3-3-常用注解" class="headerlink" title="3.3 常用注解"></a>3.3 常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Api</td><td align="center">用在请求的类上，例如Controller，表示对类的说明</td></tr><tr><td align="center">@ApiModel</td><td align="center">用在类上，通常是个实体类，表示一个返回响应数据的信息</td></tr><tr><td align="center">@ApiModelProperty</td><td align="center">用在属性上，描述响应类的属性</td></tr><tr><td align="center">@ApiOperation</td><td align="center">用在请求的方法上，说明方法的用途、作用</td></tr><tr><td align="center">@ApilmplicitParams</td><td align="center">用在请求的方法上，表示一组参数说明</td></tr><tr><td align="center">@ApilmplicitParam</td><td align="center">用在@ApilmplicitParams注解中，指定一个请求参数的各个方面</td></tr></tbody></table><ul><li>加上这些注解，可以将我们生成的接口文档更规范</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@ApiModel("用户")public class User implements Serializable {    private static final long serialVersionUID = 1L;    @ApiModelProperty("主键")    private Long id;    //姓名    @ApiModelProperty("姓名")    private String name;    //手机号    @ApiModelProperty("手机号")    private String phone;    //性别 0 女 1 男    @ApiModelProperty("性别 0 女 1 男")    private String sex;    //身份证号    @ApiModelProperty("身份证号")    private String idNumber;    //头像    @ApiModelProperty("头像")    private String avatar;    //状态 0:禁用，1:正常    @ApiModelProperty("状态 0:禁用，1:正常")    private Integer status;}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@Slf4j@RequestMapping("/user")@Api(tags = "用户相关接口")public class UserController {    @Autowired    private UserService userService;    @Autowired    private RedisTemplate redisTemplate;    @PostMapping("/sendMsg")    @ApiOperation("发送验证邮件接口")    public Result&lt;String&gt; sendMsg(@RequestBody User user) throws MessagingException {        String phone = user.getPhone();        if (!phone.isEmpty()) {            //随机生成一个验证码            String code = MailUtils.achieveCode();            log.info(code);            //这里的phone其实就是邮箱，code是我们生成的验证码            MailUtils.sendTestMail(phone, code);            //验证码缓存到Redis，设置存活时间5分钟            redisTemplate.opsForValue().set(phone, code,5, TimeUnit.MINUTES);            return Result.success("验证码发送成功");        }        return Result.error("验证码发送失败");    }    @PostMapping("/login")    @ApiOperation("用户登录接口")    @ApiImplicitParam(name = "map",value = "map集合接收数据",required = true)    public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {        log.info(map.toString());        String phone = map.get("phone").toString();        String code = map.get("code").toString();        //把Redis中缓存的code拿出来        Object codeInRedis = redisTemplate.opsForValue().get(phone);        //看看接收到用户输入的验证码是否和redis中的验证码相同        log.info("你输入的code{}，redis中的code{}，计算结果为{}", code, codeInRedis, (code != null &amp;&amp; code.equals(codeInRedis)));        if (code != null &amp;&amp; code.equals(codeInRedis)) {            LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(User::getPhone, phone);            User user = userService.getOne(queryWrapper);            if (user == null) {                user = new User();                user.setPhone(phone);                user.setName("用户" + codeInRedis);                userService.save(user);            }            session.setAttribute("user", user.getId());            //如果登陆成功，则删除Redis中的验证码            redisTemplate.delete(phone);            return Result.success(user);        }        return Result.error("登录失败");    }    @PostMapping("/loginout")    @ApiOperation("用户登出接口")    public Result&lt;String&gt; logout(HttpServletRequest request) {        request.getSession().removeAttribute("user");        return Result.success("退出成功");    }}</code></pre><ul><li>重新启动服务器，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 查看新生成的接口文档，可读性比之前提高了</li></ul><p><img src="052f1c67j00rk1ih8003pd001hc00qtp.jpg" alt="img"></p><h3 id="4-项目部署"><a href="#4-项目部署" class="headerlink" title="4. 项目部署"></a>4. 项目部署</h3><h4 id="4-1-配置环境说明"><a href="#4-1-配置环境说明" class="headerlink" title="4.1 配置环境说明"></a>4.1 配置环境说明</h4><p>一共需要三台服务器</p><ul><li>192.168.138.100（服务器A）<ul><li>Nginx：部署前端项目、配置反向代理</li><li>MySql：主从复制结构中的主库</li></ul></li><li>192.168.138.101（服务器B）<ul><li>jdk：运行java项目</li><li>git：版本控制工具</li><li>maven：项目构建工具</li><li>jar：Spring Boot 项目打成jar包基于内置Tomcat运行</li><li>MySql：主从复制结构中的从库</li></ul></li><li>101.xxx.xxx.160（服务器C，我用的我的云服务器）<ul><li>Redis：缓存中间件</li></ul></li></ul><p><img src="image-20231020111216958.png" alt="image-20231020111216958"></p><h4 id="4-2-部署前端项目"><a href="#4-2-部署前端项目" class="headerlink" title="4.2 部署前端项目"></a>4.2 部署前端项目</h4><ol><li>在服务器A中安装Nginx，将前端项目<code>打包</code>目录上传到Nginx的html目录下</li><li>修改Nginx配置文件nginx.conf，新增如下配置</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server {    listen 80;    server_name localhost;    location / {        root html/dist;        index index.html;    }    location ^~ /api/ {        rewrite ^/api/(.*)$ /$1 break;        proxy_pass http://192.168.238.132;    }}</code></pre><p><img src="image-20231020150600309.png" alt="image-20231020150600309"></p><p>请求 <a href="http://192.168.138.100/api/employee/login">http://192.168.138.100/api/employee/login</a> 转到 <a href="http://192.168..138.101:8080/employee/login">http://192.168..138.101:8080/employee/login</a></p><h4 id="4-3-部署后端项目"><a href="#4-3-部署后端项目" class="headerlink" title="4.3 部署后端项目"></a>4.3 部署后端项目</h4><ul><li>在服务器B中安装JDK，Git，MySql</li><li>将项目打成jar包，手动上传并部署（当然你也可以选择git拉取代码，然后shell脚本自动部署）</li><li>部署完后端项目之后，我们就能完成正常的登录功能了，也能进入到后台系统进行增删改查操作</li><li>图片上传路径可以修改为：/usr/local/img</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 语法速查</title>
      <link href="/2023/01/04/markdown-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/"/>
      <url>/2023/01/04/markdown-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、标题和正文"><a href="#一、标题和正文" class="headerlink" title="一、标题和正文"></a>一、标题和正文</h1><p>使用 <code>#</code> 表示标题，其中 <code>#</code> 号必须在行首，例如：</p><h1 id="一号标题"><a href="#一号标题" class="headerlink" title="一号标题"></a>一号标题</h1><h2 id="二号标题"><a href="#二号标题" class="headerlink" title="二号标题"></a>二号标题</h2><h3 id="三号标题"><a href="#三号标题" class="headerlink" title="三号标题"></a>三号标题</h3><h4 id="四号标题"><a href="#四号标题" class="headerlink" title="四号标题"></a>四号标题</h4><h5 id="五号标题"><a href="#五号标题" class="headerlink" title="五号标题"></a>五号标题</h5><h6 id="六号标题"><a href="#六号标题" class="headerlink" title="六号标题"></a>六号标题</h6><p>使用 <code>===</code> 或者 <code>---</code> 表示，例如：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>正文字体</p><p>1、改变字体<br>在 Markdown 语法中，使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签的 &nbsp;<code>face</code>&nbsp; 属性修改文字字体。字体在不同环境中支持程度不同，表现结果可能也不同。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font face="HEI"&gt;这里是黑体&lt;/font&gt;&lt;font face="KAI"&gt;这里是楷体&lt;/font&gt;&lt;font face="GB18030 Bitmap"&gt;这里是扩展字体&lt;/font&gt;</code></pre><p><font face="HEI">这里是黑体</font><br><font face="KAI">这里是楷体</font><br><font face="GB18030 Bitmap">这里是扩展字体</font></p><p>2、修改字号<br>Markdown 有三种主要方式<br>第一种是使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签；<br>第二种通过 &nbsp;<code>&lt;big&gt;</code>&nbsp; 或者 &nbsp;<code>&lt;small&gt;</code>&nbsp; 标签<br>第三种是通过修改 &nbsp;<code>style</code>&nbsp; 样式实现。</p><p>使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签 &nbsp;<code>size</code>&nbsp; 属性修改局部字号</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font size="1"&gt;1 号字 最小&lt;/font&gt;&lt;font size="2"&gt;2 号字&lt;/font&gt;&lt;font size="3"&gt;3 号字 默认&lt;/font&gt;&lt;font size="4"&gt;4 号字&lt;/font&gt;&lt;font size="5"&gt;5 号字&lt;/font&gt;&lt;font size="6"&gt;6 号字&lt;/font&gt;&lt;font size="7"&gt;7 号字 最大&lt;/font&gt;</code></pre><p><font size="1">1 号字 最小</font></p><p><font size="2">2 号字</font></p><p><font size="3">3 号字 默认</font></p><p><font size="4">4 号字</font></p><p><font size="5">5 号字</font></p><p><font size="6">6 号字</font></p><p><font size="7">7 号字 最大</font></p><p>3、字体颜色<br>在 Markdown 语法中，使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签的 &nbsp;<code>color</code>&nbsp; 属性修改文字颜色。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font color="red"&gt;红色&lt;/font&gt;&lt;font color="green"&gt;绿色&lt;/font&gt;&lt;font color="blue"&gt;蓝色&lt;/font&gt;&lt;font color="rgb(200, 100, 100)"&gt;使用 rgb 颜色值&lt;/font&gt;&lt;font color="#FF00BB"&gt;使用十六进制颜色值&lt;/font&gt;</code></pre><p><font color="red">红色</font><br><font color="green">绿色</font><br><font color="blue">蓝色</font><br><font color="rgb(200, 100, 100)">使用 rgb 颜色值</font><br><font color="#FF00BB">使用十六进制颜色值</font></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);"&gt;这是七色光彩背景颜色&lt;/font&gt;</code></pre><p><font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);">这是七色光彩背景颜色</font></p><h1 id="二、分割线"><a href="#二、分割线" class="headerlink" title="二、分割线"></a>二、分割线</h1><p>分隔线是用一条明显的横线，来划分文章的上下两个部分，从而使排版变得美观</p><p>123</p><hr><hr><h1 id="三、粗体斜体"><a href="#三、粗体斜体" class="headerlink" title="三、粗体斜体"></a>三、粗体斜体</h1><p>使用 <code>*</code> 和 <code>**</code> 分别表示斜体和粗体，例如</p><p><em>斜体</em><br><strong>粗体</strong><br><strong><em>又斜又粗</em></strong></p><p><del>我是要删掉的文字</del></p><p>使用 <code>==</code> 高亮<br>==123==</p><h1 id="四、超链接和图片"><a href="#四、超链接和图片" class="headerlink" title="四、超链接和图片"></a>四、超链接和图片</h1><p>Markdown 支持两种超链接的定义方式：<code>行内定义</code> 和 <code>全局声明</code><br>都是由 「中括号 &nbsp;<code>[]</code>」来声明。</p><p>语法：<code>中括号[链接名称](目标链接)</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Obsidan 简单入门教程[哔哩哔哩](https://space.bilibili.com/507578555/?spm_id_from=333.999.0.0 "IOI")</code></pre><p>Obsidan 简单入门教程<a href="https://space.bilibili.com/507578555/?spm_id_from=333.999.0.0" title="IOI">哔哩哔哩</a></p><p>在 Markdown 语法中，<br>语法：<code>![替换文字](图片路径 "标题(可选)")</code>&nbsp; 的形式定义图片</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">![马博峰](http://t13.baidu.com/it/u=3695680119,4124722001&amp;fm=224&amp;app=112&amp;f=JPEG?w=350&amp;h=350)</code></pre><p><img src="http://t13.baidu.com/it/u=3695680119,4124722001&amp;fm=224&amp;app=112&amp;f=JPEG?w=350&amp;h=350" alt="马博峰"></p><p><img src="https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E9%A9%AC%E5%8D%9A%E5%B3%B0&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=7108135681980891137&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=1637495421,647503309&amp;os=1482974809,4155393326&amp;simid=1637495421,647503309&amp;adpicid=0&amp;lpn=0&amp;ln=450&amp;fr=&amp;fmq=1655308061627_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=15&amp;oriquery=&amp;objurl=https://gimg2.baidu.com/image_search/src=http://zhengxin-pub.cdn.bcebos.com/mark/305f97293a328dcf971e1e684159c120.jpg&amp;refer=http://zhengxin-pub.cdn.bcebos.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1657900066&amp;t=678054910d3c0a812fadecd69827c195&amp;fromurl=ippr_z2C$qAzdH3FAzdH3Fwtqtviw_z&amp;e3Bkwt17_z&amp;e3Bv54AzdH3F4w6hAzdH3Ff?q=%25Cd%25ED%25Bd%25Al%25B0%25Ec&amp;gsm=1&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;nojc=undefined&amp;dyTabStr=MCwzLDYsMSw0LDUsNyw4LDIsOQ=="></p><h1 id="五、有序和无需列表"><a href="#五、有序和无需列表" class="headerlink" title="五、有序和无需列表"></a>五、有序和无需列表</h1><p><strong>1、无序列表</strong></p><p>使用 <code>-</code>、<code>+</code> 和 <code>*</code> 表示无序列表，前后留一行空白，可嵌套，例如</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">使用星号生成无序列表- 项目 1  使用加号生成无序列表* 项目 2  使用减号生成无序列表- 项目 3</code></pre><p>使用星号生成无序列表</p><ul><li>项目 1<br>使用加号生成无序列表</li></ul><ul><li>项目 2<br>使用减号生成无序列表</li></ul><ul><li>项目 3</li></ul><p><strong>2、无序列表的嵌套</strong></p><p>在 <code>-</code>、<code>+</code> 和 <code>*</code> 之前使用 tab 键将其缩进，每个 tab 表示一层。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">无序列表的嵌套- 第一层 1  - 第二层 1    - 第三层 1      - 第四层 1        - 第五层 1    - 第三层 2  - 第二层 2</code></pre><ul><li>第一层 1<ul><li>第二层 1<ul><li>第三层 1<ul><li>第四层 1<ul><li>第五层 1</li></ul></li></ul></li><li>第三层 2</li></ul></li><li>第二层 2</li></ul></li></ul><p><strong>3、有序列表</strong></p><p>通过「数字 +&nbsp;<code>.</code>&nbsp;」的形式定义有序列表，有序列表在发布后会被转化为：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">### 有序列表使用数字实现有序列表1. 项目 12. 项目 23. 项目 3源码中的数字与渲染后的数字并不一一对应，但可以决定列表的开始序号</code></pre><h1 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h1><p>使用 <code>&gt;</code> 表示，可以有多个 <code>&gt;</code>，表示层级更深，例如</p><blockquote><p>第一层</p><blockquote><p>第二层<br>这样是跳不出去的</p><blockquote><p>还可以更深</p></blockquote></blockquote></blockquote><h1 id="七、代码样式"><a href="#七、代码样式" class="headerlink" title="七、代码样式"></a>七、代码样式</h1><p>1、行内代码</p><p>使用 「反引号 &nbsp;<code>`</code>」符号定义行内代码。</p><p><code>行内代码</code></p><p>2、代码块</p><p>使用四个空格缩进表示代码块，例如</p><pre><code>public class HelloWorld{    public static void main(String[] args)    {        System.out.println( "Hello, World!" );    }}</code></pre><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p><strong>Markdown 表格包含三个部分：表头、分割线、数据。</strong></p><ul><li><strong>表头</strong>&nbsp; 用来对列名对象进行描述，也就是通常所说的列名；</li><li><strong>数据</strong>&nbsp; 用来展示每行的具体内容，数据是表格的核心；</li><li><strong>分割线</strong>&nbsp; 用来区分表头和数据，也是 Markdown 中表格定义的最基本语法要求。</li></ul><p><strong>Markdown 表格由 「竖线 &nbsp;<code>|</code>」、「减号 &nbsp;<code>-</code>」、「冒号 &nbsp;<code>:</code>」三种符号组成。</strong></p><ul><li><strong>竖线</strong>&nbsp; 用来定义列，每两个竖线之间为一个单元格元素；</li><li><strong>减号</strong>&nbsp; 用来定义分割线，也就是分割表头和数据体；</li><li><strong>冒号</strong>&nbsp; 配合减号使用，用于定义列数据的对齐属性。</li></ul><table><thead><tr><th>商品</th><th align="right">数量</th><th align="center">单价</th></tr></thead><tbody><tr><td>苹果苹果苹果</td><td align="right">10</td><td align="center">$1</td></tr><tr><td>电脑</td><td align="right">1</td><td align="center">$1999</td></tr></tbody></table><h1 id="九、数学公式"><a href="#九、数学公式" class="headerlink" title="九、数学公式"></a>九、数学公式</h1><p>Markdown 中的数学公式支持支持 <strong>LaTeX</strong>，分为「行中公式」和「独立公式」两种。</p><p>行中公式用两个单独的「美元符 &nbsp;<code>$</code>」表示。</p><p>世界上最难的问题$1+1=2$，如何证明？</p><p>独立公式用两个连续的「美元符 &nbsp;<code>$$</code>」表示，换行通过 &nbsp;<code>\</code>&nbsp; 实现。</p><p>平均数符号：$overline{xyz}$<br>开二次方符号：$sqrt x$<br>开方符号：$sqrt[3]{x+y}$<br>对数符号：$log(x)$<br>极限符号：$lim^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>极限符号：$displaystyle lim^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>求和符号：$sum^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>求和符号：$displaystyle sum^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>积分符号：$int^{infty}<em>{0}{xdx}$<br>积分符号：$displaystyle int^{infty}</em>{0}{xdx}$</p><h1 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h1><p>在 Markdown 文件中，在 ” 无序列表 &nbsp;<code>-,+,*</code>&nbsp;” 后面使用 &nbsp;<code>「中括号 []」</code>&nbsp; 声明复选框。在中括号中写入 &nbsp;<code>x</code>&nbsp;，便可实现选中效果。</p><ul><li><input disabled="" type="checkbox"> Java</li><li><input checked="" disabled="" type="checkbox"> Php</li></ul><h1 id="十一、标签"><a href="#十一、标签" class="headerlink" title="十一、标签"></a>十一、标签</h1><p>#标签<br>#dark</p><h1 id="十二、绘图"><a href="#十二、绘图" class="headerlink" title="十二、绘图"></a>十二、绘图</h1><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">gantt    title A Gantt Diagram    dateFormat  YYYY-MM-DD    section Section    A task           :a1, 2014-01-01, 30d    Another task     :after a1  , 20d    section Another    Task in sec      :2014-01-12  , 12d    another task      : 24d</code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR%% s=start  e=end  c=convergence  o=one-way%% 汇聚点 朱标s1[朱雄英]--&gt;|长子|c1[朱标]s2_帝((朱允炆))--&gt;|次子|c1%%汇聚点 朱八八c1--&gt;|长子|c2_帝((朱八八))s3[朱樉]--&gt;|次子|c2_帝s4[朱棡]--&gt;|三子|c2_帝s5((朱高炽))--&gt;|长子|o1_帝((朱棣))--&gt;|四子|c2_帝%% 单行线c2_帝--&gt;|子|o2[朱五四]--&gt;|子|o3[朱四九]--&gt;|子|e[朱百六]</code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">classDiagram    Animal &lt;|-- Duck    Animal &lt;|-- Fish    Animal &lt;|-- Zebra    Animal : +int age    Animal : +String gender    Animal: +isMammal()    Animal: +mate()    class Duck{      +String beakColor      +swim()      +quack()    }    class Fish{      -int sizeInFeet      -canEat()    }    class Zebra{      +bool is_wild      +run()    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> md语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 工具介绍及使用</title>
      <link href="/2023/01/03/git-%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/03/git-%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>git add . git commit -m “提交信息” / git commit -a -m “提交信息”</p><p>git remote add 远程仓库别名 url</p><p>git branch –set-upstream-to=origin/main(远程) 本地分支名 (本地分支关联远程分支)</p><p>git pull 远程仓库别名 远程仓库分支</p><p>git push 远程仓库别名 本地当前分支 (git push = git push origin master)</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css之移动端适配方案vw、rem详解</title>
      <link href="/2022/12/31/css%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88vw%E3%80%81rem%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/31/css%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88vw%E3%80%81rem%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-CSS-常见单位"><a href="#1-CSS-常见单位" class="headerlink" title="1. CSS 常见单位"></a>1. CSS 常见单位</h1><p>整体可以分成两类：</p><ul><li>绝对长度单位（Absolute length units）</li><li>相对长度单位（Relative length units）</li></ul><h2 id="1-1-绝对单位"><a href="#1-1-绝对单位" class="headerlink" title="1.1 绝对单位"></a>1.1 绝对单位</h2><p>绝对单位：</p><ul><li>与其他任何东西都没有关系，通常被认为总是相同的大小。</li><li>这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm。</li><li>惟一一个经常使用的值是px(像素)。</li></ul><table><thead><tr><th>绝对单位</th><th>名称</th><th>等价换算</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td><td>1cm = 96px/2.54</td></tr><tr><td>mm</td><td>毫米</td><td>1mm = 1/10th of 1cm</td></tr><tr><td>Q</td><td>四分之一毫米</td><td>1Q = 1/40th of 1cm</td></tr><tr><td>in</td><td>英寸</td><td>1in = 2.54cm = 96px</td></tr><tr><td>pc</td><td>十二点活字</td><td>1pc = 1/16th of 1in</td></tr><tr><td>pt</td><td>点</td><td>1pt = 1/72th of 1in</td></tr><tr><td>px</td><td>像素</td><td>1px = 1/96th of 1in</td></tr></tbody></table><h2 id="1-2-相对单位"><a href="#1-2-相对单位" class="headerlink" title="1.2 相对单位"></a>1.2 相对单位</h2><p>相对单位：</p><ul><li>相对长度单位<strong>相对于其他一些东西</strong></li><li>比如父元素的字体大小，或者视图端口的大小</li><li>使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应</li></ul><table><thead><tr><th>相对单位</th><th>相对于</th></tr></thead><tbody><tr><td>em</td><td>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td>ex</td><td>字符“x”的高度</td></tr><tr><td>ch</td><td>数字“0”的宽度</td></tr><tr><td>rem</td><td>根元素的字体大小</td></tr><tr><td>lh</td><td>元素的line-height</td></tr><tr><td>vw</td><td>视窗宽度的1%</td></tr><tr><td>vh</td><td>视窗高度的1%</td></tr></tbody></table><h2 id="1-3-px-详细介绍"><a href="#1-3-px-详细介绍" class="headerlink" title="1.3 px 详细介绍"></a>1.3 px 详细介绍</h2><p>px是pixel单词的缩写，翻译为像素。像素是影响显示的基本单位。</p><p><img src="6d50758caf2b46d59ac80e5ce9fe5793.png" alt="在这里插入图片描述"></p><p>像素单位常见的有三种像素名称：设备像素（也称之为物理像素）；设备独立像素（也称之为逻辑像素）；CSS像素</p><ul><li>设备像素，也叫物理像素。<ul><li>设备像素指的是<strong>显示器上的真实像素，每个像素的大小是屏幕固有的属性</strong>，屏幕出厂以后就不会改变了</li><li>我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小</li><li>比如iPhone X的分辨率 1125x2436，指的就是设备像素</li></ul></li><li>设备独立像素，也叫逻辑像素。<ul><li>如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的</li><li>开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发</li><li>所以在设备像素之上，<strong>操作系统为开发者进行抽象，提供了逻辑像素的概念</strong></li><li>比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小。</li></ul></li><li>CSS像素<ul><li>CSS中我们经常使用的单位也是pixel，它<strong>在默认情况下等同于设备独立像素（也就是逻辑像素）</strong>，毕竟逻辑像素才是面向我们开发者的</li><li>我们可以通过JavaScript中的screen.width和screen.height获取到电脑的逻辑分辨率</li></ul></li></ul><h1 id="2-移动端适配"><a href="#2-移动端适配" class="headerlink" title="2. 移动端适配"></a>2. 移动端适配</h1><p>移动端开发目前主要包括三类：</p><ul><li>原生App开发（iOS、Android、RN、uniapp、Flutter等）</li><li>小程序开发（原生小程序、uniapp、Taro等）</li><li>Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）</li></ul><p>移动端适配包括两个概念：自适应、响应式</p><h2 id="2-1-视口-viewport"><a href="#2-1-视口-viewport" class="headerlink" title="2.1 视口 viewport"></a>2.1 视口 viewport</h2><p>在一个浏览器中，我们可以看到的区域就是视口（viewport）</p><p><strong>视口划分为三种：布局视口、视觉视口、理想视口</strong></p><ul><li>在PC端的页面中，我们是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个</li><li>移动端的网页窗口往往比较小，布局视口是大于视觉视口的</li></ul><hr><p>布局视口：</p><ul><li>一个在PC端的网页在移动端会<strong>按照宽度为980px来布局</strong>一个页面的盒子和内容</li><li>这个视口称为布局视口，<strong>默认宽度980px</strong></li></ul><p>视觉视口：</p><ul><li>如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域 就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中</li><li>那么<strong>显示在可见区域的这个视口</strong>，就是视觉视口</li></ul><p><img src="a576718fd709423c85b06bf6b0bb5302.png" alt="在这里插入图片描述"></p><p>理想视口：</p><ul><li>如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示。<strong>我们希望的是设置100px，那么显示的就是100px。</strong></li><li>这时需要设置理想视口。</li><li>设置meta中的viewport</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;</code></pre><table><thead><tr><th>值</th><th>可能的附加值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>一个正整数，或者字符串 device-width</td><td>定义 viewport 的宽度。</td></tr><tr><td>height</td><td>一个正整数，或者字符串 device-height</td><td>定义 viewport 的高度。未被任何浏览器使用。</td></tr><tr><td>initial-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义设备宽度与 viewport 大小之间的缩放比例。</td></tr><tr><td>maximum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最大值，必须大于等于 minimum-scale，否则表现将不可预测。</td></tr><tr><td>minimum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最小值，必须小于等于 maximum-scale，否则表现将不可预测。</td></tr><tr><td>user-scalable</td><td>yes 或者 no</td><td>默认为 yes，如果设置为 no，将无法缩放当前页面。浏览器可以忽略此规则</td></tr></tbody></table><h2 id="2-2-移动端适配方案"><a href="#2-2-移动端适配方案" class="headerlink" title="2.2 移动端适配方案"></a>2.2 移动端适配方案</h2><ul><li>方案一：百分比设置<ul><li>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一</li><li>所以百分比在移动端适配中使用是非常少的</li></ul></li><li>方案二：rem单位+动态html的font-size</li><li>方案三：vw单位</li><li>方案四：flex的弹性布局</li></ul><h3 id="2-2-1-rem-适配方案"><a href="#2-2-1-rem-适配方案" class="headerlink" title="2.2.1 rem 适配方案"></a>2.2.1 rem 适配方案</h3><p>rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以<strong>动态的修改html的 font-size尺寸</strong></p><p>在开发中，我们只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，<strong>设置html不同的font-size</strong></li><li>问题二：将原来要设置的尺寸，<strong>转化成rem单位</strong></li></ul><h4 id="font-size-尺寸"><a href="#font-size-尺寸" class="headerlink" title="font-size 尺寸"></a>font-size 尺寸</h4><table><thead><tr><th>屏幕尺寸</th><th>html的font-size</th><th>盒子的设置宽度</th><th>盒子的最终宽度</th></tr></thead><tbody><tr><td>375px</td><td>37.5px</td><td>1rem</td><td>37.5px</td></tr><tr><td>320px</td><td>32px</td><td>1rem</td><td>32px</td></tr><tr><td>414px</td><td>41.4px</td><td>1rem</td><td>41.4px</td></tr></tbody></table><ul><li>方案一：媒体查询<ul><li>可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸</li><li>缺点： <ul><li>1.我们需要针对不同的屏幕编写大量的媒体查询</li><li>2.如果动态改变尺寸，不会实时的进行更新</li></ul></li></ul></li><li>方案二：编写js代码<ul><li>如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码</li><li>方法：<ul><li>1.根据html的宽度计算出font-size的大小，并且设置到html上</li><li>2.监听页面的实时改变，并且重新设置font-size的大小到html上</li></ul></li></ul></li><li>方案三：lib-flexible库<ul><li>事实上，lib-flexible库做的事情是相同的，你也可以直接引入它</li></ul></li></ul><p><img src="cb299e092059423286d07240d0b525c4.png" alt="在这里插入图片描述"></p><h4 id="rem的单位换算"><a href="#rem的单位换算" class="headerlink" title="rem的单位换算"></a>rem的单位换算</h4><ul><li>方案一：手动换算<ul><li>比如有一个在375px屏幕上，100px宽度和高度的盒子</li><li>我们需要将100px转成对应的rem值</li><li>100/37.5=2.6667，其他也是相同的方法计算即可</li></ul></li><li>方案二：less/scss函数</li><li><strong>方案三：postcss-pxtorem</strong><ul><li>目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li><li><code>npm install postcss-pxtorem</code></li></ul></li><li>方案四：VSCode插件<ul><li>px to rem 的插件，在编写时自动转化</li></ul></li></ul><h3 id="2-2-2-vw-适配方案"><a href="#2-2-2-vw-适配方案" class="headerlink" title="2.2.2 vw 适配方案"></a>2.2.2 vw 适配方案</h3><p>1vw等于屏幕的1%，vw我们只面临一个问题：将尺寸换算成vw的单位即可</p><p>vw相比于rem的优势：</p><ul><li>优势一：不需要去计算html的font-size大小，也<strong>不需要给html设置这样一个font-size</strong></li><li>优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承</li><li>优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱</li><li>优势四：<strong>vw相比于rem更加语义化</strong>，1vw刚才是1/100的viewport的大小</li><li>优势五：可以具备rem之前所有的优点</li></ul><h4 id="vw-的单位换算"><a href="#vw-的单位换算" class="headerlink" title="vw 的单位换算"></a>vw 的单位换算</h4><ul><li>方案一：手动换算<ul><li>比如有一个在375px屏幕上，100px宽度和高度的盒子</li><li>我们需要将100px转成对应的vw值</li><li>100/3.75=26.667，其他也是相同的方法计算即可</li></ul></li><li>方案二：less/scss函数</li><li><strong>方案三：postcss-px-to-viewport-8-plugin</strong><ul><li>和rem一样，在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li><li><code>npm install postcss-px-to-viewport-8-plugin</code></li></ul></li><li>方案四：VSCode插件<ul><li>px to vw 的插件，在编写时自动转化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 之 flex布局</title>
      <link href="/2022/12/30/CSS-%E4%B9%8B-flex%E5%B8%83%E5%B1%80/"/>
      <url>/2022/12/30/CSS-%E4%B9%8B-flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识-flex-布局"><a href="#一、认识-flex-布局" class="headerlink" title="一、认识 flex 布局"></a>一、认识 flex 布局</h1><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 <strong>floats 和 positioning</strong>。 但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举。</p><p>一些布局上的痛点无法解决：</p><ul><li>比如在父内容里面垂直居中一个块内容</li><li>比如使容器的所有子项等分可用宽度/高度，而不管有多少宽度/高度可用</li><li>比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同</li></ul><h2 id="1-flex-布局的重要概念"><a href="#1-flex-布局的重要概念" class="headerlink" title="1. flex 布局的重要概念"></a>1. flex 布局的重要概念</h2><p>两个重要的概念：</p><ul><li>开启了 flex 布局的元素叫 <strong>flex container</strong></li><li>flex container 里面的直接子元素叫做 <strong>flex item</strong></li></ul><p>使元素成为 flex container：</p><ul><li><code>display: flex</code>： flex container 以 block-level 形式存在（常用）</li><li><code>display: inline-flex</code>： flex container 以 inline-level 形式存在</li></ul><p><strong>flex item</strong>元素具有以下特点：</p><ul><li>flex item的布局将<strong>受flex container属性的设置</strong>来进行控制和布局</li><li>flex item<strong>不再严格区分块级元素和行内级元素</strong></li><li>flex item默认情况下是包裹内容的, 但是可以设置宽度和高度</li></ul><p><img src="99d54c486c1e4d009905a535df53dbab.png" alt="在这里插入图片描述"></p><h1 id="二、flex-相关属性"><a href="#二、flex-相关属性" class="headerlink" title="二、flex 相关属性"></a>二、flex 相关属性</h1><p>属性分为两类：<br><img src="1d3cb53339f94d87a51e3f301f39f998.png" alt="在这里插入图片描述"></p><h2 id="1-flex-container-中的属性"><a href="#1-flex-container-中的属性" class="headerlink" title="1. flex container 中的属性"></a>1. flex container 中的属性</h2><h3 id="1-1-flex-direction：item-的排布方向"><a href="#1-1-flex-direction：item-的排布方向" class="headerlink" title="1.1 flex-direction：item 的排布方向"></a>1.1 flex-direction：item 的排布方向</h3><p>flex items 默认都是沿着 main axis（主轴）<strong>从 main start 开始往 main end 方向</strong>排布</p><p>flex-direction 决定了 main axis 的方向，有 4 个取值：</p><ul><li>row（默认值）</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><p><img src="0ce90fb234a94e478f39debd207d95d6.png" alt="在这里插入图片描述"></p><h3 id="1-2-flex-wrap：排布是否换行"><a href="#1-2-flex-wrap：排布是否换行" class="headerlink" title="1.2 flex-wrap：排布是否换行"></a>1.2 flex-wrap：排布是否换行</h3><p>flex-wrap 决定了 flex container 是单行还是多行：</p><ul><li>nowrap（默认）：单行</li><li>wrap：多行</li><li>wrap-reverse：多行（对比 wrap，cross start 与 cross end 相反）</li></ul><p><img src="05b00512175744d79b634a9718e34c11.png" alt="在这里插入图片描述"></p><p><strong>注意：</strong><br>flex-wrap 取默认值时，若一行放不下所有的item元素，则会<strong>等比例压缩每个item的宽度</strong>，不会换行</p><h3 id="1-3-flex-flow：属性的合并写法"><a href="#1-3-flex-flow：属性的合并写法" class="headerlink" title="1.3 flex-flow：属性的合并写法"></a>1.3 flex-flow：属性的合并写法</h3><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写，顺序任何</p><pre class="line-numbers language-none"><code class="language-none">flex-flow: row-reverse wrap-reverse</code></pre><h3 id="1-4-justify-content：item-的水平对齐方式"><a href="#1-4-justify-content：item-的水平对齐方式" class="headerlink" title="1.4 justify-content：item 的水平对齐方式"></a>1.4 justify-content：item 的水平对齐方式</h3><p>justify-content 决定了 flex items 在 main axis 上的对齐方式：</p><ul><li><strong>flex-start（默认值）</strong>：与 main start 对齐</li><li><strong>flex-end</strong>：与 main end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>space-between</strong>：<ul><li>flex items 之间的距离相等</li><li>与 main start、main end两端对齐</li></ul></li><li><strong>space-around</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</li></ul></li><li><strong>space-evenly</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离等于 flex items 之间的距离</li></ul></li></ul><p><img src="29b815d29eed48509a27cc7b9b7694a5.png" alt="在这里插入图片描述"></p><h3 id="1-5-align-item：item-的垂直对齐方式"><a href="#1-5-align-item：item-的垂直对齐方式" class="headerlink" title="1.5 align-item：item 的垂直对齐方式"></a>1.5 align-item：item 的垂直对齐方式</h3><p>align-items 决定了 flex items 在 cross axis 上的对齐方式：</p><ul><li><strong>normal</strong>：在弹性布局中，效果和stretch一样</li><li><strong>flex-start</strong>：与 cross start 对齐</li><li><strong>flex-end</strong>：与 cross end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>stretch</strong>：当 flex items 在 cross axis 方向的 size 为 auto 时（未定义高度），会自动拉伸至填充 flex container</li><li><strong>baseline</strong>：与文字的基准线对齐</li></ul><p><img src="eb50960363c74b3ca5712746ab24bf09.png" alt="在这里插入图片描述"></p><h3 id="1-6-align-content：多行-item-的垂直对齐方式"><a href="#1-6-align-content：多行-item-的垂直对齐方式" class="headerlink" title="1.6 align-content：多行 item 的垂直对齐方式"></a>1.6 align-content：多行 item 的垂直对齐方式</h3><p>align-content 决定了多行 flex items 在 cross axis 上的对齐方式：</p><ul><li><strong>stretch（默认值）</strong>：与 align-items 的 stretch 类似</li><li><strong>flex-start</strong>：与 cross start 对齐</li><li><strong>flex-end</strong>：与 cross end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>space-between</strong>：<ul><li>flex items 之间的距离相等</li><li>与 cross start、cross end两端对齐</li></ul></li><li><strong>space-around</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul></li><li><strong>space-evenly</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 cross start、cross end 之间的距离等于 flex items 之间的距离</li></ul></li></ul><p><img src="ee127a6d01434eb2a8e281bfd850f185.png" alt="在这里插入图片描述"></p><h2 id="2-flex-item-中的属性"><a href="#2-flex-item-中的属性" class="headerlink" title="2. flex-item 中的属性"></a>2. flex-item 中的属性</h2><h3 id="2-1-order：item-的排布顺序"><a href="#2-1-order：item-的排布顺序" class="headerlink" title="2.1 order：item 的排布顺序"></a>2.1 order：item 的排布顺序</h3><p>order 决定了 flex items 的排布顺序：</p><ul><li>可以<strong>设置任意整数</strong>（正整数、负整数、0），值越小就越排在前面</li><li>默认值是 0</li></ul><h3 id="2-2-align-self：覆盖-align-items-设置的垂直对齐方式"><a href="#2-2-align-self：覆盖-align-items-设置的垂直对齐方式" class="headerlink" title="2.2 align-self：覆盖 align-items 设置的垂直对齐方式"></a>2.2 align-self：覆盖 align-items 设置的垂直对齐方式</h3><p>通过 align-self 覆盖 flex container 设置的 align-items：</p><ul><li>auto（默认值）：遵从 flex container 的 align-items 设置</li><li>stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致</li></ul><p><img src="e39cb90baf1344dcb89193572901a3d4.png" alt="在这里插入图片描述"></p><h3 id="2-3-flex-grow：item-如何拉伸"><a href="#2-3-flex-grow：item-如何拉伸" class="headerlink" title="2.3 flex-grow：item 如何拉伸"></a>2.3 flex-grow：item 如何拉伸</h3><p>flex-grow 决定了 flex items 如何扩展(拉伸/成长) ：</p><ul><li>可以设置<strong>任意非负数字</strong>（正小数、正整数、0），默认值是 0</li><li>当 flex container 在 main axis 方向上<strong>有剩余 size</strong> 时，flex-grow 属性才会有效</li></ul><p>注意：</p><ul><li>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size = <code>flex container的剩余size * (flex-grow / sum)</code></li><li>items 扩展后的最终 size 不能超过 max-width\max-height</li></ul><p><img src="3c6e47102a104c3682e8246ea5cca778.png" alt="在这里插入图片描述"></p><h3 id="2-4-flex-shrink：item-如何收缩"><a href="#2-4-flex-shrink：item-如何收缩" class="headerlink" title="2.4 flex-shrink：item 如何收缩"></a>2.4 flex-shrink：item 如何收缩</h3><p>flex-shrink 决定了 flex items 如何收缩(缩小)：</p><ul><li>可以设置<strong>任意非负数字</strong>（正小数、正整数、0），默认值是 1 </li><li>当 flex items 在 main axis 方向上<strong>超过了 flex container 的 size</strong>，flex-shrink 属性才会有效</li></ul><p>注意：</p><ul><li>如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size = <code>items超出flex container的size * (收缩比例 / 所有flex items的收缩比例之和)</code></li><li>flex items 收缩后的最终 size 不能小于 min-width\min-height</li></ul><h3 id="2-5-flex-basis：设置-items-的-base-size"><a href="#2-5-flex-basis：设置-items-的-base-size" class="headerlink" title="2.5 flex-basis：设置 items 的 base size"></a>2.5 flex-basis：设置 items 的 base size</h3><p>flex-basis 用来设置 flex items 在 main axis 方向上的 base size：</p><ul><li>auto（默认值）、具体的宽度数值（100px）</li><li>若item中某个英文单词超出flex-basis宽度（中文不会出现此种情况），可以自动显示完全，若设置的是width则不可</li></ul><p><img src="3f056e6065974077bc544d41b0053c2b.png" alt="在这里插入图片描述"></p><p>决定 flex items 最终 base size 的因素，从优先级高到低：</p><ul><li>max-width\max-height\min-width\min-height</li><li>flex-basis</li><li>width\height</li><li>内容本身的 size</li></ul><h3 id="2-6-flex-属性：属性的合并写法"><a href="#2-6-flex-属性：属性的合并写法" class="headerlink" title="2.6 flex 属性：属性的合并写法"></a>2.6 flex 属性：属性的合并写法</h3><p>flex 是 flex-grow || flex-shrink || flex-basis 的简写，flex 属性可以指定1个、2个或3个值。<br><img src="1398171db19543d9aa3f49a1ad002ae5.png" alt="在这里插入图片描述"></p><p>单值：</p><ul><li>一个<strong>无单位</strong>数(number): 它会被当作 flex-grow 的值。</li><li>一个<strong>有效的宽度</strong>(width)值: 它会被当作 flex-basis 的值。</li><li>关键字none，auto或initial</li></ul><p>双值：</p><ul><li>第一个值必须为一个<strong>无单位数</strong>，并且它会被当作 flex-grow 的值</li><li>第二个值必须为以下之一：<ul><li>一个无单位数：它会被当作 flex-shrink 的值</li><li>一个有效的宽度值: 它会被当作 flex-basis 的值</li></ul></li></ul><p>三值：</p><ul><li>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值</li></ul><h1 id="三、一个布局思考"><a href="#三、一个布局思考" class="headerlink" title="三、一个布局思考"></a>三、一个布局思考</h1><p>在日常应用布局中，经常会出现item个数未知的情况。此时布局会出现下列情况：</p><p><img src="9baf944c208d4cba8b8da39c91a34f03.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;.container {width: 500px;background-color: orange;display: flex;flex-wrap: wrap;justify-content: space-between;}.item {width: 110px;height: 140px;}.container &gt; i {/* 只能设置宽度，不能设置高度，这样i的数量超出时也不会影响布局 */width: 110px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;!-- 添加i的个数是列数减-2 --&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt;&lt;script src="./js/itemRandomColor.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>item 多出1个的时候，布局仍是正常的；只有item大于等于2个时，才会出现分散的分布，需要i进行补齐。因此添加i的个数是列数减-2</p><p><img src="e6246f82d48c4237ae2a1f764e9f139e.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML和CSS补充知识</title>
      <link href="/2022/12/15/HTML%E5%92%8CCSS%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/12/15/HTML%E5%92%8CCSS%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS高级"><a href="#一、CSS高级" class="headerlink" title="一、CSS高级"></a>一、CSS高级</h1><h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1. 精灵图"></a>1. 精灵图</h2><p>一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。</p><p>因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。</p><p><strong>核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。</strong></p><p><strong>精灵图的使用：</strong></p><ol><li>精灵技术主要针对于背景图片使用。就是把<strong>多个小背景图片整合到一张大图片中</strong>。</li><li>移动背景图片位置， 此时可以使用 <code>background-position</code>。</li><li>移动的距离就是这个目标图片的 <code>x</code> 和 <code>y</code> 坐标。一般情况下都是负值（网页中的坐标： x 轴右边走是正值，左边走是负值， y 轴往下走是正值，往上走是负值。）</li></ol><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2. 字体图标"></a>2. 字体图标</h2><p><strong>字体图标使用场景</strong>：主要用于显示网页中通用、常用的一些小图标。</p><p>精灵图图片文件比较大、图片本身放大和缩小会失真、一旦图片制作完毕想要更换非常复杂。</p><p>此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。字体图标可以为前端工程师提供一种方便高效的图标使用方式，<strong>展示的是图标，本质属于字体</strong>。</p><h3 id="2-1-字体图标的优点"><a href="#2-1-字体图标的优点" class="headerlink" title="2.1 字体图标的优点"></a>2.1 字体图标的优点</h3><ul><li>轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求；</li><li>灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等；</li><li>兼容性：几乎支持所有的浏览器，请放心使用。</li></ul><p>总结：</p><ol><li>如果遇到一些结构和样式比较简单的小图标，就用字体图标。</li><li>如果遇到一些结构和样式复杂一点的小图片，就用精灵图。</li></ol><h3 id="2-2-字体图标的使用"><a href="#2-2-字体图标的使用" class="headerlink" title="2.2 字体图标的使用"></a>2.2 字体图标的使用</h3><p>推荐下载网站： </p><ul><li><p>icomoon 字库 <a href="http://icomoon.io/">http://icomoon.io</a>。IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。（现在部分要付费）</p></li><li><p>阿里 iconfont 字库 <a href="http://www.iconfont.cn/">http://www.iconfont.cn</a> 。这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 Al 制作图标上传生成。重点是，免费！</p></li></ul><h4 id="2-2-1-IcoMoon"><a href="#2-2-1-IcoMoon" class="headerlink" title="2.2.1 IcoMoon"></a>2.2.1 IcoMoon</h4><ol><li>选择字体并下载</li><li>将下载文件中的 fonts 文件夹复制到项目根目录下</li><li>字体声明，将 <code>style.css</code> 文件中的开头的字体声明代码赋值到 html 中</li><li>打开 <code>demo.html</code>，复制页面中的方框图标到 html 代码<code>&lt;span&gt; &lt;/span&gt;</code>中。</li><li>给 <code>span</code> 声明字体：<pre class="line-numbers language-none"><code class="language-none">span {font-family: "icomoon";}</code></pre></li></ol><h4 id="2-2-2-阿里-iconfont"><a href="#2-2-2-阿里-iconfont" class="headerlink" title="2.2.2 阿里 iconfont"></a>2.2.2 阿里 iconfont</h4><ol><li>下载图标</li></ol><ul><li>图标管理-&gt;我的项目-&gt;然后新建项目</li><li>选择图标添加到购物车-&gt;购物车中选择加入项目</li><li>打开项目-&gt;下载到本地-&gt;放入项目根目录下</li></ul><ol start="2"><li>引入图标</li></ol><ul><li>在文件中引入iconfont.css <code>&lt;link rel="stylesheet" href="font/iconfont.css"&gt;</code> font为图标文件夹名称</li><li>在HTML结构中引用<code>&lt;span class="iconfont icon-shouye"&gt;&lt;/span&gt;</code></li></ul><ol start="3"><li>更改图标样式</li></ol><ul><li>更改颜色：可直接在文件样式style中更改</li><li>更改字体：需要在引入的iconfont.css中改</li></ul><h2 id="3-CSS-三角"><a href="#3-CSS-三角" class="headerlink" title="3. CSS 三角"></a>3. CSS 三角</h2><p>正放的等边三角形：</p><pre class="line-numbers language-none"><code class="language-none">.box1 {  width: 0;  height: 0;  border: 10px solid transparent;  border-bottom-color: black;  /* 照顾兼容性 */  line-height: 0;  font-size: 0;}</code></pre><p>不规则三角形：<br><img src="63adaa1b842a488d923b5c5f80980e8f.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">.box {width: 0;height: 0;/* 1.只保留右边的边框有颜色 */border-color: transparent red transparent transparent;/* 2. 样式都是solid */border-style: solid;/* 3. 上边框宽度要大， 右边框宽度稍小， 其余的边框该为 0 */border-width: 100px 50px 0 0 ;}</code></pre><h2 id="4-CSS-用户界面样式"><a href="#4-CSS-用户界面样式" class="headerlink" title="4. CSS 用户界面样式"></a>4. CSS 用户界面样式</h2><p>所谓的界面样式，就是更改一些用户操作样式，以便<strong>提高更好的用户体验</strong>。</p><h3 id="4-1-鼠标样式-cursor"><a href="#4-1-鼠标样式-cursor" class="headerlink" title="4.1 鼠标样式 cursor"></a>4.1 鼠标样式 cursor</h3><pre class="line-numbers language-none"><code class="language-none">cursor: default | pointer | move | text | not-allowed;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>default</td><td>默认</td></tr><tr><td>pointer</td><td>小手</td></tr><tr><td>move</td><td>移动</td></tr><tr><td>text</td><td>文本</td></tr><tr><td>not-allowed</td><td>禁止</td></tr></tbody></table><h3 id="4-2-取消表单蓝色边框和防止拖拽文本域"><a href="#4-2-取消表单蓝色边框和防止拖拽文本域" class="headerlink" title="4.2 取消表单蓝色边框和防止拖拽文本域"></a>4.2 取消表单蓝色边框和防止拖拽文本域</h3><pre class="line-numbers language-none"><code class="language-none">input {  outline: none;}textarea {  outline: none;  resize: none;}</code></pre><h2 id="5-vertical-align-属性应用"><a href="#5-vertical-align-属性应用" class="headerlink" title="5. vertical-align 属性应用"></a>5. vertical-align 属性应用</h2><p>CSS 的 <code>vertical-align</code> 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 </p><p>官方解释： 用于设置<strong>行内元素/行内块元素</strong>的<strong>垂直对齐方式</strong>。</p><pre class="line-numbers language-none"><code class="language-none">vertical-align :  top | middle | baseline(默认) | bottom</code></pre><p><img src="953482b4850149ef9d9b82274e69cedf.png" alt="在这里插入图片描述"></p><h3 id="5-1-图片、表单和文字对齐"><a href="#5-1-图片、表单和文字对齐" class="headerlink" title="5.1 图片、表单和文字对齐"></a>5.1 图片、表单和文字对齐</h3><pre class="line-numbers language-none"><code class="language-none">img {  vertical-align: middle;}li {  disaplay: inline-block;  vertical-align: middle;}</code></pre><h3 id="5-2-解决图片底部默认空白缝隙问题"><a href="#5-2-解决图片底部默认空白缝隙问题" class="headerlink" title="5.2 解决图片底部默认空白缝隙问题"></a>5.2 解决图片底部默认空白缝隙问题</h3><p>bug ：图片底侧会有一个空白缝隙，原因是<strong>行内块元素会预留和文字的基线对齐</strong>。主要解决方法有两种：</p><ol><li>给图片添加 <code>vertical—align: middle top bottom;</code> 等。（提倡使用的）</li><li>把图片转换为块级元素 <code>display: block；</code></li></ol><h2 id="6-溢出的文字省略号显示"><a href="#6-溢出的文字省略号显示" class="headerlink" title="6. 溢出的文字省略号显示"></a>6. 溢出的文字省略号显示</h2><h3 id="6-1-单行文本溢出显示省略号"><a href="#6-1-单行文本溢出显示省略号" class="headerlink" title="6.1 单行文本溢出显示省略号"></a>6.1 单行文本溢出显示省略号</h3><pre class="line-numbers language-none"><code class="language-none">/*1·先强制一行内显示文本*/white-space: nowrap;（默认normal 自动换行）/*2·超出的部分隐藏*/overflow: hidden;/*3.文字用省略号替代超出的部分*/text-overflow: ellipsis;</code></pre><h3 id="6-2-多行文本溢出显示省略号"><a href="#6-2-多行文本溢出显示省略号" class="headerlink" title="6.2 多行文本溢出显示省略号"></a>6.2 多行文本溢出显示省略号</h3><p><strong>更推荐让后台人员来做这个效果</strong>，因为后台人员可以设置显示多少个字，操作更简单。</p><pre class="line-numbers language-none"><code class="language-none">overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 2; /* 设置或检索伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical;</code></pre><h2 id="7-常见布局技巧"><a href="#7-常见布局技巧" class="headerlink" title="7. 常见布局技巧"></a>7. 常见布局技巧</h2><h3 id="7-1-margin负值运用"><a href="#7-1-margin负值运用" class="headerlink" title="7.1 margin负值运用"></a>7.1 margin负值运用</h3><ol><li>解决相邻盒子之间的<strong>边框宽度加倍</strong>问题。 原理：让每个盒子压住前面的盒子，边框叠加。</li></ol><pre class="line-numbers language-none"><code class="language-none">ul li {width: 150px;height: 200px;border: 1px solid red;margin-left: -1px;}</code></pre><ol start="2"><li>鼠标移动边框颜色变化效果。鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有定位，则加相对定位（保留位置）；如果有定位，则加z-index）</li></ol><pre class="line-numbers language-none"><code class="language-none">/*如果盒子li没有定位，则鼠标经过添加相对定位即可*/ul li:hover {  position: relative;  border: 1px solid orange;}/*若盒子li都有定位，则使用 z-index 提高层级*/ul li:hover {  z-index: 1;  border: 1px solid orange;}</code></pre><h3 id="7-2-文字围绕浮动元素"><a href="#7-2-文字围绕浮动元素" class="headerlink" title="7.2 文字围绕浮动元素"></a>7.2 文字围绕浮动元素</h3><p>原理：浮动元素不会遮住文字。</p><pre class="line-numbers language-none"><code class="language-none">div {  float: left;}</code></pre><p><img src="53d89feee196487fadb4e931ecde915f.png" alt="在这里插入图片描述"></p><h3 id="7-3-行内块巧妙运用"><a href="#7-3-行内块巧妙运用" class="headerlink" title="7.3 行内块巧妙运用"></a>7.3 行内块巧妙运用</h3><p>利用行内块元素做<strong>页码跳转组件</strong>：</p><ol><li>把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; </li><li>利用<strong>行内块元素中间有缝隙</strong>，并且给父级添加 text-align:center; 行内块元素会水平会居中</li></ol><h2 id="8-CSS-初始化"><a href="#8-CSS-初始化" class="headerlink" title="8. CSS 初始化"></a>8. CSS 初始化</h2><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对 HTML 文本呈现的差异，<strong>照顾浏览器的兼容</strong>，我们需要对 CSS 初始化</p><p>简单理解： CSS 初始化是指重设浏览器的样式。（也称为 CSS reset ）每个网页都必须首先进行 CSS 初始化。 这里我们以京东 css 初始化代码为例。</p><p>Unicode 编码字体： 把中文字体的名称用相应的 Unicode 编码来代替，这样就可以有效的避免浏览器解释 CSS 代码时候出现乱码的问题。<br>比如： 黑体：<code>\9ED1\4F53</code> 宋体：<code>\5B8B\4F53</code> 微软雅黑：<code>\5FAE\8F6F196C519ED1</code></p><h1 id="二、HTML5新增特性"><a href="#二、HTML5新增特性" class="headerlink" title="二、HTML5新增特性"></a>二、HTML5新增特性</h1><h2 id="1-新增的语义化标签"><a href="#1-新增的语义化标签" class="headerlink" title="1. 新增的语义化标签"></a>1. 新增的语义化标签</h2><ul><li><code>&lt;header&gt;</code>：头部标签</li><li><code>&lt;nav&gt;</code>：导航标签</li><li><code>&lt;article&gt;</code>：内容标签</li><li><code>&lt;section&gt;</code>：定义文档某个区域</li><li><code>&lt;asider&gt;</code>：侧边栏标签</li><li><code>&lt;footer&gt;</code>：尾部标签</li></ul><h2 id="2-新增的多媒体标签"><a href="#2-新增的多媒体标签" class="headerlink" title="2. 新增的多媒体标签"></a>2. 新增的多媒体标签</h2><h3 id="2-1-视频"><a href="#2-1-视频" class="headerlink" title="2.1 视频<video>"></a>2.1 视频<code>&lt;video&gt;</code></h3><p>所有浏览器支持 mp4 格式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;video src="文件地址" controls="controls"&gt;&lt;/video&gt;</code></pre><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>src</code></td><td>url</td><td>视频地址</td></tr><tr><td><code>autoplay</code></td><td>autoplay</td><td>视频就绪自动播放(google需要添加muted来实现)</td></tr><tr><td><code>muted</code></td><td>muted</td><td>静音播放</td></tr><tr><td><code>controls</code></td><td>controls</td><td>显示播放控件</td></tr><tr><td><code>width</code></td><td>像素</td><td>设置视频宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>设置视频高度</td></tr><tr><td><code>loop</code></td><td>loop</td><td>设置视频循环播放</td></tr><tr><td><code>preload</code></td><td>auto/none</td><td>是否预加载，如有autoplay就忽略</td></tr><tr><td><code>poster</code></td><td>imgurl</td><td>加载等待的封面图片</td></tr></tbody></table><h3 id="2-2-音频"><a href="#2-2-音频" class="headerlink" title="2.2 音频<audio>"></a>2.2 音频<code>&lt;audio&gt;</code></h3><p>所有浏览器支持 mp3 格式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;audio src="文件地址" controls="controls"&gt;&lt;/audio&gt;</code></pre><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>src</code></td><td>url</td><td>音频的地址</td></tr><tr><td><code>autoplay</code></td><td>autoplay</td><td>音频就绪后自动播放</td></tr><tr><td><code>controls</code></td><td>controls</td><td>显示播放控件</td></tr><tr><td><code>loop</code></td><td>loop</td><td>设置循环播放</td></tr><tr><td><strong>注：谷歌浏览器把音频和视频自动播放禁止了</strong></td><td></td><td></td></tr></tbody></table><h2 id="3-新增的input相关参数"><a href="#3-新增的input相关参数" class="headerlink" title="3. 新增的input相关参数"></a>3. 新增的input相关参数</h2><h3 id="3-1-新增的input类型"><a href="#3-1-新增的input类型" class="headerlink" title="3.1 新增的input类型"></a>3.1 新增的input类型</h3><p>重点：number  tel  search</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>type="email"</code></td><td>输入必须为Email类型</td></tr><tr><td><code>type="url"</code></td><td>输入必须为url类型</td></tr><tr><td><code>type="date"</code></td><td>输入必须为日期类型</td></tr><tr><td><code>type="time"</code></td><td>输入必须为时间类型</td></tr><tr><td><code>type="month"</code></td><td>输入必须为月类型</td></tr><tr><td><code>type="week"</code></td><td>输入必须为周类型</td></tr><tr><td><code>type="number"</code></td><td>输入必须为数字类型</td></tr><tr><td><code>type="tel"</code></td><td>输入必须为手机号码</td></tr><tr><td><code>type="search"</code></td><td>搜索框</td></tr><tr><td><code>type="color"</code></td><td>生成一个颜色选择表单</td></tr></tbody></table><h3 id="3-2-新增的表单属性"><a href="#3-2-新增的表单属性" class="headerlink" title="3.2 新增的表单属性"></a>3.2 新增的表单属性</h3><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>required</td><td>required</td><td>表单拥有该属性表示其内容不能为空，必填</td></tr><tr><td>placeholder</td><td>提示文本</td><td>表单的提示信息</td></tr><tr><td>autofocus</td><td>autofocus</td><td>自动聚焦属性，页面加载完成自动聚焦到指定表单</td></tr><tr><td>autocomplete</td><td>off/on</td><td>当用户在字段开始键入时，浏览器基于之前键入过的值，可以显示出在字段中填写的选项。默认状态为打开。需要放在表单内，同时加上name属性，同时成功提交</td></tr><tr><td>multiple</td><td>multiple</td><td>可以多选文件上传</td></tr><tr><td>可以通过以下设置方式修改placeholder里面的字体颜色：</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">input::placeholder {    color: pink;}</code></pre><h1 id="三、CSS3-的新特性"><a href="#三、CSS3-的新特性" class="headerlink" title="三、CSS3 的新特性"></a>三、CSS3 的新特性</h1><h2 id="1-新增选择器"><a href="#1-新增选择器" class="headerlink" title="1. 新增选择器"></a>1. 新增选择器</h2><h3 id="1-1-属性选择器"><a href="#1-1-属性选择器" class="headerlink" title="1.1 属性选择器"></a>1.1 属性选择器</h3><p>属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>E[att]</code></td><td>选择具有att属性的E元素</td></tr><tr><td><code>E[att="val"</code></td><td>选择具有att属性且属性值<strong>等于</strong>val的E元素</td></tr><tr><td><code>E[att^="val"]</code></td><td>匹配具有att属性且值以val<strong>开头</strong>的E元素</td></tr><tr><td><code>E[att$="val"]</code></td><td>匹配具有att属性且值以val<strong>结尾</strong>的E元素</td></tr><tr><td><code>E[att*="val"]</code></td><td>匹配具有att属性且值中<strong>含有</strong>val的E元素</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">input[type="text"] {    color: green;}&lt;input type="text"&gt;</code></pre><p>类选择器、属性选择器、伪类选择器的<strong>权重都为 10</strong></p><h3 id="1-2-结构伪类选择器"><a href="#1-2-结构伪类选择器" class="headerlink" title="1.2 结构伪类选择器"></a>1.2 结构伪类选择器</h3><p>结构伪类选择器主要根据<strong>文档结构</strong>来选择器元素，常用于选择父级选择器里面的子元素。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>E: first-child</code></td><td>匹配父元素中的第一个子元素,类型为E</td></tr><tr><td><code>E: last-child</code></td><td>匹配父元素中最后一个子元素，类型为E</td></tr><tr><td><code>E: nth-child(n)</code></td><td>匹配父元素中的第n个子元素，类型为E</td></tr><tr><td><code>E: first-of-type</code></td><td>匹配子元素E类型中的第一个</td></tr><tr><td><code>E: last-of-type</code></td><td>匹配子元素E类型中的最后一个</td></tr><tr><td><code>E: nth-of-type(n)</code></td><td>匹配子元素E类型中的第n个</td></tr></tbody></table><p><strong>重点：</strong><code>E: nth-child(n)</code></p><ul><li>n 可以是整数、关键字（<code>even/odd</code>）、公式（<code>n/2n/2n+1</code>）</li><li>如果 n 是公式，则从0开始计算，但是第 0 个元素或者超出了元素的个数会被忽略</li></ul><table><thead><tr><th>公式</th><th>取值</th></tr></thead><tbody><tr><td>2n</td><td>偶数</td></tr><tr><td>2n-1</td><td>奇数</td></tr><tr><td>5n</td><td>5的倍数</td></tr><tr><td>n+5</td><td>5 6 7 8 …</td></tr><tr><td>-n+5</td><td>前五个</td></tr></tbody></table><p><strong>关于 <code>nth-of-type</code> 与 <code>nth-child</code></strong></p><ol><li><code>div: nth-child</code> 会<strong>把所有的盒子都排列序号</strong>。执行的时候首先看 <code>:nth-child(1)</code>， 之后回去看前面 <code>div</code>，若选中的元素类型不符合，则不起效。</li><li><code>div: nth-of-type</code> 会<strong>把指定元素的盒子排列序号</strong>。执行的时候首先看指定的元素类型<code>div</code>，之后回去看 <code>:nth-of-type(1)</code> 第几个孩子</li></ol><p>区别：</p><ol><li>nth-child 对父元素里面所有孩子排序选择（序号是固定的）先找到第n个孩子，然后看看是否和E匹配</li><li>nth-of-type 对父元素里面指定子元素进行排序选择。先去匹配E ，然后再根据E找第n个孩子</li></ol><h3 id="1-3-伪元素选择器（重点）"><a href="#1-3-伪元素选择器（重点）" class="headerlink" title="1.3 伪元素选择器（重点）"></a>1.3 伪元素选择器（重点）</h3><p>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>::before</code></td><td>在元素内部的前面插入内容</td></tr><tr><td><code>::after</code></td><td>在元素内部的后面插入内容</td></tr></tbody></table><p>注意：</p><ul><li>before 和 after 创建一个元素，但是属于<strong>行内元素</strong></li><li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li><li>语法：<code>element::before {}</code></li><li>before 和 after <strong>必须有 content 属性</strong></li><li>before 在父元素内容的前面创建元素， after 在父元素内容的后面插入元素</li><li>伪元素选择器和标签选择器一样，权重为 1</li></ul><h4 id="1-3-1-应用：伪元素字体图标"><a href="#1-3-1-应用：伪元素字体图标" class="headerlink" title="1.3.1 应用：伪元素字体图标"></a>1.3.1 应用：伪元素字体图标</h4><p>父级添加after伪元素</p><pre class="line-numbers language-none"><code class="language-none">.clearfix::after {    content: '';    display: block;     height: 0;    clear: both;    visibility: hidden;}</code></pre><p>父级添加双伪元素</p><pre class="line-numbers language-none"><code class="language-none">.clearfix::before,.clearfix::after {    content: '';    display: block;}.clearfix::after {    clear: both;}</code></pre><h2 id="2-盒子属性"><a href="#2-盒子属性" class="headerlink" title="2. 盒子属性"></a>2. 盒子属性</h2><p>CSS3中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为 content-box，border-box ，这样我们计算盒子大小的方式就发生了改变。</p><p>可以分成两种情况：</p><ol><li><code>box-sizing：content-box</code> 盒子大小为 width + padding + border （以前默认的）</li><li><code>box-sizing: border-box</code> 盒子大小为 width 如果盒子模型我们改为了 box-sizing： border-box ，那padding 和 border就不会撑大盒子了（前提 padding 和 border 不会超过 width 宽度）</li></ol><h2 id="3-transition过渡（重点）"><a href="#3-transition过渡（重点）" class="headerlink" title="3. transition过渡（重点）"></a>3. transition过渡（重点）</h2><p>过渡（transition）是CSS3中具有颠覆性的特征之一，我们可以在不使用Flash动画或JavaScript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p><p>过渡动画：是从一个状态<strong>渐渐的</strong>过渡到另外一个状态 可以让我们页面更好看，更动感十足，虽然低版本浏览器不支持（ie9以下版本）但是不会影响页面布局。</p><p>我们现在经常和 :hover 一起搭配使用。</p><pre class="line-numbers language-none"><code class="language-none">transition: 要过渡的属性 花费时间 运动曲线 何时开始;</code></pre><p><strong>记住过渡的使用口诀： 谁做过渡给谁加</strong></p><ol><li><p>属性：想要变化的css属性，宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以。</p></li><li><p>花费时间：单位是秒（必须写单位）比如 0.5s</p></li><li><p>运动曲线：默认是ease（可以省略）<br><img src="2ed9c74503c84ae4acd00e47d5591616.png" alt="在这里插入图片描述"></p></li><li><p>何时开始：单位是秒（必须写单位）可以设置延迟触发时间默认是0s（可以省略）</p></li></ol><h2 id="4-CSS3-其他特性（了解）"><a href="#4-CSS3-其他特性（了解）" class="headerlink" title="4. CSS3 其他特性（了解）"></a>4. CSS3 其他特性（了解）</h2><h3 id="4-1-CSS3-滤镜-filter"><a href="#4-1-CSS3-滤镜-filter" class="headerlink" title="4.1 CSS3 滤镜 filter"></a>4.1 CSS3 滤镜 filter</h3><p>ilter CSS属性将模糊或颜色偏移等图形效果应用于元素。</p><pre class="line-numbers language-none"><code class="language-none">filter: 函数();</code></pre><p>例如： <code>filter： blur(5px);</code> blur 模糊处理数值越大越模糊</p><h3 id="4-2-CSS3-calc-函数"><a href="#4-2-CSS3-calc-函数" class="headerlink" title="4.2 CSS3 calc 函数"></a>4.2 CSS3 calc 函数</h3><p>此 CSS 函数让你在声明CSS属性值时执行一些计算。</p><pre class="line-numbers language-none"><code class="language-none">width: calc(100%-30px);/* 子盒子永远比父盒子小30px */</code></pre><p>括号里面可以使用 <code>+ - * /</code> 来进行计算。</p><h2 id="5-2D-转换"><a href="#5-2D-转换" class="headerlink" title="5. 2D 转换"></a>5. 2D 转换</h2><p>转换（<code>transform</code>）是 CSS3 中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。</p><p>转换可以理解为变形。</p><ul><li>移动：<code>translate</code></li><li>旋转：<code>rotate</code></li><li>缩放：<code>scale</code><br><img src="baa21c87b83e43f1830d99047cf230de.png" alt="在这里插入图片描述"></li></ul><h3 id="5-1-2D-转换之移动-translate"><a href="#5-1-2D-转换之移动-translate" class="headerlink" title="5.1 2D 转换之移动 translate"></a>5.1 2D 转换之移动 translate</h3><p>2D移动是2D转换里面的一种功能，可以<strong>改变元素在页面中的位置</strong>，类似定位。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: translate(x, y);transform: translateX(x);transform: translateY(y);</code></pre><ul><li>定义 2D 转换中的移动，沿着X和Y轴移动元素</li><li>translate 最大的优点：<strong>不会影响到其他元素的位置</strong></li><li>参数 <code>x, y</code> 可以是百分数，translate 中的百分比单位是相对于 <strong>自身元素</strong> 的宽度或高度的百分比 <code>translate:(50%，50%)</code></li><li>对<strong>行内标签</strong>没有效果</li></ul><p><em><strong>盒子实现水平和垂直居中</strong></em></p><pre class="line-numbers language-none"><code class="language-none">/*子绝父相*/position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);</code></pre><h3 id="5-2-2D-转换之旋转-rotate"><a href="#5-2-2D-转换之旋转-rotate" class="headerlink" title="5.2 2D 转换之旋转 rotate"></a>5.2 2D 转换之旋转 rotate</h3><p>2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: rotate(45deg);</code></pre><ul><li>值为正数则顺时针旋转，为负数则逆时针旋转。</li><li>默认旋转的中心点是<strong>元素的中心点</strong></li></ul><h4 id="5-2-1-2D-转换中心点-transform-origin"><a href="#5-2-1-2D-转换中心点-transform-origin" class="headerlink" title="5.2.1 2D 转换中心点 transform-origin"></a>5.2.1 2D 转换中心点 transform-origin</h4><p>我们可以通过设置 <code>transform-origin</code> 设置元素转换的中心点。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform-origin: x y;</code></pre><ul><li>x y 默认转换的中心点是元素的中心点（50% 50%）</li><li>还可以给 x y 设置像素或者方位名词（top bottom left right center）</li></ul><h3 id="5-3-2D-转换之缩放scale"><a href="#5-3-2D-转换之缩放scale" class="headerlink" title="5.3 2D 转换之缩放scale"></a>5.3 2D 转换之缩放scale</h3><p>缩放，顾名思义，可以放大和缩小。 只要给元素添加上了这个属性就能控制它放大还是缩小。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: scale(x, y);</code></pre><ul><li>参数大于 <code>1</code> 则放大，小于 <code>1</code> 则缩小。</li><li><code>x, y</code> 不跟单位的话，是指缩放的倍数。</li><li><code>transform: scale(2)</code>：只写一个参数，第二个参数则和第一个参数一样，相当于 <code>scale(2,2)</code></li><li>可以配合 <code>transform-origin</code> 使用，改变缩放中心。</li><li>scale 的优势：不占空间</li></ul><h3 id="5-4-2D-转换综合写法"><a href="#5-4-2D-转换综合写法" class="headerlink" title="5.4 2D 转换综合写法"></a>5.4 2D 转换综合写法</h3><ol><li>同时使用多个转换，其格式为： <code>transform: translate() rotate() scale();</code></li><li>其<strong>顺序会影响</strong>转换的效果。（如先旋转会改变坐标轴方向）</li><li>当我们同时有位移和其他属性的时候，记得要将位移放到最前。</li></ol><h2 id="6-动画"><a href="#6-动画" class="headerlink" title="6. 动画"></a>6. 动画</h2><p>动画( animation ) 是 CSS3 中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。</p><h3 id="6-1-动画的基本使用"><a href="#6-1-动画的基本使用" class="headerlink" title="6.1 动画的基本使用"></a>6.1 动画的基本使用</h3><p>分为两步：</p><ol><li>定义动画 (动画序列 <code>%α</code>)</li><li>使用动画<pre class="line-numbers language-none"><code class="language-none"> /* 1. 定义动画 */@keyframes move {    /*开始状态*/    0% {        transform: translateX(0px);    }    /*结束状态*/    100% {        transform: translateX(1000px);    }}div {    width: 200px;    height: 200px;    background-color: pink;    /* 2. 调用动画 */    /* 动画名称 */    animation-name: move;    /* 持续时间 */    animation-duration: 5s;}</code></pre></li></ol><p><strong>动画序列</strong></p><ul><li>0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。</li><li>在 <code>@keyframes</code> 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</li><li>一个元素可以添加多个动画，调用时用逗号分隔。<code>animation: bear .4s, move 3s;</code></li><li>请用百分比来规定变化发生的时间，或用关键词”from”和“to”，等同于0%和100%。</li></ul><p>注意：</p><ol><li>可以做多个状态的变化 <code>keyframes</code> 关键帧</li><li>百分比必须是<strong>整数</strong></li><li>百分比是总时间 <code>animation-duration</code> 的划分</li></ol><h3 id="6-2-动画常用属性"><a href="#6-2-动画常用属性" class="headerlink" title="6.2 动画常用属性"></a>6.2 动画常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>@keyframes</code></td><td>规定动画。</td></tr><tr><td><code>animation</code></td><td>所有动画属性的简写属性，除了animation-play-state属性。</td></tr><tr><td><code>animation-name</code></td><td>规定@keyframes动画的名称。(必须的)</td></tr><tr><td><code>animation-duration</code></td><td>规定动画完成一个周期所花费的秒或毫秒，默认是0。(必须的)</td></tr><tr><td><code>animation-timing-function</code></td><td>规定动画的速度曲线，默认是“ease” .</td></tr><tr><td><code>animation-delay</code></td><td>规定动画何时开始，默认是0.</td></tr><tr><td><code>animation-iteration-count</code></td><td>规定动画被播放的次数，默认是1，还有infinite</td></tr><tr><td><code>animation-direction</code></td><td>规定动画是否在下一周期逆向播放，默认是 “normal”,alternate逆播放</td></tr><tr><td><code>animation-play-state</code></td><td>规定动画是否正在运行或暂停。默认是”running”,还有”paused”.</td></tr><tr><td><code>animation-fill-mode</code></td><td>规定动画结束后状态,保持forwards回到起始backwards</td></tr></tbody></table><p><img src="7f16501478d5437193c6fe15c4435a9c.png" alt="在这里插入图片描述"></p><p><strong>动画属性简写</strong></p><pre class="line-numbers language-none"><code class="language-none">animation: 动画名称(必) 持续时间(必) 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;</code></pre><pre class="line-numbers language-none"><code class="language-none">animation: myfirst 5s linear 2s infinite alternate;</code></pre><ul><li>简写属性里面不包含 <code>animation-play-state</code></li><li>暂停动画: <code>animation-play-state: puased;</code></li><li>经常和鼠标经过等其他配合使用想要动画走回来，而不是直接跳回来: <code>animation-direction: alternate</code></li><li>盒子动画结束后，停在结束位置:  <code>animation-fill-mode: forwards</code></li></ul><h2 id="7-3D-转换"><a href="#7-3D-转换" class="headerlink" title="7. 3D 转换"></a>7. 3D 转换</h2><p>三维坐标系其实就是指立体空间，立体空间是由3个轴共同组成的。 </p><ul><li>x轴：水平向右 注意： x 右边是正值，左边是负值 </li><li>y轴：垂直向下 注意： y 下面是正值，上面是负值 </li><li>z轴：垂直屏幕 注意： 往外面是正值，往里面是负值<br><img src="e58016773b084eb38618e64f60f968e4.png" alt="在这里插入图片描述"></li></ul><h3 id="7-1-3D-移动-translate3d"><a href="#7-1-3D-移动-translate3d" class="headerlink" title="7.1 3D 移动 translate3d"></a>7.1 3D 移动 translate3d</h3><p>3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向。</p><ul><li><code>transform:translateX(100px)</code>：仅仅是在x轴上移动 </li><li><code>transform:translateY(100px)</code>：仅仅是在Y轴上移动 </li><li><code>transform:translateZ(100px)</code>：仅仅是在Z轴上移动（注意：translateZ一般用px单位） </li><li><code>transform:translate3d(x,y,z)</code>：其中 x、y、z 分别指要移动的轴的方向的距离</li></ul><p>因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动</p><h3 id="7-2-透视-perspective"><a href="#7-2-透视-perspective" class="headerlink" title="7.2 透视 perspective"></a>7.2 透视 perspective</h3><p>在2D平面产生近大远小视觉立体，但是只是效果二维的 </p><ul><li>如果想要在网页产生<strong>3D效果</strong>需要透视（理解成3D物体投影在2D平面内）。 </li><li>模拟人类的视觉位置，可认为安排一只眼睛去看 </li><li><strong>透视也称为视距</strong>：视距就是人的眼睛到屏幕的距离 </li><li>距离视觉点越近的在电脑平面成像越大，越远成像越小 </li><li>透视的单位是像素</li></ul><p>透视写在<strong>被观察元素的父盒子</strong>上面的<br><strong>d</strong>：就是视距，视距就是一个距离人的眼睛到屏幕的距离。视距越小，看到的物体越大。<br><strong>z</strong>：就是 z轴，物体距离屏幕的距离，z轴越大（正值） 我们看到的物体就越大。<br><strong>d 需要&gt;= z</strong>，否则无法显示<br><img src="95b8f12938ce4bb3a552661bc811025d.png" alt="在这里插入图片描述"></p><h3 id="7-3-3D-旋转-rotate3d"><a href="#7-3-3D-旋转-rotate3d" class="headerlink" title="7.3 3D 旋转 rotate3d"></a>7.3 3D 旋转 rotate3d</h3><p>3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴（原点在元素中心位置）或者自定义轴进行旋转。</p><ul><li><code>transform:rotateX(45deg)</code>：沿着x轴正方向旋转 45度 </li><li><code>transform:rotateY(45deg)</code>：沿着y轴正方向旋转 45deg </li><li><code>transform:rotateZ(45deg)</code>：沿着Z轴正方向旋转 45deg </li><li><code>transform:rotate3d(x,y,z,deg)</code>： 沿着自定义轴旋转 deg为角度（了解即可）。<ul><li>xyz是表示旋转轴的矢量</li><li><code>transform:rotate3d(1,0,0,45deg)</code>就是沿着x轴旋转 45deg</li><li><code>transform:rotate3d(1,1,0,45deg)</code>就是沿着对角线旋转 45deg</li></ul></li></ul><p><strong>旋转方向判断——左手准则</strong> </p><ul><li>左手拇指指向 x/y/z 轴的正方向 </li><li>其余手指的弯曲方向就是该元素沿着 x/y/z 轴旋转的方向（正值）</li></ul><h3 id="7-4-3D-呈现-transfrom-style"><a href="#7-4-3D-呈现-transfrom-style" class="headerlink" title="7.4 3D 呈现 transfrom-style"></a>7.4 3D 呈现 transfrom-style</h3><p>控制<strong>子元素</strong>是否开启三维立体环境。</p><ul><li><code>transform-style: flat;</code>：子元素不开启3D立体空间（默认）</li><li><code>transform-style: preserve-3d;</code>：子元素开启立体空间 </li><li><strong>代码写给父级，但是影响的是子盒子</strong></li><li>这个属性很重要，后面必用</li></ul><h3 id="7-5-案例"><a href="#7-5-案例" class="headerlink" title="7.5 案例"></a>7.5 案例</h3><h4 id="7-5-1-两面魔方翻转"><a href="#7-5-1-两面魔方翻转" class="headerlink" title="7.5.1 两面魔方翻转"></a>7.5.1 两面魔方翻转</h4><p>HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="box"&gt;&lt;div class="front"&gt;你好呀&lt;/div&gt;&lt;div class="back"&gt;你是谁&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS：</p><pre class="line-numbers language-none"><code class="language-none">.box {position: relative;width: 200px;height: 100px;margin: 100px auto;transition: all .6s;transform-style: preserve-3d;}.box:hover {transform: rotateX(90deg);}.front,.back {position: absolute;top: 0;left: 0;width: 100%;height: 100%;line-height: 100px;text-align: center;font-size: 16px;color: white;backface-visibility: hidden;}.front {background-color: pink;/* 重要！！！应该向前移动front，这样box的旋转中心轴就在立方体中间了 */transform: translateZ(50px);}.back {background-color: purple;/* 不能先旋转再移动 */transform: translateY(50px) rotateX(-90deg);}</code></pre><ul><li><strong>旋转会改变 x/y/z 轴的方向</strong></li></ul><h4 id="7-5-2-旋转木马"><a href="#7-5-2-旋转木马" class="headerlink" title="7.5.2 旋转木马"></a>7.5.2 旋转木马</h4><p><img src="9aae961d66344c1ab0019510d62c4187.png" alt="在这里插入图片描述"></p><p>HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;section&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/section&gt;</code></pre><p>CSS：</p><pre class="line-numbers language-none"><code class="language-none">body {perspective: 1000px;}section {position: relative;width: 300px;height: 200px;margin: 150px auto;transform-style: preserve-3d;animation: rotate 7s linear infinite;background: url(media/pig.jpg) no-repeat;}section:hover {animation-play-state: paused;}@keyframes rotate {0% {}100% {transform: rotateY(360deg);}}div {position: absolute;top: 0;left: 0;width: 100%;height: 100%;background: url(media/dog.jpg) no-repeat;}div:nth-child(1) {transform: translateZ(300px);}div:nth-child(2) {/* 先旋转再移动 *//* 这里旋转的时候z轴方向也跟着旋转，因此还是300px */transform: rotateY(60deg) translateZ(300px);}div:nth-child(3) {transform: rotateY(120deg) translateZ(300px);}div:nth-child(4) {transform: rotateY(180deg) translateZ(300px);}div:nth-child(5) {transform: rotateY(240deg) translateZ(300px);}div:nth-child(6) {transform: rotateY(300deg) translateZ(300px);}</code></pre><h1 id="四、品优购项目"><a href="#四、品优购项目" class="headerlink" title="四、品优购项目"></a>四、品优购项目</h1><h2 id="1-常用模块类名命名"><a href="#1-常用模块类名命名" class="headerlink" title="1. 常用模块类名命名"></a>1. 常用模块类名命名</h2><p><img src="1e7295a5263c4963a97e5614566849a5.png" alt="在这里插入图片描述"></p><h2 id="2-模块化开发"><a href="#2-模块化开发" class="headerlink" title="2. 模块化开发"></a>2. 模块化开发</h2><h3 id="2-1-初始化文件"><a href="#2-1-初始化文件" class="headerlink" title="2.1 初始化文件"></a>2.1 初始化文件</h3><p>一些页面样式的初始化统一写入 base.css 文件中。</p><h3 id="2-2-公共样式文件"><a href="#2-2-公共样式文件" class="headerlink" title="2.2 公共样式文件"></a>2.2 公共样式文件</h3><p>有些样式和结构在很多页面都会出现，比如页面头部和底部，大部分页面都有。此时，可以把这些结构和样式单独作为一个模块 common.css ，然后重复使用。</p><p><strong>common.css 公共样式里面包含版心宽度、清除浮动、页面文字颜色等公共样式。</strong></p><h2 id="3-网站-favicon-图标"><a href="#3-网站-favicon-图标" class="headerlink" title="3. 网站 favicon 图标"></a>3. 网站 favicon 图标</h2><p>favicon.ico 一般用于作为缩略的网站标志，它显示在浏览器的地址栏或者标签上。</p><ol><li>制作 favicon 图标。把 png 图片转换为 ico 图标，这需要借助于第三方转换网站，例如比特虫：<a href="http://www.bitbug.net/">http://www.bitbug.net/</a></li><li>把 favicon 图标放到项目文件根目录下</li><li>在html 页面里面的<code>&lt;head&gt;&lt;/head&gt;</code>元素之间引入代码。<code>&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/&gt; </code></li></ol><h2 id="4-LOGO-SEO-优化"><a href="#4-LOGO-SEO-优化" class="headerlink" title="4. LOGO SEO 优化"></a>4. LOGO SEO 优化</h2><ol><li>logo 里面首先放一个 <code>h1</code> 标签，目的是为了提权，告诉搜索引擎，这个地方很重要。</li><li>h1 里面再放一个<code>a链接</code>，可以返回首页的，把 logo 的背景图片给链接即可。 </li><li>为了搜索引擎收录我们，我们<strong>链接里面要放文字（网站名称）</strong>，但是文字不要显示出来。<ol><li>方法1：<code>text-indent</code> 移到盒子外面（<code>text-indent: -9999px</code>) ，然后 <code>overflow:hidden</code>，淘宝的做法。 </li><li>方法2：直接给 <code>font-size: 0;</code> 就看不到文字了，京东的做法。</li></ol></li><li>最后给链接一个 <code>title</code> 属性，这样鼠标放到 logo 上就可以看到提示文字了。</li></ol><h2 id="5-一些tips"><a href="#5-一些tips" class="headerlink" title="5. 一些tips"></a>5. 一些tips</h2><ol><li>若要让相邻两个文字中间有一段距离，直接用<code>&amp;nbsp;</code>（空格符）即可。</li><li>nav导航栏处的dropdown盒子有讲究，它和下面的盒子是一体的，包含.dt 和.dd两个盒子<br><img src="490d976d82df478faa4e316864e12e9c.png" alt="在这里插入图片描述"></li></ol><p><img src="7475593a2d59417a9e1ed01af3a7a59a.png" alt="在这里插入图片描述"></p><ol start="3"><li><p>两行文字不需要分为两个<code>&lt;p&gt;</code>，可以直接在中间加<code>&lt;br&gt;</code>即可实现换行。若要增加两行文字间的距离，可以增大<code>line-height</code>属性即可。</p></li><li><p>一行文字中有文字需要加粗，则给需要加粗的文字套一个<code>&lt;strong&gt;&lt;/strong&gt;</code></p></li><li><p>多个<code>li</code>排成的多行<img src="57ad8614778f41cd9ea36bb55ade9207.png" alt="在这里插入图片描述"></p></li><li><p><code>text-align</code> 属性的巧用：<br>在一个 div 中包含 i（行内元素），此时对 div 赋予 <code>text-align: center</code>，i 也会在 div 内水平居中；<br>在一个 div 中包含 img（行内块元素），此时对 div 赋予 <code>text-align: center</code>，img 也会在 div 内水平居中；<br>在一个 div 中包含 p（块元素），此时对 div 赋予 <code>text-align: center</code>，p 会继承该属性，内容在标签内水平居中。</p></li><li><p>Tab栏原理-布局需求<br>要求选项卡个数要和内容个数一致，tab_content 里面包含 内容部分。<br><img src="606a50640560432386a8238c485aa3e7.png" alt="在这里插入图片描述"></p></li><li><p><code>vertical-align: middle;</code> 可以使行内块元素与文字对齐</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/10/hello-world/"/>
      <url>/2022/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 页面布局三大核心</title>
      <link href="/2022/12/01/CSS-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/"/>
      <url>/2022/12/01/CSS-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><strong>网页布局过程：</strong></p><ol><li>准备网页元素，网页元素基本都是盒子 box</li><li>利用 CSS 设置好盒子样式，然后摆放到相应位置。</li><li>往盒子里放东西。</li></ol><p><strong>网页布局的核心本质</strong>：利用 CSS 摆盒子。</p><p><strong>CSS 提供了三种传统布局方式：</strong></p><ul><li>普通流（标准流）</li><li>浮动</li><li>定位</li></ul><p>所谓的标准流，就是标签按照规定好的默认方式排列（<strong>最基本的布局方式</strong>）。</p><ol><li>块级元素会独占一行，从上到下顺序排列 常用元素：div、hr、p、h1-h6、ul、ol、dl、form、table</li><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 常用元素：span、a、i、em</li></ol><h1 id="一、盒子模型"><a href="#一、盒子模型" class="headerlink" title="一、盒子模型"></a>一、盒子模型</h1><h2 id="1-盒子模型的组成"><a href="#1-盒子模型的组成" class="headerlink" title="1. 盒子模型的组成"></a>1. 盒子模型的组成</h2><p>CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素。</p><p><strong>包括：边框、外边距、内边距和实际内容。</strong></p><p><img src="604bacd3c99c449c8a0da847b9241d8a.png"></p><h2 id="2-边框（border）"><a href="#2-边框（border）" class="headerlink" title="2. 边框（border）"></a>2. 边框（border）</h2><p>border 可以设置元素边框。边框有三个组成：<code>border-width</code>、<code>border-style</code>、<code>border-color</code></p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">/*属性可连写*/border: border-width || border-style || border-color;</code></pre><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>定义边框粗细，单位 px</td></tr><tr><td>border-style</td><td>边框样式：none(默认无边框)、solid(单实线)、dashed(虚线)、dotted(点线)</td></tr><tr><td>border-color</td><td>边框颜色</td></tr></tbody></table><p><strong>边框属性分写：</strong></p><pre class="line-numbers language-none"><code class="language-none">/*注意层叠性*/border-top: 1px solid red;</code></pre><h3 id="2-1-表格的边框合并"><a href="#2-1-表格的边框合并" class="headerlink" title="2.1 表格的边框合并"></a>2.1 表格的边框合并</h3><p><code>border-collapse</code> 属性控制浏览器绘制表格边框的方式。它可以使相邻单元格的边框合并在一起。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-collapse: collapse;</code></pre><h3 id="2-2-圆角边框"><a href="#2-2-圆角边框" class="headerlink" title="2.2 圆角边框"></a>2.2 圆角边框</h3><p>CSS3 新增 <strong>圆角边框</strong> 属性，盒子可以变成圆角。</p><p><code>border-radius</code> 属性用于设置元素的外边框圆角。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-radius: length;</code></pre><p><strong>原理：</strong><br>（椭）圆与边框的交集形成的圆角效果。</p><p><strong>参数：</strong></p><ul><li>参数值可以为数值或百分比的形式</li><li>若是正方形，想要设置一个圆，则将数值修改为高度或者宽度的一般即可，或者直接写为 50%</li><li>简写属性，跟四个值，分别代表左上角、右上角、右下角、左下角</li><li>分开来写：<code>border-top-left-radius</code>、<code>border-top-right-radius</code>、<code>border-bottom-right-radius</code>、<code>border-bottom-left-radius</code></li></ul><h3 id="2-3-边框会影响盒子大小"><a href="#2-3-边框会影响盒子大小" class="headerlink" title="2.3 边框会影响盒子大小"></a>2.3 边框会影响盒子大小</h3><p>边框会额外增加盒子的实际大小，因此有两种方案解决。</p><ol><li>测量盒子大小的时候，不量边框。</li><li>若测量的时候包含了边框，则需要 width/height-边框宽度。</li></ol><h2 id="3-内边距（padding）"><a href="#3-内边距（padding）" class="headerlink" title="3. 内边距（padding）"></a>3. 内边距（padding）</h2><p><code>padding</code> 属性设置内边距，即边框与内容之间的距离。</p><ul><li><code>padding-left</code>: 左内边距</li><li><code>padding-right</code>: 右内边距</li><li><code>padding-top</code>: 上内边距</li><li><code>padding-bottom</code>: 下内边距</li></ul><p><strong>padding 属性简写：</strong></p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>padding: 5px;</td><td>上下左右5</td></tr><tr><td>padding: 5px 10px;</td><td>上下5 左右10</td></tr><tr><td>padding: 5px 10px 20px;</td><td>上5 左右10 下20</td></tr><tr><td>padding: 5px 10px 20px 30px;</td><td>上5 右10 下20 左30</td></tr></tbody></table><h3 id="3-1-内边距会影响盒子大小"><a href="#3-1-内边距会影响盒子大小" class="headerlink" title="3.1 内边距会影响盒子大小"></a>3.1 内边距会影响盒子大小</h3><p>当给盒子指定了 <code>padding</code> 值以后，发生了两件事情：</p><ol><li>内容和边框有了距离，增加内边距</li><li>padding 值影响了盒子实际大小</li></ol><p>也就是说，<strong>当盒子已经有了宽度和高度</strong>，再指定内边距，会撑大盒子。（如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小）</p><p>要保证盒子和效果图一样大，则让 <code>width/height</code>-多出来的内边距大小。</p><h2 id="4-盒子大小变动解决方案"><a href="#4-盒子大小变动解决方案" class="headerlink" title="4. 盒子大小变动解决方案"></a>4. 盒子大小变动解决方案</h2><p>在设置了一个盒子的 <code>width/height</code> 后，再设置其 <code>border/padding</code> 会影响盒子实际大小。当进行响应式布局时，这个尤其烦人。</p><p><code>box-sizing</code> 属性可以被用来调整这些表现。</p><ul><li><p><code>content-box</code> 是默认值。如果你设置一个元素的宽为<code>100px</code>，那么这个元素整体会有 <code>100px</code> 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: content-box;</code></pre></li><li><p><code>border-box</code> 告诉浏览器：你想要设置的边框和内边距的值是包含在 <code>width</code> 内的。也就是说，如果你将一个元素的 <code>width</code> 设为 <code>100px</code>，那么这 <code>100px</code> 会包含它的 <code>border</code> 和 <code>padding</code>，内容区的实际宽度是 <code>width</code> 减去 <code>(border + padding)</code> 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: border-box;</code></pre><p>尺寸计算公式： <code>width = border + padding + 内容的宽度</code> 、<code>height = border + padding + 内容的高度</code></p></li></ul><h2 id="5-外边距（margin）"><a href="#5-外边距（margin）" class="headerlink" title="5. 外边距（margin）"></a>5. 外边距（margin）</h2><p><code>margin</code> 属性用于设置外边距，即控制盒子与盒子之间的距离。</p><ul><li><code>margin-left</code>: 左外边距</li><li><code>margin-right</code>: 右外边距</li><li><code>margin-top</code>: 上外边距</li><li><code>margin-bottotm</code>: 下外边距</li></ul><p><code>margin</code> 简写方式与 <code>padding</code> 一致。</p><h3 id="5-1-外边距典型应用"><a href="#5-1-外边距典型应用" class="headerlink" title="5.1 外边距典型应用"></a>5.1 外边距典型应用</h3><p>外边距可以让块级盒子 <strong>水平居中</strong>，但是必须满足两个条件：</p><ol><li>盒子必须指定宽度（width）</li><li>盒子左右的外边距都设置为 <code>auto</code></li></ol><pre class="line-numbers language-none"><code class="language-none">.header {  width: 960px;  margin: 0 auto;}</code></pre><h3 id="5-2-外边距合并"><a href="#5-2-外边距合并" class="headerlink" title="5.2 外边距合并"></a>5.2 外边距合并</h3><p>使用 <code>margin</code> 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><h4 id="5-2-1-上下相邻块元素垂直外边距的合并"><a href="#5-2-1-上下相邻块元素垂直外边距的合并" class="headerlink" title="5.2.1 上下相邻块元素垂直外边距的合并"></a>5.2.1 上下相邻块元素垂直外边距的合并</h4><p>当上下相邻块元素相遇时，若上面的元素有下外边距，下面的元素有上外边距，则他们之间的垂直间距不是 <code>margin-bottotm</code> 与 <code>margin-top</code> 之和。<strong>取两个值中的较大者</strong>这种现象被称为相邻元素垂直外边距的合并。</p><p>解决方案：尽量只给一个盒子添加margin值。</p><p>![[Pasted image 20221209144024.png]]</p><h4 id="5-2-2-嵌套块元素垂直外边距的塌陷"><a href="#5-2-2-嵌套块元素垂直外边距的塌陷" class="headerlink" title="5.2.2 嵌套块元素垂直外边距的塌陷"></a>5.2.2 嵌套块元素垂直外边距的塌陷</h4><p>对于两个嵌套关系的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><p>解决方案：</p><ol><li>为父元素定义上边框</li><li>为父元素定义上内边距</li><li>为父元素添加 <code>overflow:hidden</code></li></ol><p><img src="2884c415f1284d7abcfa54e3115596dd.png" alt="在这里插入图片描述"></p><h2 id="6-清除内外边距"><a href="#6-清除内外边距" class="headerlink" title="6. 清除内外边距"></a>6. 清除内外边距</h2><p>网页元素很多都带有默认内外边距，而且不同浏览器默认的也不一致，因此在布局前，要先清除网页元素的内外边距。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">* {  margin: 0;  padding: 0;}</code></pre><p><em><strong>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距（不起效果）。但是转换为块级和行内块元素就可以设置。</strong></em></p><h2 id="7-盒子阴影"><a href="#7-盒子阴影" class="headerlink" title="7. 盒子阴影"></a>7. 盒子阴影</h2><p>CSS3 新增盒子阴影，使用 <code>box-shadow</code> 属性。</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">bxo-shadow: h-shadow v-shadow blur spread color inset;</code></pre><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必需，水平阴影的位置，允许负值</td></tr><tr><td>v-shadow</td><td>必需，垂直阴影的位置，允许负值</td></tr><tr><td>blur</td><td>可选，模糊距离</td></tr><tr><td>spread</td><td>可选，阴影的尺寸</td></tr><tr><td>color</td><td>可选，阴影的颜色</td></tr><tr><td>inset</td><td>可选，将外部阴影改为内部阴影（默认是外部阴影）</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3);</code></pre><p>注意：</p><ol><li>默认是外阴影，但是不可以写这个单词（outset）</li><li><strong>盒子阴影不占空间，不会影响其他盒子排列</strong></li></ol><h1 id="二、浮动"><a href="#二、浮动" class="headerlink" title="二、浮动"></a>二、浮动</h1><h2 id="1-浮动相关概念"><a href="#1-浮动相关概念" class="headerlink" title="1. 浮动相关概念"></a>1. 浮动相关概念</h2><h3 id="1-1-为什么需要浮动"><a href="#1-1-为什么需要浮动" class="headerlink" title="1.1 为什么需要浮动"></a>1.1 为什么需要浮动</h3><ol><li><p>如何让多个块级盒子(div)水平排列成一行？<br>比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的<strong>空白缝隙</strong>，很难控制。</p></li><li><p>如何实现两个盒子的左右对齐？</p></li></ol><p>总结：很多布局效果，标准流没办法完成，此时就可以利用浮动完成布局。浮动可以改变元素标签默认排列方式。</p><p><strong>浮动最典型应用：让多个块级元素一行显示。</strong></p><p>网页布局第一准则：<em><strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</strong></em>。<br>网页布局第二准则：先设置盒子大小，再设置盒子位置。</p><h3 id="1-2-什么是浮动"><a href="#1-2-什么是浮动" class="headerlink" title="1.2 什么是浮动"></a>1.2 什么是浮动</h3><p><code>float</code> 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 { float: 属性值; }</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h3 id="1-3-浮动特性（重点）"><a href="#1-3-浮动特性（重点）" class="headerlink" title="1.3 浮动特性（重点）"></a>1.3 浮动特性（重点）</h3><p>加了浮动之后的元素，会具有一些特性。</p><ol><li>浮动元素会脱离标准流（脱标）</li><li>浮动元素会一行内显示并且元素顶部对齐</li><li>浮动的元素会具有行内块元素的特性</li></ol><h4 id="1-3-1-重要特性"><a href="#1-3-1-重要特性" class="headerlink" title="1.3.1 重要特性"></a>1.3.1 重要特性</h4><ol><li><p>脱离文档流的控制（浮）移动到指定位置（动）（俗称脱标）。浮动的盒子不再保留原先的位置。<br><img src="a33af70ed3d541f889d93ffc584a2252.png" alt="在这里插入图片描述"></p></li><li><p>如果多个盒子都设置了浮动，则它们会按照属性值<strong>一行显示并且顶端对齐排列</strong>。 浮动的元素是相互贴在一起的（没有间隙），若父级宽度放不下这些浮动的盒子，多出的盒子会另起一行对齐。</p></li><li><p>浮动元素具有行内块元素特性。 任何元素都可以浮动，元素添加浮动后都具有<strong>行内块元素</strong>性质。</p></li></ol><ul><li>若块级元素没有设置宽度，则默认和父级一样宽。但添加浮动后，大小根据内容来决定</li><li>浮动盒子中间无间隙，紧挨着</li><li>行内块元素同理</li></ul><h4 id="1-3-2-浮动布局注意点"><a href="#1-3-2-浮动布局注意点" class="headerlink" title="1.3.2 浮动布局注意点"></a>1.3.2 浮动布局注意点</h4><p><strong>1. 浮动和标准流的父盒子搭配</strong></p><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</p><p><strong>2. 一个元素浮动了，理论上其余兄弟元素也要浮动</strong></p><ul><li><p>一个盒子里有多个盒子，其中一个盒子浮动，其他兄弟也应该浮动，防止引起问题。 </p></li><li><p>浮动的盒子只会影响浮动盒子<strong>后面</strong>的标准流，不会影响前面的标准流。</p></li></ul><h2 id="2-清除浮动"><a href="#2-清除浮动" class="headerlink" title="2. 清除浮动"></a>2. 清除浮动</h2><h3 id="2-1-为什么需要清除浮动"><a href="#2-1-为什么需要清除浮动" class="headerlink" title="2.1 为什么需要清除浮动"></a>2.1 为什么需要清除浮动</h3><p>由于父级盒子很多情况下，<strong>不方便给高度</strong>（产品可能有很多很多；新闻页面不知道有多少字不方便给高度）。<br>盒子浮动不占有位置，<strong>若父级盒子高度为 0 时，就会影响下面的盒子</strong>，对后面元素排版产生影响。<br><img src="48fc3938fad84506b096e53a1bf40817.png" alt="在这里插入图片描述"></p><h3 id="2-2-清除浮动的本质"><a href="#2-2-清除浮动的本质" class="headerlink" title="2.2 清除浮动的本质"></a>2.2 清除浮动的本质</h3><ul><li>清除浮动的本质是清除浮动元素造成的影响</li><li>如果父盒子本身具有高度，则不需要清除浮动</li><li>清除浮动之后，<strong>父级会根据浮动的子盒子自动检测高度</strong>，父级有了高度，就不会影响下面的标准流了。</li></ul><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 {  clear: 属性值;}</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素</td></tr><tr><td>right</td><td>不允许右侧有浮动元素</td></tr><tr><td>both</td><td>同时清除左右两侧浮动</td></tr><tr><td>清除浮动策略：闭合浮动</td><td></td></tr></tbody></table><h3 id="2-3-清除浮动的方法"><a href="#2-3-清除浮动的方法" class="headerlink" title="2.3 清除浮动的方法"></a>2.3 清除浮动的方法</h3><h4 id="2-3-1-额外标签法（隔墙法）"><a href="#2-3-1-额外标签法（隔墙法）" class="headerlink" title="2.3.1 额外标签法（隔墙法）"></a>2.3.1 额外标签法（隔墙法）</h4><p>额外标签法是在最后一个浮动元素末尾添加一个<strong>空块级元素</strong>，给其赋以属性 <code>clear: both;</code>。(不常用)</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;  .clear {  clear: both;}&lt;/style&gt;&lt;div class="clear"&gt;&lt;/div&gt;</code></pre><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义的标签，结构化差</li></ul><h4 id="2-3-2-父级添加-overflow-属性"><a href="#2-3-2-父级添加-overflow-属性" class="headerlink" title="2.3.2 父级添加 overflow 属性"></a>2.3.2 父级添加 overflow 属性</h4><p>可以给父级添加 <code>overflow</code> 属性，将其属性设置为 <code>hidden</code>、<code>auto</code>或<code>scroll</code>。</p><p>注意是<strong>给父元素添加代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">.box {overflow: hidden;}</code></pre><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出部分</li></ul><h4 id="2-3-3-after-伪元素法"><a href="#2-3-3-after-伪元素法" class="headerlink" title="2.3.3 :after 伪元素法"></a>2.3.3 :after 伪元素法</h4><p><code>:after</code> 方式是额外标签法的升级版。给父元素添加（常用）</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:after {content: "";display: block;height: 0;clear: both;visibility: hidden;}.clearfix {/*IE6、7专有*/*zoom: 1;}</code></pre><p>优点：没有增加标签，结构更简单</p><h4 id="2-3-4-双伪元素清除浮动"><a href="#2-3-4-双伪元素清除浮动" class="headerlink" title="2.3.4 双伪元素清除浮动"></a>2.3.4 双伪元素清除浮动</h4><p>给父元素添加（常用）</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:before,.clearfix:after {  content: "";  display: table;}.clearfix:after {  clear: both;}.clearfix {  *zoom: 1;}</code></pre><h2 id="3-学成在线案例"><a href="#3-学成在线案例" class="headerlink" title="3. 学成在线案例"></a>3. 学成在线案例</h2><h3 id="3-1-CSS属性书写顺序"><a href="#3-1-CSS属性书写顺序" class="headerlink" title="3.1 CSS属性书写顺序"></a>3.1 CSS属性书写顺序</h3><p><img src="9f10784467f742579317d741a3e25e16.png" alt="在这里插入图片描述"></p><h3 id="3-2-页面布局分析"><a href="#3-2-页面布局分析" class="headerlink" title="3.2 页面布局分析"></a>3.2 页面布局分析</h3><p>为了提高网页制作的效率，布局时通常有以下的布局流程：</p><ol><li>必须确定页面的版心（可视区），我们测量可得知。</li><li>分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成的。</li><li>制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</li><li>开始运用盒子模型的原理，通过 div+css 布局来控制网页的各个模块。</li></ol><h3 id="3-3-注意点"><a href="#3-3-注意点" class="headerlink" title="3.3 注意点"></a>3.3 注意点</h3><p>导航栏注意点：</p><p>实际开发中，不会直接用链接 a 而是用 li 包含链接（li+a）的做法。</p><ol><li><p>li+a 语义更清晰，一看就是有条理的列表型内容。</p></li><li><p>如果直接用 a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名。</p></li><li><p>让导航栏一行显示，给 <code>li</code> 加浮动，因为 li 是块级元素，需要一行显示。</p></li><li><p>这个 nav 导航栏可以不给宽度，将来可以继续添加其余文字。</p></li><li><p>因为导航栏里面文字不一样多，所以最好<strong>给链接 a 左右 padding 撑开盒子</strong>，而不是指定宽度。</p></li></ol><p>其他注意点：</p><ol><li><p>浮动的盒子不会出现外边距合并的问题。</p></li><li><p>注意元素的显示模式（块级、行内、行内块），必要时进行模式转换。</p></li><li><p>若添加了margin导致5个盒子无法在父元素的一行显示、一个盒子到下一行显示的问题时，直接增加父元素的宽度即可。</p></li></ol><h1 id="三、定位"><a href="#三、定位" class="headerlink" title="三、定位"></a>三、定位</h1><h2 id="1-为什么需要定位"><a href="#1-为什么需要定位" class="headerlink" title="1. 为什么需要定位"></a>1. 为什么需要定位</h2><p>在一些场景，我们希望实现以下功能：</p><ol><li>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子</li><li>当我们滚动窗口的时候，盒子是固定屏幕某个位置的。</li></ol><p>以上效果，标准流或浮动都无法快速实现，此时<strong>需要定位来实现</strong>。 所以： </p><ol><li>浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 </li><li>定位则是可以<strong>让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置</strong>，并且可以压住其他盒子。</li></ol><h2 id="2-定位组成"><a href="#2-定位组成" class="headerlink" title="2. 定位组成"></a>2. 定位组成</h2><p>定位：将盒子定在某一个位置，所以<strong>定位也是在摆放盒子，按照定位的方式移动盒子</strong>。定位=定位模式+边偏移。</p><p><strong>定位模式</strong>用于指定一个元素在文档中的定位方式。<strong>边偏移</strong>则决定了该元素的最终位置。</p><h3 id="2-1-定位模式"><a href="#2-1-定位模式" class="headerlink" title="2.1 定位模式"></a>2.1 定位模式</h3><p>定位模式决定元素的定位方式，它通过 CSS 的 <code>position</code> 属性来设置，其值可以分为四个值：</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><h3 id="2-2-边偏移"><a href="#2-2-边偏移" class="headerlink" title="2.2 边偏移"></a>2.2 边偏移</h3><p>边偏移就是定位的盒子移动到最终位置。有 top， bottom， left 和 right 4 个属性</p><p><strong>注意：如果一个盒子既有left属性又有right属性，则默认会执行left属性。同理top和bottom默认会执行top。</strong></p><table><thead><tr><th>边偏移属性</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td><strong>top</strong></td><td><code>top:80px</code></td><td>顶端偏移量，定义元素相对于其父元素上边线的距离。</td></tr><tr><td>bottom</td><td><code>bottom: 80px</code></td><td>底部偏移量，定义元素相对于其父元素下边线的距离。</td></tr><tr><td><strong>left</strong></td><td><code>left： 80px</code></td><td>左侧偏移量，定义元素相对于其父元素左边线的距离。</td></tr><tr><td>right</td><td><code>right: 80px</code></td><td>右侧偏移量，定义元素相对于其父元素右边线的距离。</td></tr></tbody></table><h2 id="3-定位模式介绍"><a href="#3-定位模式介绍" class="headerlink" title="3. 定位模式介绍"></a>3. 定位模式介绍</h2><h3 id="3-1-静态定位-static（了解）"><a href="#3-1-静态定位-static（了解）" class="headerlink" title="3.1 静态定位 static（了解）"></a>3.1 静态定位 static（了解）</h3><p>静态定位是元素的<strong>默认定位方式</strong>，无定位的意思。语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: static;}</code></pre><p>静态定位<strong>按照标准流特性</strong>摆放位置，它没有边偏移，在布局时很少用到。</p><h3 id="3-2-相对定位-relative（重要）"><a href="#3-2-相对定位-relative（重要）" class="headerlink" title="3.2 相对定位 relative（重要）"></a>3.2 相对定位 relative（重要）</h3><p>相对定位是元素在移动位置的时候，是<strong>相对于它原来的位置</strong>来说的（自恋型）。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: relative;}</code></pre><p><strong>相对定位的特点：（务必记住）</strong></p><ol><li><p>它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。</p></li><li><p><strong>原来</strong>在标准流的<strong>位置继续占有</strong>，后面的盒子仍然以标准流的方式对待它。（<strong>不脱标</strong>，继续保留原来位置。它最典型的应用是给绝对定位当爹。）</p></li></ol><h3 id="3-3-绝对定位-absolute（重要）"><a href="#3-3-绝对定位-absolute（重要）" class="headerlink" title="3.3 绝对定位 absolute（重要）"></a>3.3 绝对定位 absolute（重要）</h3><p>绝对定位是元素在移动位置的时候，是相对于它<strong>祖先元素</strong>来说的（拼爹型）。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: absolute;}</code></pre><p>绝对定位的特点： （务必记住）</p><ol><li><p>如果 <strong>没有祖先元素</strong> 或者 <strong>祖先元素没有定位</strong>，则以 <strong>浏览器</strong> 为准定位（ Document 文档）。</p></li><li><p>如果祖先元素有定位（相对、绝对、固定定位） ，则以<strong>最近一级的有定位祖先元素</strong>为参考点移动位置。</p></li><li><p>绝对定位<strong>不再占有原先的位置</strong>。（脱标）</p></li></ol><h4 id="3-3-1-子绝父相"><a href="#3-3-1-子绝父相" class="headerlink" title="3.3.1 子绝父相"></a>3.3.1 子绝父相</h4><ul><li><p><strong>子级绝对定位，不占有位置</strong>，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p></li><li><p>父盒子需要<strong>加定位限制子盒子</strong>在父盒子内显示。</p></li><li><p>父盒子布局时，<strong>需要占有位置</strong>，因此父亲只能是相对定位。</p></li></ul><p>这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。<br><strong>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</strong></p><p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，<strong>子绝父绝</strong>也会遇到。</p><h3 id="3-4-固定定位-fixed-（重要）"><a href="#3-4-固定定位-fixed-（重要）" class="headerlink" title="3.4 固定定位 fixed （重要）"></a>3.4 固定定位 fixed （重要）</h3><p>固定定位是元素<strong>固定于浏览器可视区的位置</strong>。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: fixed;}</code></pre><p>固定定位的特点： （务必记住）</p><ol><li>以浏览器的可视窗口为参照点移动元素。<ul><li>跟父元素没有任何关系</li><li>不随滚动条滚动</li></ul></li><li>固定定位<strong>不占有原先的位置</strong>。 固定定位也是脱标的，其实固定定位也可以看做是<strong>一种特殊的绝对定位</strong>。</li></ol><p><em><strong>固定定位小技巧：固定在版心右侧位置。</strong></em></p><ol><li>让固定定位的盒子 left：50%，走到浏览器可视区（也可以看做版心）的一半位置。</li><li>让固定定位的盒子 margin-left：板心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了</li></ol><h3 id="3-5-粘性定位-sticky（了解）"><a href="#3-5-粘性定位-sticky（了解）" class="headerlink" title="3.5 粘性定位 sticky（了解）"></a>3.5 粘性定位 sticky（了解）</h3><p>粘性定位可以被认为是相对定位和固定定位的混合。<br><strong>应用：滑动到元素所在定义位置（如top: 10px表示滑动到浏览器可视窗口距元素10px）后，继续下滑时元素固定。</strong></p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {position: sticky;top: 10px;}</code></pre><p>粘性定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li><strong>必须添加 top， left， right， bottom 其中一个</strong>才有效跟页面滚动搭配使用。兼容性较差， IE 不支持。</li></ol><h3 id="3-6-定位模式总结"><a href="#3-6-定位模式总结" class="headerlink" title="3.6 定位模式总结"></a>3.6 定位模式总结</h3><table><thead><tr><th>定位模式</th><th>是否脱标</th><th>移动位置</th><th>是否常用</th></tr></thead><tbody><tr><td>static静态定位</td><td>否 (占有位置)</td><td>不能使用边偏移</td><td>很少</td></tr><tr><td>relative相对定位</td><td>否 (占有位置)</td><td>相对于自身位置移动</td><td>常用</td></tr><tr><td>absolute绝对定位</td><td>是 (不占有位置)</td><td>带有定位的父级</td><td>常用</td></tr><tr><td>fixed固定定位</td><td>是 (不占有位置)</td><td>浏览器可视区</td><td>常用</td></tr><tr><td>sticky粘性定位</td><td>否 (占有位置)</td><td>浏览器可视区</td><td>当前阶段少</td></tr></tbody></table><h2 id="4-定位的拓展"><a href="#4-定位的拓展" class="headerlink" title="4. 定位的拓展"></a>4. 定位的拓展</h2><h3 id="4-1-定位叠放次序-z-index"><a href="#4-1-定位叠放次序-z-index" class="headerlink" title="4.1 定位叠放次序 z-index"></a>4.1 定位叠放次序 z-index</h3><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 <code>z-index</code> 来控制盒子的前后次序（z 轴）</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {z-index: 1;}</code></pre><ul><li>数值可以是正整数、负整数或 0，默认是 auto ，<strong>数值越大，盒子越靠上</strong></li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有 <code>z-index</code> 属性</li></ul><h3 id="4-2-绝对定位的盒子居中"><a href="#4-2-绝对定位的盒子居中" class="headerlink" title="4.2 绝对定位的盒子居中"></a>4.2 绝对定位的盒子居中</h3><p>加了<strong>绝对定位</strong>的盒子不能通过 margin：0 auto 水平居中，但是可以通过以下计算方法实现水平和垂直居中。</p><ul><li><code>left: 50%;</code>：让盒子的左侧移动到父级元素的水平中心位置。</li><li><code>margin-left: -100px;</code>：让盒子向左移动自身宽度的一半。</li></ul><h3 id="4-3-绝对定位和固定定位的特殊特性"><a href="#4-3-绝对定位和固定定位的特殊特性" class="headerlink" title="4.3 绝对定位和固定定位的特殊特性"></a>4.3 绝对定位和固定定位的特殊特性</h3><h4 id="4-3-1-元素模式转换"><a href="#4-3-1-元素模式转换" class="headerlink" title="4.3.1 元素模式转换"></a>4.3.1 元素模式转换</h4><p><strong>绝对定位和固定定位</strong>也和<strong>浮动</strong>类似。添加后<strong>变为行内块元素</strong>。</p><ol><li>行内元素添加绝对或者固定定位，可以直接设置高度和完度。</li><li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li></ol><h4 id="4-3-2-不会触发外边距合并"><a href="#4-3-2-不会触发外边距合并" class="headerlink" title="4.3.2 不会触发外边距合并"></a>4.3.2 不会触发外边距合并</h4><p><strong>浮动</strong>元素、<strong>绝对定位/固定定位</strong>的元素 都不会触发外边距合并的问题。</p><h4 id="4-3-3-完全压住盒子"><a href="#4-3-3-完全压住盒子" class="headerlink" title="4.3.3 完全压住盒子"></a>4.3.3 完全压住盒子</h4><ul><li><p>浮动元素不同，只会压住它下面标准流的盒子，但是<strong>不会压住下面标准流盒子里面的文字（图片）</strong></p><blockquote><p>因为浮动产生的目的最初是为了<strong>做文字环绕效果</strong>的。文字会围绕浮动元素。</p></blockquote></li><li><p>绝对定位（固定定位）会压住<strong>下面标准流所有的内容</strong>。</p></li></ul><h2 id="5-网页布局总结"><a href="#5-网页布局总结" class="headerlink" title="5. 网页布局总结"></a>5. 网页布局总结</h2><p>通过盒子模型，清楚知道大部分 html 标签是一个盒子。<br>通过 CSS 浮动、定位可以让每个盒子排列成为网页。<br>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p><p><strong>1.  标准流</strong></p><ul><li>可以让盒子上下排列或者左右排列，<strong>垂直的块级盒子显示就用标准流布局</strong>。<br><strong>2.  浮动</strong></li><li>可以让多个块级元素一行显示或者左右对齐盒子，<strong>多个块级盒子水平显示就用浮动布局</strong>。<br><strong>3.  定位</strong></li><li>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。<strong>如果元素自由在某个盒子内移动就用定位布局</strong>。</li></ul><h2 id="6-元素的显示与隐藏"><a href="#6-元素的显示与隐藏" class="headerlink" title="6. 元素的显示与隐藏"></a>6. 元素的显示与隐藏</h2><p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！<br>本质：<strong>让一个元素在页面中隐藏或者显示出来</strong>。</p><h3 id="6-1-display-属性"><a href="#6-1-display-属性" class="headerlink" title="6.1 display 属性"></a>6.1 display 属性</h3><p><code>display</code> 属性用于设置一个元素应如何显示。</p><ul><li><code>display: none;</code> 隐藏对象</li><li><code>display: block;</code> 除了转换为块级元素之外，同时还有显示元素的意思。</li></ul><p>display 隐藏元素后，<strong>不再占有原来的位置</strong>。</p><p>后面应用及其广泛，搭配 JS 可以做很多的网页特效。</p><h3 id="6-2-visibility-可见性"><a href="#6-2-visibility-可见性" class="headerlink" title="6.2 visibility 可见性"></a>6.2 visibility 可见性</h3><p><code>visibility</code> 属性用于指定一个元素应可见还是隐藏。</p><ul><li><code>visibility: hidden;</code> 元素隐藏</li><li><code>visibility: visible;</code> 元素可视</li></ul><p>visibility 隐藏元素后，<strong>继续占有原来的位置</strong>。</p><p><em><strong>如果隐藏元素想要原来位置，就用 <code>visibility：hidden</code><br>如果隐藏元素不想要原来位置，就用 <code>display：none</code> （用处更多，重点）</strong></em></p><h3 id="6-3-overflow-溢出"><a href="#6-3-overflow-溢出" class="headerlink" title="6.3 overflow 溢出"></a>6.3 overflow 溢出</h3><p><code>overflow</code> 属性指定了如果<strong>内容溢出</strong>一个元素的框（超过其指定高度及宽度）时，会发生什么。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>不剪切内容也不添加滚动条</td></tr><tr><td>hidden</td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td>scroll</td><td>不管是否超出内容，总是显示滚动条</td></tr><tr><td>auto</td><td>超出则自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><p>一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。但是如果有定位的盒子，请慎用 <code>overflow: hidden</code> 因为它会隐藏多余的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS属性&amp;元素显示模式&amp;引用方式&amp;三大特性</title>
      <link href="/2022/11/20/CSS%E5%B1%9E%E6%80%A7-%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2022/11/20/CSS%E5%B1%9E%E6%80%A7-%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS-属性"><a href="#一、CSS-属性" class="headerlink" title="一、CSS 属性"></a>一、CSS 属性</h1><h2 id="1-CSS-字体属性"><a href="#1-CSS-字体属性" class="headerlink" title="1. CSS 字体属性"></a>1. CSS 字体属性</h2><p>CSS fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。</p><h3 id="1-1-字体系列"><a href="#1-1-字体系列" class="headerlink" title="1.1 字体系列"></a>1.1 字体系列</h3><p>CSS 使用 <code>font-family</code> 属性定义文本字体系列。 </p><pre class="line-numbers language-none"><code class="language-none">body {  font-family: "Microsoft YaHei", Arial, Helvetica, sans-serif;}</code></pre><p><strong>注意：</strong></p><ul><li>尽量使用默认字体，保证不同浏览器的兼容性。（谷歌浏览器默认字体为微软雅黑）</li><li>最常见的几个字体：<code>body {font-family: 'Microsoft YaHei',tahoma,arial,'Hiragino Sans GB'; }</code></li><li>支持同时定义多个字体，<strong>从左至右优先级</strong>，以防因电脑未装字体而无法正常显示。</li></ul><h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。</p><pre class="line-numbers language-none"><code class="language-none">body {  font-size: 16px;}</code></pre><ul><li>谷歌浏览器默认是 <code>16px</code></li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 <code>body</code> 指定整个页面文字大小</li></ul><h3 id="1-3-字体粗细"><a href="#1-3-字体粗细" class="headerlink" title="1.3 字体粗细"></a>1.3 字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置字体粗细</p><pre class="line-numbers language-none"><code class="language-none">p {  font-weight: 700;}</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值（不加粗）</td></tr><tr><td>bold</td><td>定义粗体（加粗）</td></tr><tr><td>100-900</td><td>400 等价于 normal，700 等价于 bold，无单位</td></tr></tbody></table><h3 id="1-4-文字样式"><a href="#1-4-文字样式" class="headerlink" title="1.4 文字样式"></a>1.4 文字样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本风格。</p><pre class="line-numbers language-none"><code class="language-none">p { font-style: italic; }</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常显示</td></tr><tr><td>italic</td><td>斜体</td></tr></tbody></table><p><strong>注意：</strong><br>平常很少给字体加斜体，而是给斜体标签（<code>em</code>,<code>i</code>）改为不倾斜字体。</p><h3 id="1-5-字体复合属性写法"><a href="#1-5-字体复合属性写法" class="headerlink" title="1.5 字体复合属性写法"></a>1.5 字体复合属性写法</h3><p>将各种字体属性写在同一选择器下，节约代码。</p><p>规则：严格遵守顺序，且 <code>font-size</code> 和 <code>font-family</code> 必须有。</p><pre class="line-numbers language-none"><code class="language-none">body {  font: font-style font-weight font-size/line-hight font-family;}</code></pre><h3 id="1-6-字体属性总结"><a href="#1-6-字体属性总结" class="headerlink" title="1.6 字体属性总结"></a>1.6 字体属性总结</h3><table><thead><tr><th>字体属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>font-family</td><td>字体</td><td>按照团队约定来写</td></tr><tr><td>font-size</td><td>字号</td><td>单位是<code>px</code></td></tr><tr><td>font-weight</td><td>字体粗细</td><td>400=normal,700=bold</td></tr><tr><td>font-style</td><td>字体样式</td><td>italic，normal，常用 normal</td></tr><tr><td>font</td><td>属性连写</td><td>顺序不能变，字体和字号属性必须有</td></tr></tbody></table><h2 id="2-CSS-文本属性"><a href="#2-CSS-文本属性" class="headerlink" title="2. CSS 文本属性"></a>2. CSS 文本属性</h2><p>CSS text(文本)属性定义文本<strong>外观</strong>，比如颜色、对齐、装饰、缩进、行间距等。</p><h3 id="2-1-文本颜色"><a href="#2-1-文本颜色" class="headerlink" title="2.1 文本颜色"></a>2.1 文本颜色</h3><p><code>color</code> 属性定义文本颜色。</p><pre class="line-numbers language-none"><code class="language-none">div {  color: red;}</code></pre><table><thead><tr><th>表示颜色</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色值</td><td>red,green,pink</td></tr><tr><td>十六进制（常用)</td><td><code>#FF0000</code>，<code>#FF6600</code></td></tr><tr><td>RGB 代码</td><td>rgb(255,0,0)</td></tr></tbody></table><h3 id="2-2-装饰文本"><a href="#2-2-装饰文本" class="headerlink" title="2.2 装饰文本"></a>2.2 装饰文本</h3><p><code>text-decoration</code> 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><pre class="line-numbers language-none"><code class="language-none">text-decoration: underline;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，无装饰（最常用）</td></tr><tr><td>underline</td><td>下划线，a 标签自带（常用）</td></tr><tr><td>overline</td><td>上划线。（几乎不用）</td></tr><tr><td>line-through</td><td>删除线。（不常用）</td></tr></tbody></table><h3 id="2-3-对齐文本"><a href="#2-3-对齐文本" class="headerlink" title="2.3 对齐文本"></a>2.3 对齐文本</h3><p><code>text-align</code> 属性用于设置元素文本内容的对齐方式。</p><pre class="line-numbers language-none"><code class="language-none">div {  text-align: center;}</code></pre><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="2-4-文本缩进"><a href="#2-4-文本缩进" class="headerlink" title="2.4 文本缩进"></a>2.4 文本缩进</h3><p><code>text-indent</code>定义段落首行缩进。</p><pre class="line-numbers language-none"><code class="language-none">p {  text-indet: 5px;}</code></pre><p><code>em</code> 是一个相对单位，<code>1em</code> 就是一个字符所占大小。当 <code>text-indent=2em</code>，则恰好缩进两个文字。</p><h3 id="2-5-行高"><a href="#2-5-行高" class="headerlink" title="2.5 行高"></a>2.5 行高</h3><p><code>line-height</code> 设置行间的距离，行间距=文本高度+上间距+下间距</p><pre class="line-numbers language-none"><code class="language-none">p { line-height: 26px; }</code></pre><p><img src="a67be00ff20c43c69f6db5ac463be879.png" alt="在这里插入图片描述"></p><h4 id="2-5-1-单行文字垂直居中的小技巧"><a href="#2-5-1-单行文字垂直居中的小技巧" class="headerlink" title="2.5.1 单行文字垂直居中的小技巧"></a>2.5.1 单行文字垂直居中的小技巧</h4><p>CSS 没有给我们提供文字垂直居中的代码. 这里我们可以使用一个小技巧来实现。</p><ul><li><p>解决方案：让<strong>文字的行高等于盒子的高度</strong>。</p></li><li><p>原理分析：行高=文字本身高度+上空隙+下空隙=盒子高度</p></li><li><p>当行高小于盒子高度，则文字偏上；当行高大于盒子高度，文字偏下。</p></li></ul><h3 id="2-6-文本属性总结"><a href="#2-6-文本属性总结" class="headerlink" title="2.6 文本属性总结"></a>2.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常十六进制缩写</td></tr><tr><td>text-decoration</td><td>文本装饰</td><td>添加下划线underline，取消下划线none</td></tr><tr><td>text-align</td><td>文本对齐</td><td>可以设定文字水平的对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>通常用于段落首行缩进2个字的距离，记住 <code>text-indent: 2em;</code></td></tr><tr><td>line-height</td><td>行高</td><td>控制行与行之间的距离</td></tr></tbody></table><h2 id="3-CSS背景属性"><a href="#3-CSS背景属性" class="headerlink" title="3. CSS背景属性"></a>3. CSS背景属性</h2><p>CSS 背景属性可以给元素添加背景样式。</p><p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p><h3 id="3-1-背景颜色"><a href="#3-1-背景颜色" class="headerlink" title="3.1 背景颜色"></a>3.1 背景颜色</h3><p><code>background-color</code> 定义了元素的背景颜色。</p><pre class="line-numbers language-none"><code class="language-none">background-color: 颜色值;</code></pre><p>一般而言，颜色默认值是 <code>transparent</code>（透明），我们也可以指定背景颜色为透明色或其他色。</p><h4 id="3-1-1-背景色半透明"><a href="#3-1-1-背景色半透明" class="headerlink" title="3.1.1 背景色半透明"></a>3.1.1 背景色半透明</h4><p>CSS3 提供 <code>background: rgba(r,g,b,a)</code> 属性设置图片透明度。</p><pre class="line-numbers language-none"><code class="language-none">background-color: rgba(0, 0, 0, .3);</code></pre><p><strong>注意：</strong></p><ul><li>背景半透明是指盒子背景半透明，盒子里面的内容不受影响。</li></ul><h3 id="3-2-背景图片"><a href="#3-2-背景图片" class="headerlink" title="3.2 背景图片"></a>3.2 背景图片</h3><p><code>background-image</code> 属性描述了元素的背景图像，实际开发用于 logo 或者一些装饰性开发的小图片或者是超大的背景图片，优点是<strong>便于控制位置</strong>。（也用于精灵图）</p><pre class="line-numbers language-none"><code class="language-none">background-image: none（默认无背景图）|  url(图片url) （使用绝对或相对地址指定图片）;</code></pre><h3 id="3-3-背景平铺"><a href="#3-3-背景平铺" class="headerlink" title="3.3 背景平铺"></a>3.3 背景平铺</h3><p>若需要在 HTML 页面上对背景图进行平铺，可以使用 <code>background-repeat</code> 属性。</p><pre class="line-numbers language-none"><code class="language-none">background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y;</code></pre><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>repeat</td><td>背景图像在纵向和横向上平铺（默认）</td></tr><tr><td>no-repeat</td><td>背景图像不平铺</td></tr><tr><td>repeat-x</td><td>背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td>背景图像在纵向上平铺</td></tr></tbody></table><h3 id="3-4-背景图像固定"><a href="#3-4-背景图像固定" class="headerlink" title="3.4 背景图像固定"></a>3.4 背景图像固定</h3><p><code>background-attachment</code> 属性设置背景图像是否随着页面其余部分滚动。</p><p><code>background-attachment</code> 后期可以制作视差滚动效果。</p><pre class="line-numbers language-none"><code class="language-none">background-attachment: scroll | fixed;</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>scroll</td><td>背景图像随着对象内容滚动</td></tr><tr><td>fixed</td><td>背景图像固定</td></tr></tbody></table><h3 id="3-5-背景图片位置"><a href="#3-5-背景图片位置" class="headerlink" title="3.5 背景图片位置"></a>3.5 背景图片位置</h3><p><code>background-position</code> 可以改变图片在背景中的位置。</p><pre class="line-numbers language-none"><code class="language-none">background-position: x y;</code></pre><p>参数代表的意思是：x 坐标和 y 坐标。 可以使用 <strong>方位名词</strong> 或者 <strong>精确单位</strong></p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>百分数 / 由浮点数字和单位字符组成的长度值</td></tr><tr><td>position</td><td>top / center / bottom / left / center / right 方位名词</td></tr></tbody></table><p><strong>1.参数是方位名词</strong></p><ul><li>若两个值都是方位名词，则两个值前后顺序无关，比如<code>left top</code>和<code>top left</code> 效果一致。</li><li>若只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐。</li></ul><p><strong>2.参数是精确单位</strong></p><ul><li>第一个必定是 x 坐标，第二个是 y 坐标</li><li>若只指定一个数值，那该值一定是x坐标，另一个默认垂直居中</li></ul><p><strong>3.参数是混合单位</strong></p><ul><li>若是混合单位，则第一个值是 x 坐标，第二个值是 y 坐标。</li></ul><h3 id="3-6-背景属性复合写法"><a href="#3-6-背景属性复合写法" class="headerlink" title="3.6 背景属性复合写法"></a>3.6 背景属性复合写法</h3><p>简化代码，将属性写在同一个属性 <code>background</code> 下。 </p><p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p><p><code>background：背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</code></p><pre class="line-numbers language-none"><code class="language-none">background: transparent url(image.jpg) repeat-y fixed top;</code></pre><h3 id="3-7-背景属性总结"><a href="#3-7-背景属性总结" class="headerlink" title="3.7 背景属性总结"></a>3.7 背景属性总结</h3><table><thead><tr><th>属性</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td>背景图片</td><td>url(图片路径)</td></tr><tr><td>background-repeat</td><td>背景平铺</td><td>repeat(默认)/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-attachment</td><td>背景固定</td><td>scroll/fixed</td></tr><tr><td>background-position</td><td>背景位置</td><td>x,y坐标</td></tr><tr><td>背景复合写法</td><td>简化书写</td><td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td></tr></tbody></table><h1 id="二、元素显示模式"><a href="#二、元素显示模式" class="headerlink" title="二、元素显示模式"></a>二、元素显示模式</h1><p>元素显示模式就是<strong>元素（标签）以什么方式进行显示</strong>，比如<code>&lt;div&gt;</code>自己占一行，比如一行可以放多个<code>span</code>。</p><h2 id="1-块元素"><a href="#1-块元素" class="headerlink" title="1. 块元素"></a>1. 块元素</h2><p>常见的块元素有 <code>h1-h6</code>、<code>p</code>、<code>div</code>、<code>ul</code>、<code>ol</code>、<code>li</code>等，典型块元素是 <code>div</code>。</p><p>块级元素的特点：</p><ol><li>独占一行。</li><li>高度、宽度、外边距以及内边距都可以控制。</li><li>宽度默认是容器（父级宽度）的 100%。</li><li>是一个容器及盒子，里面可以放行内或块级元素。</li></ol><p><strong>注意：</strong></p><ul><li>文字类的标签（主要用于存放文字）内不能放块级元素。</li><li>文字类标签有 <code>p</code>，<code>h1-h6</code>，里面不能放块级元素，特别不能放 <code>div</code> 元素。</li></ul><h2 id="2-行内元素"><a href="#2-行内元素" class="headerlink" title="2. 行内元素"></a>2. 行内元素</h2><p>常见行内元素：<code>a</code>、<code>strong</code>、<code>b</code>、<code>em</code>、<code>i</code>、<code>del</code>、<code>s</code>、<code>ins</code>、<code>u</code>、<code>span</code>，典型行内元素是 <code>span</code>，行内元素也叫内联元素。</p><p>行内元素的特点：</p><ol><li>相邻行内元素在一行上，<strong>之间存在空白缝隙</strong>，一行可以显示多个。</li><li><strong>高、宽直接设置是无效的</strong>。</li><li><strong>默认宽度就是它本身内容宽度</strong>。</li><li>行内元素只能容纳文本或其他行内元素。</li></ol><p><strong>注意</strong></p><ul><li><code>a</code> 链接里面不能放链接</li><li>特殊情况链接 <code>a</code> 里面可以放块级元素，但是给 <code>a</code> 转换一下块级模式最安全。</li></ul><h2 id="3-行内块元素"><a href="#3-行内块元素" class="headerlink" title="3. 行内块元素"></a>3. 行内块元素</h2><p>在行内元素中有几个特殊标签——<code>img</code>, <code>input</code>、<code>td</code>，它们同时具有块元素和行内元素的特点。有些资料称为行内块元素。</p><p><strong>特点：</strong></p><ol><li>和相邻行内元素（行内块）在一行上，之间存在空白缝隙，一行可以显示多个（<strong>行内元素特点</strong>）。</li><li>默认宽度是本身内容宽度（<strong>行内元素特点</strong>）。</li><li>高度、行高、外边距、内边距都可以控制（<strong>块级元素特点</strong>）。</li></ol><h2 id="4-元素显示模式转换"><a href="#4-元素显示模式转换" class="headerlink" title="4. 元素显示模式转换"></a>4. 元素显示模式转换</h2><p>特殊情况下，需要将一个元素的模式转换为另外一种模式，使其具有另外一种模式的特性。<br>比如想要增加链接 <code>a</code> 的触发范围。</p><ul><li>行内-&gt;块级</li></ul><pre class="line-numbers language-none"><code class="language-none">a {  display: block;}</code></pre><ul><li>块级-&gt;行内</li></ul><pre class="line-numbers language-none"><code class="language-none">div {  display: inline;}</code></pre><ul><li>行内/块级-&gt; 行内块元素</li></ul><pre class="line-numbers language-none"><code class="language-none">span {  display: inline-block;}</code></pre><h2 id="5-元素显示模式总结"><a href="#5-元素显示模式总结" class="headerlink" title="5. 元素显示模式总结"></a>5. 元素显示模式总结</h2><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置高度宽度</td><td>容器的 100%</td><td>可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以设置宽度高度</td><td>本身内容宽度</td><td>容纳文本或者其他行内元素</td></tr><tr><td>行内块元素</td><td>一行可以放置多个行内块元素</td><td>可以设置高度宽度</td><td>本身内容宽度</td><td></td></tr></tbody></table><h1 id="三、CSS-引用方式"><a href="#三、CSS-引用方式" class="headerlink" title="三、CSS 引用方式"></a>三、CSS 引用方式</h1><p>按照 CSS 书写的位置不同，CSS 样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h2 id="1-行内样式表"><a href="#1-行内样式表" class="headerlink" title="1. 行内样式表"></a>1. 行内样式表</h2><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式，适合修改简单样式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style="color: red; font-size: 12px"&gt;行内样式表&lt;/div&gt;</code></pre><h2 id="2-内部样式表"><a href="#2-内部样式表" class="headerlink" title="2. 内部样式表"></a>2. 内部样式表</h2><p>将 CSS 代码写在 HTML 页面内部，单独放在一个 <code>&lt;style&gt;</code> 标签中。</p><ul><li><code>&lt;style&gt;</code> 理论上可以放在 HTML 文档中任何一个地方，一般放在 <code>&lt;head&gt;</code> 标签中。</li><li>方便控制整个页面中的元素样式。</li></ul><p>练习时使用，实际开发不用。</p><h2 id="3-外部样式表"><a href="#3-外部样式表" class="headerlink" title="3. 外部样式表"></a>3. 外部样式表</h2><p>实际开发中都是外部样式表，适用于样式比较多的情况。<br>核心：样式单独写到 CSS 文件中，再将 CSS 文件引入到 HTML 页面中。</p><p><strong>引入外部样式表分为两步：</strong></p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 </li><li>在 HTML 页面中，使用 标签引入这个文件。<pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="css文件路径" /&gt;</code></pre></li></ol><ul><li>rel：定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个<strong>样式表文件</strong>。</li><li>href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</li></ul><h1 id="四、CSS三大特性"><a href="#四、CSS三大特性" class="headerlink" title="四、CSS三大特性"></a>四、CSS三大特性</h1><h2 id="1-层叠性"><a href="#1-层叠性" class="headerlink" title="1. 层叠性"></a>1. 层叠性</h2><p><strong>相同选择器设置相同的样式</strong>，此时一个样式就会覆盖另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p><em><strong>层叠性原则：</strong></em></p><ul><li>样式冲突：遵循的原则是<strong>就近原则</strong>，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><h2 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h2><p>CSS 中子标签会继承父标签的某些样式，如文本颜色和字号。</p><ul><li>恰当使用继承可以简化代码，降低 CSS 的复杂性</li><li>子元素可以继承父元素的样式（<strong>text-, font-, line-这些元素开头的可以继承，以及 color 属性</strong>）</li><li>不继承width、height、内外边距</li></ul><h3 id="2-1-行高的继承性"><a href="#2-1-行高的继承性" class="headerlink" title="2.1 行高的继承性"></a>2.1 行高的继承性</h3><pre class="line-numbers language-none"><code class="language-none">body {  font: 12px/1.5 Microsoft Yahei;}</code></pre><ul><li>行高可以跟单位也可以不跟</li><li>如果子元素没有设置行高，则会继承父元素的行高为 1.5</li><li>此时子元素的行高是：当前<strong>子元素的文字大小<code>*1.5</code></strong></li><li>body 行高 1.5 这样写法最大优势就是里面的子元素<strong>可以根据文字大小自动调整行高</strong></li></ul><h2 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3. 优先级"></a>3. 优先级</h2><p>当一个元素指定多个选择器时，就会有有优先级的产生。</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，则根据选择器权重执行</li></ul><p><strong>选择器权重：</strong></p><p>important&gt;style=””&gt;id&gt;伪类&gt;class&gt;元素&gt;<code>*</code>&gt;浏览器&gt;继承</p><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承或者<code>*</code></td><td><code>0,0,0,0</code></td></tr><tr><td>元素选择器</td><td><code>0,0,0,1</code></td></tr><tr><td>类选择器，伪类选择器</td><td><code>0,0,1,0</code></td></tr><tr><td>id 选择器</td><td><code>0,1,0,0</code></td></tr><tr><td>行内样式 <code>style=""</code></td><td><code>1,0,0,0</code></td></tr><tr><td><code>!important</code></td><td>∞ 无穷大</td></tr><tr><td><code>!important</code>写法：</td><td></td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">p {  color: pink !important;}</code></pre><ul><li>权重是有4组数字组成，但是不会有进位。可以理解为类选择器永远大于元素选择器，以此类推..</li><li><strong>继承的权重为 0</strong>，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。</li><li><code>a</code> 链接，浏览器默认指定了一个样式（蓝色，下划线），不会继承父级样式。</li></ul><p><strong>复合选择器权重的叠加</strong></p><p>权重可以叠加，需要计算权重，但是没有进位。</p><ul><li>div ul li ——&gt; 0,0,0,3 </li><li>.nav ul li ——&gt; 0,0,1,2 </li><li>a:hover —–—&gt; 0,0,1,1 </li><li>.nav a ——&gt; 0,0,1,1</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS简介与选择器</title>
      <link href="/2022/11/20/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/11/20/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS-简介"><a href="#一、CSS-简介" class="headerlink" title="一、CSS 简介"></a>一、CSS 简介</h1><h2 id="1-CSS-和-HTML"><a href="#1-CSS-和-HTML" class="headerlink" title="1. CSS 和 HTML"></a>1. CSS 和 HTML</h2><pre class="line-numbers language-none"><code class="language-none">HTML 是网友的骨架，只关注内容的语义。例如`&lt;h1&gt;`表示大标题，`&lt;p&gt;`表示段落。早期的时候，HTML 只能做一些简单的样式，网页非常丑，而且使 HTML 代码臃肿。</code></pre><pre class="line-numbers language-none"><code class="language-none">CSS 是 层叠样式表（Cascading Style Sheets）的简称。它也是一种标记语言。CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</code></pre><p><em><strong>CSS 最大价值:</strong></em> 由 HTML 专注去做结构呈现，样式交给 CSS，即<strong>结构 ( HTML ) 与样式( CSS )</strong> 相分离。</p><h2 id="2-CSS-语法规范"><a href="#2-CSS-语法规范" class="headerlink" title="2. CSS 语法规范"></a>2. CSS 语法规范</h2><p><strong>CSS 规则由两个部分组成：选择器和一条或多条声明。</strong></p><p><img src="bde5b4c3556b40e59a58f8d4222e9530.png"></p><ul><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式 </li><li>属性和属性值以<code>键值对</code>的形式出现 </li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等 </li><li>属性和属性值之间用英文<code>:</code>分开 </li><li>多个“键值对”之间用英文<code>;</code>进行区分</li></ul><p>所有的样式，都包含在<code>&lt;style&gt;</code>标签内，表示是样式表。</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;p {color: red;font-size: 12px;}&lt;/style&gt;</code></pre><h2 id="3-CSS-代码风格"><a href="#3-CSS-代码风格" class="headerlink" title="3. CSS 代码风格"></a>3. CSS 代码风格</h2><p>以下代码书写风格不是强制规范,而是符合实际开发书写方式。</p><ul><li>展开格式（分行）<pre class="line-numbers language-none"><code class="language-none">h3 { color: pink;font-size: 20px; }</code></pre></li><li>空格规范（选择器和大括号中间保留空格；冒号后面保留一个空格）<pre class="line-numbers language-none"><code class="language-none">h3 {color: pink; }</code></pre></li><li>样式选择器，属性名，属性关键字全部<strong>小写</strong></li></ul><h2 id="5-emmet-语法"><a href="#5-emmet-语法" class="headerlink" title="5. emmet 语法"></a>5. emmet 语法</h2><h3 id="5-1-快速生成-HTML-结构语法"><a href="#5-1-快速生成-HTML-结构语法" class="headerlink" title="5.1 快速生成 HTML 结构语法"></a>5.1 快速生成 HTML 结构语法</h3><ol><li>生成标签：直接输入标签名，按tab键即可。如：div 然后tab 键， 就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></li><li>生成多个相同标签：加上 <code>*</code> 。如：<code>div*3</code> 可以快速生成3个<code>&lt;div&gt;&lt;/div&gt;</code></li><li>生成父子级关系的标签：用 <code>&gt;</code> 。如： <code>ul&gt;li</code></li><li>生成兄弟关系的标签：用 <code>+</code> 。 如： <code>div+p</code> </li><li>生成带有类名或者id名字的标签： 直接写 <code>.demo</code> 或者 <code>#two</code>，再按 tab 键</li><li>生成的标签名称/内容按1、2…顺序：用 自增符号 <code>$</code></li><li>在生成的标签内部写内容：用 <code>{}</code> 表示</li></ol><h3 id="5-2-快速生成-CSS-样式语法"><a href="#5-2-快速生成-CSS-样式语法" class="headerlink" title="5.2 快速生成 CSS 样式语法"></a>5.2 快速生成 CSS 样式语法</h3><p>CSS 基本采取简写形式即可。</p><ol><li>比如 w200 按 tab 可以生成 width: 200px。</li><li>比如 lh26px 按 tab 可以生成 line-height: 26px。</li></ol><h1 id="二、CSS-基础选择器"><a href="#二、CSS-基础选择器" class="headerlink" title="二、CSS 基础选择器"></a>二、CSS 基础选择器</h1><p>选择器就是根据不同需求把不同标签选择出来。简单来说，就是<em><strong>用于选择标签</strong></em>的。</p><p>选择器分为<strong>基础选择器</strong>和<strong>复合选择器</strong>两大类。</p><ul><li>基础选择器由单个选择器组成</li><li>基础选择器包括：标签选择器、类选择器、id 选择器和通配符选择器</li></ul><h2 id="1-标签选择器"><a href="#1-标签选择器" class="headerlink" title="1. 标签选择器"></a>1. 标签选择器</h2><p>直接用 <strong>HTML 标签名</strong>作为选择器，按标签名称分类，<strong>为页面某一类标签指定统一的 CSS 样式。</strong></p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">标签名 {    属性1： 属性值1;    属性2： 属性值2;    属性3： 属性值3;}</code></pre><p>优点：标签选择器可以<strong>把某一标签全部选择出来</strong>，快速为同类型标签设置统一样式。</p><p>缺点：<strong>不能设置差异化样式</strong>，只能选择全部当前标签。</p><h2 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2. 类选择器"></a>2. 类选择器</h2><p>差异化选择不同标签，<strong>单独选一个或者某几个</strong>标签。</p><p><strong>语法</strong></p><p>类选择器在 HTML 中以 <code>class</code> 属性表示，在 CSS 中，类选择器以一个 <code>.</code> 号显示。</p><pre class="line-numbers language-none"><code class="language-none">.类名 { 属性1: 属性值1; ... }</code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;div class="类名"&gt; &lt;/div&gt;</code></pre><p><em>记忆口诀：</em><br>样式<code>点</code>定义，结构<code>类</code>调用。一个或多个，开发最常用。</p><p><strong>注意</strong></p><ol><li>类选择器用 <code>.</code> 标识，后面紧跟类名。</li><li>类名小写，长名称或词组使用 <code>-</code> 连接单词。不要用纯数字、中文。</li><li>命名要有意义。</li></ol><h3 id="2-1-多类名"><a href="#2-1-多类名" class="headerlink" title="2.1 多类名"></a>2.1 多类名</h3><p>简单来说，就是一个标签有多个名字。</p><p><strong>使用场景：</strong></p><ul><li>一些标签元素具有相同的样式(共同的部分)，多类名可以把他们放到一个类里面。</li><li>这些标签都可以调用这个公共的类,然后再调用自己独有的类。</li><li>从而节省CSS代码,统一修改也非常方便。<pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;.box {width: 150px;height: 100px;}.red {background-color: red;}.green {background-color: green;}&lt;/style&gt;&lt;body&gt;&lt;div class="box red"&gt;红色&lt;/div&gt;&lt;div class="box green"&gt;绿色&lt;/div&gt;&lt;/body&gt;</code></pre></li></ul><p><strong>语法</strong></p><p>在标签class中书写多个类名，类名间用空格分开</p><pre class="line-numbers language-none"><code class="language-none">&lt;p class="class-name1 class-name2"&gt;&lt;/p&gt;</code></pre><h2 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3. id选择器"></a>3. id选择器</h2><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p><strong>语法</strong></p><p>HTML 元素以 <code>id</code> 属性来设置 id 选择器，用 <code>#</code> 来定义。</p><pre class="line-numbers language-none"><code class="language-none">#id名 {    属性1: 属性值1;    ...}&lt;div id="id名"&gt; &lt;/div&gt;</code></pre><p><em>记忆口诀：</em><br>样式 <code>#</code> 定义，结构 <code>id</code> 调用，别人切勿使用。</p><p><em><strong>id 选择器与类选择器的区别</strong></em></p><ol><li>class 类选择器好比<strong>名字</strong>，一个人可以有多个名字，同时一个名字也可以被多个人使用。（一对多，多对一）</li><li>id 选择器好比<strong>身份证号码</strong>，每个人对应唯一的一个号码，不得重复。（一一配对）</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h2 id="4-通配符选择器"><a href="#4-通配符选择器" class="headerlink" title="4. 通配符选择器"></a>4. 通配符选择器</h2><p>在 CSS 中，通配符选择器使用 <code>*</code> 定义，它表示选取页面中所有元素（标签）。</p><pre class="line-numbers language-none"><code class="language-none">* {    属性1: 属性值1;    ...}</code></pre><p><strong>特殊情况（常见）使用：</strong></p><pre class="line-numbers language-none"><code class="language-none">* {    margin: 0;    padding: 0;}</code></pre><h2 id="5-基础选择器总结"><a href="#5-基础选择器总结" class="headerlink" title="5. 基础选择器总结"></a>5. 基础选择器总结</h2><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>选中所有相同标签</td><td>不能差异化选择</td><td>较多</td><td><code>p{color:red;}</code></td></tr><tr><td>类选择器</td><td>选出一个或多个标签</td><td>可以根据需求选择</td><td>最多</td><td><code>.nav {color: red;}</code></td></tr><tr><td>id选择器</td><td>一次只能选中一个标签</td><td>一一配对</td><td>一般配合js使用</td><td><code>#nav {color: red;}</code></td></tr><tr><td>通配符选择器</td><td>选择所有标签元素</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td><code>* {color: red; }</code></td></tr></tbody></table><h1 id="三、CSS-复合选择器"><a href="#三、CSS-复合选择器" class="headerlink" title="三、CSS 复合选择器"></a>三、CSS 复合选择器</h1><p>复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。</p><p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等</p><h2 id="1-后代选择器（重要）"><a href="#1-后代选择器（重要）" class="headerlink" title="1. 后代选择器（重要）"></a>1. 后代选择器（重要）</h2><p>后代选择器又称为包含选择器，可以<strong>选择父元素里的子元素</strong>。写法是将外层标签写在前面，内层标签写在后面，中间空格分开。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1 元素2 { 样式声明; }</code></pre><ul><li>上述语法表示选择元素1里面的所有元素2（后代元素）。</li><li>元素2可以是儿子，也可以是孙子等，只要是<strong>元素1的后代</strong>即可。</li><li>元素1 是父级，元素2 是子级，<strong>最终选择的是元素2</strong></li></ul><h2 id="2-子选择器（重要）"><a href="#2-子选择器（重要）" class="headerlink" title="2. 子选择器（重要）"></a>2. 子选择器（重要）</h2><p>子元素选择器（子选择器）只能选择作为元素作为元素的最近一级子元素。简单理解就是<strong>选亲儿子</strong>。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1 &gt; 元素2 { 样式声明; }</code></pre><ul><li>上述语法表示选择元素1里面的所有直接后代（子元素）元素2。</li><li>元素2必须是<strong>亲儿子</strong>，其孙子、重孙之类都不归他管。</li><li>元素1是父级，元素2是子级，<strong>最终选择的是元素2</strong></li></ul><h2 id="3-并集选择器（重要）"><a href="#3-并集选择器（重要）" class="headerlink" title="3. 并集选择器（重要）"></a>3. 并集选择器（重要）</h2><p>并集选择器可以<strong>选择多组标签</strong>，同时为他们<strong>定义相同的样式</strong>。通常用于集体声明。</p><p>并集选择器是各选择器通过英文逗号 <code>,</code> 连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1, 元素2 { 样式声明; }</code></pre><h2 id="4-伪类选择器（重要）"><a href="#4-伪类选择器（重要）" class="headerlink" title="4. 伪类选择器（重要）"></a>4. 伪类选择器（重要）</h2><p>伪类选择器用于向某些选择器添加特殊的效果。<br>伪类选择器书写最大特点是用冒号 <code>:</code> 表示。<br>伪类选择器种类多，比如链接伪类选择器、结构选择器等。</p><h3 id="4-1-链接伪类选择器"><a href="#4-1-链接伪类选择器" class="headerlink" title="4.1 链接伪类选择器"></a>4.1 链接伪类选择器</h3><pre class="line-numbers language-none"><code class="language-none">a:link /*选择所有未被访问的链接*/a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/a:active /*选择活动链接（鼠标按下未弹起的链接）*/</code></pre><p><strong>注意事项</strong></p><ol><li>确保样式生效，要按照 <strong>LVHA</strong> 的顺序声明：link,visited,hover, active。</li><li>a 链接在浏览器中有默认样式，所以实际开发都需要给链接单独指定样式。</li></ol><h3 id="4-2-focus-伪类选择器"><a href="#4-2-focus-伪类选择器" class="headerlink" title="4.2 focus 伪类选择器"></a>4.2 focus 伪类选择器</h3><p><code>:focus</code> 伪类选择器用于获取焦点的表单元素。<br>焦点就是光标，一般情况 <code>&lt;input&gt;</code> 类表单元素才能获取，因此这个选择器也主要针对表单元素来说。</p><pre class="line-numbers language-none"><code class="language-none">input:focus {  background-color: yellow;}</code></pre><h3 id="4-3-其他标准伪类选择器"><a href="#4-3-其他标准伪类选择器" class="headerlink" title="4.3 其他标准伪类选择器"></a>4.3 其他标准伪类选择器</h3><p>1.<code>first-child</code>、<code>last-child</code>、<code>nth-child(n)</code></p><ul><li><code>:first-child</code>表示父元素的第一个子元素。</li><li><code>:last-child</code>表示父元素的最后一个子元素。</li><li><code>:nth-child(an+b)</code> 首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从 1 开始排序，选择的结果为 CSS 伪类 <code>:nth-child</code>括号中表达式 <code>(an+b)</code> 匹配到的元素集合 <code>(n=0，1，2，3...)</code></li></ul><ol start="2"><li><p><code>:not(p)</code><br><code>:not()</code> 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negation pseudo-class）。</p></li><li><p><code>::after (:after)</code><br><code>::after</code> 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合 <code>content</code> 属性（必有该字段）来为该元素添加装饰内容。这个虚拟元素默认是行内元素。</p></li></ol><pre class="line-numbers language-none"><code class="language-none">.sad::after {·content: "";  background-color: green;}</code></pre><ol start="4"><li><code>::before (:before)</code><br><code>::before</code> 用来创建一个伪元素，作为已选中元素的第一个子元素。通常会配合 <code>content</code> 属性（必有该字段）来为该元素添加装饰内容。这个虚拟元素默认是行内元素。 使用 <code>::before</code> 伪元素的一个简单示例就是用于加入引号。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;q&gt;一些引用&lt;/q&gt;, 他说, &lt;q&gt;比没有好。&lt;/q&gt;.q::before {content: "«";color: blue;}q::after {content: "»";color: red;}</code></pre><h2 id="5-复合选择器总结"><a href="#5-复合选择器总结" class="headerlink" title="5. 复合选择器总结"></a>5. 复合选择器总结</h2><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择后代元素</td><td>可以是子孙后代</td><td>较多</td><td>符号是空格 <code>.nav a</code></td></tr><tr><td>子选择器</td><td>选择最近一级元素</td><td>只能选亲儿子</td><td>较少</td><td>符号是大于 <code>.nav&gt;p</code></td></tr><tr><td>并集选择器</td><td>选择某些相同样式的元素</td><td>可以用于集体声明</td><td>较多</td><td>符号是逗号，<code>.nav, a</code></td></tr><tr><td>链接伪类选择器</td><td>选择不同状态的链接</td><td>跟链接相关</td><td>较多</td><td>重点记住<code>a{}</code>和<code>a:hover{}</code></td></tr><tr><td>focus选择器</td><td>选择获得光标的表单</td><td>跟表单相关</td><td>较少</td><td>记住<code>input:focus</code>用法</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/2022/11/16/HTML%E6%A0%87%E7%AD%BE/"/>
      <url>/2022/11/16/HTML%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-HTML预备知识"><a href="#一、-HTML预备知识" class="headerlink" title="一、 HTML预备知识"></a>一、 HTML预备知识</h1><h2 id="1-基本语法规范"><a href="#1-基本语法规范" class="headerlink" title="1.  基本语法规范"></a>1.  基本语法规范</h2><ol><li>HTML 标签是由尖括号包围的关键词，例如<code>&lt;html&gt;</code>。 </li><li>双标签：HTML 标签通常是成对出现的，例如<code>&lt;html&gt;</code>和<code>&lt;html/&gt;</code>，称为双标签。第一个是开始标签，第二个是结束标签。</li><li>单标签：有些特殊标签必须是单个标签（极少情况），例如<code>&lt;br/&gt;</code>，我们称之为单标签。</li><li>标签关系：包含关系和并列关系。</li></ol><h2 id="2-基本结构标签"><a href="#2-基本结构标签" class="headerlink" title="2. 基本结构标签"></a>2. 基本结构标签</h2><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p><table><thead><tr><th align="center">标签名</th><th align="center">定义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">html /html</td><td align="center">HTML标签</td><td align="center">页面中最大的标签，称为根标签</td></tr><tr><td align="center">head /head</td><td align="center">文档的头部</td><td align="center">注意在head标签中必须要设置的是title</td></tr><tr><td align="center">title /title</td><td align="center">文档的标题</td><td align="center">让页面拥有一个属于自己的网页标题</td></tr><tr><td align="center">body /body</td><td align="center">文档的主体</td><td align="center">元素包含文档的所有内容，页面内容基本放于此</td></tr></tbody></table><p><img src="Pasted%20image%2020221206150125.png"></p><h2 id="3-VSCode-工具生成骨架标签新增代码"><a href="#3-VSCode-工具生成骨架标签新增代码" class="headerlink" title="3. VSCode 工具生成骨架标签新增代码"></a>3. VSCode 工具生成骨架标签新增代码</h2><h3 id="3-1-文档类型声明标签"><a href="#3-1-文档类型声明标签" class="headerlink" title="3.1 文档类型声明标签"></a>3.1 文档类型声明标签</h3><p><code>!&lt;DOCTYPE&gt;</code>&nbsp;文档类型声明，告诉浏览器使用何种 HTML 版本来显示网页。</p><pre><code>&lt;!DOCTYPE html&gt;</code></pre><p>此代码表明：当前页面采用的是 HTML5 版本来显示网页。</p><p><strong>注意：</strong></p><ol><li><code>&lt;!DOCTYPE&gt;</code>&nbsp;声明位于文档最前面的位置，处于<code>&lt;html&gt;</code>标签之前。</li><li><code>&lt;!DOCTYPE&gt;</code>&nbsp;不是一个 HTML 标签，他就是文档类型声明标签。</li></ol><h3 id="3-2-lang-语言种类"><a href="#3-2-lang-语言种类" class="headerlink" title="3.2 lang 语言种类"></a>3.2 lang 语言种类</h3><p>用来显示当前文档显示的语言。</p><pre><code>&lt;html lang="zh-CN"&gt;    &lt;html lang="en"&gt;&lt;/html&gt; &lt;/html&gt;</code></pre><ol><li><code>en</code>&nbsp;定义语言为英文。</li><li><code>zh-CN</code>&nbsp;定义语言为中文。</li></ol><h3 id="3-3-charset-字符集"><a href="#3-3-charset-字符集" class="headerlink" title="3.3 charset 字符集"></a>3.3 charset 字符集</h3><pre><code>&lt;meta charset="UTF-8" /&gt;</code></pre><p>字符集（character set）是多个字符的集合，以便计算机能够识别和存储各种文字。</p><p>在<code>&lt;head&gt;</code>标签内，可以通过<code>&lt;meta&gt;</code>标签的<code>charset</code>&nbsp;属性来设置文档使用何种字符编码。</p><p><code>charset</code>常用的值有：GBK、UTF-8，其中UTF-8被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><hr><h1 id="二、HTML基础标签"><a href="#二、HTML基础标签" class="headerlink" title="二、HTML基础标签"></a>二、HTML基础标签</h1><h2 id="1-标题标签"><a href="#1-标题标签" class="headerlink" title="1. 标题标签"></a>1. 标题标签</h2><p>为了使网页具有语义化，经常使用标题标签，HTML 提供 6 个等级的网页标题标签即&nbsp;<code>&lt;h1&gt;-&lt;h6&gt;</code>。</p><p><strong>特点：</strong></p><ol><li>加了标题的文字会<strong>加粗</strong>，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;h1&gt;标题标签&lt;/h1&gt;&lt;h1&gt;标题一共六级选,&lt;/h1&gt;&lt;h2&gt;文字加粗一行显。&lt;/h2&gt;&lt;h3&gt;由大到小依次减，&lt;/h3&gt;&lt;h4&gt;从重到轻随之变。&lt;/h4&gt;&lt;h5&gt;语法规范书写后，&lt;/h5&gt;&lt;h6&gt;具体效果刷新见。&lt;/h6&gt;</code></pre><h2 id="2-段落和换行标签"><a href="#2-段落和换行标签" class="headerlink" title="2. 段落和换行标签"></a>2. 段落和换行标签</h2><ul><li>在 html 中，<code>&lt;p&gt;</code>&nbsp;标签用于定义段落，将整个网页分成若干个段落。</li></ul><blockquote><p><code>p</code>&nbsp;指<strong>paragraph</strong>，意为段落。把文字有条理的显示出来就需要将文字分段显示。</p></blockquote><p>**特点：</p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。 </li><li>段落和段落之间保有空隙。</li></ol><ul><li>在 html 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望 某段文本强制换行显示，就需要使用换行标签 <code>&lt;br/&gt;</code>。</li></ul><blockquote><p><code>&lt;br/&gt;</code>&nbsp;是 break 缩写，意为打断、换行。</p></blockquote><p><strong>特点：</strong></p><ol><li><code>&lt;br/&gt;</code>&nbsp;是个单标签。</li><li><code>&lt;br/&gt;</code>&nbsp;标签只是简单地开始新的一行，跟段落不一样，<em><strong>段落之间会插入一些垂直的间距</strong></em>。</li></ol><p><img src="Pasted%20image%2020221206154311.png"></p><h2 id="3-文本格式化标签"><a href="#3-文本格式化标签" class="headerlink" title="3. 文本格式化标签"></a>3. 文本格式化标签</h2><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code></td><td>更推荐<code>&lt;strong&gt;</code>，语义更强烈</td></tr><tr><td>斜体</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code></td><td>更推荐使用<code>&lt;em&gt;</code>，语义更强烈</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;s/&gt;</code></td><td>更推荐使用<code>&lt;del&gt;</code>，语义更强烈</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code></td><td>更推荐使用<code>&lt;ins&gt;</code>，语义更强烈</td></tr></tbody></table><h2 id="4-注释和特殊字符号"><a href="#4-注释和特殊字符号" class="headerlink" title="4.注释和特殊字符号"></a>4.注释和特殊字符号</h2><ol><li><p>注释:&nbsp;<code>&lt;!--注释--&gt;</code>&nbsp;VSCode 中快捷键：Ctrk + /</p></li><li><p>字符实体</p></li></ol><table><thead><tr><th>字符</th><th>显示</th></tr></thead><tbody><tr><td><code>&amp;nbsp;</code></td><td>空格</td></tr><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr><tr><td><code>&amp;copy;</code></td><td>©</td></tr><tr><td>补充：（使用较少，按需查阅）</td><td></td></tr></tbody></table><p><img src="Pasted%20image%2020221206161316.png"></p><h2 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5. 超链接标签"></a>5. 超链接标签</h2><h3 id="5-1-链接的语法格式"><a href="#5-1-链接的语法格式" class="headerlink" title="5.1 链接的语法格式"></a>5.1 链接的语法格式</h3><p>a 是单词 anchor 的简写，是锚的意思。</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt;</code></pre><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>指定链接地址 url，为必须属性。</td></tr><tr><td><code>target</code></td><td>指定页面打开方式，<code>_self</code>为默认值，<code>_blank</code>为在新窗口中打开</td></tr></tbody></table><h3 id="5-2-链接分类"><a href="#5-2-链接分类" class="headerlink" title="5.2 链接分类"></a>5.2 链接分类</h3><ol><li>外部链接：例如 <code>&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;</code>。 </li><li>内部链接：网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href="index.html"&gt;首页&lt;/a&gt;</code>。 </li><li>空链接：<code>#</code></li><li>下载链接：地址链接的是文件.exe、压缩包.zip 等。<code>&lt;a href="img.zip"&gt;下载文件&lt;/a&gt;</code></li><li>网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接。<code>&lt;a href="http://www.baidu.com"&gt;&lt;img src="img.jpg"/&gt;&lt;/a&gt;</code></li><li>**锚点链接：点击链接，可以快速定位到页面中的某个位置。<ul><li>在链接文本的 href 属性中，设置属性值为<code> #名字</code> 的形式，如：<code>&lt;a href="#two"&gt;第二季&lt;/a&gt;</code>。</li><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id="two"&gt;第二季介绍&lt;/h3&gt;</code></li></ul></li></ol><h2 id="6-图像标签和路径"><a href="#6-图像标签和路径" class="headerlink" title="6. 图像标签和路径"></a>6. 图像标签和路径</h2><h3 id="6-1-图像标签"><a href="#6-1-图像标签" class="headerlink" title="6.1 图像标签"></a>6.1 图像标签</h3><p>在 HTML 标签中，<code>&lt;img /&gt;</code>&nbsp;标签用于定义 HTML 标签页面中的图像。</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src="图像url" /&gt;</code></pre><p><strong>标签内属性</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，当图片不显示时显示文字</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本。鼠标放到图像上显示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>图像宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>图像高度</td></tr><tr><td><code>border</code></td><td>像素</td><td>图像边框粗细</td></tr><tr><td>图像标签属性注意点：</td><td></td><td></td></tr></tbody></table><ol><li>图像标签可以拥有多个属性，必须写在标签名称的后面。 </li><li>属性之间不分先后顺序，标签名称与属性、属性与属性之间均以<strong>空格</strong>分开。 </li><li>属性采取键值对的格式，即 key=“value” 的格式，属性 =“属性值”。</li></ol><h3 id="6-2-路径"><a href="#6-2-路径" class="headerlink" title="6.2 路径"></a>6.2 路径</h3><ul><li><strong>相对路径：</strong>&nbsp;以引用文件位置为参考基础，而建立出来的目录路径。是<em><strong>图片相对于 HTML 页面的位置</strong></em>。</li></ul><table><thead><tr><th>分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同级路径</td><td></td><td>同一级</td></tr><tr><td>下一级路径</td><td><code>/</code></td><td>图像文件位于HTML文件下一级</td></tr><tr><td>上一级路径</td><td><code>../</code></td><td>图像文件位于HTML文件上一级</td></tr></tbody></table><ul><li><strong>绝对路径：</strong>&nbsp;是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径或者完整的网络地址。</li></ul><blockquote><p>例如，<code>D:\web\img\logo.gif</code>或完整的网络地址“<a href="http://www.itcast.cn/images/logo.gif%E2%80%9D%E3%80%82">http://www.itcast.cn/images/logo.gif”。</a></p></blockquote><h2 id="7-div-和-span-标签"><a href="#7-div-和-span-标签" class="headerlink" title="7. div 和 span 标签"></a>7. div 和 span 标签</h2><p><code>&lt;div&gt;</code>&nbsp;和&nbsp;<code>&lt;span&gt;</code>&nbsp;是没有语义的，它们是一个盒子，用来装内容的。</p><blockquote><p>div 是 division 的缩写，表示分割、分区。span 意思是跨度、跨距。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;这是头部&lt;/div&gt;&lt;span&gt;今日价格&lt;/span&gt;</code></pre><p>特点：</p><ol><li><p>div 标签用来布局，一行只能放一个 div大盒子。</p></li><li><p>span 标签用来布局，一行可以多个 span小盒子。</p></li></ol><h1 id="三、HTML高阶标签"><a href="#三、HTML高阶标签" class="headerlink" title="三、HTML高阶标签"></a>三、HTML高阶标签</h1><h2 id="1-表格标签"><a href="#1-表格标签" class="headerlink" title="1. 表格标签"></a>1. 表格标签</h2><h3 id="1-1-表格的基本语法"><a href="#1-1-表格的基本语法" class="headerlink" title="1.1 表格的基本语法"></a>1.1 表格的基本语法</h3><ol><li><code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;用于定义表格的标签。</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;标签用于定义表格中的行，必须嵌套在&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>中。</li><li><code>&lt;th&gt;&lt;/th&gt;</code>（table head）&nbsp;标签用于定义表格的表头部分，必须嵌套在&nbsp;<code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;中。常用于表格第一行，突出重要性，表头单元格里面的文字会<strong>加粗居中</strong>显示。</li><li><code>&lt;td&gt;&lt;/td&gt;</code>&nbsp;（table data）标签用于定义表格中的单元格，必须嵌套在&nbsp;<code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;中。</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table&gt;&lt;tr&gt;&lt;th&gt;表头名称&lt;/th&gt;...&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单元格内的文字&lt;/td&gt;...&lt;/tr&gt;...&lt;/table&gt;</code></pre><h3 id="1-2-表格属性"><a href="#1-2-表格属性" class="headerlink" title="1.2 表格属性"></a>1.2 表格属性</h3><p>只作了解，后期通过 CSS 来设置。 这些属性都要写到&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;标签中</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>align</code></td><td>left、center、right</td><td>表格元素对齐方式</td></tr><tr><td><code>border</code></td><td>1或””</td><td>规定是否有边框，默认为<code>""</code>，表示没有边框</td></tr><tr><td><code>cellpadding</code></td><td>像素值</td><td>规定单元边沿与其内容之间空白，默认1px</td></tr><tr><td><code>cellspacing</code></td><td>像素值</td><td>规定单元格之间的空白，默认为2px</td></tr><tr><td><code>width</code></td><td>像素值或百分比</td><td>规定表格宽度</td></tr><tr><td><code>hight</code></td><td>像素值或百分比</td><td>规定表格高度</td></tr></tbody></table><h3 id="1-3-表格结构标签"><a href="#1-3-表格结构标签" class="headerlink" title="1.3 表格结构标签"></a>1.3 表格结构标签</h3><p>场景：表格可能很长，将表格分割为表格头部和表格主题两大部分。</p><p><code>&lt;thead&gt;</code>&nbsp;表示头部区域，<code>&lt;tbody&gt;</code>&nbsp;表示主体区域，更好区分表格结构。</p><p>注意：</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：定义表格头部，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：定义表格主体，存放数据，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li>以上标签都放在&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;里面。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;表头名称&lt;/th&gt;...&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单元格内的文字&lt;/td&gt;&lt;/tr&gt;...&lt;/tbody&gt;</code></pre><h3 id="1-4-合并单元格"><a href="#1-4-合并单元格" class="headerlink" title="1.4 合并单元格"></a>1.4 合并单元格</h3><ul><li>跨行合并：rowspan=”合并单元格个数”</li><li>跨列合并：colspan=”合并单元格个数”</li></ul><p>合并三部曲：</p><ol><li>确定跨行 or 跨列。</li><li>找到目标单元格：跨行取最上面为目标单元格，跨列取最左边为目标单元格。<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code></li><li>删除多余单元格。</li></ol><h2 id="2-列表标签"><a href="#2-列表标签" class="headerlink" title="2. 列表标签"></a>2. 列表标签</h2><h3 id="2-1-无序列表"><a href="#2-1-无序列表" class="headerlink" title="2.1 无序列表"></a>2.1 无序列表</h3><p><code>&lt;ul&gt;</code>&nbsp;标签标识 HTML 页面项目中的无序列表，一般以项目符号呈现列表项，而列表项使用<code>&lt;li&gt;</code>标签定义。</p><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt;</code></pre><p>注意：</p><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能包含<code>&lt;li&gt;&lt;/li&gt;</code>，写入其他标签或文字是不允许的。</li><li><code>&lt;li&gt;&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</li><li>无序列表带有自己的属性，可用 CSS 修改样式属性。</li></ol><h3 id="2-2-有序列表"><a href="#2-2-有序列表" class="headerlink" title="2.2 有序列表"></a>2.2 有序列表</h3><p>使用&nbsp;<code>&lt;ol&gt;</code>&nbsp;标签来定义有序列表，<code>&lt;li&gt;</code>&nbsp;来定义列表项。</p><pre class="line-numbers language-none"><code class="language-none">&lt;ol&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt;</code></pre><p>与无序列表类似，有自己的样式属性，通过 CSS 设置。</p><h3 id="2-3-自定义列表"><a href="#2-3-自定义列表" class="headerlink" title="2.3 自定义列表"></a>2.3 自定义列表</h3><p>自定义列表的列表项前没有任何项目符号。</p><p><code>&lt;dl&gt;</code>&nbsp;定义描述列表，与&nbsp;<code>&lt;dt&gt;</code>&nbsp;和&nbsp;<code>&lt;dd&gt;</code>&nbsp;标签配合使用。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;    &lt;dt&gt;名词1&lt;/dt&gt;    &lt;dd&gt;名词1解释1&lt;/dd&gt;    &lt;dd&gt;名词1解释2&lt;/dd&gt;&lt;/dl&gt;</code></pre><p><strong>注意</strong></p><ol><li>dl 里面只能包含 dt 和 dd。</li><li>dt和dd个数没有限制，经常是一个dt对应多个dd。</li></ol><h2 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="3. 表单标签"></a>3. 表单标签</h2><h3 id="3-1-表单组成"><a href="#3-1-表单组成" class="headerlink" title="3.1 表单组成"></a>3.1 表单组成</h3><p>在 HTML 中，一个完整的表单通常由<strong>表单域、表单控件（也称为表单元素）和 提示信息</strong>3个部分构成。</p><p><img src="Pasted%20image%2020221206201222.png"></p><h3 id="3-2-表单域"><a href="#3-2-表单域" class="headerlink" title="3.2 表单域"></a>3.2 表单域</h3><p>表单域是一个包含表单元素的区域。 使用&nbsp;<code>&lt;form&gt;</code>&nbsp;标签用于定义表单域，以实现用户信息的收集和传递。<br><code>&lt;form&gt;</code>标签会将它范围内的表单元素信息提交给服务器。</p><pre class="line-numbers language-none"><code class="language-none">&lt;form action="url地址" method="提交方式" name="表单域名称"&gt;  各种表单元素控件&lt;/form&gt;</code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url地址</td><td>指定接受并处理表单数据的服务器的 url 地址</td></tr><tr><td>method</td><td>get/post</td><td>设置表单数据的提交方式</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单名称，区分同一个页面中的多个表单域</td></tr><tr><td>**注意：</td><td></td><td></td></tr></tbody></table><ol><li>写表单元素之前需要有表单域将其包含。</li><li>表单域是&nbsp;<code>form</code>&nbsp;标签。</li></ol><h3 id="3-3-表单控件"><a href="#3-3-表单控件" class="headerlink" title="3.3 表单控件"></a>3.3 表单控件</h3><h4 id="3-3-1-表单元素"><a href="#3-3-1-表单元素" class="headerlink" title="3.3.1 <input>&nbsp;表单元素"></a>3.3.1 <code>&lt;input&gt;</code>&nbsp;表单元素</h4><p><code>&lt;input&gt;</code>&nbsp;标签用于收集用户信息。</p><p><code>input</code>&nbsp;标签包含&nbsp;<code>type</code>&nbsp;属性，决定了输入字段的不同形式：***文本字段、复选框、掩码后的文本控件、单选按钮、按钮等。</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="属性值" /&gt;</code></pre><ul><li><code>input</code>&nbsp;标签为单标签</li><li><code>type</code>&nbsp;属性设置不同属性值来指定不同控件类型</li></ul><p><em><strong>type 常用属性值</strong></em></p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>输入字段。用户可输入文本，默认宽度为 20 个字符。</td></tr><tr><td>button</td><td>可点击按钮，后期结合js搭配使用。</td></tr><tr><td>radio</td><td>单选按钮</td></tr><tr><td>checkbox</td><td>复选框</td></tr><tr><td>password</td><td>密码字段。字符被掩码。</td></tr><tr><td>file</td><td>定义输入字段和“浏览”按钮，供文件上传</td></tr><tr><td>submit</td><td>提交按钮。会把表单数据发送到服务器。</td></tr><tr><td>reset</td><td>重置按钮，清除表单所有数据。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr></tbody></table><p><em><strong>input 的其他属性</strong></em></p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>自定义</td><td>定义 input 元素名称</td></tr><tr><td>value</td><td>自定义</td><td>规定 input 元素的值（可以显示出来）</td></tr><tr><td>checked</td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字段字符的最大长度</td></tr></tbody></table><ol><li><code>name 和 value</code> 是每个表单元素都有的属性值,主要给<strong>后台人员</strong>使用。<ol><li>name：多选一或复选时，所有的单选按钮和复选框要有<strong>相同</strong>的name值。</li><li>value：多选一或复选时，每个单选按钮和复选框要有<strong>不同</strong>的value值。</li></ol></li><li>checked 属性主要针对于单选按钮和复选框, 主要作用一打开页面,就要可以<strong>默认选中</strong>某个表单元素。</li><li>maxlength 是用户可以在表单元素输入的最大字符数, 一般较少使用。</li></ol><p><em><strong>label标签</strong></em></p><p><code>&lt;label&gt;</code>&nbsp;标签为 input 元素定义标注。<br><code>&lt;label&gt;</code>&nbsp;标签用于绑定一个表单源深路，当<strong>点击 label 标签内的文本</strong>时，浏览器<strong>自动将焦点转到或者选择</strong>对应的表单元素上，提升用户体验。</p><pre class="line-numbers language-none"><code class="language-none">&lt;label for="nan"&gt;男&lt;/label&gt;&lt;input type="radio" name="sex" id="nan" /&gt;</code></pre><p><strong>核心：</strong>&nbsp;<code>&lt;lable&gt;</code>标签的 for 属性与input元素的 id 属性相同。</p><h4 id="3-3-2-下拉表单元素"><a href="#3-3-2-下拉表单元素" class="headerlink" title="3.3.2 <select>下拉表单元素"></a>3.3.2 <code>&lt;select&gt;</code>下拉表单元素</h4><pre class="line-numbers language-none"><code class="language-none">&lt;select&gt;    &lt;option&gt;选项1&lt;/option&gt;    &lt;option&gt;选项2&lt;/option&gt;    &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;</code></pre><p><strong>注意</strong></p><ol><li>select 中至少包含一对 option。</li><li>在 option 中定义属性<code>selected="selected"</code>，当前项即为默认选项。</li></ol><h4 id="3-3-3-文本域元素"><a href="#3-3-3-文本域元素" class="headerlink" title="3.3.3 <textarea> 文本域元素"></a>3.3.3 <code>&lt;textarea&gt;</code> 文本域元素</h4><pre class="line-numbers language-none"><code class="language-none">&lt;textarea rows="3" cols="20"&gt;    文本内容&lt;/textarea&gt;</code></pre><ul><li>cols=”每行的字符数”，rows=”显示的行数”。**我们在实际开发中不会使用，都是用 CSS 来改变大小。</li></ul><h1 id="四、搜索优化"><a href="#四、搜索优化" class="headerlink" title="四、搜索优化"></a>四、搜索优化</h1><h2 id="1-TDK-标签-SEO-优化"><a href="#1-TDK-标签-SEO-优化" class="headerlink" title="1. TDK 标签 SEO 优化"></a>1. TDK 标签 SEO 优化</h2><p>SEO（Search Engine Optimization），即搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。</p><p>SEO 的目的是对网站进行深度优化，从而帮助网站获得免费流量，进而在搜索引擎上提升网站排名，提高网站知名度。</p><p>页面必须有三个标签用来进行 SEO 优化。</p><ul><li><code>title</code></li><li><code>description</code></li><li><code>keyword</code></li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 网站标题 --&gt;&lt;title&gt;&lt;/title&gt;&lt;!-- 网站说明 --&gt;&lt;meta name="description" content=""&gt;&lt;!-- 网站关键词 --&gt;&lt;meta name="keywords" content=""&gt;</code></pre><h3 id="1-1-title-网站标题"><a href="#1-1-title-网站标题" class="headerlink" title="1.1 title 网站标题"></a>1.1 title 网站标题</h3><p><code>title</code>&nbsp;具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点。</p><p>建议：网站名（产品名）- 网站的介绍（尽量不要超过30个汉字）</p><p>例如：</p><ul><li>京东(JD.COM) - 综合网购首选-正品低价、品质保障、配送及时、轻松购物！</li><li>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</li></ul><h3 id="1-2-description-网站说明"><a href="#1-2-description-网站说明" class="headerlink" title="1.2 description 网站说明"></a>1.2 description 网站说明</h3><p>简要说明我们网站主要是做什么的。</p><p>我们提倡，description 作为网站的总体业务和主题概括，多采用“我们是…”、“我们提供…”、“×××网作为…”、“电话：010…”之类语句。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"&gt;</code></pre><h3 id="1-3-keywords-关键字"><a href="#1-3-keywords-关键字" class="headerlink" title="1.3 keywords 关键字"></a>1.3 keywords 关键字</h3><ul><li>keywords 是页面关键词，是搜索引擎的关注点之一。</li><li>keywords 最好限制为6～8 个关键词，关键词之间用英文逗号隔开，采用关键词1,关键词2 的形式。</li></ul><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name= " keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"&gt;</code></pre><h2 id="2-LOGO-SEO-优化"><a href="#2-LOGO-SEO-优化" class="headerlink" title="2. LOGO SEO 优化"></a>2. LOGO SEO 优化</h2><ol><li>logo 首先放一个<code>h1</code>标签，目的是为了提权，告诉搜索引擎，这个地方很重要。</li><li><code>h1</code>里面再放一个<code>a</code>链接，可以返回首页的，把logo 的背景图片给a链接即可。</li><li>为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来。</li></ol><ul><li>方法1：text-indent 移到盒子外面（text-indent: -9999px) ，然后overflow:hidden ，淘宝的做法。</li><li>方法2：直接给font-size: 0; 就看不到文字了，京东的做法。</li></ul><ol start="4"><li>最后给logo图片一个<code>title</code>属性，这样鼠标放到 logo 上就可以看到提示文字了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML简介</title>
      <link href="/2022/11/15/HTML%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/11/15/HTML%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网页"><a href="#1-网页" class="headerlink" title="1. 网页"></a>1. 网页</h2><h3 id="1-1-什么是网页"><a href="#1-1-什么是网页" class="headerlink" title="1.1 什么是网页"></a>1.1 什么是网页</h3><ol><li><p>网页是根据因特网上一定的规则，使用 html 等制作的用于展示特定内容的网页集合。</p></li><li><p>网页是构成网站的基本元素。</p></li><li><p>网页是图片、链接、文字、声音、视频等源深路组成，其实就是一个 html 文件。</p></li></ol><h3 id="1-2-什么是-HTML"><a href="#1-2-什么是-HTML" class="headerlink" title="1.2 什么是 HTML"></a>1.2 什么是 HTML</h3><p>HTML 指的是超文本标记语言（Hyper Text Markup Language）,它是用来描述网页的一种语言。</p><p>HTML 不是一种编程语言，而是一种标记语言（markup language）。 标记语言是一套标记标签（markup tag）。</p><p><strong>超文本的含义：</strong></p><ol><li>它可以加入图片、声音、动画、多媒体等内容（超越文本限制）。</li><li>它可以从一个文件跳转到另一个文件，于世界各地主机的文件连接（超级链接文本）。</li></ol><h3 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h3><p>网页由网页元素组成，这些元素通过 html 标签描述出来，然后通过浏览器解析并显示出来。</p><h2 id="2-常用浏览器及其内核"><a href="#2-常用浏览器及其内核" class="headerlink" title="2. 常用浏览器及其内核"></a>2. 常用浏览器及其内核</h2><h3 id="2-1-常用浏览器"><a href="#2-1-常用浏览器" class="headerlink" title="2.1 常用浏览器"></a>2.1 常用浏览器</h3><p>浏览器是网页显示、运行的平台。</p><p>五大浏览器有 IE、Firefox、Chrome、Safari 和 Opera。</p><p>四大内核：Trident, Gecko, Webkit, Blink</p><h3 id="2-2-浏览器内核"><a href="#2-2-浏览器内核" class="headerlink" title="2.2 浏览器内核"></a>2.2 浏览器内核</h3><p>浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。<br><img src="Pasted%20image%2020221206114523.png"></p><h2 id="3-Web-标准"><a href="#3-Web-标准" class="headerlink" title="3. Web 标准"></a>3. Web 标准</h2><p>Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。</p><h3 id="3-1-为什么需要-Web-标准"><a href="#3-1-为什么需要-Web-标准" class="headerlink" title="3.1 为什么需要 Web 标准"></a>3.1 为什么需要 Web 标准</h3><p>浏览器不同，它们显示的页面或者排版有些许差异。</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li>让 Web 标准发展前景更为广阔</li><li>内容能被更广泛的设备访问。</li><li>更容易被搜索引擎了搜索。</li><li>降低网站流量费用。</li><li>易于维护。</li><li>提高页面浏览速度。</li></ol><h3 id="3-2-Web-标准的构成"><a href="#3-2-Web-标准的构成" class="headerlink" title="3.2 Web 标准的构成"></a>3.2 Web 标准的构成</h3><p>主要包括结构（Structure） 、表现（Presentation）和行为（Behavior）三个方面。<br><img src="Pasted%20image%2020221206114713.png"><br>Web 标准提出的最佳体验方案：结构、样式、行为相分离。</p><p>简单理解： ==结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中==。</p><p><img src="Pasted%20image%2020221206114849.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
