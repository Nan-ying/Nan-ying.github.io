<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/2023/10/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/"/>
      <url>/2023/10/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>先建表，然后创建一个SpringBoot的工程，勾选<code>Spring Web</code>，<code>MySQL</code>，然后在pom中引入其他</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.23&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.4.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.76&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-lang&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-lang&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.18.20&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>导入前端资源，放在<code>resources</code>目录下。直接放在<code>resources</code>目录下，需要配置一下资源映射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        log.info(&quot;开始进行静态资源映射...&quot;);        registry.addResourceHandler(&quot;&#x2F;backend&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;backend&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;front&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;front&#x2F;&quot;);    &#125;&#125;</code></pre><p>之后配置一下yml文件就能访问静态页面了</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8080spring:  application:    name: reggie_take_out  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;reggie?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;allowPublicKeyRetrieval&#x3D;true      username: root      password: 123456mybatis-plus:  configuration:    map-underscore-to-camel-case: true    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    db-config:      id-type: ASSIGN_ID</code></pre><p>打开浏览器，访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a> 可以看到登录页面，不过此时无法登录</p><h2 id="2-后台系统登录功能分析"><a href="#2-后台系统登录功能分析" class="headerlink" title="2. 后台系统登录功能分析"></a>2. 后台系统登录功能分析</h2><h3 id="2-1-创建对应的实体类"><a href="#2-1-创建对应的实体类" class="headerlink" title="2.1 创建对应的实体类"></a>2.1 创建对应的实体类</h3><p>创建一个Employee类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    private LocalDateTime createTime;    private LocalDateTime updateTime;    private Long createUser;    private Long updateUser;&#125;</code></pre><h3 id="2-2-创建对应的Mapper和Service"><a href="#2-2-创建对应的Mapper和Service" class="headerlink" title="2.2 创建对应的Mapper和Service"></a>2.2 创建对应的Mapper和Service</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface EmployeeMapper extends BaseMapper&lt;Employee&gt; &#123;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EmployeeService extends IService&lt;Employee&gt; &#123;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper, Employee&gt; implements EmployeeService &#123;&#125;</code></pre><h3 id="2-3-统一结果封装"><a href="#2-3-统一结果封装" class="headerlink" title="2.3 统一结果封装"></a>2.3 统一结果封装</h3><p>编写一个Result类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Result&lt;T&gt; &#123;    private Integer code;  &#x2F;&#x2F; 编码：1成功。0和其他数字失败    private String errMsg;  &#x2F;&#x2F; 错误信息    private T data; &#x2F;&#x2F; 数据    private Map map &#x3D; new HashMap();  &#x2F;&#x2F; 动态数据    public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123;        Result&lt;T&gt; r &#x3D; new Result&lt;&gt;();        r.code &#x3D; 1;  &#x2F;&#x2F;成功状态码        r.data &#x3D; data;        return r;    &#125;    public static &lt;T&gt; Result&lt;T&gt; error(String errMsg) &#123;        Result&lt;T&gt; r &#x3D; new Result&lt;&gt;();        r.errMsg &#x3D; errMsg; &#x2F;&#x2F;设置错误信息        r.code &#x3D; 0;  &#x2F;&#x2F;默认失败状态码，后期我们可以根据自己的需求来设置其他状态码        return r;    &#125;    public Result&lt;T&gt; add(String msg, String value) &#123;        this.map.put(msg, value);        return this;    &#125;&#125;</code></pre><h3 id="2-4-编写Controller"><a href="#2-4-编写Controller" class="headerlink" title="2.4 编写Controller"></a>2.4 编写Controller</h3><p>给EmployeeController类添加一个login方法</p><ul><li><code>@RequestBody</code> 主要用于接收前端传递给后端的json字符串（请求体中的数据）</li><li><code>HttpServletRequest</code> 作用：如果登录成功，将员工对应的id存到session一份，这样想获取一份登录用户的信息就可以随时获取出来</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;employee&quot;)public class EmployeeController &#123;    @Autowired    private EmployeeService employeeService;    &#x2F;**     * 登入功能     * @param request        * @param employee     * @return     *&#x2F;    &#x2F;&#x2F;发送post请求    @PostMapping(&quot;&#x2F;login&quot;)    public Result&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee) &#123;        String password &#x3D; employee.getPassword();        password &#x3D; DigestUtils.md5DigestAsHex(password.getBytes());        &#x2F;&#x2F;这部分就是MP        LambdaQueryWrapper&lt;Employee&gt; lqw &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;相当于sql里面的where        lqw.eq(Employee::getUsername, employee.getUsername());        Employee emp &#x3D; employeeService.getOne(lqw);        if (emp &#x3D;&#x3D; null) &#123;            return Result.error(&quot;登陆失败&quot;);        &#125;        if (!emp.getPassword().equals(password)) &#123;            return Result.error(&quot;登录失败&quot;);        &#125;        if (emp.getStatus() &#x3D;&#x3D; 0) &#123;            return Result.error(&quot;该用户已被禁用&quot;);        &#125;        &#x2F;&#x2F;存个Session，只存个id就行了        request.getSession().setAttribute(&quot;employee&quot;,emp.getId());        return Result.success(emp);    &#125;        &#x2F;**     * 登出功能     * @param request     * @return     *&#x2F;    @PostMapping(&quot;&#x2F;logout&quot;)    public Result&lt;String&gt; logout(HttpServletRequest request) &#123;        request.getSession().removeAttribute(&quot;employee&quot;);        return Result.success(&quot;退出成功&quot;);    &#125;&#125;</code></pre><h3 id="2-5-登录测试"><a href="#2-5-登录测试" class="headerlink" title="2.5 登录测试"></a>2.5 登录测试</h3><p>数据库中目前只有一条用户信息，username为<code>admin</code>，password为<code>123456</code>（已经经过MD5加密了）<br>现在我们访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a><br>输入正确的用户名和密码，正常登录，并跳转至<code>http://localhost/backend/index.html</code><br>输入错误的用户名或密码，会显示登陆失败<br>对应的HTML代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">methods: &#123;    async handleLogin() &#123;        this.$refs.loginForm.validate(async (valid) &#x3D;&gt; &#123;        if (valid) &#123;            this.loading &#x3D; true            let res &#x3D; await loginApi(this.loginForm)            if (String(res.code) &#x3D;&#x3D;&#x3D; &#39;1&#39;) &#123;            localStorage.setItem(&#39;userInfo&#39;,JSON.stringify(res.data))            window.location.href&#x3D; &#39;&#x2F;backend&#x2F;index.html&#39;            &#125; else &#123;            this.$message.error(res.msg)            this.loading &#x3D; false            &#125;        &#125;        &#125;)    &#125;&#125;</code></pre><p>对应的JS代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function loginApi(data) &#123;  return $axios(&#123;    &#39;url&#39;: &#39;&#x2F;employee&#x2F;login&#39;,    &#39;method&#39;: &#39;post&#39;,    data  &#125;)&#125;function logoutApi()&#123;  return $axios(&#123;    &#39;url&#39;: &#39;&#x2F;employee&#x2F;logout&#39;,    &#39;method&#39;: &#39;post&#39;,  &#125;)&#125;</code></pre><h3 id="2-6-登出功能"><a href="#2-6-登出功能" class="headerlink" title="2.6 登出功能"></a>2.6 登出功能</h3><p>先·简单分析一下前端代码<br>登出的功能是在index页面的，右上角有一个按钮，点击就能登出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div class&#x3D;&quot;right-menu&quot;&gt;    &lt;!--这里动态的显示登录的用户名--&gt;    &lt;div class&#x3D;&quot;avatar-wrapper&quot;&gt;&#123;&#123; userInfo.name &#125;&#125;&lt;&#x2F;div&gt;    &lt;!--这里就是登出的按钮--&gt;    &lt;img src&#x3D;&quot;images&#x2F;icons&#x2F;btn_close@2x.png&quot; class&#x3D;&quot;outLogin&quot; alt&#x3D;&quot;退出&quot; @click&#x3D;&quot;logout&quot; &#x2F;&gt;&lt;&#x2F;div&gt;</code></pre><p>对应的函数如下，这里的logoutApi是用来发送post请求的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">logout() &#123;    logoutApi().then((res)&#x3D;&gt;&#123;        if(res.code &#x3D;&#x3D;&#x3D; 1)&#123;        localStorage.removeItem(&#39;userInfo&#39;)        window.location.href &#x3D; &#39;&#x2F;backend&#x2F;page&#x2F;login&#x2F;login.html&#39;        &#125;    &#125;)&#125;function logoutApi()&#123;  return $axios(&#123;    &#39;url&#39;: &#39;&#x2F;employee&#x2F;logout&#39;,    &#39;method&#39;: &#39;post&#39;,  &#125;)&#125;</code></pre><p>登出功能的后端操作很简单，只要删除session就好了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 登出功能    * @param request    * @return    *&#x2F;@PostMapping(&quot;&#x2F;logout&quot;)public Result&lt;String&gt; logout(HttpServletRequest request) &#123;    request.getSession().removeAttribute(&quot;employee&quot;);    return Result.success(&quot;退出成功&quot;);&#125;</code></pre><h3 id="2-7-完善登录功能"><a href="#2-7-完善登录功能" class="headerlink" title="2.7 完善登录功能"></a>2.7 完善登录功能</h3><p>问题分析：</p><ul><li>之前的登录功能，我们不登录，直接访问 <a href="http://localhost/backend/index.html">http://localhost/backend/index.html</a> 也可以正常访问，这显然是不合理的</li><li>我们希望看到的效果是，只有登录成功才能看到页面，未登录状态则跳转到登录页面</li><li>那么具体改如何实现呢？使用过滤器或拦截器，在过滤器或拦截器中判断用户是否登录，然后在选择是否跳转到对应页面</li></ul><h4 id="2-7-1-测试Filter拦截路径"><a href="#2-7-1-测试Filter拦截路径" class="headerlink" title="2.7.1 测试Filter拦截路径"></a>2.7.1 测试Filter拦截路径</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName &#x3D; &quot;loginCheckFilter&quot;, urlPatterns &#x3D; &quot;&#x2F;*&quot;)public class LoginCheckFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request &#x3D; (HttpServletRequest) servletRequest;        HttpServletResponse response &#x3D; (HttpServletResponse) servletResponse;        &#x2F;&#x2F;将拦截到的URI输出到日志，&#123;&#125;是占位符，将自动填充request.getRequestURI()的内容        log.info(&quot;拦截到的URI：&#123;&#125;&quot;, request.getRequestURI());        &#x2F;&#x2F;放行        filterChain.doFilter(request, response);    &#125;&#125;</code></pre><p>并在启动类上加入注解<code>@ServletComponentScan</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ServletComponentScanpublic class ReggieApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ReggieApplication.class, args);&#125;&#125;</code></pre><p>启动服务器，访问index页面，查看日志，现在可以拦截到URI了</p><blockquote><p>2022-09-29 18:05:53.190 …… : 拦截到的URI：&#x2F;backend&#x2F;index.html<br>2022-09-29 18:06:01.174 …… : 拦截到的URI：&#x2F;employee&#x2F;page</p></blockquote><h4 id="2-7-2-编写Filter逻辑"><a href="#2-7-2-编写Filter逻辑" class="headerlink" title="2.7.2 编写Filter逻辑"></a>2.7.2 编写Filter逻辑</h4><p>首先看一下JS代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 响应拦截器service.interceptors.response.use(res &#x3D;&gt; &#123;    if (res.data.code &#x3D;&#x3D;&#x3D; 0 &amp;&amp; res.data.msg &#x3D;&#x3D;&#x3D; &#39;NOTLOGIN&#39;) &#123; &#x2F;&#x2F; 返回登录页面格式    console.log(&#39;---&#x2F;backend&#x2F;page&#x2F;login&#x2F;login.html---&#39;)    localStorage.removeItem(&#39;userInfo&#39;)    window.top.location.href &#x3D; &#39;&#x2F;backend&#x2F;page&#x2F;login&#x2F;login.html&#39;    &#125; else &#123;    return res.data    &#125;&#125;</code></pre><p>知道了拦截的返回格式后，开始编写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName &#x3D; &quot;LoginCheckFilter&quot;, urlPatterns &#x3D; &quot;&#x2F;*&quot;)public class LoginCheckFilter implements Filter &#123;    &#x2F;&#x2F;路径匹配器，支持通配符    private static final AntPathMatcher PATH_MATCHER &#x3D; new AntPathMatcher();    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request &#x3D; (HttpServletRequest) servletRequest;        HttpServletResponse response &#x3D; (HttpServletResponse) servletResponse;        &#x2F;&#x2F; 1.获取本次请求的URI        String uri &#x3D; request.getRequestURI();        &#x2F;&#x2F; 定义不需要处理的请求路径        String[] urls &#x3D; new String[]&#123;                &quot;&#x2F;employee&#x2F;login&quot;,                &quot;&#x2F;employee&#x2F;logout&quot;,                &#x2F;&#x2F; &#x2F;** 拦截所有的文件夹及里面的子文件夹                &#x2F;&#x2F; 即所有静态页面可以访问（只有骨架没有数据）                &quot;&#x2F;backend&#x2F;**&quot;,                &quot;&#x2F;front&#x2F;**&quot;        &#125;;        &#x2F;&#x2F; 2.判断本次请求是否需要拦截处理        boolean check &#x3D; check(urls, uri);        &#x2F;&#x2F; 3.如果不需要处理直接放行        if (check) &#123;            log.info(&quot;本次请求：&#123;&#125;，不需要处理&quot;,uri);            filterChain.doFilter(request, response);            return;        &#125;        &#x2F;&#x2F; 4.如果需要处理，判定登录状态，若登录则放行        if (request.getSession().getAttribute(&quot;employee&quot;) !&#x3D; null) &#123;            log.info(&quot;用户已登录，id为&#123;&#125;&quot;,request.getSession().getAttribute(&quot;employee&quot;));            filterChain.doFilter(request, response);            return;        &#125;        &#x2F;&#x2F; 5.如果未登录则返回未登录结果,通过输出流方式向客户端页面响应数据        log.info(&quot;本次请求：&#123;&#125;&quot;,uri);        log.info(&quot;用户未登录&quot;);        log.info(&quot;用户id&#123;&#125;&quot;,request.getSession().getAttribute(&quot;employee&quot;));        response.getWriter().write(JSON.toJSONString(R.error(&quot;NOTLOGIN&quot;)));    &#125;    &#x2F;&#x2F;检查是否匹配    private boolean check(String[] urls, String uri) &#123;        for (String url : urls) &#123;            boolean match &#x3D; PATH_MATCHER.match(url, uri);            if (match) return true;        &#125;        return false;    &#125;&#125;</code></pre><h4 id="2-7-3-测试登录"><a href="#2-7-3-测试登录" class="headerlink" title="2.7.3 测试登录"></a>2.7.3 测试登录</h4><p>当我们直接访问 <a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a> 时，日志输出如下</p><pre class="line-numbers language-none"><code class="language-none">：拦截到请求：&#x2F;employee&#x2F;page: 用户未登录: 用户id为：null</code></pre><p>随后将自动跳转至登录页面</p><pre class="line-numbers language-none"><code class="language-none">: 拦截到请求：&#x2F;employee&#x2F;login: 本次请求：&#x2F;employee&#x2F;login，不需要处理</code></pre><blockquote><p>自动跳转是因为：访问<a href="http://localhost:8080/backend/index.html%E6%97%B6%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AEpage/member/list.html%EF%BC%8Clist.html%E5%8F%88%E8%AE%BF%E9%97%AE/employee/page">http://localhost:8080/backend/index.html时会默认访问page/member/list.html，list.html又访问/employee/page</a></p></blockquote><h1 id="员工管理"><a href="#员工管理" class="headerlink" title="员工管理"></a>员工管理</h1><h2 id="3-添加员工"><a href="#3-添加员工" class="headerlink" title="3. 添加员工"></a>3. 添加员工</h2><h3 id="3-1-流程分析"><a href="#3-1-流程分析" class="headerlink" title="3.1 流程分析"></a>3.1 流程分析</h3><p>实现功能之前，我们先梳理一下整个执行流程</p><ol><li>页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据进行保存</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231002125855639.png" alt="image-20231002125855639"></p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>新增的员工信息只有部分数据，id，password，status，createTime等都还没有指定。</p><ul><li><code>id</code> 这个就用自动生成的就好了（雪花算法&#x2F;自动递增）</li><li><code>password</code> 当你注册某些教育网站的时候，一般都会给你默认指定一个密码（身份证后六位，123456等），所以我们这里的解决策略就直接指定一个123456了，但是这个密码不能直接在数据库中设为默认值，因为数据库设置的默认值无法加密</li><li><code>status</code> 设定员工的状态，1表示启用，0表示禁用，这个表里直接设置了默认值</li><li><code>createTime</code> 创建时间，这个就指定当前时间就好了</li><li><code>updateTime</code> 作用同上</li><li><code>createUser</code> 这个是创建人的ID，我们首先需要一个管理员账号登录到后台管理界面，然后才能添加员工信息，所以我们也需要对这个员工信息的创建人，进行设置，避免出现莫名的员工账号，依靠这个可以溯源</li><li><code>updateUser</code> 作用同上</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic R&lt;String&gt; save(HttpServletRequest request, @RequestBody Employee employee) &#123;    &#x2F;&#x2F; 设置员工的password，createTime，updateTime,createUser,updateUser    employee.setPassword(DigestUtils.md5DigestAsHex(&quot;123456&quot;.getBytes()));    employee.setCreateTime(LocalDateTime.now());    employee.setUpdateTime(LocalDateTime.now());    &#x2F;&#x2F; 从session获取当前登录用户    Long employee1 &#x3D; (Long) request.getSession().getAttribute(&quot;employee&quot;);    employee.setCreateUser(employee1);    employee.setUpdateUser(employee1);    employeeService.save(employee);    return R.success(&quot;添加员工成功&quot;);&#125;</code></pre><blockquote><p>值得注意的一点是，username不能重复，因为在建表的时候设定了unique，只能存在唯一的username，如果存入相同的username则会报错。</p><p>这个报错目前也不太人性化，咱也不知道具体为啥添加失败了，所以我们还得继续完善一下，那么具体该怎么完善呢？可以使用全局统一异常处理</p></blockquote><h3 id="3-3-完善全局异常处理器并测试"><a href="#3-3-完善全局异常处理器并测试" class="headerlink" title="3.3 完善全局异常处理器并测试"></a>3.3 完善全局异常处理器并测试</h3><p>在<code>com.blog.common</code>包下创建一个全局异常处理类<code>GlobalExceptionHandler</code>，并添加exceptionHandler方法用来捕获异常，并返回结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ControllerAdvice(annotations &#x3D; &#123;RestController.class, Controller.class&#125;)@ResponseBody@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex) &#123;        log.error(ex.getMessage());        &#x2F;&#x2F;如果包含Duplicate entry，则说明有条目重复        if (ex.getMessage().contains(&quot;Duplicate entry&quot;)) &#123;            &#x2F;&#x2F;对字符串切片            String[] s &#x3D; ex.getMessage().split(&quot; &quot;);            &#x2F;&#x2F;报错字符串格式是固定的，s[2]这个位置必然是username            return R.error(&quot;用户名&quot; + s[2] + &quot;已存在&quot;);        &#125;        return R.error(&quot;未知错误&quot;);    &#125;&#125;</code></pre><h2 id="4-员工信息分页查询"><a href="#4-员工信息分页查询" class="headerlink" title="4. 员工信息分页查询"></a>4. 员工信息分页查询</h2><p><img src="image-20231002163302249.png" alt="image-20231002163302249"></p><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p><ol><li>页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务</li><li>服务端Controller接收页面提交的数据并调用Service查询数据</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收到分页数据并通过ElementUI的Table组件展示到页面上</li></ol><h3 id="4-1-前端代码分析"><a href="#4-1-前端代码分析" class="headerlink" title="4.1 前端代码分析"></a>4.1 前端代码分析</h3><p><img src="image-20231002163457504.png" alt="image-20231002163457504"></p><p>关于数据显示的功能，就是由这部分代码完成的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () &#123;    const params &#x3D; &#123;        page: this.page,        pageSize: this.pageSize,        name: this.input ? this.input : undefined    &#125;    await getMemberList(params).then(res &#x3D;&gt; &#123;        if (String(res.code) &#x3D;&#x3D;&#x3D; &#39;1&#39;) &#123;        this.tableData &#x3D; res.data.records || [] &#x2F;&#x2F; 返回的列表数据在这里        this.counts &#x3D; res.data.total        &#125;    &#125;).catch(err &#x3D;&gt; &#123;        this.$message.error(&#39;请求出错了：&#39; + err)    &#125;)&#125;function getMemberList (params) &#123;  return $axios(&#123;    url: &#39;&#x2F;employee&#x2F;page&#39;,    method: &#39;get&#39;,    params  &#125;)&#125;</code></pre><h3 id="4-2-配置MyBatisPlus分页插件"><a href="#4-2-配置MyBatisPlus分页插件" class="headerlink" title="4.2 配置MyBatisPlus分页插件"></a>4.2 配置MyBatisPlus分页插件</h3><p>新建<code>com.itheima.config</code>包，并在其中新建<code>MybatisPlusConfig</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor mybatisPlusInterceptor &#x3D; new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mybatisPlusInterceptor;    &#125;&#125;</code></pre><h3 id="4-3-编写具体的业务逻辑"><a href="#4-3-编写具体的业务逻辑" class="headerlink" title="4.3 编写具体的业务逻辑"></a>4.3 编写具体的业务逻辑</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;page&quot;)public Result&lt;Page&gt; page(int page, int pageSize, String name) &#123;    log.info(&quot;page&#x3D;&#123;&#125;,pageSize&#x3D;&#123;&#125;,name&#x3D;&#123;&#125;&quot;, page, pageSize, name);        &#x2F;&#x2F;构造分页构造器    Page&lt;Employee&gt; pageInfo &#x3D; new Page&lt;&gt;(page, pageSize);    &#x2F;&#x2F;构造条件构造器    LambdaQueryWrapper&lt;Employee&gt; lqw &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加过滤条件（当我们没有输入name时，就相当于查询所有了）    lqw.like(!(name &#x3D;&#x3D; null || &quot;&quot;.equals(name)), Employee::getName, name);    &#x2F;&#x2F;并对查询的结果进行降序排序，根据更新时间    lqw.orderByDesc(Employee::getUpdateTime);        &#x2F;&#x2F;执行查询    employeeService.page(pageInfo, wrapper);    return Result.success(pageInfo);&#125;</code></pre><h2 id="5-启用-禁用员工账号"><a href="#5-启用-禁用员工账号" class="headerlink" title="5. 启用&#x2F;禁用员工账号"></a>5. 启用&#x2F;禁用员工账号</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><ol><li>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。</li><li>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。</li><li>管理员admin登录系统可以对所有员工账号进行启用、禁用操作。</li><li>如果某个员工账号状态为正常，则按钮显示为“禁用”，如果员工账号状态为已禁用，则按钮显示为“启用”</li></ol><p><img src="20230412044305_357.jpg" alt="img"></p><h3 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h3><ol><li><p>页面发送ajax请求，将参数(id、status)提交到服务端</p><p><img src="image-20231002182702506.png" alt="image-20231002182702506"></p></li><li><p>服务端Controller接收页面提交的数据并调用Service更新数据</p></li><li><p>Service调用Mapper操作数据库</p></li></ol><p><img src="image-20231002182232130.png" alt="image-20231002182232130"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) &#123;    log.info(employee.toString());    Long id &#x3D; (Long) request.getSession().getAttribute(&quot;employee&quot;);    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success(&quot;员工信息修改成功&quot;);&#125;</code></pre><p>查看数据库，我们发现status并没有被修改<br>通过查看日志，我们发现更新操作并没有完成，这是怎么回事呢？</p><blockquote><p>&#x3D;&#x3D;&gt; Preparing: UPDATE employee SET status&#x3D;?, update_time&#x3D;?, update_user&#x3D;? WHERE id&#x3D;?<br>&#x3D;&#x3D;&gt; Parameters: 0(Integer), 2022-10-04T09:37:21.459(LocalDateTime), 1(Long), 1575840690817011700(Long)<br>&#x3D;&#x3D;&gt; Updates: 0</p><ul><li>仔细观察这里的id值为<code>1575840690817011700</code>，而实际的id值为<code>1575840690817011713</code></li><li>问题的原因：</li><li>JS对Long型数据进行处理时丢失精度，导致提交的id和数据库中的id不一致。</li><li>如何解决这个问题?</li><li>我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串</li></ul></blockquote><h3 id="5-3-配置状态转换器"><a href="#5-3-配置状态转换器" class="headerlink" title="5.3 配置状态转换器"></a>5.3 配置状态转换器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import java.math.BigInteger;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;&#x2F;** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] *&#x2F;public class JacksonObjectMapper extends ObjectMapper &#123;    public static final String DEFAULT_DATE_FORMAT &#x3D; &quot;yyyy-MM-dd&quot;;    public static final String DEFAULT_DATE_TIME_FORMAT &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;;    public static final String DEFAULT_TIME_FORMAT &#x3D; &quot;HH:mm:ss&quot;;    public JacksonObjectMapper() &#123;        super();        &#x2F;&#x2F;收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        &#x2F;&#x2F;反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule &#x3D; new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(BigInteger.class, ToStringSerializer.instance)                .addSerializer(Long.class, ToStringSerializer.instance)                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        &#x2F;&#x2F;注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    &#125;&#125;</code></pre><p>扩展Mvc框架的消息转换器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;&#x2F;backend&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;backend&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;front&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;front&#x2F;&quot;);    &#125;    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        MappingJackson2HttpMessageConverter messageConverter &#x3D; new MappingJackson2HttpMessageConverter();        &#x2F;&#x2F;设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        &#x2F;&#x2F;将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    &#125;&#125;</code></pre><p>此时可以修改成功</p><h2 id="6-编辑员工信息"><a href="#6-编辑员工信息" class="headerlink" title="6. 编辑员工信息"></a>6. 编辑员工信息</h2><p>在开发代码之前，我们先来梳理一下整个操作流程与对应程序的执行顺序</p><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code></li><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li><li>服务端接受请求，并根据<code>员工id</code>查询员工信息，并将员工信息以<code>json</code>形式响应给页面</li><li>页面接收服务端响应的<code>json</code>数据，并通过Vue的<code>双向绑定</code>进行员工信息回显</li><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li><li>服务端接受员工信息，并进行处理，完成后给页面响应</li><li>页面接收到服务端响应信息后进行相应处理</li></ol><h3 id="6-1-页面根据id回显功能实现"><a href="#6-1-页面根据id回显功能实现" class="headerlink" title="6.1 页面根据id回显功能实现"></a>6.1 页面根据id回显功能实现</h3><h4 id="6-1-1-前端分析"><a href="#6-1-1-前端分析" class="headerlink" title="6.1.1 前端分析"></a>6.1.1 前端分析</h4><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code><br>编辑按钮绑定的点击事件为<code>addMemberHandle(scope.row.id)</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type&#x3D;&quot;text&quot;    size&#x3D;&quot;small&quot;    class&#x3D;&quot;blueBug&quot;    @click&#x3D;&quot;addMemberHandle(scope.row.id)&quot;    :class&#x3D;&quot;&#123;notAdmin:user !&#x3D;&#x3D; &#39;admin&#39;&#125;&quot;&gt;    编辑&lt;&#x2F;el-button&gt;addMemberHandle (st) &#123;    if (st &#x3D;&#x3D;&#x3D; &#39;add&#39;)&#123;        window.parent.menuHandle(&#123;        id: &#39;2&#39;,        url: &#39;&#x2F;backend&#x2F;page&#x2F;member&#x2F;add.html&#39;,        name: &#39;添加员工&#39;        &#125;,true)    &#125; else &#123;        window.parent.menuHandle(&#123;        id: &#39;2&#39;,        url: &#39;&#x2F;backend&#x2F;page&#x2F;member&#x2F;add.html?id&#x3D;&#39;+st, &#x2F;&#x2F;这里        name: &#39;修改员工&#39;        &#125;,true)    &#125;&#125;</code></pre><ol start="2"><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() &#123;    this.id &#x3D; requestUrlParam(&#39;id&#39;)    this.actionType &#x3D; this.id ? &#39;edit&#39; : &#39;add&#39;    if (this.id) &#123;    this.init()    &#125;&#125;&#x2F;&#x2F;获取url地址上面的参数function requestUrlParam(argname)&#123;  var url &#x3D; location.href  var arrStr &#x3D; url.substring(url.indexOf(&quot;?&quot;)+1).split(&quot;&amp;&quot;)  for(var i &#x3D;0;i&lt;arrStr.length;i++)  &#123;      var loc &#x3D; arrStr[i].indexOf(argname+&quot;&#x3D;&quot;)      if(loc!&#x3D;-1)&#123;          return arrStr[i].replace(argname+&quot;&#x3D;&quot;,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;)      &#125;  &#125;  return &quot;&quot;&#125;</code></pre><ol start="3"><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () &#123;    queryEmployeeById(this.id).then(res &#x3D;&gt; &#123;        console.log(res)        if (String(res.code) &#x3D;&#x3D;&#x3D; &#39;1&#39;) &#123;            console.log(res.data)            this.ruleForm &#x3D; res.data            this.ruleForm.sex &#x3D; res.data.sex &#x3D;&#x3D;&#x3D; &#39;0&#39; ? &#39;女&#39; : &#39;男&#39;            &#x2F;&#x2F; this.ruleForm.password &#x3D; &#39;&#39;        &#125; else &#123;            this.$message.error(res.msg || &#39;操作失败&#39;)        &#125;    &#125;)&#125;&#x2F;&#x2F; 修改页面反查详情接口function queryEmployeeById (id) &#123;  return $axios(&#123;    url: &#96;&#x2F;employee&#x2F;$&#123;id&#125;&#96;,    method: &#39;get&#39;  &#125;)&#125;</code></pre><h4 id="6-1-2-具体实现"><a href="#6-1-2-具体实现" class="headerlink" title="6.1.2 具体实现"></a>6.1.2 具体实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public R&lt;Employee&gt; getById(@PathVariable Long id) &#123;    log.info(&quot;根据id查询员工信息...&quot;);    Employee employee &#x3D; employeeService.getById(id);    if (employee !&#x3D; null) &#123;        return R.success(employee);    &#125;    return R.error(&quot;没有查询到对应员工信息&quot;);&#125;</code></pre><h3 id="6-2-保存功能实现"><a href="#6-2-保存功能实现" class="headerlink" title="6.2 保存功能实现"></a>6.2 保存功能实现</h3><ol><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type&#x3D;&quot;primary&quot;    @click&#x3D;&quot;submitForm(&#39;ruleForm&#39;, false)&quot;&gt;    保存&lt;&#x2F;el-button&gt;submitForm (formName, st) &#123;    this.$refs[formName].validate((valid) &#x3D;&gt; &#123;        if (valid) &#123;        if (this.actionType &#x3D;&#x3D;&#x3D; &#39;add&#39;) &#123;            const params &#x3D; &#123;            ...this.ruleForm,            sex: this.ruleForm.sex &#x3D;&#x3D;&#x3D; &#39;女&#39; ? &#39;0&#39; : &#39;1&#39;            &#125;            addEmployee(params).then(res &#x3D;&gt; &#123;            if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                this.$message.success(&#39;员工添加成功！&#39;)                if (!st) &#123;                this.goBack()                &#125; else &#123;                this.ruleForm &#x3D; &#123;                    username: &#39;&#39;,                    &#39;name&#39;: &#39;&#39;,                    &#39;phone&#39;: &#39;&#39;,                    &#x2F;&#x2F; &#39;password&#39;: &#39;&#39;,                    &#x2F;&#x2F; &#39;rePassword&#39;: &#39;&#39;,&#x2F;                    &#39;sex&#39;: &#39;男&#39;,                    &#39;idNumber&#39;: &#39;&#39;                &#125;                &#125;            &#125; else &#123;                this.$message.error(res.msg || &#39;操作失败&#39;)            &#125;            &#125;).catch(err &#x3D;&gt; &#123;            this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)        &#125; else &#123;            const params &#x3D; &#123;            ...this.ruleForm,            sex: this.ruleForm.sex &#x3D;&#x3D;&#x3D; &#39;女&#39; ? &#39;0&#39; : &#39;1&#39;            &#125;            editEmployee(params).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 这里            if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                this.$message.success(&#39;员工信息修改成功！&#39;)                this.goBack()            &#125; else &#123;                this.$message.error(res.msg || &#39;操作失败&#39;)            &#125;            &#125;).catch(err &#x3D;&gt; &#123;            this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)        &#125;        &#125; else &#123;        console.log(&#39;error submit!!&#39;)        return false        &#125;    &#125;)&#125;&#x2F;&#x2F; 修改---添加员工function editEmployee (params) &#123;  return $axios(&#123;    url: &#39;&#x2F;employee&#39;,    method: &#39;put&#39;,    data: &#123; ...params &#125;  &#125;)&#125;</code></pre><p>由于修改员工信息也是发送的PUT请求，与之前启用&#x2F;禁用员工账号是一致的，而且前面我们已经写过了PUT请求的Controller层<br>所以当我们点击保存按钮时，调用<code>submitForm</code>函数，而在<code>submitForm</code>函数中我们又调用了<code>editEmployee</code>函数，发送PUT请求，实现修改功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) &#123;    log.info(employee.toString());    Long id &#x3D; (Long) request.getSession().getAttribute(&quot;employee&quot;);    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success(&quot;员工信息修改成功&quot;);&#125;</code></pre><h1 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h1><p><img src="image-20231003152635364.png" alt="image-20231003152635364"></p><h2 id="7-公共字段自动填充"><a href="#7-公共字段自动填充" class="headerlink" title="7. 公共字段自动填充"></a>7. 公共字段自动填充</h2><h3 id="7-1-问题分析"><a href="#7-1-问题分析" class="headerlink" title="7.1 问题分析"></a>7.1 问题分析</h3><ul><li>前面我们已经完成了对员工数据的添加与修改，在添加&#x2F;修改员工数据的时候，都需要指定一下创建人、创建时间、修改人、修改时间等字段，而这些字段又属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。</li><li>那我们有没有办法让这些字段在一个地方统一管理呢？这样可以简化我们的开发<ul><li>答案就是使用<code>MybatisPlus</code>给我们提供的公共字段自动填充功能</li></ul></li></ul><h3 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h3><ol><li>在实体类的属性上方加入<code>@TableFiled</code>注解，指定自动填充的策略</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    @TableField(fill &#x3D; FieldFill.INSERT)&#x2F;&#x2F;插入时填充字段值    private LocalDateTime createTime;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)&#x2F;&#x2F;插入和更新时填充字段值    private LocalDateTime updateTime;    @TableField(fill &#x3D; FieldFill.INSERT)&#x2F;&#x2F;插入时填充字段值    private Long createUser;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)&#x2F;&#x2F;插入和更新时填充字段值    private Long updateUser;&#125;</code></pre><ol start="2"><li>按照框架要求编写元数据对象处理器，在此类中统一对公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口<br>实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充<br>关于字段填充方式，使用metaObject的<code>setValue</code>来实现</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        log.info(&quot;公共字段自动填充(insert)...&quot;);        log.info(metaObject.toString());        metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now());        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        log.info(&quot;公共字段自动填充(update)...&quot;);        log.info(metaObject.toString());        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());    &#125;&#125;</code></pre><h3 id="7-3-功能完善"><a href="#7-3-功能完善" class="headerlink" title="7.3 功能完善"></a>7.3 功能完善</h3><ul><li><p>关于id的获取，我们之前是存到session里的，但在<code>MyMetaObjectHandler</code>类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户Id。</p><ul><li>可以使用<code>ThreadLocal</code>来解决这个问题</li></ul></li><li><p>在学习ThreadLocal之前，我们需要先确认一个事情，就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程:</p><ol><li><code>LocalCheekFilter</code>中的<code>doFilter</code>方法</li><li><code>EmployeeController</code>中的<code>update</code>方法</li><li><code>MyMetaObjectHandler</code>中的<code>updateFill</code>方法</li></ol></li></ul><p>那么什么是ThreadLocal?</p><ul><li>ThreadLocal并不是一个Thread，而是<strong>Thread的局部变量</strong></li><li>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本</li><li>所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li></ul><p>ThreadLocal常用方法:</p><ul><li><code>public void set(T value)</code> 设置当前线程的线程局部变量的值</li><li><code>public T get()</code> 返回当前线程所对应的线程局部变量的值</li></ul><p>那么我们如何用ThreadLocal来解决我们上述的问题呢？</p><ul><li>我们可以在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中获取当前登录用户id，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值（用户id)，然后在<code>MyMetaObjectHandler</code>的<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值（用户id)。</li></ul><p>具体实现</p><ul><li>在com.blog.common包下新建BaseContext类</li><li>作用：基于ThreadLocal的封装工具类，用于保护和获取当前用户id</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BaseContext &#123;    &#x2F;&#x2F; 用户保存、获取当前登录用户id    private static ThreadLocal&lt;Long&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;&#125;</code></pre><ul><li>随后在LoginCheckFilter类中添加代码<br>使用<code>request.getSession</code>来获取当前登录用户的id值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;4.判断登录状态，如果已登录，则直接放行if (request.getSession().getAttribute(&quot;employee&quot;) !&#x3D; null) &#123;    log.info(&quot;用户已登录，id为&#123;&#125;&quot;, request.getSession().getAttribute(&quot;employee&quot;));        &#x2F;&#x2F;根据session来获取之前我们存的id值    Long empId &#x3D; (Long) request.getSession().getAttribute(&quot;employee&quot;);    &#x2F;&#x2F;使用BaseContext封装id    BaseContext.setCurrentId(empId);        filterChain.doFilter(request, response);    return;&#125;</code></pre><ul><li>在MyMetaObjectHandler类中，添加设置id的代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        log.info(&quot;公共字段填充（create）...&quot;);        metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now());        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());        &#x2F;&#x2F;设置创建人id        metaObject.setValue(&quot;createUser&quot;, BaseContext.getCurrentId());        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        log.info(&quot;公共字段填充（insert）...&quot;);        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());        &#x2F;&#x2F;设置更新人id        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());    &#125;&#125;</code></pre><h2 id="8-新增菜品分类"><a href="#8-新增菜品分类" class="headerlink" title="8. 新增菜品分类"></a>8. 新增菜品分类</h2><h3 id="8-1-需求分析"><a href="#8-1-需求分析" class="headerlink" title="8.1 需求分析"></a>8.1 需求分析</h3><ul><li>后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类</li><li>当我们在后台系统中添加菜品时，需要选择一个菜品分类</li><li>当我们在后台系统中天啊及一个套餐时，需要选择一个套餐分类</li><li>在移动端也会按照菜品分类和套餐分类来战士对应的菜品和套餐</li></ul><p>可以在后台系统的分类管理页面分别添加菜品分类和套餐分类，如下:</p><p>分类管理页面</p><p><img src="image-20231003171449686.png" alt="image-20231003171449686"></p><p>新增菜品分类表单</p><p><img src="image-20231003171506896.png" alt="image-20231003171506896"></p><p>新增套餐分类表单</p><p><img src="image-20231003171539212.png" alt="image-20231003171539212"></p><h3 id="8-2-数据模型"><a href="#8-2-数据模型" class="headerlink" title="8.2 数据模型"></a>8.2 数据模型</h3><p>简单浏览一下category表中的数据</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center">类型 1 菜品分类 2 套餐分类</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">分类名称</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr></tbody></table><p>id是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类</p><h3 id="8-3-准备工作"><a href="#8-3-准备工作" class="headerlink" title="8.3 准备工作"></a>8.3 准备工作</h3><p>在开发业务之前，先将需要用到的类和接口的基本结构先创建好</p><ol><li>实体类Category，对应上表来创建<br>菜品分类也有<code>createUser</code>和<code>createTime</code>等字段，也可以用上面的公共字段自动填充</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Category implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    private Long id;    &#x2F;&#x2F;类型 1 菜品分类 2 套餐分类    private Integer type;    &#x2F;&#x2F;分类名称    private String name;    &#x2F;&#x2F;顺序    private Integer sort;    &#x2F;&#x2F;创建时间    @TableField(fill &#x3D; FieldFill.INSERT)    private LocalDateTime createTime;    &#x2F;&#x2F;更新时间    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    &#x2F;&#x2F;创建人    @TableField(fill &#x3D; FieldFill.INSERT)    private Long createUser;    &#x2F;&#x2F;修改人    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private Long updateUser;&#125;</code></pre><ol start="2"><li>Mapper接口CategoryMapper</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;&#125;</code></pre><ol start="3"><li>业务层接口CategoryService</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; &#123;&#125;</code></pre><ol start="4"><li>业务层实现类CatrgoryServiceImpl</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;&#125;</code></pre><ol start="5"><li>控制层CategoryController</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Slf4j@RestController@RequestMapping(&quot;&#x2F;category&quot;)public class CategoryController &#123;    @Autowired    private CategoryService categoryService;&#125;</code></pre><h3 id="8-4-流程分析"><a href="#8-4-流程分析" class="headerlink" title="8.4 流程分析"></a>8.4 流程分析</h3><p>在编写代码之前，我们还是先来分析一下整个流程</p><ol><li>页面发送ajax请求，将新增分类窗口输入的数据以json形式提交给服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据存储到数据库</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231003173637383.png" alt="image-20231003173637383"></p><h3 id="8-5-代码实现"><a href="#8-5-代码实现" class="headerlink" title="8.5 代码实现"></a>8.5 代码实现</h3><p>服务端只需要将接收到的json数据添加到数据库中，并响应一个成功的提示信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody Category category) &#123;    log.info(&quot;category:&#123;&#125;&quot;, category);    categoryService.save(category);    return Result.success(&quot;新增分类成功&quot;);&#125;</code></pre><h2 id="9-分类信息分页查询"><a href="#9-分类信息分页查询" class="headerlink" title="9. 分类信息分页查询"></a>9. 分类信息分页查询</h2><p>与之前的员工信息分页查询类似</p><h3 id="9-1-流程分析"><a href="#9-1-流程分析" class="headerlink" title="9.1 流程分析"></a>9.1 流程分析</h3><p>按照惯例，我们还是先来分析一下流程</p><ol><li>页面发送Ajax请求，将分页查询的参数（page、pageSize）提交到服务端</li><li>服务端Controller接受到页面提交的数据之后，调用Service进行查询</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收分页数据，并通过ElementUI的Table组件战士到页面上</li></ol><p><img src="image-20231003174931272.png" alt="image-20231003174931272"></p><h3 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h3><p>在CategoryController类中编写page方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;page&quot;)public Result&lt;Page&gt; page(int page, int pageSize) &#123;    &#x2F;&#x2F;分页构造器    Page&lt;Category&gt; pageInfo &#x3D; new Page&lt;&gt;(page, pageSize);    &#x2F;&#x2F;条件查询器    LambdaQueryWrapper&lt;Category&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加排序条件    queryWrapper.orderByDesc(Category::getSort);    &#x2F;&#x2F;分页查询    categoryService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);&#125;</code></pre><h2 id="10-删除分类"><a href="#10-删除分类" class="headerlink" title="10. 删除分类"></a>10. 删除分类</h2><h3 id="10-1-需求分析"><a href="#10-1-需求分析" class="headerlink" title="10.1 需求分析"></a>10.1 需求分析</h3><ul><li>在分类管理列表页面，可以对某个分类进行删除操作</li><li>需要注意的是：当分类关联了菜品或者套餐时，此分类将不允许被删除</li></ul><h3 id="10-2-流程分析"><a href="#10-2-流程分析" class="headerlink" title="10.2 流程分析"></a>10.2 流程分析</h3><p>按照惯例，继续分析一遍流程</p><ol><li>页面发送ajax请求，将参数(id)提交给服务端</li><li>服务端Controller接收页面提交的数据，并调用Service删除数据</li><li>Service调用Mapper操作数据库</li></ol><p><img src="image-20231003181059718.png" alt="image-20231003181059718"></p><h3 id="10-3-前端代码分析"><a href="#10-3-前端代码分析" class="headerlink" title="10.3 前端代码分析"></a>10.3 前端代码分析</h3><p>删除按钮绑定了<code>deleteHandle</code>函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">HTML&lt;el-button    type&#x3D;&quot;text&quot;    size&#x3D;&quot;small&quot;    class&#x3D;&quot;delBut non&quot;    @click&#x3D;&quot;deleteHandle(scope.row.id)&quot;&gt;    删除&lt;&#x2F;el-button&gt;deleteHandle(id) &#123;    this.$confirm(&#39;此操作将永久删除该文件, 是否继续?&#39;, &#39;提示&#39;, &#123;        &#39;confirmButtonText&#39;: &#39;确定&#39;,        &#39;cancelButtonText&#39;: &#39;取消&#39;,        &#39;type&#39;: &#39;warning&#39;    &#125;).then(() &#x3D;&gt; &#123;        deleCategory(id).then(res &#x3D;&gt; &#123;        if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;            this.$message.success(&#39;删除成功！&#39;)            this.handleQuery()        &#125; else &#123;            this.$message.error(res.msg || &#39;操作失败&#39;)        &#125;        &#125;).catch(err &#x3D;&gt; &#123;        this.$message.error(&#39;请求出错了：&#39; + err)        &#125;)    &#125;)&#125;&#x2F;&#x2F; 删除当前列的接口const deleCategory &#x3D; (id) &#x3D;&gt; &#123;  return $axios(&#123;    url: &#39;&#x2F;category&#39;,    method: &#39;delete&#39;,    params: &#123;id&#125;  &#125;)&#125;</code></pre><h3 id="10-4-代码实现"><a href="#10-4-代码实现" class="headerlink" title="10.4 代码实现"></a>10.4 代码实现</h3><p>在CategoryController类上添加delete方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingprivate Result&lt;String&gt; delete(Long id) &#123;    log.info(&quot;将被删除的id：&#123;&#125;&quot;, id);    categoryService.removeById(id);    return Result.success(&quot;分类信息删除成功&quot;);&#125;</code></pre><h3 id="10-5-功能完善"><a href="#10-5-功能完善" class="headerlink" title="10.5 功能完善"></a>10.5 功能完善</h3><p>当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除</p><ul><li>那么我们如何实现这个功能呢？<ul><li>其实也很简单，我们只需要在删除的时候，拿着当前分类的id值，去对应的菜品&#x2F;套餐表中进行查询，如果能查询到数据，则说明该分类关联了菜品，不允许被删除，否则则可以删除</li></ul></li></ul><p>那么明确了思路之后，我们就来写代码</p><ul><li>首先我们需要根据数据表创建菜品和套餐对应的模型类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 菜品 *&#x2F;@Datapublic class Dish implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    private Long id;    &#x2F;&#x2F;菜品名称    private String name;    &#x2F;&#x2F;菜品分类id    private Long categoryId;    &#x2F;&#x2F;菜品价格    private BigDecimal price;    &#x2F;&#x2F;商品码    private String code;    &#x2F;&#x2F;图片    private String image;    &#x2F;&#x2F;描述信息    private String description;    &#x2F;&#x2F;0 停售 1 起售    private Integer status;    &#x2F;&#x2F;顺序    private Integer sort;    @TableField(fill &#x3D; FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill &#x3D; FieldFill.INSERT)    private Long createUser;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private Long updateUser;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 套餐 *&#x2F;@Datapublic class Setmeal implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    private Long id;    &#x2F;&#x2F;分类id    private Long categoryId;    &#x2F;&#x2F;套餐名称    private String name;    &#x2F;&#x2F;套餐价格    private BigDecimal price;    &#x2F;&#x2F;状态 0:停用 1:启用    private Integer status;    &#x2F;&#x2F;编码    private String code;    &#x2F;&#x2F;描述信息    private String description;    &#x2F;&#x2F;图片    private String image;    @TableField(fill &#x3D; FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill &#x3D; FieldFill.INSERT)    private Long createUser;    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)    private Long updateUser;&#125;</code></pre><ul><li><p>随后编写对应的Mapper接口</p></li><li><p>编写对应的Service接口及Impl实现类</p></li><li><p>在common包下新增<code>CustomException</code>类<br>该类用于<strong>封装我们的自定义异常</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CustomException extends RuntimeException&#123;    public CustomException(String msg)&#123;        super(msg);    &#125;&#125;</code></pre><ul><li>在我们的全局异常处理器类中，使用<code>exceptionHandler</code>处理<code>CustomerException</code>异常</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ExceptionHandler(CustomException.class)public Result&lt;String&gt; exceptionHandler(CustomException ex) &#123;    log.error(ex.getMessage());    return Result.error(ex.getMessage());&#125;</code></pre><ul><li>在CategoryService接口中自己写一个<code>remove</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; &#123;    void remove(Long id);&#125;</code></pre><ul><li>在CategoryServiceImpl中来写具体业务逻辑<br>我们需要在删除数据之前，根据<code>id</code>值，去<code>Dish</code>表和<code>Setmeal</code>表中查询是否关联了数据<br>如果存在关联数据，则不能删除，并抛一个异常<br>如果不存在关联数据（也就是查询到的数据条数为0），正常删除即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service@Slf4jpublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;    @Autowired    DishService dishService;    @Autowired    SetmealService setmealService;    &#x2F;**     * 根据id删除分类，删除之前需要进行判断     * @param id     *&#x2F;    @Override    public void remove(Long id) &#123;        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;添加dish查询条件，根据分类id进行查询        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);        int count1 &#x3D; dishService.count(dishLambdaQueryWrapper);        &#x2F;&#x2F;方便Debug用的        log.info(&quot;dish查询条件，查询到的条目数为：&#123;&#125;&quot;,count1);        &#x2F;&#x2F;查看当前分类是否关联了菜品，如果已经关联，则抛出异常        if (count1 &gt; 0)&#123;            &#x2F;&#x2F;已关联菜品，抛出一个业务异常            throw new CustomException(&quot;当前分类下关联了菜品，不能删除&quot;);        &#125;        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;添加dish查询条件，根据分类id进行查询        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);        int count2 &#x3D; setmealService.count(setmealLambdaQueryWrapper);        &#x2F;&#x2F;方便Debug用的        log.info(&quot;setmeal查询条件，查询到的条目数为：&#123;&#125;&quot;,count2);        &#x2F;&#x2F;查看当前分类是否关联了套餐，如果已经关联，则抛出异常        if (count2 &gt; 0)&#123;            &#x2F;&#x2F;已关联套餐，抛出一个业务异常            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);        &#125;                &#x2F;&#x2F;正常删除        super.removeById(id);    &#125;&#125;</code></pre><ul><li>最后记得在controller中调用我们新写的remove方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; delete(Long id)&#123;    log.info(&quot;将要删除的分类id:&#123;&#125;&quot;,id);    categoryService.remove(id);    return Result.success(&quot;分类信息删除成功&quot;);&#125;</code></pre><h2 id="11-修改分类"><a href="#11-修改分类" class="headerlink" title="11. 修改分类"></a>11. 修改分类</h2><h3 id="11-1-需求分析"><a href="#11-1-需求分析" class="headerlink" title="11.1 需求分析"></a>11.1 需求分析</h3><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p><p><img src="20230412035047_459.jpg" alt="img"></p><h3 id="11-2-前端分析"><a href="#11-2-前端分析" class="headerlink" title="11.2 前端分析"></a>11.2 前端分析</h3><p>数据回显</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type&#x3D;&quot;text&quot;    size&#x3D;&quot;small&quot;    class&#x3D;&quot;blueBug&quot;    @click&#x3D;&quot;editHandle(scope.row)&quot;&gt;    修改&lt;&#x2F;el-button&gt;        editHandle(dat) &#123;    this.classData.title &#x3D; &#39;修改分类&#39;    this.action &#x3D; &#39;edit&#39;    this.classData.name &#x3D; dat.name    this.classData.sort &#x3D; dat.sort    this.classData.id &#x3D; dat.id    this.classData.dialogVisible &#x3D; true&#125;classData: &#123;    &#39;title&#39;: &#39;添加菜品分类&#39;,    &#39;dialogVisible&#39;: false,    &#39;categoryId&#39;: &#39;&#39;,    &#39;name&#39;: &#39;&#39;,    sort: &#39;&#39;&#125;&#x2F;&#x2F; 数据双向绑定，回显&lt;el-form    class&#x3D;&quot;demo-form-inline&quot;    label-width&#x3D;&quot;100px&quot;    &gt;    &lt;el-form-item label&#x3D;&quot;分类名称：&quot;&gt;        &lt;el-input            v-model&#x3D;&quot;classData.name&quot; &#x2F;&#x2F;这里            placeholder&#x3D;&quot;请输入分类名称&quot;            maxlength&#x3D;&quot;14&quot;        &#x2F;&gt;    &lt;&#x2F;el-form-item&gt;    &lt;el-form-item label&#x3D;&quot;排序：&quot;&gt;        &lt;el-input v-model&#x3D;&quot;classData.sort&quot;  type&#x3D;&quot;number&quot; placeholder&#x3D;&quot;请输入排序&quot; &#x2F;&gt; &#x2F;&#x2F;这里    &lt;&#x2F;el-form-item&gt;&lt;&#x2F;el-form&gt;</code></pre><p>数据提交是采用的一个通用的<code>submitForm</code>函数，由于我们是修改操作，所以直接从<code>else</code>开始往后看就行了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;数据提交submitForm(st) &#123;    const classData &#x3D; this.classData    const valid &#x3D; (classData.name &#x3D;&#x3D;&#x3D; 0 ||classData.name)  &amp;&amp; (classData.sort &#x3D;&#x3D;&#x3D; 0 || classData.sort)    if (this.action &#x3D;&#x3D;&#x3D; &#39;add&#39;) &#123;        if (valid) &#123;            const reg &#x3D; &#x2F;^\d+$&#x2F;            if (reg.test(classData.sort)) &#123;            addCategory(&#123;&#39;name&#39;: classData.name,&#39;type&#39;:this.type, sort: classData.sort&#125;).then(res &#x3D;&gt; &#123;                console.log(res)                if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                this.$message.success(&#39;分类添加成功！&#39;)                if (!st) &#123;                    this.classData.dialogVisible &#x3D; false                &#125; else &#123;                    this.classData.name &#x3D; &#39;&#39;                    this.classData.sort &#x3D; &#39;&#39;                &#125;                this.handleQuery()                &#125; else &#123;                this.$message.error(res.msg || &#39;操作失败&#39;)                &#125;            &#125;).catch(err &#x3D;&gt; &#123;                this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)            &#125; else &#123;            this.$message.error(&#39;排序只能输入数字类型&#39;)            &#125;        &#125; else &#123;            this.$message.error(&#39;请输入分类名称或排序&#39;)        &#125;    &#125; else if (valid) &#123;        const reg &#x3D; &#x2F;^\d+$&#x2F;        if (reg.test(this.classData.sort)) &#123;            editCategory(&#123;&#39;id&#39;:this.classData.id,&#39;name&#39;: this.classData.name, sort: this.classData.sort&#125;).then(res &#x3D;&gt; &#123;                if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                    this.$message.success(&#39;分类修改成功！&#39;)                    this.classData.dialogVisible &#x3D; false                    this.handleQuery()                &#125; else &#123;                    this.$message.error(res.msg || &#39;操作失败&#39;)                &#125;            &#125;).catch(err &#x3D;&gt; &#123;                    this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)        &#125; else &#123;            this.$message.error(&#39;排序只能输入数字类型&#39;)        &#125;    &#125; else &#123;        this.$message.error(&#39;请输入分类名称或排序&#39;)    &#125;&#125;&#x2F;&#x2F; 修改接口const editCategory &#x3D; (params) &#x3D;&gt; &#123;  return $axios(&#123;    url: &#39;&#x2F;category&#39;,    method: &#39;put&#39;,    data: &#123; ...params &#125;  &#125;)&#125;</code></pre><h3 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Category category) &#123;    log.info(&quot;修改分类信息为：&#123;&#125;&quot;, category);    categoryService.updateById(category);    return Result.success(&quot;修改分类信息成功&quot;);&#125;</code></pre><h1 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h1><p><img src="image-20231004112854643.png" alt="image-20231004112854643"></p><h2 id="12-文件上传与下载"><a href="#12-文件上传与下载" class="headerlink" title="12. 文件上传与下载"></a>12. 文件上传与下载</h2><h3 id="12-1-文件上传简介"><a href="#12-1-文件上传简介" class="headerlink" title="12.1 文件上传简介"></a>12.1 文件上传简介</h3><ul><li><p>文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程</p></li><li><p>文件上传时，对页面的form表单有如下要求：</p><ol><li><code>method=&quot;post&quot;</code>，采用post方式提交数据</li><li><code>enctype=&quot;multipart/form-data&quot;</code>，采用multipart格式上传文件</li><li><code>type=&quot;file&quot;</code>，使用input的file控件上传</li></ol></li><li><p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传，这里我们就用提供好的组件就行了<br>我们把这段代码放在<code>backend/demo</code>目录下，命名为<code>upload.html</code></p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;  &lt;title&gt;文件上传&lt;&#x2F;title&gt;  &lt;!-- 引入样式 --&gt;  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;..&#x2F;plugins&#x2F;element-ui&#x2F;index.css&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;..&#x2F;styles&#x2F;common.css&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;..&#x2F;styles&#x2F;page.css&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;   &lt;div class&#x3D;&quot;addBrand-container&quot; id&#x3D;&quot;food-add-app&quot;&gt;    &lt;div class&#x3D;&quot;container&quot;&gt;        &lt;el-upload class&#x3D;&quot;avatar-uploader&quot;                action&#x3D;&quot;&#x2F;common&#x2F;upload&quot;                :show-file-list&#x3D;&quot;false&quot;                :on-success&#x3D;&quot;handleAvatarSuccess&quot;                :before-upload&#x3D;&quot;beforeUpload&quot;                ref&#x3D;&quot;upload&quot;&gt;            &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;avatar&quot;&gt;&lt;&#x2F;img&gt;            &lt;i v-else class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt;        &lt;&#x2F;el-upload&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;    &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;plugins&#x2F;vue&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;plugins&#x2F;element-ui&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- 引入axios --&gt;    &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;plugins&#x2F;axios&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;      new Vue(&#123;        el: &#39;#food-add-app&#39;,        data() &#123;          return &#123;            imageUrl: &#39;&#39;          &#125;        &#125;,        methods: &#123;          handleAvatarSuccess (response, file, fileList) &#123;              this.imageUrl &#x3D; &#96;&#x2F;common&#x2F;download?name&#x3D;$&#123;response.data&#125;&#96;          &#125;,          beforeUpload (file) &#123;            if(file)&#123;              const suffix &#x3D; file.name.split(&#39;.&#39;)[1]              const size &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 2              if([&#39;png&#39;,&#39;jpeg&#39;,&#39;jpg&#39;].indexOf(suffix) &lt; 0)&#123;                this.$message.error(&#39;上传图片只支持 png、jpeg、jpg 格式！&#39;)                this.$refs.upload.clearFiles()                return false              &#125;              if(!size)&#123;                this.$message.error(&#39;上传文件大小不能超过 2MB!&#39;)                return false              &#125;              return file            &#125;          &#125;        &#125;      &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:<ul><li><code>commons-fileupload</code></li><li><code>commons-io</code></li></ul></li><li>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中<strong>声明一个MultipartFile类型的参数</strong>即可接收上传的文件，例如</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;common&quot;)@Slf4jpublic class CommonController &#123;    @PostMapping(&quot;&#x2F;upload&quot;)    public Result&lt;String&gt; upload(MultipartFile file) &#123;        log.info(&quot;获取文件：&#123;&#125;&quot;, file.toString());        return null;    &#125;&#125;</code></pre><h3 id="12-2-文件下载简介"><a href="#12-2-文件下载简介" class="headerlink" title="12.2 文件下载简介"></a>12.2 文件下载简介</h3><ul><li>文件下载，也成为了download，是指将文件从服务器传输到本地计算机的过程</li><li>通过浏览器进行文件下载，通常有两种表现形式<ol><li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li><li>直接在浏览器中打开</li></ol></li><li>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程</li></ul><h3 id="12-3-文件上传代码实现"><a href="#12-3-文件上传代码实现" class="headerlink" title="12.3 文件上传代码实现"></a>12.3 文件上传代码实现</h3><p>将我们上传的临时文件<strong>转存到指定位置</strong></p><ul><li><p>文件转存的位置改为动态可配置的，通过配置文件的方式指定，我们在application.yml文件中加入以下内容</p><ul><li><pre><code class="yml">reggie:  path: D:\\reggie\\imgs\\<pre class="line-numbers language-none"><code class="language-none">- 使用 @Value(“$&#123;reggie.path&#125;”)读取到配置文件中的动态转存位置- 使用uuid方式重新生成文件名，避免文件名重复造成文件覆盖- 通过获取原文件名来截取文件后缀&#96;&#96;&#96;java@RestController@RequestMapping(&quot;&#x2F;common&quot;)@Slf4jpublic class CommonController &#123;    &#x2F;&#x2F;导入yml中配置的属性    @Value(&quot;$&#123;reggie.path&#125;&quot;)    private String basepath;    @PostMapping(&quot;&#x2F;upload&quot;)    &#x2F;&#x2F;file是个临时文件，我们在断点调试的时候可以看到，但是执行完整个方法之后就消失了    public Result&lt;String&gt; upload(MultipartFile file) &#123;        log.info(&quot;获取文件：&#123;&#125;&quot;, file.toString());        &#x2F;&#x2F;判断一下当前目录是否存在，不存在则创建        File dir &#x3D; new File(basepath);        if (!dir.exists()) &#123;            dir.mkdirs();        &#125;        &#x2F;&#x2F;获取一下传入的原文件名        String originalFilename &#x3D; file.getOriginalFilename();        &#x2F;&#x2F;我们只需要获取一下格式后缀，取子串，起始点为最后一个.        String suffix &#x3D; originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));        &#x2F;&#x2F;为了防止出现重复的文件名，我们需要使用UUID        String fileName &#x3D; UUID.randomUUID() + suffix;        try &#123;            &#x2F;&#x2F;我们将其转存到我们的指定目录下            file.transferTo(new File(basepath + fileName));        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;        &#x2F;&#x2F;将文件名返回给前端，便于后期的开发        return Result.success(fileName);    &#125;&#125;</code></pre></code></pre></li></ul></li></ul><h3 id="12-4-文件下载代码实现"><a href="#12-4-文件下载代码实现" class="headerlink" title="12.4 文件下载代码实现"></a>12.4 文件下载代码实现</h3><ul><li>前端页面的ElementUI的upload组件会在上传完图片后，触发img组件发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;el-upload class&#x3D;&quot;avatar-uploader&quot;        action&#x3D;&quot;&#x2F;common&#x2F;upload&quot;        :show-file-list&#x3D;&quot;false&quot;        :on-success&#x3D;&quot;handleAvatarSuccess&quot;        :before-upload&#x3D;&quot;beforeUpload&quot;        ref&#x3D;&quot;upload&quot;&gt;    &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;avatar&quot;&gt;&lt;&#x2F;img&gt;    &lt;i v-else class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;el-upload&gt;</code></pre><ul><li>定义前端发送回显图片请求的地址<br>通过这个url我们可以看出，请求路径为<code>/common/download</code>，且发送的是GET请求</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">handleAvatarSuccess (response, file, fileList) &#123;    this.imageUrl &#x3D; &#96;&#x2F;common&#x2F;download?name&#x3D;$&#123;response.data&#125;&#96;&#125;</code></pre><h2 id="13-新增菜品"><a href="#13-新增菜品" class="headerlink" title="13. 新增菜品"></a>13. 新增菜品</h2><h3 id="13-1-需求分析"><a href="#13-1-需求分析" class="headerlink" title="13.1 需求分析"></a>13.1 需求分析</h3><ol><li>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品</li><li>在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传当前的菜品图片</li><li>在移动端会按照菜品分类来展示对应的菜品信息（前端的活儿，跟咱没啥太大关系）</li></ol><p><img src="image-20231004164529518.png" alt="image-20231004164529518"></p><h3 id="13-2-数据模型"><a href="#13-2-数据模型" class="headerlink" title="13.2 数据模型"></a>13.2 数据模型</h3><p>dish表，最后一条字段is_deleted是逻辑删除</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">菜品名称</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品价格</td></tr><tr><td align="center">code</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">商品码</td></tr><tr><td align="center">image</td><td align="center">varchar(200)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">description</td><td align="center">varchar(400)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">0 停售 1 起售</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><p>dish_flavor表</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味名称</td></tr><tr><td align="center">value</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味数据list</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="13-3-代码开发"><a href="#13-3-代码开发" class="headerlink" title="13.3 代码开发"></a>13.3 代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>按照惯例，在开发代码之前，我们先来梳理一下整个流程</p><ol><li>页面（backend&#x2F;page&#x2F;food&#x2F;add.html）发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器</li><li>页面发送请求进行图片下载，并回显上传的图片</li><li>点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</li></ol><p>所以开发新增菜品功能，其实就是在服务端编写代码去处理前端发送的这4次请求即可</p><h4 id="查询菜品分类数据"><a href="#查询菜品分类数据" class="headerlink" title="查询菜品分类数据"></a>查询菜品分类数据</h4><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() &#123;    this.getDishList()    &#x2F;&#x2F; 口味临时数据    this.getFlavorListHand()    this.id &#x3D; requestUrlParam(&#39;id&#39;)    this.actionType &#x3D; this.id ? &#39;edit&#39; : &#39;add&#39;    if (this.id) &#123;    this.init()    &#125;&#125;getDishList () &#123;    getCategoryList(&#123; &#39;type&#39;: 1 &#125;).then(res &#x3D;&gt; &#123;        if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;        this.dishList &#x3D; res.data        &#125; else &#123;        this.$message.error(res.msg || &#39;操作失败&#39;)        &#125;    &#125;)&#125;&#x2F;&#x2F; 获取菜品分类列表const getCategoryList &#x3D; (params) &#x3D;&gt; &#123;  return $axios(&#123;    url: &#39;&#x2F;category&#x2F;list&#39;,    method: &#39;get&#39;,    params  &#125;)&#125;&#x2F;&#x2F;下拉框&lt;el-select    v-model&#x3D;&quot;ruleForm.categoryId&quot;    placeholder&#x3D;&quot;请选择菜品分类&quot;&gt;    &lt;el-option v-for&#x3D;&quot;(item,index) in dishList&quot; :key&#x3D;&quot;index&quot; :label&#x3D;&quot;item.name&quot; :value&#x3D;&quot;item.id&quot; &#x2F;&gt;&lt;&#x2F;el-select&gt;</code></pre><ul><li>后端实现</li></ul><p>在<code>CategoryController</code>类中，添加list方法<br>我们只需要发送get请求，将数据返回给前端即可，操作很简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;Category&gt;&gt; list(Category category) &#123;    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;Category&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加条件，这里只需要判断是否为菜品（type为1是菜品，type为2是套餐）    queryWrapper.eq(category.getType() !&#x3D; null,Category::getType,category.getType());    &#x2F;&#x2F;添加排序条件    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);    &#x2F;&#x2F;查询数据    List&lt;Category&gt; list &#x3D; categoryService.list(queryWrapper);    &#x2F;&#x2F;返回数据    return Result.success(list);&#125;</code></pre><h4 id="接收与回显图片"><a href="#接收与回显图片" class="headerlink" title="接收与回显图片"></a>接收与回显图片</h4><p>这个功能再刚刚我们已经实现了，到现在可以直接用</p><h4 id="提交数据到服务端"><a href="#提交数据到服务端" class="headerlink" title="提交数据到服务端"></a>提交数据到服务端</h4><p><img src="20230412045403_688.jpg" alt="img"></p><ul><li>接收数据分析</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;name: &quot;啊&quot;, price: 32100, code: &quot;&quot;, image: &quot;1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg&quot;,…&#125;categoryId:&quot;1397844263642378242&quot;code:&quot;&quot;description:&quot;好吃的彩虹&quot;flavors:[&#123;name: &quot;甜味&quot;, value: &quot;[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;,&quot;多糖&quot;,&quot;全糖&quot;]&quot;, showOption: false&#125;,…]0:&#123;name: &quot;甜味&quot;, value: &quot;[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;,&quot;多糖&quot;,&quot;全糖&quot;]&quot;, showOption: false&#125;1:&#123;name: &quot;温度&quot;, value: &quot;[&quot;热饮&quot;,&quot;常温&quot;,&quot;去冰&quot;,&quot;少冰&quot;,&quot;多冰&quot;]&quot;, showOption: false&#125;image:&quot;1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg&quot;name:&quot;啊&quot;price:32100status:1</code></pre><ul><li>因为Dish实体类无法接收flavor参数，即需要导入DishDto，用于封装页面提交的数据</li><li>DTO，全称为<code>Data Transfer Object</code>，即数据传输对象，一般用于展示层与服务层之间的数据传输。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class DishDto extends Dish &#123;    private List&lt;DishFlavor&gt; flavors &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F;后面这两条属性暂时没用，这里只需要用第一条属性    private String categoryName;    private Integer copies;&#125;</code></pre><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">submitForm(formName, st) &#123;    this.$refs[formName].validate((valid) &#x3D;&gt; &#123;        if (valid) &#123;        let params &#x3D; &#123;...this.ruleForm&#125;        &#x2F;&#x2F; params.flavors &#x3D; this.dishFlavors        params.status &#x3D; this.ruleForm ? 1 : 0        params.price *&#x3D; 100        params.categoryId &#x3D; this.ruleForm.categoryId        params.flavors &#x3D; this.dishFlavors.map(obj &#x3D;&gt; (&#123; ...obj, value: JSON.stringify(obj.value) &#125;))        delete params.dishFlavors        if(!this.imageUrl)&#123;            this.$message.error(&#39;请上传菜品图片&#39;)            return         &#125;        if (this.actionType &#x3D;&#x3D; &#39;add&#39;) &#123;            delete params.id            addDish(params).then(res &#x3D;&gt; &#123;            if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                this.$message.success(&#39;菜品添加成功！&#39;) &#x2F;&#x2F;这里                if (!st) &#123;                this.goBack()                &#125; else &#123;                this.dishFlavors &#x3D; []                &#x2F;&#x2F; this.dishFlavorsData &#x3D; []                this.imageUrl &#x3D; &#39;&#39;                this.ruleForm &#x3D; &#123;                    &#39;name&#39;: &#39;&#39;,                    &#39;id&#39;: &#39;&#39;,                    &#39;price&#39;: &#39;&#39;,                    &#39;code&#39;: &#39;&#39;,                    &#39;image&#39;: &#39;&#39;,                    &#39;description&#39;: &#39;&#39;,                    &#39;dishFlavors&#39;: [],                    &#39;status&#39;: true,                    categoryId: &#39;&#39;                &#125;                &#125;            &#125; else &#123;                this.$message.error(res.msg || &#39;操作失败&#39;)            &#125;            &#125;).catch(err &#x3D;&gt; &#123;            this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)        &#125; else &#123;            delete params.updateTime            editDish(params).then(res &#x3D;&gt; &#123;            if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;                this.$message.success(&#39;菜品修改成功！&#39;)                this.goBack()            &#125; else &#123;                this.$message.error(res.msg || &#39;操作失败&#39;)            &#125;            &#125;).catch(err &#x3D;&gt; &#123;            this.$message.error(&#39;请求出错了：&#39; + err)            &#125;)        &#125;        &#125; else &#123;        return false        &#125;    &#125;)&#125;&#x2F;&#x2F; 新增接口const addDish &#x3D; (params) &#x3D;&gt; &#123;  return $axios(&#123;    url: &#39;&#x2F;dish&#39;,    method: &#39;post&#39;,    data: &#123; ...params &#125;  &#125;)&#125;</code></pre><ul><li>后端实现</li></ul><p>在<code>DishController</code>类中添加<code>save</code>方法，重启服务器，断点调试一下看看是否封装好了数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;    log.info(&quot;接收到的数据为：&#123;&#125;&quot;,dishDto);    return null;&#125;</code></pre><p><img src="20230412063714_358.jpg" alt="img"></p><p>从图中我们可以看出，DishFlavor 中的 dishId 为 null<br>但是我们需要对 DishFlavor 中的 dishId 进行赋值<br>所以我们要取出 dishDto 的 dishId，然后对每一组 flavor 的 dishId 赋值</p><ul><li>这里进行一下小结，我们需要做的有以下几点<ul><li>将菜品数据保存到<code>dish</code>表</li><li>将菜品口味数据保存到<code>dish_flavor </code>表<ul><li>但是<code>dish_flavor</code>表中需要一个<code>dishId</code>字段值，这个字段值需要我们从<code>dishDto</code>中获取</li><li>获取方式为：取出<code>dishDto</code>的<code>dishId</code>，对每一组<code>flavor</code>的<code>dishId</code>赋值</li></ul></li></ul></li><li>梳理完毕之后，那么我们就在<code>DishFlavorService</code>中编写一个<code>saveWithFlavor</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface DishService extends IService&lt;Dish&gt; &#123;    void saveWithFlavor(DishDto dishDto);&#125;</code></pre><ul><li>同时在<code>DishFlavorServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123;    @Autowired    private DishFlavorService dishFlavorService;    @Override    @Transactional &#x2F;&#x2F; 涉及多表联查，开启事务管理，同时需要在启动类上加入@EnableTransactionManagement    public void saveWithFlavor(DishDto dishDto) &#123;        &#x2F;&#x2F;将菜品数据保存到dish表        this.save(dishDto);        &#x2F;&#x2F;获取dishId        Long dishId &#x3D; dishDto.getId();        &#x2F;&#x2F;将获取到的dishId赋值给dishFlavor的dishId属性        List&lt;DishFlavor&gt; flavors &#x3D; dishDto.getFlavors();        for (DishFlavor dishFlavor : flavors) &#123;            dishFlavor.setDishId(dishId);        &#125;        &#x2F;&#x2F;同时将菜品口味数据保存到dish_flavor表        dishFlavorService.saveBatch(flavors);    &#125;&#125;</code></pre><h2 id="14-菜品信息分页查询"><a href="#14-菜品信息分页查询" class="headerlink" title="14. 菜品信息分页查询"></a>14. 菜品信息分页查询</h2><h3 id="14-1-需求分析"><a href="#14-1-需求分析" class="headerlink" title="14.1 需求分析"></a>14.1 需求分析</h3><ul><li>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>所以一般的系统中都会以分页的方式来展示列表数据。</li><li>其中图片列和菜品分类列比较特殊<ul><li>图片列：会用到文件的下载功能</li><li>菜品分类列：由于我们的菜品表只保存了category_id，所以我们需要查询category_id对应的菜品分类名称，从而回显数据</li></ul></li></ul><p><img src="20230412065920_105.jpg" alt="img"></p><h3 id="14-2-梳理交互过程"><a href="#14-2-梳理交互过程" class="headerlink" title="14.2 梳理交互过程"></a>14.2 梳理交互过程</h3><p>按照惯例，我们还是先来梳理一遍流程</p><ol><li>页面(backend&#x2F;page&#x2F;food&#x2F;list.html)发送ajax请求，将分页查询参数(<code>page</code>、<code>pageSize</code>、<code>name</code>)，提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示</li></ol><p>那么开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p><h3 id="14-3-代码开发"><a href="#14-3-代码开发" class="headerlink" title="14.3 代码开发"></a>14.3 代码开发</h3><ul><li>在<code>DishController</code>下添加<code>page</code>方法，进行分页查询</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;page&quot;)public Result&lt;Page&gt; page(int page, int pageSize, String name) &#123;    &#x2F;&#x2F;构造分页构造器对象    Page&lt;Dish&gt; pageInfo &#x3D; new Page&lt;&gt;(page, pageSize);    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加条件    queryWrapper.like(name !&#x3D; null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    &#x2F;&#x2F;执行分页查询    dishService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);&#125;</code></pre><ul><li>由于有菜品分类数据<ul><li>我们传递的是一个Dish对象，dish对象没有菜品分类名称属性，但是有菜品分类id</li><li>那我们就可以根据这个菜品分类id，去菜品分类表中查询对应的菜品分类名称</li></ul></li><li>所以我们之前的DishDto类中的另外一个属性就派上用场了，我们返回一个DishDto对象就有菜品分类名称数据了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;page&quot;)public Result&lt;Page&gt; page(int page, int pageSize, String name) &#123;    &#x2F;&#x2F;构造分页构造器对象    Page&lt;Dish&gt; pageInfo &#x3D; new Page&lt;&gt;(page, pageSize);    &#x2F;&#x2F;这个就是我们到时候返回的结果    Page&lt;DishDto&gt; dishDtoPage &#x3D; new Page&lt;&gt;(page, pageSize);        &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加条件    queryWrapper.like(name !&#x3D; null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    &#x2F;&#x2F;执行分页查询    dishService.page(pageInfo, queryWrapper);&#x2F;&#x2F;结果为pageInfo    &#x2F;&#x2F;对象拷贝，这里只需要拷贝一下查询到的条目数    BeanUtils.copyProperties(pageInfo, dishDtoPage, &quot;records&quot;);&#x2F;&#x2F; 忽略结果数据集records    &#x2F;&#x2F;获取原records数据    List&lt;Dish&gt; records &#x3D; pageInfo.getRecords();    &#x2F;&#x2F;遍历records的每一条Dish数据，为categoryName赋值，封装成DishDto数据    List&lt;DishDto&gt; list &#x3D; records.stream().map((item) -&gt; &#123;        DishDto dishDto &#x3D; new DishDto();        &#x2F;&#x2F;将数据赋给dishDto对象        BeanUtils.copyProperties(item, dishDto);        &#x2F;&#x2F;然后获取一下dish对象的category_id属性        Long categoryId &#x3D; item.getCategoryId();  &#x2F;&#x2F;分类id        &#x2F;&#x2F;根据这个属性，获取到Category对象（这里需要用@Autowired注入一个CategoryService对象）        Category category &#x3D; categoryService.getById(categoryId);        &#x2F;&#x2F;随后获取Category对象的name属性，也就是菜品分类名称        String categoryName &#x3D; category.getName();        &#x2F;&#x2F;最后将菜品分类名称赋给dishDto对象就好了        dishDto.setCategoryName(categoryName);        &#x2F;&#x2F;结果返回一个dishDto对象        return dishDto;        &#x2F;&#x2F;并将dishDto对象封装成一个集合，作为我们的最终结果    &#125;).collect(Collectors.toList());    dishDtoPage.setRecords(list);    return Result.success(dishDtoPage);&#125;</code></pre><h2 id="15-修改菜品"><a href="#15-修改菜品" class="headerlink" title="15. 修改菜品"></a>15. 修改菜品</h2><h3 id="15-1-梳理交互过程"><a href="#15-1-梳理交互过程" class="headerlink" title="15.1 梳理交互过程"></a>15.1 梳理交互过程</h3><p>按照惯例，还是先来梳理一下整个流程</p><ol><li>页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前我们已经实现过了）</li><li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前我们已经实现过了）</li><li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li></ol><p><img src="20230412030551_672.jpg" alt="img"></p><h3 id="15-2-查询菜品信息"><a href="#15-2-查询菜品信息" class="headerlink" title="15.2 查询菜品信息"></a>15.2 查询菜品信息</h3><ul><li>菜品信息回显功能，需要我们先根据id来查询到对应的菜品信息才能回显</li><li>但修改表单中有一个菜品口味属性，普通的Dish类没有这个属性，所以还是要用到DishDto</li><li>那我们这里先在 DishServiceImpl 中编写一个<code>getByIdWithFlavor</code>方法</li><li>菜品口味需要根据<code>dish_id</code>去<code>dish_flavor</code>表中查询，将查询到的菜品口味数据赋给我们的<code>DishDto</code>对象即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic DishDto getByIdWithFlavor(Long id) &#123;    &#x2F;&#x2F;先根据id查询到对应的dish对象    Dish dish &#x3D; this.getById(id);    &#x2F;&#x2F;创建一个dishDao对象    DishDto dishDto &#x3D; new DishDto();    &#x2F;&#x2F;拷贝对象    BeanUtils.copyProperties(dish, dishDto);    &#x2F;&#x2F;条件构造器，对DishFlavor表查询    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;根据dish_id来查询对应的菜品口味数据    queryWrapper.eq(DishFlavor::getDishId, id);    &#x2F;&#x2F;获取查询的结果    List&lt;DishFlavor&gt; flavors &#x3D; dishFlavorService.list(queryWrapper);    &#x2F;&#x2F;并将其赋给dishDto    dishDto.setFlavors(flavors);    &#x2F;&#x2F;作为结果返回给前端    return dishDto;&#125;</code></pre><ul><li>在<code>DishController</code>中添加get方法，实现添加在<code>DishServicelmpl</code>中的逻辑代码，返回查询到的数据信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public Result&lt;DishDto&gt; getByIdWithFlavor(@PathVariable Long id) &#123;    DishDto dishDto &#x3D; dishService.getByIdWithFlavor(id);    log.info(&quot;查询到的数据为：&#123;&#125;&quot;, dishDto);    return Result.success(dishDto);&#125;</code></pre><h3 id="15-3-修改菜品信息"><a href="#15-3-修改菜品信息" class="headerlink" title="15.3 修改菜品信息"></a>15.3 修改菜品信息</h3><p>由于Dish表中没有Flavor这个属性，所以修改的时候，我们也是需要修改两张表</p><p>首先去DishService中创建<code>updateWithFlavor</code>方法，然后在<code>DishServiceImpl</code>中重写方法</p><ul><li>根据<code>id</code>修改菜品的基本信息</li><li>通过<code>dish_id</code>,删除菜品的<code>flavor</code></li><li>获取前端提交的<code>flavor</code>数据</li><li>为条<code>flavor</code>的<code>dishId</code>属性赋值</li><li>将数据批量保存到<code>dish_flavor</code>数据库</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void updateWithFlavor(DishDto dishDto) &#123;    &#x2F;&#x2F;更新当前菜品数据（dish表）    this.updateById(dishDto);    &#x2F;&#x2F;下面是更新当前菜品的口味数据    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;条件是当前菜品id    queryWrapper.eq(DishFlavor::getDishId, dishDto.getId());    &#x2F;&#x2F;将其删除掉    dishFlavorService.remove(queryWrapper);    &#x2F;&#x2F;获取传入的新的口味数据    List&lt;DishFlavor&gt; flavors &#x3D; dishDto.getFlavors();    &#x2F;&#x2F;这些口味数据还是没有dish_id，所以需要赋予其dishId    flavors &#x3D; flavors.stream().map((item) -&gt; &#123;        item.setDishId(dishDto.getId());        return item;    &#125;).collect(Collectors.toList());    &#x2F;&#x2F;再重新加入到表中    dishFlavorService.saveBatch(flavors);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) &#123;    log.info(&quot;接收到的数据为：&#123;&#125;&quot;, dishDto);    dishService.updateWithFlavor(dishDto);    return Result.success(&quot;修改菜品成功&quot;);&#125;</code></pre><h1 id="套餐管理"><a href="#套餐管理" class="headerlink" title="套餐管理"></a>套餐管理</h1><h2 id="16-新增套餐"><a href="#16-新增套餐" class="headerlink" title="16. 新增套餐"></a>16. 新增套餐</h2><h3 id="16-1-需求分析"><a href="#16-1-需求分析" class="headerlink" title="16.1 需求分析"></a>16.1 需求分析</h3><ul><li>套餐就是菜品的集合</li><li>后台系统中可以管理套餐信息，通过新增套餐来添加一个新的套餐</li><li>在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片</li></ul><h3 id="16-2-数据模型"><a href="#16-2-数据模型" class="headerlink" title="16.2 数据模型"></a>16.2 数据模型</h3><ul><li>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表中，而且还要向setmeal_dish表中插入套餐和菜品关联数据</li><li>所以在新增套餐时，需要对两张表进行操作<ol><li>setmeal表 –&gt; 套餐表</li><li>setmeal_dish表 –&gt; 套餐菜品关系表</li></ol></li><li>setmeal表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">套餐名称</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐价格</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">状态 0:停用 1:启用</td></tr><tr><td align="center">code</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">编码</td></tr><tr><td align="center">description</td><td align="center">varchar(512)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">image</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><ul><li>setmeal_dish表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">setmeal_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">name</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品名称 （冗余字段）</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品原价（冗余字段）</td></tr><tr><td align="center">copies</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">份数</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">排序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="16-3-梳理交互过程"><a href="#16-3-梳理交互过程" class="headerlink" title="16.3 梳理交互过程"></a>16.3 梳理交互过程</h3><p>在开发代码之前，我们先来梳理一下新增套餐时前端页面与服务端的交互过程</p><ol><li>页面发送ajax请求，请求服务端，获取套餐分类数据并展示到下拉框中（这个之前做过）</li><li>页面发送ajax请求，请求服务端，获取菜品分类数据并展示到添加菜品窗口中</li><li>页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器（已完成）</li><li>页面发送请求进行图片下载，将上传的图片进行回显（已完成）</li><li>点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</li></ol><p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求</p><h3 id="16-4-代码开发"><a href="#16-4-代码开发" class="headerlink" title="16.4 代码开发"></a>16.4 代码开发</h3><p>新增套餐页面，现在的套餐分类下拉框中已经能显示套餐分类了，这个功能在之前我们已经实现过了</p><p><img src="20230412050217_118.jpg" alt="img"></p><ul><li>添加菜品页面，这个页面是发送的GET请求，且路径为<code>dish/list?categoryId=xxx</code></li></ul><p><img src="20230412063516_850.jpg" alt="img"></p><ul><li>所以我们先去DishController中编写对应的get方法来正确显示菜品数据</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;Dish&gt;&gt; get(Dish dish) &#123;    &#x2F;&#x2F;条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() !&#x3D; null, Dish::getCategoryId, dish.getCategoryId());    &#x2F;&#x2F;只查询状态为1的菜品（启售菜品）    queryWrapper.eq(Dish::getStatus, 1);    &#x2F;&#x2F;简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    &#x2F;&#x2F;获取查询到的结果作为返回值    List&lt;Dish&gt; list &#x3D; dishService.list(queryWrapper);    return Result.success(list);&#125;</code></pre><ul><li>编写save方法<br>我们先打个断点，看看提交的数据是啥样的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) &#123;    log.info(&quot;套餐信息：&#123;&#125;&quot;, setmealDto);    return Result.success(&quot;套餐添加成功&quot;);&#125;</code></pre><p><img src="6342946616f2c2beb19f11db.jpg" alt="img"></p><p>需要注意的是这个setmealId为null，我们具体的代码中，要对其进行赋值</p><ul><li>具体业务逻辑如下</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) &#123;    log.info(&quot;套餐信息：&#123;&#125;&quot;, setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success(&quot;套餐添加成功&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;    @Autowired    protected SetmealDishService setmealDishService;    @Override    public void saveWithDish(SetmealDto setmealDto) &#123;        &#x2F;&#x2F;保存套餐setmeal基本信息        this.save(setmealDto);                List&lt;SetmealDish&gt; setmealDishes &#x3D; setmealDto.getSetmealDishes();        setmealDishes &#x3D; setmealDishes.stream().map((item) -&gt; &#123;            item.setSetmealId(setmealDto.getId());            return item;        &#125;).collect(Collectors.toList());        &#x2F;&#x2F;保存套餐和菜品关联信息到setmeal_dish        setmealDishService.saveBatch(setmealDishes);    &#125;&#125;</code></pre><h2 id="17-套餐信息分页查询"><a href="#17-套餐信息分页查询" class="headerlink" title="17. 套餐信息分页查询"></a>17. 套餐信息分页查询</h2><h3 id="17-1-需求分析"><a href="#17-1-需求分析" class="headerlink" title="17.1 需求分析"></a>17.1 需求分析</h3><ul><li>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>一般的系统中都会以分页的方式来展示列表数据</li></ul><p><img src="image-20231006174357620.png" alt="image-20231006174357620"></p><h3 id="17-2-梳理交互过程"><a href="#17-2-梳理交互过程" class="headerlink" title="17.2 梳理交互过程"></a>17.2 梳理交互过程</h3><ol><li>页面发送ajax请求，将分页查询参数（page，pageSize，name）提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示（已完成）</li></ol><p><img src="image-20231006174558812.png" alt="image-20231006174558812"></p><h3 id="17-3-代码开发"><a href="#17-3-代码开发" class="headerlink" title="17.3 代码开发"></a>17.3 代码开发</h3><ul><li>SetmealController类中，添加list方法<br>其实跟前面的菜品信息分页查询代码几乎一模一样，这遍就当review了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;page&quot;)public Result&lt;Page&gt; page(int page, int pageSize, String name) &#123;    Page&lt;Setmeal&gt; pageInfo &#x3D; new Page&lt;&gt;(page, pageSize);    Page&lt;SetmealDto&gt; dtoPage &#x3D; new Page&lt;&gt;(page, pageSize);        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(name !&#x3D; null, Setmeal::getName, name);    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    setmealService.page(pageInfo, queryWrapper);        &#x2F;&#x2F; 通过categoryId查询categoryName    BeanUtils.copyProperties(pageInfo, dtoPage, &quot;records&quot;);    List&lt;Setmeal&gt; records &#x3D; pageInfo.getRecords();    List&lt;SetmealDto&gt; list &#x3D; records.stream().map((item) -&gt; &#123;        SetmealDto setmealDto &#x3D; new SetmealDto();        BeanUtils.copyProperties(item, setmealDto);        Long categoryId &#x3D; item.getCategoryId();        Category category &#x3D; categoryService.getById(categoryId);        if (category !&#x3D; null) &#123;            setmealDto.setCategoryName(category.getName());        &#125;        return setmealDto;    &#125;).collect(Collectors.toList());    dtoPage.setRecords(list);    return Result.success(dtoPage);&#125;</code></pre><h2 id="18-删除套餐"><a href="#18-删除套餐" class="headerlink" title="18. 删除套餐"></a>18. 删除套餐</h2><h3 id="18-1-需求分析"><a href="#18-1-需求分析" class="headerlink" title="18.1 需求分析"></a>18.1 需求分析</h3><ul><li>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息</li><li>也可以通过复选框选择多个套餐，选择批量删除一次性删除多个套餐</li></ul><p>注意：对于<code>在售</code>中的套餐不能删除，需要先<code>停售</code>，然后才能删除</p><h3 id="18-2-梳理交互过程"><a href="#18-2-梳理交互过程" class="headerlink" title="18.2 梳理交互过程"></a>18.2 梳理交互过程</h3><ol><li>删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</li><li>删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐开发删除套餐功能<ul><li>请求网址: <a href="http://localhost/setmeal?ids=1579044544635232258,1415580119015145474">http://localhost/setmeal?ids=1579044544635232258,1415580119015145474</a></li><li>请求方法: DELETE</li></ul></li></ol><ul><li>删除单个套餐和批量删除这两种请求的地址和请求方式都是相同的</li><li>不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</li></ul><h3 id="18-3-代码开发"><a href="#18-3-代码开发" class="headerlink" title="18.3 代码开发"></a>18.3 代码开发</h3><ul><li>在SetmealController中添加delete方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; deleteByIds(@RequestParam List&lt;Long&gt; ids) &#123;    log.info(&quot;要删除的套餐id为：&#123;&#125;&quot;,ids);    setmealService.removeWithDish(ids);    return Result.success(&quot;删除成功&quot;);&#125;</code></pre><ul><li>在<code>SetmealServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void removeWithDish(List&lt;Long&gt; ids) &#123;    &#x2F;&#x2F;先判断一下能不能删，如果status为1，则套餐在售，不能删    &#x2F;&#x2F;select * from setmeal where id in (ids) and status &#x3D; 1    LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    setmealLambdaQueryWrapper.in(Setmeal::getId, ids);    setmealLambdaQueryWrapper.eq(Setmeal::getStatus, 1);        int count &#x3D; this.count(setmealLambdaQueryWrapper);    if (count &gt; 0) &#123;        throw new CustomException(&quot;套餐正在售卖中，请先停售再进行删除&quot;);    &#125;    &#x2F;&#x2F;如果没有在售套餐，则直接删除    this.removeByIds(ids);        &#x2F;&#x2F;继续删除    LambdaQueryWrapper&lt;SetmealDish&gt; setmealDishLambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    setmealDishLambdaQueryWrapper.in(SetmealDish::getSetmealId, ids);    setmealDishService.remove(setmealDishLambdaQueryWrapper);&#125;</code></pre><h1 id="用户端操作"><a href="#用户端操作" class="headerlink" title="用户端操作"></a>用户端操作</h1><h2 id="19-邮件发送（替换手机验证）"><a href="#19-邮件发送（替换手机验证）" class="headerlink" title="19. 邮件发送（替换手机验证）"></a>19. 邮件发送（替换手机验证）</h2><p>其实黑马这里用的是短信业务，但咱也没那条件，所以我只能自己换成QQ邮箱验证码了，这个简单，具体操作我们也只需要开启POP3&#x2F;STMP服务，获取一个16位的授权码：oblbemkgmircebfj</p><p><img src="20230412053436_681.jpg" alt="img"></p><h3 id="19-1-需求分析"><a href="#19-1-需求分析" class="headerlink" title="19.1 需求分析"></a>19.1 需求分析</h3><ul><li>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能(咱平替成邮箱验证码)</li><li>手机（邮箱）验证码登录的优点：<ul><li>方便快捷，无需注册，直接登录</li><li>使用短信验证码作为登录凭证，无需记忆密码</li><li>安全</li></ul></li><li>登录流程:<ul><li>输入手机号（邮箱） &gt; 获取验证码 &gt; 输入验证码 &gt; 点击登录 &gt; 登录成功</li></ul></li><li>用户登录界面</li></ul><p><img src="20230412034549_543.jpg" alt="img"></p><h3 id="19-2-数据模型"><a href="#19-2-数据模型" class="headerlink" title="19.2 数据模型"></a>19.2 数据模型</h3><p>这里的手机号也是varchar类型，所以我们就不用动它了，咱就用它存咱自己邮箱号就行（动手能力强的自己改一下也无所谓，大不了改出BUG再自己修）</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">sex</td><td align="center">varchar(2)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别</td></tr><tr><td align="center">id_number</td><td align="center">varchar(18)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">身份证号</td></tr><tr><td align="center">avatar</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">头像</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">0</td><td align="center">状态 0:禁用，1:正常</td></tr></tbody></table><ul><li>手机号（邮箱）是区分不同用户的标识，在用户登录的时候判断所输入的手机号（邮箱）是否存储在表中</li><li>如果不在表中，说明该用户为一个新的用户，将该用户自动保在user表中</li></ul><h3 id="19-3-准备工作"><a href="#19-3-准备工作" class="headerlink" title="19.3 准备工作"></a>19.3 准备工作</h3><p>在开发业务功能之前，我们先将要用到的类和接口的基本结构都创建好</p><ul><li><p>实体类User</p></li><li><p>Mapper接口UserMapper</p></li><li><p>业务层接口UserService</p></li><li><p>业务层实现类UserServiceImpl</p></li><li><p>控制层UserController</p></li><li><p>工具类（我们自己造自己的邮箱工具类）</p><ul><li>首先导入坐标</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.activation&#x2F;activation --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.activation&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;activation&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.mail&#x2F;mail --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.mail&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mail&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.7&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.commons&#x2F;commons-email --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-email&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li><ul><li>然后编写一个工具类，用于发送邮件验证码</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Properties;import javax.mail.Authenticator;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class MailUtils &#123;    public static void main(String[] args) throws MessagingException &#123;        &#x2F;&#x2F;可以在这里直接测试方法，填自己的邮箱即可        sendTestMail(&quot;2442926123@qq.com&quot;, new MailUtils().achieveCode());    &#125;    public static void sendTestMail(String email, String code) throws MessagingException &#123;        &#x2F;&#x2F; 创建Properties 类用于记录邮箱的一些属性        Properties props &#x3D; new Properties();        &#x2F;&#x2F; 表示SMTP发送邮件，必须进行身份验证        props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);        &#x2F;&#x2F;此处填写SMTP服务器        props.put(&quot;mail.smtp.host&quot;, &quot;smtp.qq.com&quot;);        &#x2F;&#x2F;端口号，QQ邮箱端口587        props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;);        &#x2F;&#x2F; 此处填写，写信人的账号        props.put(&quot;mail.user&quot;, &quot;2442926123@qq.com&quot;);        &#x2F;&#x2F; 此处填写16位STMP口令        props.put(&quot;mail.password&quot;, &quot;oblbemkgmircebfj&quot;);        &#x2F;&#x2F; 构建授权信息，用于进行SMTP进行身份验证        Authenticator authenticator &#x3D; new Authenticator() &#123;            protected PasswordAuthentication getPasswordAuthentication() &#123;                &#x2F;&#x2F; 用户名、密码                String userName &#x3D; props.getProperty(&quot;mail.user&quot;);                String password &#x3D; props.getProperty(&quot;mail.password&quot;);                return new PasswordAuthentication(userName, password);            &#125;        &#125;;        &#x2F;&#x2F; 使用环境属性和授权信息，创建邮件会话        Session mailSession &#x3D; Session.getInstance(props, authenticator);        &#x2F;&#x2F; 创建邮件消息        MimeMessage message &#x3D; new MimeMessage(mailSession);        &#x2F;&#x2F; 设置发件人        InternetAddress form &#x3D; new InternetAddress(props.getProperty(&quot;mail.user&quot;));        message.setFrom(form);        &#x2F;&#x2F; 设置收件人的邮箱        InternetAddress to &#x3D; new InternetAddress(email);        message.setRecipient(RecipientType.TO, to);        &#x2F;&#x2F; 设置邮件标题        message.setSubject(&quot;【瑞吉外卖】验证码&quot;);        &#x2F;&#x2F; 设置邮件的内容体        message.setContent(&quot;尊敬的用户:你好!\n注册验证码为:&quot; + code + &quot;(有效期为一分钟,请勿告知他人)&quot;, &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);        &#x2F;&#x2F; 最后当然就是发送邮件啦        Transport.send(message);    &#125;    &#x2F;&#x2F; 生成验证码    public static String achieveCode() &#123;  &#x2F;&#x2F;由于数字 1 、 0 和字母 O 、l 有时分不清楚，所以，没有数字 1 、 0        String[] beforeShuffle &#x3D; new String[]&#123;&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;,&quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;,&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;        List&lt;String&gt; list &#x3D; Arrays.asList(beforeShuffle);&#x2F;&#x2F;将数组转换为集合        Collections.shuffle(list);  &#x2F;&#x2F;打乱集合顺序        StringBuilder sb &#x3D; new StringBuilder();        for (String s : list) &#123;            sb.append(s); &#x2F;&#x2F;将集合转化为字符串        &#125;        return sb.substring(3, 8);    &#125;&#125;</code></pre><h3 id="19-4-修改拦截器"><a href="#19-4-修改拦截器" class="headerlink" title="19.4 修改拦截器"></a>19.4 修改拦截器</h3><ul><li>对用户登录操作放行</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义不需要处理的请求String[] urls &#x3D; new String[]&#123;        &quot;&#x2F;employee&#x2F;login&quot;,        &quot;&#x2F;employee&#x2F;logout&quot;,        &quot;&#x2F;backend&#x2F;**&quot;,        &quot;&#x2F;front&#x2F;**&quot;,        &quot;&#x2F;common&#x2F;**&quot;,        &#x2F;&#x2F;对用户登陆操作放行        &quot;&#x2F;user&#x2F;login&quot;,        &quot;&#x2F;user&#x2F;sendMsg&quot;&#125;;</code></pre><ul><li>判断用户是否登录</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;判断用户是否登录if(request.getSession().getAttribute(&quot;user&quot;) !&#x3D; null)&#123;    log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;user&quot;));    Long userId &#x3D; (Long)request.getSession().getAttribute(&quot;user&quot;);    BaseContext.setCurrentId(userId);    filterChain.doFilter(request,response);    return;&#125;</code></pre><h3 id="19-5-发送验证码"><a href="#19-5-发送验证码" class="headerlink" title="19.5 发送验证码"></a>19.5 发送验证码</h3><ul><li>发送验证码的请求方式是POST，路径为<code>/user/sendMsg</code></li><li>那么我们在UserController控制层中，添加sendMsg方法<br>这个是真滴能发送的奥，邮箱里可以收到的，待会儿我就写校验功能了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;sendMsg&quot;)public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException &#123;    String phone &#x3D; user.getPhone();    if (!phone.isEmpty()) &#123;        &#x2F;&#x2F;随机生成一个验证码        String code &#x3D; MailUtils.achieveCode();        log.info(code);        &#x2F;&#x2F;这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        &#x2F;&#x2F;验证码存session，方便后面拿出来比对        session.setAttribute(phone, code);        return Result.success(&quot;验证码发送成功&quot;);    &#125;    return Result.error(&quot;验证码发送失败&quot;);&#125;</code></pre><h3 id="19-6-登录功能"><a href="#19-6-登录功能" class="headerlink" title="19.6 登录功能"></a>19.6 登录功能</h3><ul><li>输入验证码，点击登录</li></ul><p> 请求路径为:<code>/user/login</code>，数据以json格式返回给服务端</p><p><img src="image-20231013165753060.png" alt="image-20231013165753060"></p><p><img src="image-20231013165802147.png" alt="image-20231013165802147"></p><ul><li>在UserController控制层中，添加<code>login</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;login&quot;)public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) &#123;    log.info(map.toString());    &#x2F;&#x2F;获取邮箱    String phone &#x3D; map.get(&quot;phone&quot;).toString();    &#x2F;&#x2F;获取验证码    String code &#x3D; map.get(&quot;code&quot;).toString();    &#x2F;&#x2F;从session中获取验证码    String codeInSession &#x3D; session.getAttribute(phone).toString();    &#x2F;&#x2F;比较这用户输入的验证码和session中存的验证码是否一致    if (code !&#x3D; null &amp;&amp; code.equals(codeInSession)) &#123;        &#x2F;&#x2F;如果输入正确，判断一下当前用户是否存在        LambdaQueryWrapper&lt;User&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;判断依据是从数据库中查询是否有其邮箱        queryWrapper.eq(User::getPhone, phone);        User user &#x3D; userService.getOne(queryWrapper);        &#x2F;&#x2F;如果不存在，则创建一个，存入数据库        if (user &#x3D;&#x3D; null) &#123;            user &#x3D; new User();            user.setPhone(phone);            userService.save(user);            user.setName(&quot;用户&quot; + codeInSession);        &#125;        &#x2F;&#x2F;存个session，表示登录状态        session.setAttribute(&quot;user&quot;,user.getId());        &#x2F;&#x2F;并将其作为结果返回        return Result.success(user);    &#125;    return Result.error(&quot;登录失败&quot;);&#125;</code></pre><h2 id="20-地址簿"><a href="#20-地址簿" class="headerlink" title="20. 地址簿"></a>20. 地址簿</h2><h3 id="20-1-需求分析"><a href="#20-1-需求分析" class="headerlink" title="20.1 需求分析"></a>20.1 需求分析</h3><ul><li>地址簿，指的是移动端消费者用户的地址信息（外卖快递的收货地址）</li><li>用户登录成功后可以维护自己的地址信息（自己修改删除新增等）</li><li>同一个用户可以有多个地址信息，但是只能有一个默认地址。（有默认地址的话会很方便）</li></ul><p><img src="image-20231014115207776.png" alt="image-20231014115207776"></p><h3 id="20-2-数据模型"><a href="#20-2-数据模型" class="headerlink" title="20.2 数据模型"></a>20.2 数据模型</h3><p>注意这里的phone类型为varchar(11)，这显然不够我们邮箱用的，所以我们自己改一下这里，改大一点，不然做到新增地址的时候，会报错<br><code>com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column &#39;phone&#39; at row 1</code></p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户id</td></tr><tr><td align="center">consignee</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr><tr><td align="center">sex</td><td align="center">tinyint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别 0 女 1 男</td></tr><tr><td align="center">phone</td><td align="center">varchar(11)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">province_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级区划编号</td></tr><tr><td align="center">province_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级名称</td></tr><tr><td align="center">city_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级区划编号</td></tr><tr><td align="center">city_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级名称</td></tr><tr><td align="center">district_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级区划编号</td></tr><tr><td align="center">district_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级名称</td></tr><tr><td align="center">detail</td><td align="center">varchar(200)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">详细地址</td></tr><tr><td align="center">label</td><td align="center">varchar(100)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">标签</td></tr><tr><td align="center">is_default</td><td align="center">tinyint(1)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">默认 0 否 1是</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="20-3-准备工作"><a href="#20-3-准备工作" class="headerlink" title="20.3 准备工作"></a>20.3 准备工作</h3><ol><li>创建对应的实体类<code>AddressBook</code></li><li><code>Mapper</code>接口<code>AddressBookMapper</code></li><li>业务层接口<code>AddressBookService</code></li><li>业务层实现类<code>AddressBookServicelmpl</code></li><li>控制层<code>AddressBookController</code></li></ol><h3 id="20-4-新增收货地址"><a href="#20-4-新增收货地址" class="headerlink" title="20.4 新增收货地址"></a>20.4 新增收货地址</h3><p><img src="20230412055617_809.jpg" alt="img"></p><ul><li>修改前端代码<br>这段代码是新增地址的前端代码 address-edit.html ，我们将其中的手机号全部替换成邮箱，判断手机号的正则也换成判断邮箱的正则，懒人就直接Copy我这段代码就好了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;        &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0,user-scalable&#x3D;no,minimal-ui&quot;&gt;        &lt;title&gt;菩提阁&lt;&#x2F;title&gt;        &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;.&#x2F;..&#x2F;images&#x2F;favico.ico&quot;&gt;        &lt;!--不同屏幕尺寸根字体设置--&gt;        &lt;script src&#x3D;&quot;.&#x2F;..&#x2F;js&#x2F;base.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;!--element-ui的样式--&gt;        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;..&#x2F;backend&#x2F;plugins&#x2F;element-ui&#x2F;index.css&quot; &#x2F;&gt;        &lt;!--引入vant样式--&gt;        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;styles&#x2F;vant.min.css&quot;&#x2F;&gt;        &lt;!-- 引入样式  --&gt;        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;styles&#x2F;index.css&quot; &#x2F;&gt;        &lt;!--本页面内容的样式--&gt;        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;..&#x2F;styles&#x2F;address-edit.css&quot; &#x2F;&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;div id&#x3D;&quot;address_edit&quot; class&#x3D;&quot;app&quot;&gt;            &lt;div class&#x3D;&quot;divHead&quot;&gt;                &lt;div class&#x3D;&quot;divTitle&quot;&gt;                    &lt;i class&#x3D;&quot;el-icon-arrow-left&quot; @click&#x3D;&quot;goBack&quot;&gt;&lt;&#x2F;i&gt;&#123;&#123;title&#125;&#125;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;divContent&quot;&gt;                &lt;div class&#x3D;&quot;divItem&quot;&gt;                   &lt;span&gt;联系人：&lt;&#x2F;span&gt;                    &lt;el-input placeholder&#x3D;&quot; 请填写收货人的姓名&quot; v-model&#x3D;&quot;form.consignee&quot;  maxlength&#x3D;&#39;10&#39; class&#x3D;&quot;inputUser&quot;&#x2F;&gt;&lt;&#x2F;el-input&gt;                   &lt;span class&#x3D;&quot;spanChecked&quot; @click&#x3D;&quot;form.sex &#x3D; &#39;1&#39;&quot;&gt;                    &lt;i :class&#x3D;&quot;&#123;iActive:form.sex &#x3D;&#x3D;&#x3D; &#39;1&#39;&#125;&quot;&gt;&lt;&#x2F;i&gt;                    先生                   &lt;&#x2F;span&gt;                   &lt;span class&#x3D;&quot;spanChecked&quot; @click&#x3D;&quot;form.sex &#x3D; &#39;0&#39;&quot;&gt;                    &lt;i :class&#x3D;&quot;&#123;iActive:form.sex &#x3D;&#x3D;&#x3D; &#39;0&#39;&#125;&quot;&gt;&lt;&#x2F;i&gt;                    女士                &lt;&#x2F;span&gt;                &lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;divItem&quot;&gt;                    &lt;span&gt;邮箱：&lt;&#x2F;span&gt;                    &lt;el-input placeholder&#x3D;&quot; 请填写收货人邮箱&quot; v-model&#x3D;&quot;form.phone&quot;  maxlength&#x3D;&#39;20&#39; style&#x3D;&quot;width: calc(100% - 80rem);&quot;&#x2F;&gt;&lt;&#x2F;el-input&gt;                &lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;divItem&quot;&gt;                    &lt;span&gt;收货地址：&lt;&#x2F;span&gt;                     &lt;el-input placeholder&#x3D;&quot; 请输入收货地址&quot; v-model&#x3D;&quot;form.detail&quot;  maxlength&#x3D;&#39;140&#39;&#x2F;&gt;&lt;&#x2F;el-input&gt;                &lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;divItem &quot;&gt;                    &lt;span&gt;标签：&lt;&#x2F;span&gt;                     &lt;span v-for&#x3D;&quot;(item,index) in labelList&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;form.label &#x3D; item;activeIndex &#x3D; index&quot; :class&#x3D;&quot;&#123;spanItem:true,spanActiveSchool:activeIndex &#x3D;&#x3D;&#x3D; index&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;span&gt;                &lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;divSave&quot; @click&#x3D;&quot;saveAddress&quot;&gt;保存地址&lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;divDelete&quot; @click&#x3D;&quot;deleteAddress&quot; v-if&#x3D;&quot;id&quot;&gt;删除地址&lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;        &lt;!-- 开发环境版本,包含了有帮助的命令行警告 --&gt;        &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;backend&#x2F;plugins&#x2F;vue&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;!-- 引入组件库 --&gt;        &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;backend&#x2F;plugins&#x2F;element-ui&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;!-- 引入vant样式 --&gt;        &lt;script src&#x3D;&quot;.&#x2F;..&#x2F;js&#x2F;vant.min.js&quot;&gt;&lt;&#x2F;script&gt;               &lt;script src&#x3D;&quot;.&#x2F;..&#x2F;js&#x2F;common.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;script src&#x3D;&quot;.&#x2F;..&#x2F;api&#x2F;address.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;!-- 引入axios --&gt;        &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;backend&#x2F;plugins&#x2F;axios&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;script src&#x3D;&quot;.&#x2F;..&#x2F;js&#x2F;request.js&quot;&gt;&lt;&#x2F;script&gt;        &lt;script&gt;            new Vue(&#123;                el:&quot;#address_edit&quot;,                data()&#123;                    return &#123;                        title:&#39;新增收货地址&#39;,                        form:&#123;                            consignee:&#39;&#39;,&#x2F;&#x2F;联系人                            phone:undefined,&#x2F;&#x2F;手机号                            sex:&#39;1&#39;,&#x2F;&#x2F;0表示女 1 表示男                            detail:&#39;&#39;,&#x2F;&#x2F;收货地址                            label:&#39;公司&#39;,&#x2F;&#x2F;标签                        &#125;,                        labelList:[                            &#39;无&#39;,&#39;公司&#39;,&#39;家&#39;,&#39;学校&#39;                        ],                        id:undefined,                        activeIndex :0                    &#125;                &#125;,                computed:&#123;&#125;,                created()&#123;                    this.initData()                &#125;,                mounted()&#123;                &#125;,                methods:&#123;                    goBack()&#123;                        history.go(-1)                    &#125;,                    async initData()&#123;                        const params &#x3D; parseUrl(window.location.search)                        this.id &#x3D; params.id                        if(params.id)&#123;                            this.title &#x3D; &#39;编辑收货地址&#39;                            const res &#x3D; await addressFindOneApi(params.id)                            if(res.code &#x3D;&#x3D;&#x3D; 1)&#123;                                this.form &#x3D; res.data                            &#125;else&#123;                                this.$notify(&#123; type:&#39;warning&#39;, message:res.msg&#125;);                            &#125;                        &#125;                    &#125;,                    async saveAddress()&#123;                        const form &#x3D; this.form                        if(!form.consignee)&#123;                            this.$notify(&#123; type:&#39;warning&#39;, message:&#39;请输入联系人&#39;&#125;);                            return                         &#125;                        if(!form.phone)&#123;                            this.$notify(&#123; type:&#39;warning&#39;, message:&#39;请输入邮箱&#39;&#125;);                            return                         &#125;                        if(!form.detail)&#123;                            this.$notify(&#123; type:&#39;warning&#39;, message:&#39;请输入收货地址&#39;&#125;);                            return                         &#125;                        const reg &#x3D; &#x2F;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&#x2F;                        if(!reg.test(form.phone))&#123;                            this.$notify(&#123; type:&#39;warning&#39;, message:&#39;邮箱不合法&#39;&#125;);                            return                          &#125;                        let res&#x3D; &#123;&#125;                        if(this.id)&#123;                            res &#x3D; await updateAddressApi(this.form)                        &#125;else&#123;                            res &#x3D; await addAddressApi(this.form)                        &#125;                                                if(res.code &#x3D;&#x3D;&#x3D; 1)&#123;                            window.requestAnimationFrame(()&#x3D;&gt;&#123;                                window.location.replace(&#39;&#x2F;front&#x2F;page&#x2F;address.html&#39;)                            &#125;)                        &#125;else&#123;                            this.$notify(&#123; type:&#39;warning&#39;, message:res.msg&#125;);                        &#125;                    &#125;,                    deleteAddress()&#123;                        this.$dialog.confirm(&#123;                            title: &#39;确认删除&#39;,                            message: &#39;确认要删除当前地址吗？&#39;,                        &#125;)                        .then( async () &#x3D;&gt; &#123;                            const res &#x3D; await deleteAddressApi(&#123;ids:this.id &#125;)                            if(res.code &#x3D;&#x3D;&#x3D; 1)&#123;                                window.requestAnimationFrame(()&#x3D;&gt;&#123;                                    window.location.replace(&#39;&#x2F;front&#x2F;page&#x2F;address.html&#39;)                                &#125;)                            &#125;else&#123;                                this.$notify(&#123; type:&#39;warning&#39;, message:res.msg&#125;);                            &#125;                        &#125;)                        .catch(() &#x3D;&gt; &#123;                        &#125;);                    &#125;,                &#125;            &#125;)            &lt;&#x2F;script&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>请求路径</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;新增地址function  addAddressApi(data)&#123;    return $axios(&#123;        &#39;url&#39;: &#39;&#x2F;addressBook&#39;,        &#39;method&#39;: &#39;post&#39;,        data      &#125;)&#125;</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; addAddress(@RequestBody AddressBook addressBook) &#123;    addressBook.setUserId(BaseContext.getCurrentId());    log.info(&quot;addressBook:&#123;&#125;&quot;, addressBook);    addressBookService.save(addressBook);    return Result.success(&quot;添加地址成功&quot;);&#125;</code></pre><h3 id="20-5-修改收货地址"><a href="#20-5-修改收货地址" class="headerlink" title="20.5 修改收货地址"></a>20.5 修改收货地址</h3><p><img src="image-20231014131340422.png" alt="image-20231014131340422"></p><ul><li>前端代码分析</li></ul><p>首先点击编辑按钮，回显数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;查询单个地址function addressFindOneApi(id) &#123;  return $axios(&#123;    &#39;url&#39;: &#96;&#x2F;addressBook&#x2F;$&#123;id&#125;&#96;,    &#39;method&#39;: &#39;get&#39;,  &#125;)&#125;</code></pre><p>修改数据之后，点击保存，发送请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;修改地址function  updateAddressApi(data)&#123;    return $axios(&#123;        &#39;url&#39;: &#39;&#x2F;addressBook&#39;,        &#39;method&#39;: &#39;put&#39;,        data      &#125;)&#125;</code></pre><ul><li>代码实现</li></ul><h3 id="20-6-查询地址"><a href="#20-6-查询地址" class="headerlink" title="20.6 查询地址"></a>20.6 查询地址</h3><ul><li>点击地址管理，查看请求方式与地址</li></ul><p><img src="20230412045510_417.jpg" alt="img"></p><ul><li>请求路径为<code>/addressBook/list</code>，请求方式为GET，那么我们现在来<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public R&lt;List&lt;AddressBook&gt;&gt; list() &#123;    AddressBook addressBook &#x3D; new AddressBook();    addressBook.setUserId(BaseContext.getCurrentId());    LambdaQueryWrapper&lt;AddressBook&gt; wrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    wrapper.eq(addressBook.getUserId() !&#x3D; null, AddressBook::getUserId, addressBook.getUserId());    wrapper.orderByDesc(AddressBook::getUpdateTime);        &#x2F;&#x2F;SQL:select * from address_book where user_id &#x3D; ? order by update_time desc    List&lt;AddressBook&gt; list &#x3D; addressBookService.list(wrapper);    return R.success(list);&#125;</code></pre><h3 id="20-7-设置默认地址"><a href="#20-7-设置默认地址" class="headerlink" title="20.7 设置默认地址"></a>20.7 设置默认地址</h3><ul><li><p>先来想想怎么设置默认地址</p><ul><li><p>默认地址，按理说数据库中，有且仅有一条数据为默认地址，也就是<code>is_default</code>字段为1</p></li><li><p>如何保证整个表中的</p><pre class="line-numbers language-none"><code class="language-none">is_default</code></pre><p>字段只有一条为1</p><ul><li>每次设置默认地址的时候，将当前用户所有地址的<code>is_default</code>字段设为0，随后将当前地址的<code>is_default</code>字段设为1</li></ul></li></ul></li><li><p>当我们点击上图的设为默认按钮的时候，会发送请求</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;设置默认地址function  setDefaultAddressApi(data)&#123;  return $axios(&#123;      &#39;url&#39;: &#39;&#x2F;addressBook&#x2F;default&#39;,      &#39;method&#39;: &#39;put&#39;,      data    &#125;)&#125;</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping(&quot;&#x2F;default&quot;)public R&lt;String&gt; setDefault(@RequestBody AddressBook addressBook) &#123;    LambdaUpdateWrapper&lt;AddressBook&gt; lambdaUpdateWrapper &#x3D; new LambdaUpdateWrapper&lt;&gt;();    lambdaUpdateWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());    lambdaUpdateWrapper.set(AddressBook::getIsDefault, 0);    &#x2F;&#x2F;SQL:update address_book set is_default &#x3D; 0 where user_id &#x3D; ?    addressBookService.update(lambdaUpdateWrapper);    addressBook.setIsDefault(1);    &#x2F;&#x2F;SQL:update address_book set is_default &#x3D; 1 where id &#x3D; ?    addressBookService.updateById(addressBook);    return R.success(&quot;设置默认地址成功&quot;);&#125;</code></pre><h2 id="21-菜品展示"><a href="#21-菜品展示" class="headerlink" title="21. 菜品展示"></a>21. 菜品展示</h2><h3 id="21-1-需求分析"><a href="#21-1-需求分析" class="headerlink" title="21.1 需求分析"></a>21.1 需求分析</h3><ul><li>用户登陆成功之后，跳转到菜品页面，根据菜品分类来展示菜品和套餐</li><li>如果菜品设置了口味信息，则需要展示选择规格按钮，否则只展示+按钮（这部分是前端实现的）</li></ul><p><img src="image-20231014135711064.png" alt="image-20231014135711064"></p><h3 id="21-2-梳理交互过程"><a href="#21-2-梳理交互过程" class="headerlink" title="21.2 梳理交互过程"></a>21.2 梳理交互过程</h3><ol><li>页面(front&#x2F;index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类）（已完成）</li><li>页面发送ajax请求，根据具体的菜品&#x2F;套餐分类，展示对应分类中的具体菜品（已完成）</li></ol><h3 id="21-3-前端分析"><a href="#21-3-前端分析" class="headerlink" title="21.3 前端分析"></a>21.3 前端分析</h3><ul><li><p>启动服务器，登录账号，监测Network选项卡，发现登录到首页会发送两个请求</p><ul><li>分类</li></ul><blockquote><p>请求网址: <a href="http://localhost/category/list">http://localhost/category/list</a><br>请求方法: GET</p></blockquote><ul><li>购物车</li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/list">http://localhost/shoppingCart/list</a><br>请求方法: GET</p></blockquote></li><li><p>其中分类请求我们之前写过了，但是当我们访问页面的时候，并没有加载出来</p><ul><li><p>原因是购物车相关功能还没写，所以这里我们用一个写死了的json数据骗骗它<br>将url换成我们注释掉的那个就好了</p></li><li><pre><code class="js">//获取购物车内商品的集合function cartListApi(data) &#123;    return $axios(&#123;        &#39;url&#39;: &#39;/shoppingCart/list&#39;,        //&#39;url&#39;: &#39;/front/cartData.json&#39;,        &#39;method&#39;: &#39;get&#39;,        params: &#123;...data&#125;    &#125;)&#125;<pre class="line-numbers language-none"><code class="language-none">- 那我们再次重启服务器，此时首页已经可以显示分类数据![image-20231014141230596](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96&#x2F;image-20231014141230596.png)获取分类数据：http:&#x2F;&#x2F;localhost&#x2F;category&#x2F;list ，之前在分类管理中已完成展示菜品分类中的具体菜品：http:&#x2F;&#x2F;localhost&#x2F;dish&#x2F;list ，之前在套餐管理中已完成（新增套餐时需要选择相应的菜品）展示套餐分类中的具体套餐在后面开发![image-20231014151254220](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96&#x2F;image-20231014151254220.png)### 21.4 选择规格- 但是现在还存在一个问题，我们的菜品是有口味数据的，那么这里的按钮不该是一个&#96;+&#96;，而应该是&#96;选择规格&#96;&#96;&#96;&#96;html&lt;div class&#x3D;&quot;divTypes&quot; v-if&#x3D;&quot;detailsDialog.item.flavors &amp;&amp; detailsDialog.item.flavors.length &gt; 0 &amp;&amp; !detailsDialog.item.number &quot; @click &#x3D;&quot;chooseFlavorClick(detailsDialog.item)&quot;&gt;选择规格&lt;&#x2F;div&gt;               </code></pre></code></pre></li></ul></li><li><p>通过代码我们可以看出，选择规格按钮，是根据服务端返回数据中是否有flavors字段来决定的，但我们返回的是一个<code>List&lt;Dish&gt;</code>，其中并没有<code>flavors</code>属性，所以我们需要修改前面的方法返回值为<code>DishDto</code>，<code>DishDto</code>继承了<code>Dish</code>，且新增了<code>flavors</code>属性</p></li><li><p>那么现在我们直接来修改原本的list方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) &#123;    &#x2F;&#x2F;条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() !&#x3D; null, Dish::getCategoryId, dish.getCategoryId());    &#x2F;&#x2F;只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    &#x2F;&#x2F;简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    &#x2F;&#x2F;获取查询到的结果作为返回值    List&lt;Dish&gt; list &#x3D; dishService.list(queryWrapper);    log.info(&quot;查询到的菜品信息list:&#123;&#125;&quot;,list);    &#x2F;&#x2F;item就是list中的每一条数据，相当于遍历了    List&lt;DishDto&gt; dishDtoList &#x3D; list.stream().map((item) -&gt; &#123;        &#x2F;&#x2F;创建一个dishDto对象        DishDto dishDto &#x3D; new DishDto();        &#x2F;&#x2F;将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);                &#x2F;&#x2F;然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId &#x3D; item.getId();        &#x2F;&#x2F;条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;条件就是菜品id        lambdaQueryWrapper.eq(itemId !&#x3D; null, DishFlavor::getDishId, itemId);        &#x2F;&#x2F;根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors &#x3D; dishFlavorService.list(lambdaQueryWrapper);        &#x2F;&#x2F;赋给dishDto的对应属性        dishDto.setFlavors(flavors);        &#x2F;&#x2F;并将dishDto作为结果返回        return dishDto;        &#x2F;&#x2F;将所有返回结果收集起来，封装成List    &#125;).collect(Collectors.toList());    return Result.success(dishDtoList);&#125;</code></pre><h2 id="22-套餐展示"><a href="#22-套餐展示" class="headerlink" title="22. 套餐展示"></a>22. 套餐展示</h2><ul><li>关于菜品的展示我们就完成了，但是套餐和菜品用的并不是同一个controller，所以我们还需要来完善套餐展示</li></ul><blockquote><p>请求网址: <a href="http://localhost/setmeal/list?categoryId=1413342269393674242&status=1">http://localhost/setmeal/list?categoryId=1413342269393674242&amp;status=1</a><br>请求方法: GET</p></blockquote><ul><li>那么我们现在就在<code>SetmealController</code>中编写对应的方法<br>由于套餐没有口味数据，所以开发起来还是比较简单的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) &#123;    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加条件    queryWrapper.eq(setmeal.getCategoryId() !&#x3D; null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() !&#x3D; null, Setmeal::getStatus, 1);    &#x2F;&#x2F;排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList &#x3D; setmealService.list(queryWrapper);    return Result.success(setmealList);&#125;</code></pre><h2 id="23-购物车"><a href="#23-购物车" class="headerlink" title="23. 购物车"></a>23. 购物车</h2><h3 id="23-1-需求分析"><a href="#23-1-需求分析" class="headerlink" title="23.1 需求分析"></a>23.1 需求分析</h3><ul><li>移动端用户可以将菜品&#x2F;套餐添加到购物车</li><li>对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现）</li><li>对于套餐来说，可以直接点击当前套餐加入购物车</li><li>在购物车中可以修改菜品&#x2F;套餐的数量，也可以清空购物车</li></ul><p><img src="image-20231014172121854.png" alt="image-20231014172121854"></p><h3 id="23-2-数据模型"><a href="#23-2-数据模型" class="headerlink" title="23.2 数据模型"></a>23.2 数据模型</h3><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名称</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr></tbody></table><h3 id="23-3-梳理交互过程"><a href="#23-3-梳理交互过程" class="headerlink" title="23.3 梳理交互过程"></a>23.3 梳理交互过程</h3><ol><li>点击加入购物车按钮，页面发送ajax请求，请求服务端，将菜品&#x2F;套餐添加到购物车</li><li>点击购物车图标，页面发送ajax请求，请求服务端，查询购物车中的菜品和套餐</li><li>点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</li></ol><h3 id="23-4-准备工作"><a href="#23-4-准备工作" class="headerlink" title="23.4 准备工作"></a>23.4 准备工作</h3><p>在开发业务功能之前，先将需要用到的类和接口的基本结构都创建好</p><ol><li>实体类<code>ShoppingCart</code></li><li><code>Mapper</code>接口<code>ShoppingCartMapper</code></li><li>业务层接口<code>ShoppingCartService</code></li><li>业务层实现类<code>ShoppingCartServiceImpl</code></li><li>控制层<code>ShoppingCartController</code></li></ol><h3 id="23-5-代码开发"><a href="#23-5-代码开发" class="headerlink" title="23.5 代码开发"></a>23.5 代码开发</h3><h4 id="加入购物车"><a href="#加入购物车" class="headerlink" title="加入购物车"></a>加入购物车</h4><ul><li>点击<code>加入购物车</code>，页面发送请求，请求路径<code>/shoppingCart/add</code>，请求方式<code>POST</code></li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/add">http://localhost/shoppingCart/add</a><br>请求方法: POST</p></blockquote><ul><li>页面将数据以json格式发送给服务端</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;add&quot;)public Result&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart) &#123;    log.info(&quot;shoppingCart&#x3D;&#123;&#125;&quot;, shoppingCart);    &#x2F;&#x2F;获取当前用户id    Long currentId &#x3D; BaseContext.getCurrentId();    &#x2F;&#x2F;设置当前用户id    shoppingCart.setUserId(currentId);    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(ShoppingCart::getUserId, currentId);        &#x2F;&#x2F;获取当前菜品id    Long dishId &#x3D; shoppingCart.getDishId();    &#x2F;&#x2F;判断添加的是菜品还是套餐    if (dishId !&#x3D; null) &#123;        queryWrapper.eq(ShoppingCart::getDishId, dishId);    &#125; else &#123;        queryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());    &#125;    &#x2F;&#x2F;查询当前菜品或者套餐是否在购物车中    ShoppingCart cartServiceOne &#x3D; shoppingCartService.getOne(queryWrapper);    if (cartServiceOne !&#x3D; null) &#123;        &#x2F;&#x2F;如果已存在就在当前的数量上加1        Integer number &#x3D; cartServiceOne.getNumber();        cartServiceOne.setNumber(number + 1);        shoppingCartService.updateById(cartServiceOne);    &#125; else &#123;        &#x2F;&#x2F;如果不存在，则还需设置一下创建时间        shoppingCart.setCreateTime(LocalDateTime.now());        &#x2F;&#x2F;如果不存在，则添加到购物车，数量默认为1        shoppingCartService.save(shoppingCart);        &#x2F;&#x2F;这里是为了统一结果，最后都返回cartServiceOne会比较方便        cartServiceOne &#x3D; shoppingCart;    &#125;    return Result.success(cartServiceOne);&#125;</code></pre><h4 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h4><ul><li>之前为了不报错，我们将查看购物车的地址换成了一个死数据<br>那现在我们要做的就是换成真数据</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;获取购物车内商品的集合function cartListApi(data) &#123;    return $axios(&#123;        &#39;url&#39;: &#39;&#x2F;shoppingCart&#x2F;list&#39;,        &#x2F;&#x2F;&#39;url&#39;: &#39;&#x2F;front&#x2F;cartData.json&#39;,        &#39;method&#39;: &#39;get&#39;,        params: &#123;...data&#125;    &#125;)&#125;</code></pre><ul><li>请求路径为<code>/shoppingCart/list</code>，请求方式为<code>GET</code><br>直接来<code>ShoppingCartController</code>中添加对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;ShoppingCart&gt;&gt; list() &#123;    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    Long userId &#x3D; BaseContext.getCurrentId();    queryWrapper.eq(ShoppingCart::getUserId, userId);    List&lt;ShoppingCart&gt; shoppingCarts &#x3D; shoppingCartService.list(queryWrapper);    return Result.success(shoppingCarts);&#125;</code></pre><h4 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h4><ul><li><p>我们点击上图中的清空按钮，请求路径为<code>/shoppingCart/clean</code>，请求方式为<code>DELETE</code></p></li><li><p>清空购物车的逻辑倒是比较简单，获取用户id，然后去<code>shopping__cart</code>表中删除对应id的数据即可<br>那么我们现在就来<code>ShoppingCartController</code>中编写对应的方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMapping(&quot;&#x2F;clean&quot;)public Result&lt;String&gt; clean() &#123;    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;获取当前用户id    Long userId &#x3D; BaseContext.getCurrentId();    queryWrapper.eq(userId !&#x3D; null, ShoppingCart::getUserId, userId);    &#x2F;&#x2F;删除当前用户id的所有购物车数据    shoppingCartService.remove(queryWrapper);    return Result.success(&quot;成功清空购物车&quot;);&#125;</code></pre><h2 id="24-用户下单"><a href="#24-用户下单" class="headerlink" title="24. 用户下单"></a>24. 用户下单</h2><h3 id="24-1-需求分析"><a href="#24-1-需求分析" class="headerlink" title="24.1 需求分析"></a>24.1 需求分析</h3><ul><li>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的<code>去结算</code>按钮，页面跳转到订单确认页面，点击<code>去支付</code>按钮，完成下单操作</li></ul><p><img src="image-20231015113216825.png" alt="image-20231015113216825"></p><h3 id="24-2-数据模型"><a href="#24-2-数据模型" class="headerlink" title="24.2 数据模型"></a>24.2 数据模型</h3><p>户下单业务对应的数据表为<code>orders</code>表和<code>order_detail</code>表</p><ul><li><code>orders</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">number</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单号</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">订单状态 1待付款，2待派送，3已派送，4已完成，5已取消</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单用户</td></tr><tr><td align="center">address_book_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址id</td></tr><tr><td align="center">order_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单时间</td></tr><tr><td align="center">checkout_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">结账时间</td></tr><tr><td align="center">pay_method</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">支付方式 1微信,2支付宝</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">实收金额</td></tr><tr><td align="center">remark</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">备注</td></tr><tr><td align="center">phone</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">address</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址</td></tr><tr><td align="center">user_name</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户名</td></tr><tr><td align="center">consignee</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr></tbody></table><ul><li><code>order_detail</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名字</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">order_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单id</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr></tbody></table><h3 id="24-3-梳理交互过程"><a href="#24-3-梳理交互过程" class="headerlink" title="24.3 梳理交互过程"></a>24.3 梳理交互过程</h3><ol><li>在购物车中点击<code>去结算</code>按钮，页面跳转到订单确认页面</li><li>在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址</li><li>在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据（已完成）</li><li>在订单确认页面点击<code>去支付</code>按钮，发送ajax请求，请求服务端，完成下单操作</li></ol><h3 id="24-4-准备工作"><a href="#24-4-准备工作" class="headerlink" title="24.4 准备工作"></a>24.4 准备工作</h3><ol><li><p>实体类<code>Orders</code>和<code>OrderDetail</code></p></li><li><p><code>Mapper</code>接口<code>OrderMapper</code>、<code>OrderDetailMapper</code></p></li><li><p>业务层接口<code>OrderService</code>、<code>OrderDetailService</code></p></li><li><p>业务层接口实现类<code>OrderServiceImpl</code>、<code>OrderDetailServiceImpl</code></p></li><li><p>控制层<code>OrderController</code>、<code>OrderDetailController</code></p></li></ol><h3 id="24-5-获取默认地址"><a href="#24-5-获取默认地址" class="headerlink" title="24.5 获取默认地址"></a>24.5 获取默认地址</h3><ul><li>我们点击去结算按钮，然后查看发送的请求url和方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/addressBook/default">http://localhost/addressBook/default</a><br>请求方法: GET</p></blockquote><ul><li>我们根据请求路径<code>/addressBook/default</code>，请求方式<code>GET</code>自己来编写方法，进入到<code>AddressBookController</code>编写</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;default&quot;)public Result&lt;AddressBook&gt; defaultAddress() &#123;    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;当前用户    queryWrapper.eq(userId !&#x3D; null, AddressBook::getUserId, BaseContext.getCurrentId());    &#x2F;&#x2F;默认地址    queryWrapper.eq(AddressBook::getIsDefault, 1);        AddressBook addressBook &#x3D; addressBookService.getOne(queryWrapper);    return Result.success(addressBook);&#125;</code></pre><h3 id="24-6-结算"><a href="#24-6-结算" class="headerlink" title="24.6 结算"></a>24.6 结算</h3><ul><li>点击上图中的去结算按钮，查看发送的请求url与请求方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/order/submit">http://localhost/order/submit</a><br>请求方法: POST</p></blockquote><ul><li>提交给服务端的数据格式为JSON</li></ul><pre class="line-numbers language-none"><code class="language-none">AVRASMaddressBookId: &quot;1579828298672885762&quot;,payMethod: 1,remark: &quot;&quot;</code></pre><ul><li><p>请求路径<code>/order/submit</code>，请求方式<code>POST</code>，那么我们现在就去<code>OrderController</code>中开发对应的功能<br>具体的<code>submit</code>方法我们放在<code>OrderService</code>写，<code>OrderController</code>调用写好的<code>submit</code>方法就好了</p></li><li><p>编写具体的submit方法的逻辑代码，我们先来分析一下下单功能，都需要做什么事情</p><ul><li><p>获取当前用户id</p></li><li><p>根据用户id查询其购物车数据</p></li><li><p>根据查询到的购物车数据，对订单表插入数据（1条）</p></li><li><p>根据查询到的购物车数据，对订单明细表插入数据（多条）</p></li><li><p>清空购物车数据</p></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService &#123;    @Autowired    private ShoppingCartService shoppingCartService;    @Autowired    private UserService userService;    @Autowired    private AddressBookService addressBookService;    @Autowired    private OrderDetailService orderDetailService;    @Override    public void submit(Orders orders) &#123;        &#x2F;&#x2F;获取当前用户id        Long userId &#x3D; BaseContext.getCurrentId();        &#x2F;&#x2F;条件构造器        LambdaQueryWrapper&lt;ShoppingCart&gt; shoppingCartLambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;根据当前用户id查询其购物车数据        shoppingCartLambdaQueryWrapper.eq(userId !&#x3D; null, ShoppingCart::getUserId, userId);        List&lt;ShoppingCart&gt; shoppingCarts &#x3D; shoppingCartService.list(shoppingCartLambdaQueryWrapper);        &#x2F;&#x2F;判断一下购物车是否为空        if (shoppingCarts &#x3D;&#x3D; null) &#123;            throw new CustomException(&quot;购物车数据为空，不能下单&quot;);        &#125;        &#x2F;&#x2F;判断一下地址是否有误        Long addressBookId &#x3D; orders.getAddressBookId();        AddressBook addressBook &#x3D; addressBookService.getById(addressBookId);        if (addressBookId &#x3D;&#x3D; null) &#123;            throw new CustomException(&quot;地址信息有误，不能下单&quot;);        &#125;        &#x2F;&#x2F;获取用户信息，为了后面赋值        User user &#x3D; userService.getById(userId);        long orderId &#x3D; IdWorker.getId();        &#x2F;&#x2F;原子数，更精细计算        AtomicInteger amount &#x3D; new AtomicInteger(0);        &#x2F;&#x2F;向订单细节表设置属性        List&lt;OrderDetail&gt; orderDetailList&#x3D; shoppingCarts.stream().map((item) -&gt; &#123;            OrderDetail orderDetail &#x3D; new OrderDetail();            orderDetail.setOrderId(orderId);            orderDetail.setName(item.getName());            orderDetail.setImage(item.getImage());            orderDetail.setDishId(item.getDishId());            orderDetail.setSetmealId(item.getSetmealId());            orderDetail.setDishFlavor(item.getDishFlavor());            orderDetail.setNumber(item.getNumber());            orderDetail.setAmount(item.getAmount());            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());            return orderDetail;        &#125;).collect(Collectors.toList());        &#x2F;&#x2F;向订单表设置属性        orders.setId(orderId);        orders.setNumber(String.valueOf(orderId));        orders.setStatus(2);        orders.setUserId(userId);        orders.setAddressBookId(addressBookId);        orders.setOrderTime(LocalDateTime.now());        orders.setCheckoutTime(LocalDateTime.now());        orders.setAmount(new BigDecimal(amount.get()));        orders.setPhone(addressBook.getPhone());        orders.setUserName(user.getName());        orders.setConsignee(addressBook.getConsignee());        orders.setAddress(                (addressBook.getProvinceName() &#x3D;&#x3D; null ? &quot;&quot;:addressBook.getProvinceName())+                        (addressBook.getCityName() &#x3D;&#x3D; null ? &quot;&quot;:addressBook.getCityName())+                        (addressBook.getDistrictName() &#x3D;&#x3D; null ? &quot;&quot;:addressBook.getDistrictName())+                        (addressBook.getDetail() &#x3D;&#x3D; null ? &quot;&quot;:addressBook.getDetail())        );        &#x2F;&#x2F;根据查询到的购物车数据，对订单表插入数据（1条）        this.save(orders);        &#x2F;&#x2F;根据查询到的购物车数据，对订单明细表插入数据（多条）        orderDetailService.saveBatch(orderDetailList);        &#x2F;&#x2F;清空购物车数据        shoppingCartService.remove(shoppingCartLambdaQueryWrapper);    &#125;&#125;</code></pre><h1 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h1><ul><li>问题说明：<ul><li>当用户数量足够多的时候，系统访问量大</li><li>频繁的访问数据库，系统性能下降，用户体验差</li><li>所以一些通用、常用的数据，我们可以使用Redis来缓存，避免用户频繁访问数据库</li></ul></li></ul><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><h4 id="1-1-导入SpringDataRedis的maven坐标"><a href="#1-1-导入SpringDataRedis的maven坐标" class="headerlink" title="1.1 导入SpringDataRedis的maven坐标"></a>1.1 导入SpringDataRedis的maven坐标</h4><ul><li>这里我们就还是用SpringDataRedis来开发了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><h4 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h4><ul><li>配置连接redis的数据，我这里配置的是我的云服务器上装的Redis</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0</code></pre><h4 id="1-3-配置类"><a href="#1-3-配置类" class="headerlink" title="1.3 配置类"></a>1.3 配置类</h4><ul><li>配置一下序列化器，方便我们在图形化界面中查看我们存入的数据，在config包下新建RedisConfig类</li><li>但是也可以不配置RedisConfig，而是直接用<code>SpringRedisConfig</code>，它的默认序列化器就是<code>StringRedisSerializer</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;Object, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();        &#x2F;&#x2F;默认key序列化器为：JdkSerializationRedisSerializer        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setConnectionFactory(connectionFactory);        return redisTemplate;    &#125;&#125;</code></pre><h3 id="2-缓存短信验证码"><a href="#2-缓存短信验证码" class="headerlink" title="2. 缓存短信验证码"></a>2. 缓存短信验证码</h3><h4 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h4><ul><li>先来回顾一下我们之前的邮件验证码是储存在哪儿的<ul><li>之前我们是存的Session，session的有效期是30分钟</li></ul></li><li>那现在我们学了Redis的基础应用，我们现在就可以把它缓存在Redis里</li><li>具体实现思路如下<ol><li>在服务端UserController中注入RedisTemplate对象，用于操作Redis;</li><li>在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟;</li><li>在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码;</li></ol></li></ul><h4 id="2-2-代码改造"><a href="#2-2-代码改造" class="headerlink" title="2.2 代码改造"></a>2.2 代码改造</h4><ol><li>在UserController中注入RedisTemplate或StringRedisTemplate对象，用于操作Redis</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改UserController中的sendMsg方法，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;sendMsg&quot;)public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException &#123;    String phone &#x3D; user.getPhone();    if (!phone.isEmpty()) &#123;        &#x2F;&#x2F;随机生成一个验证码        String code &#x3D; MailUtils.achieveCode();        log.info(code);        &#x2F;&#x2F;这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        &#x2F;&#x2F;验证码缓存到Redis，设置存活时间5分钟        redisTemplate.opsForValue().set(&quot;code&quot;, code,5, TimeUnit.MINUTES);        return Result.success(&quot;验证码发送成功&quot;);    &#125;    return Result.error(&quot;验证码发送失败&quot;);&#125;</code></pre><ol start="3"><li>在服务端的UserController的login方法中，从Redis获取验证码，如果登录成功则删除Redis中的验证码</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;login&quot;)public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) &#123;    log.info(map.toString());    String phone &#x3D; map.get(&quot;phone&quot;).toString();    String code &#x3D; map.get(&quot;code&quot;).toString();    &#x2F;&#x2F;把Redis中缓存的code拿出来    Object codeInRedis &#x3D; redisTemplate.opsForValue().get(phone);    &#x2F;&#x2F;看看接收到用户输入的验证码是否和redis中的验证码相同    log.info(&quot;你输入的code&#123;&#125;，redis中的code&#123;&#125;，计算结果为&#123;&#125;&quot;, code, codeInRedis, (code !&#x3D; null &amp;&amp; code.equals(codeInRedis)));    if (code !&#x3D; null &amp;&amp; code.equals(codeInRedis)) &#123;        LambdaQueryWrapper&lt;User&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getPhone, phone);        User user &#x3D; userService.getOne(queryWrapper);        if (user &#x3D;&#x3D; null) &#123;            user &#x3D; new User();            user.setPhone(phone);            user.setName(&quot;用户&quot; + codeInRedis);            userService.save(user);        &#125;        session.setAttribute(&quot;user&quot;, user.getId());        &#x2F;&#x2F;如果登陆成功，则删除Redis中的验证码        redisTemplate.delete(phone);        return Result.success(user);    &#125;    return Result.error(&quot;登录失败&quot;);&#125;</code></pre><h3 id="3-缓存菜品数据"><a href="#3-缓存菜品数据" class="headerlink" title="3. 缓存菜品数据"></a>3. 缓存菜品数据</h3><ul><li>菜品数据是我们登录移动端之后的展示页面</li><li>所以每当我们访问首页的时候，都会调用数据库查询一遍菜品数据</li><li>对于这种需要频繁访问的数据，我们可以将其缓存到Redis中以减轻服务器的压力</li></ul><h4 id="3-1-实现思路"><a href="#3-1-实现思路" class="headerlink" title="3.1 实现思路"></a>3.1 实现思路</h4><ul><li>移动端对应的菜品查看功能，是DishController中的list方法，此方法会根据前端提交的查询条件进行数据库查询操作（用户选择不同的菜品分类）。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。所以现在我们需要对此方法进行缓存优化，提高系统性能</li><li>但是还有存在一个问题，我们是将所有的菜品缓存一份，还是按照菜品&#x2F;套餐分类，来进行缓存数据呢？</li><li>答案是后者，当我们点击某一个分类时，只需展示当前分类下的菜品，而其他分类的菜品数据并不需要展示，所以我们在缓存的时候，根据菜品的分类，缓存多分数据，页面在查询时，点击某个分类，则查询对应分类下的菜品的缓存数据</li><li>具体实现思路如下<ol><li>修改DishController中的list方法，先从Redis中获取分类对应的菜品数据，如果有，则直接返回；如果无，则查询数据库，并将查询到的菜品数据存入Redis</li><li>修改DishController的save、update和delete方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改&#x2F;更新&#x2F;删除了某些菜品，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="3-2-代码改造"><a href="#3-2-代码改造" class="headerlink" title="3.2 代码改造"></a>3.2 代码改造</h4><ol><li>先在DishController中注入RedisTemplate</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改DishController的list方法，先从Redis中获取菜品数据</li></ol><ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的菜品数据让Redis缓存</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) &#123;    List&lt;DishDto&gt; dishDtoList;    String key &#x3D; &quot;dish_&quot; + dish.getCategoryId() + &quot;_&quot; + dish.getStatus();    dishDtoList &#x3D; (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);    &#x2F;&#x2F;如果有，则直接返回    if (dishDtoList !&#x3D; null)&#123;        return Result.success(dishDtoList);    &#125;    &#x2F;&#x2F;如果无，则查询    &#x2F;&#x2F;条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() !&#x3D; null, Dish::getCategoryId, dish.getCategoryId());    &#x2F;&#x2F;只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    &#x2F;&#x2F;简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    &#x2F;&#x2F;获取查询到的结果作为返回值    List&lt;Dish&gt; list &#x3D; dishService.list(queryWrapper);    log.info(&quot;查询到的菜品信息list:&#123;&#125;&quot;, list);    &#x2F;&#x2F;item就是list中的每一条数据，相当于遍历了    dishDtoList &#x3D; list.stream().map((item) -&gt; &#123;        &#x2F;&#x2F;创建一个dishDto对象        DishDto dishDto &#x3D; new DishDto();        &#x2F;&#x2F;将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);        &#x2F;&#x2F;由于dish表中没有categoryName属性，只存了categoryId        Long categoryId &#x3D; item.getCategoryId();        &#x2F;&#x2F;所以我们要根据categoryId查询对应的category        Category category &#x3D; categoryService.getById(categoryId);        if (category !&#x3D; null) &#123;            &#x2F;&#x2F;然后取出categoryName，赋值给dishDto            dishDto.setCategoryName(category.getName());        &#125;        &#x2F;&#x2F;然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId &#x3D; item.getId();        &#x2F;&#x2F;条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();        &#x2F;&#x2F;条件就是菜品id        lambdaQueryWrapper.eq(itemId !&#x3D; null, DishFlavor::getDishId, itemId);        &#x2F;&#x2F;根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors &#x3D; dishFlavorService.list(lambdaQueryWrapper);        &#x2F;&#x2F;赋给dishDto的对应属性        dishDto.setFlavors(flavors);        &#x2F;&#x2F;并将dishDto作为结果返回        return dishDto;        &#x2F;&#x2F;将所有返回结果收集起来，封装成List    &#125;).collect(Collectors.toList());    &#x2F;&#x2F;将查询的结果让Redis缓存，设置存活时间为60分钟    redisTemplate.opsForValue().set(key,dishDtoList,60, TimeUnit.MINUTES);    return Result.success(dishDtoList);&#125;</code></pre><ol start="3"><li>修改DishController里的save、update和批量修改方法(status)，加入清理缓存的逻辑</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;    log.info(&quot;接收到的数据为：&#123;&#125;&quot;, dishDto);    dishService.saveWithFlavor(dishDto);    String key &#x3D; &quot;dish_&quot; + dishDto.getCategoryId() + &quot;_1&quot;;    redisTemplate.delete(key);    return Result.success(&quot;添加菜品成功&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) &#123;    log.info(&quot;接收到的数据为：&#123;&#125;&quot;, dishDto);    dishService.updateWithFlavor(dishDto);    String key &#x3D; &quot;dish_&quot; + dishDto.getCategoryId() + &quot;_1&quot;;    redisTemplate.delete(key);    return Result.success(&quot;修改菜品成功&quot;);&#125;</code></pre><blockquote><p>注意：这里并不需要我们对删除操作也进行缓存清理，因为删除操作执行之前，必须先将菜品状态修改为<code>停售</code>，而停售状态也会帮我们清理缓存，同时也看不到菜品，随后将菜品删除，仍然看不到菜品，故删除操作不需要进行缓存清理</p></blockquote><h3 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4. SpringCache"></a>4. SpringCache</h3><h4 id="4-1-SpringCache介绍"><a href="#4-1-SpringCache介绍" class="headerlink" title="4.1 SpringCache介绍"></a>4.1 SpringCache介绍</h4><ul><li>SpringCache是一个框架，实现了基本注解的缓存功能，只需要简单的添加一个注解，就能实现缓存功能</li><li>SpringCache提供了一层抽象，底层可以切换不同的cache实现，具体就是通过CacheManager接口来统一不同的缓存技术</li><li>针对不同的缓存技术，需要实现不同的CacheManager</li></ul><table><thead><tr><th align="center">CacheManger</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">EhCacheCacheManager</td><td align="center">使用EhCache作为缓存技术</td></tr><tr><td align="center">GuavaCacheManager</td><td align="center">使用Googke的GuavaCache作为缓存技术</td></tr><tr><td align="center">RedisCacheManager</td><td align="center">使用Redis作为缓存技术</td></tr></tbody></table><h4 id="4-2-SpringCache常用注解"><a href="#4-2-SpringCache常用注解" class="headerlink" title="4.2 SpringCache常用注解"></a>4.2 SpringCache常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能</td></tr><tr><td align="center">@Cacheable</td><td align="center">在方法执行前spring先查看缓存中是否有数据。如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict</td><td align="center">将一条或者多条数据从缓存中删除</td></tr></tbody></table><p> @Cacheable<br><code>@Cacheable</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，其主要参数说明如下</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value&#x3D;“mycache”)或者@Cacheable(value&#x3D;(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value&#x3D;“setmealCache”,key&#x3D;“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,condition&#x3D;“#userName.length()&gt;2”)</td></tr><tr><td align="center">unless</td><td align="center">满足条件则不缓存</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,unless&#x3D;“#result &#x3D; &#x3D;null”)</td></tr></tbody></table><blockquote><p><code>@Cacheable(value=“setmealCache”,key=“#setmeal.categoryId + &#39;_&#39; + #setmeal.status”) </code>在redis中会以<code>setmealCache::setmealCache::1413342269393674242_1</code>的方式存储</p><p><img src="image-20231018170050126.png" alt="image-20231018170050126"></p></blockquote><p>@CachePut<br><code>@CachePut</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和@Cacheable不同的是，它每次都会触发真实方法的调用，其主要参数说明如下（其实跟@Cacheable一样）</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value&#x3D;“mycache”)或者@Cacheable(value&#x3D;(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,key&#x3D;“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,condition&#x3D;“#userName.length()&gt;2”)</td></tr></tbody></table><p>@CachEvict<br><code>@CachEvict</code>的作用主要针对方法配置，能够根据一定的条件对缓存进行清空</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value&#x3D;“mycache”)或者@Cacheable(value&#x3D;{“cache1”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,key&#x3D;“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value&#x3D;“testcache”,condition&#x3D;“#userName.length()&gt;2”)</td></tr><tr><td align="center">allEntries</td><td align="center">是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存</td><td align="center">例如:@CachEvict(value&#x3D;“testcache”,allEntries&#x3D;true)</td></tr><tr><td align="center">beforelnvocation</td><td align="center">是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td align="center">例如:@CachEvict(value&#x3D;“testcache”, beforelnvocation&#x3D;true)</td></tr></tbody></table><h4 id="4-3-SpringCache使用方式"><a href="#4-3-SpringCache使用方式" class="headerlink" title="4.3 SpringCache使用方式"></a>4.3 SpringCache使用方式</h4><ul><li>在SpringBoot项目中，使用缓存技术只需要在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存技术支持即可。</li><li>这里我们使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li>随后配置application.yml</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0  cache:    redis:      time-to-live: 3600000 #设置存活时间为一小时，如果不设置，则一直存活</code></pre><h3 id="5-缓存套餐数据"><a href="#5-缓存套餐数据" class="headerlink" title="5. 缓存套餐数据"></a>5. 缓存套餐数据</h3><h4 id="5-1-实现思路"><a href="#5-1-实现思路" class="headerlink" title="5.1 实现思路"></a>5.1 实现思路</h4><ul><li>前面我们已经实现了移动端查看套餐的功能，对应SetmealController中的list方法</li><li>此方法会根据前端提交的查询条件进行数据库查询操作</li><li>在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增强</li><li>现在需要对此方法进行缓存优化，提高系统性能</li><li>具体实现思路如下<ol><li>修改SetmealController中的list方法，先从Redis缓存中获取套餐数据<ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的套餐数据存入Redis</li></ul></li><li>修改SetmealController的save、update方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改&#x2F;更新&#x2F;删除了某些套餐，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="5-2-代码修改"><a href="#5-2-代码修改" class="headerlink" title="5.2 代码修改"></a>5.2 代码修改</h4><ol><li><p>导入SpringCache和Redis相关的maven坐标</p></li><li><p>在appilcation.yml中配置缓存数据的过期时间</p></li><li><p>在启动类上加上<code>@EnableCaching</code>注解，开启缓存注解功能</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@ServletComponentScan@EnableTransactionManagement@EnableCaching  &#x2F;&#x2F;开启缓存注解功能public class ReggieApplication &#123;    public static void main(String[] args) throws Exception &#123;        SpringApplication.run(ReggieApplication.class,args);        log.info(&quot;项目启动成功...&quot;);    &#125;&#125;</code></pre><ol start="4"><li>在SetmealController的list方法上加上<code>@Cacheable</code>注解<br>该注解的功能是：在方法执行前，Spring先查看缓存中是否有数据；如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;list&quot;)@Cacheable(value &#x3D; &quot;setmealCache&quot;, key &#x3D; &quot;#setmeal.categoryId + &#39;_&#39; + #setmeal.status&quot;)public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) &#123;    &#x2F;&#x2F;条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    &#x2F;&#x2F;添加条件    queryWrapper.eq(setmeal.getCategoryId() !&#x3D; null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() !&#x3D; null, Setmeal::getStatus, 1);    &#x2F;&#x2F;排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList &#x3D; setmealService.list(queryWrapper);    return Result.success(setmealList);&#125;</code></pre><ol start="5"><li>修改SetmealController的save、update和status方法，加入清理缓存的逻辑</li></ol><p>不用修改delete方法，因为只需要编辑status即可，前面有说过</p><p>实现手段也只需要加上<code>@CacheEvict</code>注解，该注解的功能是：将一条或者多条数据从缓存中删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping&#x2F;&#x2F;设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value &#x3D; &quot;setmealCache&quot;, allEntries &#x3D; true)public Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) &#123;    log.info(&quot;套餐信息：&#123;&#125;&quot;, setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success(&quot;套餐添加成功&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping&#x2F;&#x2F;设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value &#x3D; &quot;setmealCache&quot;, allEntries &#x3D; true)public Result&lt;Setmeal&gt; updateWithDish(@RequestBody SetmealDto setmealDto) &#123;    List&lt;SetmealDish&gt; setmealDishes &#x3D; setmealDto.getSetmealDishes();    Long setmealId &#x3D; setmealDto.getId();    &#x2F;&#x2F;先根据id把setmealDish表中对应套餐的数据删了    LambdaQueryWrapper&lt;SetmealDish&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(SetmealDish::getSetmealId, setmealId);    setmealDishService.remove(queryWrapper);    &#x2F;&#x2F;然后在重新添加    setmealDishes &#x3D; setmealDishes.stream().map((item) -&gt; &#123;        item.setSetmealId(setmealId);        return item;    &#125;).collect(Collectors.toList());    &#x2F;&#x2F;更新套餐数据    setmealService.updateById(setmealDto);    &#x2F;&#x2F;更新套餐对应菜品数据    setmealDishService.saveBatch(setmealDishes);    return Result.success(setmealDto);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;status&#x2F;&#123;status&#125;&quot;)&#x2F;&#x2F;设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value &#x3D; &quot;setmealCache&quot;, allEntries &#x3D; true)public Result&lt;String&gt; status(@PathVariable String status, @RequestParam List&lt;Long&gt; ids) &#123;    LambdaUpdateWrapper&lt;Setmeal&gt; updateWrapper &#x3D; new LambdaUpdateWrapper&lt;&gt;();    updateWrapper.in(Setmeal::getId, ids);    updateWrapper.set(Setmeal::getStatus, status);    setmealService.update(updateWrapper);    return Result.success(&quot;批量操作成功&quot;);&#125;</code></pre><blockquote><ul><li>在做完这一步之后，会发现报错:<code>DefaultSerializer requires a Serializable payload but received an object of type</code></li><li>这是因为要缓存的JAVA对象必须实现<code>Serializable</code>接口，因为Spring会先将对象序列化再存入Redis，将缓存实体类继承<code>Serializable</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Result&lt;T&gt; implements Serializable</code></pre></blockquote><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h3><ul><li>目前我们所有的读和写的压力都是由一台数据库来承担，</li><li>如果数据库服务器磁盘损坏，则数据会丢失（没有备份）</li><li>解决这个问题，就可以用MySQL的主从复制，写操作交给主库，读操作交给从库</li><li>同时将主库写入的内容，同步到从库中</li></ul><p><img src="7d9f6630j00rjzmok002gd0017r00mjp.jpg" alt="img"></p><h3 id="2-MySQL主从复制"><a href="#2-MySQL主从复制" class="headerlink" title="2. MySQL主从复制"></a>2. MySQL主从复制</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的二进制日志功能。就是一台或多台NysQL数据库（slave，即从库）从另一台MySQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。</li><li>MySQL复制过程分成三步:<ol><li><code>maste</code>r将改变记录到二进制日志(<code>binary log</code>)</li><li><code>slave</code>将<code>master</code>的<code>binary log</code>拷贝到它的中继日志(<code>relay log</code>)</li><li><code>slave</code>重做中继日志中的事件，将改变应用到自己的数据库中</li></ol></li></ul><p><img src="2ee25861j00rjzn78000yd000lf00emp.jpg" alt="img"></p><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><ul><li><p>前置条件<br>准备好两台服务器，分别安装MySQL并启动服务成功，我这里用的两台虚拟机（另一台是克隆的，记得修改克隆虚拟机的MySQL的UUID）</p></li><li><p>修改克隆机的MySQL的uuid</p><ol><li>登录克隆机的MySQL</li><li>执行SQL语句，记住生成的uuid，待会需要用</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; select uuid();+--------------------------------------+| uuid()                               |+--------------------------------------+| aaa9efc9-6e25-11ee-9d03-000c294093b6 |+--------------------------------------+</code></pre><ol start="3"><li>查看配置文件目录</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; show variables like &#39;datadir&#39;;+---------------+-----------------+| Variable_name | Value           |+---------------+-----------------+| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |+---------------+-----------------+</code></pre><ol start="4"><li>编辑配置文件目录，修改uuid为刚刚我们生成的uuid</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;auto.cnf</code></pre><ol start="5"><li>重启服务</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service mysqld restart</code></pre></li><li><p>配置主库，我这里就用虚拟机上的mysql当主库了</p><ol><li><p>修改MySQL数据库的配置文件，虚拟机是</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入两行</li></ul><pre class="line-numbers language-none"><code class="language-none">log_bin&#x3D;mysql-bin #[必须]启用二进制日志server-id&#x3D;100 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</code></pre></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create user nanying identified by &#39;Root@123456&#39;;grant replication slave on *.* to nanying;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show master status;</code></pre><p>记录下结果中File和Position的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      694 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+</code></pre></li><li><p>配置从库，我这里就用我的另一台克隆的虚拟机了</p><ol><li><p>修改MySQL数据库的配置文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入一行</li></ul><blockquote><p>server-id&#x3D;130 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</p></blockquote></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL，将参数修改为你自己的</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">change master to master_host&#x3D;&#39;192.168.71.100&#39;,master_user&#x3D;&#39;nanying&#39;,master_password&#x3D;&#39;Root@123456&#39;,master_log_file&#x3D;&#39;mysql-bin.000001&#39;,master_log_pos&#x3D;694;CHANGE MASTER TO GET_MASTER_PUBLIC_KEY&#x3D;1; # 修改mysql 8.0之后默认的认证方式start slave;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行SQL，查看从库的状态</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show slave status\G</code></pre></li></ul><p>看到如下如下三行配置相同，则主从连接成功</p><blockquote><p>Slave_IO_State: Waiting for master to send event<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes</p></blockquote><h3 id="3-读写分离案例"><a href="#3-读写分离案例" class="headerlink" title="3. 读写分离案例"></a>3. 读写分离案例</h3><h4 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h4><ul><li>面对日益增加的系统访问量，数据库的吞吐量面临着巨大的瓶颈。</li><li>对于同一时刻有<code>大量并发读操作</code>和<code>较少的写操作</code>类型的应用系统来说，将数据库拆分为<code>主库</code>和<code>从库</code></li><li><code>主库</code>主要负责处理事务性的增删改操作</li><li><code>从库</code>主要负责查询操作</li><li>这样就能有效避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善</li></ul><h4 id="3-2-Sharding-JDBC介绍"><a href="#3-2-Sharding-JDBC介绍" class="headerlink" title="3.2 Sharding-JDBC介绍"></a>3.2 Sharding-JDBC介绍</h4><ul><li>Sharding-JDBC定位为轻量级的JAVA框架，在JAVA的JDBC层提供额外的服务，它使得客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</li><li>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离<ul><li>适用于任何基于JDBC的ORM框架</li><li>支持任何第三方的数据库连接池</li><li>支持任意实现JDBC规范的数据库</li></ul></li><li>使用Sharding-JDBC框架的步骤<ol><li>导入对应的maven坐标</li><li>在配置文件中配置读写分离规则</li><li>在配置文件中配置允许bean定义覆盖配置项</li></ol></li></ul><h3 id="4-项目实现读写分离"><a href="#4-项目实现读写分离" class="headerlink" title="4. 项目实现读写分离"></a>4. 项目实现读写分离</h3><ul><li><p>前面我们已经配置好了主从数据库，那么我们现在就用瑞吉外卖试试读写分离</p><ol><li>导入瑞吉外卖的SQL数据</li><li>Git创建一个新分支<code>v1.1</code>，便于我们提交维护</li><li>导入<code>Sharding-JDBC</code>的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.0.0-RC1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="4"><li>在配置文件中配置读写分离规则,配置允许bean定义覆盖配置项<br>配置项可能会爆红，但是不影响影响项目启动，是IDEA的问题</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  shardingsphere:    datasource:      names:        master,slave      master:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql:&#x2F;&#x2F;192.168.71.100:3306&#x2F;reggie?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;allowPublicKeyRetrieval&#x3D;true        username: root        password: 123456      slave:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql:&#x2F;&#x2F;192.168.71.130:3306&#x2F;reggie?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;allowPublicKeyRetrieval&#x3D;true        username: root        password: 123456    masterslave:      load-balance-algorithm-type: round_robin      name: dataSource      master-data-source-name: master      slave-data-source-names: slave    props:      sql:        show: true  main:    allow-bean-definition-overriding: true</code></pre></li></ul><blockquote><p>可能遇到的问题</p><ul><li>启动时不报错，但是登陆功能报<code>500</code>异常</li><li>查看控制台出现<code>SQLFeatureNotSupportedException</code>异常</li></ul><p>解决方案</p><ul><li><p>修改pom.xml中druid的maven坐标为</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.20&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></li></ul></blockquote><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li>Nginx是一款轻量级的<code>Web</code>&#x2F;<code>反向代理</code>服务器以及电子邮件(IMAP&#x2F;POP3)代理服务器，其特点是占有内存少，并发能力强。</li><li>事实上Nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用Nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</li><li>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Pam6nep）开发的，第一个公开版本0.1.0发布于2004年10月4日。</li><li>官网：<a href="https://nginx.org/">https://nginx.org/</a></li></ul><h3 id="2-Nginx的下载和安装"><a href="#2-Nginx的下载和安装" class="headerlink" title="2. Nginx的下载和安装"></a>2. Nginx的下载和安装</h3><ul><li><p>官网下载链接：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p></li><li><p>安装过程：</p><ol><li>Nginx是C语言开发的，所以需要先安装依赖</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</code></pre><ol start="2"><li>下载Nginx安装包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wgetwget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.24.0.tar.gz</code></pre><ol start="3"><li>解压，我习惯放在<code>/usr/local</code>目录下</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf nginx-1.24.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</code></pre><ol start="4"><li>进入到我们解压完毕后的文件夹内</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;nginx-1.24.0&#x2F;</code></pre><ol start="5"><li>建安装路径文件夹</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;usr&#x2F;local&#x2F;nginx</code></pre><ol start="6"><li>安装前检查工作</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</code></pre><ol start="7"><li>编译并安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make &amp;&amp; make install</code></pre></li></ul><h3 id="3-Nginx目录结构"><a href="#3-Nginx目录结构" class="headerlink" title="3. Nginx目录结构"></a>3. Nginx目录结构</h3><ul><li><p>安装完Nginx后，我们先来熟悉一下Nginx的目录结构</p></li><li><p>重点目录&#x2F;文件:</p><ul><li>conf&#x2F;nginx.conf<ul><li>nginx配置文件</li></ul></li><li>html<ul><li>存放静态文件(html、css、Js等)</li></ul></li><li>logs<ul><li>日志目录，存放日志文件</li></ul></li><li>sbin&#x2F;nginx<ul><li>二进制文件，用于启动、停止Nginx服务</li></ul></li></ul></li><li><p>文件目录树状图如下</p></li><li><p>文件目录树状图如下</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── conf                        &lt;-- Nginx配置文件│   ├── fastcgi.conf│   ├── fastcgi.conf.default│   ├── fastcgi_params│   ├── fastcgi_params.default│   ├── koi-utf│   ├── koi-win│   ├── mime.types│   ├── mime.types.default│   ├── nginx.conf              &lt;-- 这个文件我们经常操作│   ├── nginx.conf.default│   ├── scgi_params│   ├── scgi_params.default│   ├── uwsgi_params│   ├── uwsgi_params.default│   └── win-utf├── html                        &lt;-- 存放静态文件，我们后期部署项目，就要将静态文件放在这│   ├── 50x.html        │   └── index.html              &lt;-- 提供的默认的页面├── logs                        &lt;-- 日志目录，由于我们新装的Nginx，所以现在还没有日志文件└── sbin                        └── nginx                       &lt;-- 这个文件我们也经常操作</code></pre><h3 id="4-Nginx配置文件结构"><a href="#4-Nginx配置文件结构" class="headerlink" title="4. Nginx配置文件结构"></a>4. Nginx配置文件结构</h3><ul><li>Nginx配置文件(conf&#x2F;nginx.conf)整体分为三部分<ul><li>全局块 和Nginx运行相关的全局配置</li><li>events块 和网络连接相关的配置</li><li>http块 代理、缓存、日志记录、虚拟主机配置<ul><li>http全局块</li><li>Server块<ul><li>Server全局块</li><li>location块</li></ul></li></ul></li></ul></li></ul><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">worker_processes  1;                              &lt;-- 全局块  events &#123;                                          &lt;-- events块    worker_connections  1024;  &#125;    http &#123;                                            &lt;-- http块    include       mime.types;                     &lt;-- http全局块    default_type  application&#x2F;octet-stream;      sendfile        on;      keepalive_timeout  65;        server &#123;                                      &lt;-- Server块        listen       80;                          &lt;-- Server全局块        server_name  localhost;          location &#x2F; &#123;                              &lt;-- location块            root   html;            index  index.html index.htm;        &#125;        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;    &#125;&#125;</code></pre><p>注意：http块中可以配置多个Server块，每个Server块中可以配置多个location块</p><h3 id="5-Nginx命令"><a href="#5-Nginx命令" class="headerlink" title="5. Nginx命令"></a>5. Nginx命令</h3><ul><li><p>查看版本</p><ul><li>进入sbin目录，输入<code>./nginx -v</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## .&#x2F;nginx -vnginx version: nginx&#x2F;1.22.1</code></pre></li><li><p>检查配置文件正确性</p><ul><li>进入sbin目录，输入<code>./nginx -t</code>，如果有错误会报错，而且也会记日志</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## .&#x2F;nginx -tnginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test is successful</code></pre></li><li><p>启动与停止</p><ul><li>进入sbin目录，输入<code>./nginx</code>，启动完成后查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## .&#x2F;nginx [root@localhost sbin]## ps -ef | grep nginxroot      89623      1  0 22:08 ?        00:00:00 nginx: master process .&#x2F;nginxnobody    89624  89623  0 22:08 ?        00:00:00 nginx: worker processroot      89921   1696  0 22:08 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx</code></pre><ul><li>如果想停止Nginx服务，输入<code>./nginx -s stop</code>，停止服务后再次查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## .&#x2F;nginx -s stop[root@localhost sbin]## ps -ef | grep nginxroot      93772   1696  0 22:11 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx</code></pre></li><li><p>重新加载配置文件</p><ul><li>当修改Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：<code>./nginx -s reload</code>。</li></ul></li></ul><blockquote><ul><li><p>上面的所有命令，都需要我们在sbin目录下才能运行，比较麻烦，所以我们可以将Nginx的二进制文件配置到环境变量中，这样无论我们在哪个目录下，都能使用上面的命令</p></li><li><p>使用<code>vim /etc/profile</code>命令打开配置文件，并配置环境变量，保存并退出</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH+ PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin:$JAVA_HOME&#x2F;bin:$PATH</code></pre></li><li><p>之后重新加载配置文件，使用<code>source /etc/profile</code>命令，然后我们在任意位置输入<code>nginx</code>即可启动服务，<code>nginx -s stop</code>即可停止服务</p></li></ul></blockquote><ul><li>查看自己IP，启动服务后，浏览器输入ip地址就可以访问Nginx的默认页面<ul><li><code>ip addr</code></li></ul></li></ul><h3 id="6-Nginx具体应用"><a href="#6-Nginx具体应用" class="headerlink" title="6. Nginx具体应用"></a>6. Nginx具体应用</h3><h4 id="6-1-部署静态资源"><a href="#6-1-部署静态资源" class="headerlink" title="6.1 部署静态资源"></a>6.1 部署静态资源</h4><ul><li>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</li><li><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效</strong>，所以在生产环境下，一般都会将静态资源部署到Nginx中。</li><li>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</li></ul><h4 id="6-2-反向代理"><a href="#6-2-反向代理" class="headerlink" title="6.2 反向代理"></a>6.2 反向代理</h4><ul><li><code>正向代理</code><ul><li>正向代理是一个位于客户端和原始服务器（origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</li><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。</li><li>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。（梯子）</li></ul></li></ul><p><img src="b7a9bc05j00rk13jv000id000ld008bp.jpg" alt="img"></p><ul><li><p><code>反向代理</code></p><ul><li><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，<strong>反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。</p><ul><li>便于统一管理多台web服务器</li><li>web服务器可能在公司内网，无法直接访问</li></ul></li><li><p><strong>用户不需要知道目标服务器的地址</strong>，也无须在用户端作任何设定。</p></li></ul></li></ul><p><img src="220be961j00rk13nz000rd000q600avp.jpg" alt="img"></p><ul><li><p><code>举个例子</code></p><ul><li>正向代理：你让舍友去给你带三楼卖的煎饼（你最终会得到一个三楼的煎饼）</li><li>反向代理：你让舍友去给你买煎饼（你最终只会得到一个煎饼，但你不知道煎饼是哪儿卖的）</li><li>和正向代理不同，反向代理相当于是为目标服务器工作的，当你去访问某个网站时，你以为你访问问的是目标服务器，其实不然，当你访问时，其实是由一个代理服务器去接收你的请求，正向代理与反向代理最简单的区别： 正向代理隐藏的是用户（卖煎饼的不知道是你要买），反向代理隐藏的是服务器（你不知道煎饼是谁卖的）。</li><li>正向代理侧重的是用户，用户知道可以通过代理访问无法访问的资源，而反向代理侧重点在服务器这边，用户压根不知道自己访问的是资源时通过代理人去转发的。</li></ul></li><li><p><code>配置反向代理</code><br>这里是在<code>192.168.138.100</code>上配置的，那么访问流程如下<br>客户端 –&gt; <code>192.168.138.100:82</code> –&gt; <code>192.168.138.101/50x.html</code><br>客户端访问反向代理服务器的82端口，而82端口又将请求转发给web服务器的<code>50x.html</code>资源<br>注意这里需要开启反向代理服务器的82端口</p></li></ul><p><img src="image-20231019192535504.png" alt="image-20231019192535504"></p><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">server &#123;    listen       82;    server_name  localhost;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;http:&#x2F;&#x2F;192.168.138.101&#x2F;50x.html;    &#125;&#125;</code></pre><h4 id="6-3-负载均衡"><a href="#6-3-负载均衡" class="headerlink" title="6.3 负载均衡"></a>6.3 负载均衡</h4><ul><li>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</li><li>应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据。</li><li>负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理。</li></ul><p><img src="7bec0435j00rk16la000pd000rd0090p.jpg" alt="img"></p><ul><li>配置负载均衡<br>默认是轮询算法，第一次访问是<code>192.168.138.101</code>，第二次访问是<code>101.XXX.XXX.160</code><br>也可以改用权重方式，权重越大，几率越大，现在的访问三分之二是第一台服务器接收，三分之一是第二台服务器接收<br><code>server 192.168.138.101 weight=10</code><br><code>server 101.XXX.XXX.160 weight=5</code></li></ul><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">upstream targetServer&#123;    server 192.168.138.101;    server 101.XXX.XXX.160;&#125;server &#123;    listen       82;    server_name  localhost;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;targetServer;    &#125;&#125;</code></pre><ul><li>负载均衡策略</li></ul><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">默认方式</td></tr><tr><td align="center">weight</td><td align="center">权重方式</td></tr><tr><td align="center">ip_hash</td><td align="center">依据ip分配方式</td></tr><tr><td align="center">least_conn</td><td align="center">依据最少连接方式</td></tr><tr><td align="center">url_hash</td><td align="center">依据url分配方式</td></tr><tr><td align="center">fair</td><td align="center">依据响应时间方式</td></tr></tbody></table><h3 id="7-Nginx的特点"><a href="#7-Nginx的特点" class="headerlink" title="7. Nginx的特点"></a>7. Nginx的特点</h3><ol><li>跨平台：Nginx可以在大多数操作系统中运行，而且也有Windows的移植版本</li><li>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置</li><li>非阻塞、高并发：数据复制时，磁盘I&#x2F;O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2-3万并发连接数（这得益于Nginx使用了最新的epoll模型）</li><li>事件驱动：通信机制采用epoll模式，支持更大的并发连接数</li><li>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx进程才消耗150M内存（15M*10&#x3D;150M）</li><li>成本低廉：Nginx作为开源软件，可以免费试用。而购买F5 BIG-IP、NetScaler等硬件负载均衡交换机则需要十多万至几十万人民币</li><li>内置健康检查功能：如果Nginx Proxy后端的某台Web服务器宕机了，不会影响前端访问。</li><li>节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头。</li><li>稳定性高：用于反向代理，宕机的概率微乎其微。</li></ol><h2 id="前后端分离开发"><a href="#前后端分离开发" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h2><ul><li>开发人员同时负责前端和后端代码开发，分工不明确，开发效率低</li><li>前后端代码混合在一个工程中，不便于管理</li><li>对开发人员要求高，人员招聘困难</li><li>所以衍生出了一种前后端分离开发</li></ul><h3 id="1-前后端分离开发"><a href="#1-前后端分离开发" class="headerlink" title="1. 前后端分离开发"></a>1. 前后端分离开发</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li><code>前后端分离开发</code>，就是在项目开发过程中，对前端代码的开发，专门由<code>前端开发人员</code>负责，后端代码由<code>后端开发人员</code>负责，这样可以做到分工明确，各司其职，提高开发效率，前后端代码并行开发，可以加快项目的开发速度。目前，前后端分离开发方式已经被越来越多的公司采用了，成为现在项目开发的主流开发方式。</li><li>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为<code>前端工程和后端工程</code></li></ul><p><img src="74b098faj00rk1epy000md000r80093p.jpg" alt="img"></p><h4 id="1-2-开发流程"><a href="#1-2-开发流程" class="headerlink" title="1.2 开发流程"></a>1.2 开发流程</h4><ul><li>前后端开发人员都参照接口API文档进行开发</li><li>接口（API接口） 就是一个http的请求地址，主要就是去定义：请求路径、请求方式、请求参数、响应参数等内容。</li></ul><p><img src="2583d817j00rk1era000md000oj00byp.jpg" alt="img"></p><h3 id="2-YApi"><a href="#2-YApi" class="headerlink" title="2. YApi"></a>2. YApi</h3><h4 id="2-1-介绍-1"><a href="#2-1-介绍-1" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护API，YApi还为用户提供了优秀的交互体验，开发人员只需要利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</li><li>YApi让接口开发更简单高效，让接口的管理更具有可读性、可维护性，让团队协作更合理。</li><li>Git仓库：<a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></li></ul><h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><p>需要首先在本地配置</p><ul><li>使用YApi，可以执行下面操作：<ul><li>添加项目</li><li>添加分类</li><li>添加接口</li><li>编辑接口</li><li>查看接口</li></ul></li></ul><h3 id="3-Swagger"><a href="#3-Swagger" class="headerlink" title="3. Swagger"></a>3. Swagger</h3><h4 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h4><ul><li>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做成各种格式的接口文档，以及在线接口调试页面等。</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><h4 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h4><ol><li>导入对应的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.0.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="2"><li>导入knife4j相关配置，并配置静态资源映射，否则接口文档页面无法访问，注意将controller的包路径修改为你自己的</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4j@EnableSwagger2 &#x2F;&#x2F;+@EnableKnife4j &#x2F;&#x2F;+public class WebMvcConfig extends WebMvcConfigurationSupport &#123;    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        log.info(&quot;开始进行静态资源映射...&quot;);        registry.addResourceHandler(&quot;&#x2F;backend&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;backend&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;front&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;front&#x2F;&quot;);        &#x2F;&#x2F; 设置静态资源映射        registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;);&#x2F;&#x2F;+        registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;).addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;);&#x2F;&#x2F;+    &#125;    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        MappingJackson2HttpMessageConverter messageConverter &#x3D; new MappingJackson2HttpMessageConverter();        &#x2F;&#x2F;设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        &#x2F;&#x2F;将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    &#125;    &#x2F;&#x2F;+    @Bean    public Docket createRestApi() &#123;        &#x2F;&#x2F;文档类型        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.blog.controller&quot;))                .paths(PathSelectors.any())                .build();    &#125;    &#x2F;&#x2F;+    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;瑞吉外卖&quot;)                .version(&quot;1.0&quot;)                .description(&quot;瑞吉外卖接口文档&quot;)                .build();    &#125;&#125;</code></pre><ol start="3"><li>在拦截器在中设置不需要处理的请求路径</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义不需要处理的请求String[] urls &#x3D; new String[]&#123;        &quot;&#x2F;employee&#x2F;login&quot;,        &quot;&#x2F;employee&#x2F;logout&quot;,        &quot;&#x2F;backend&#x2F;**&quot;,        &quot;&#x2F;front&#x2F;**&quot;,        &quot;&#x2F;common&#x2F;**&quot;,        &#x2F;&#x2F;对用户登陆操作放行        &quot;&#x2F;user&#x2F;login&quot;,        &quot;&#x2F;user&#x2F;sendMsg&quot;,        &quot;&#x2F;doc.html&quot;,        &quot;&#x2F;webjars&#x2F;**&quot;,        &quot;&#x2F;swagger-resources&quot;,        &quot;&#x2F;v2&#x2F;api-docs&quot;&#125;;</code></pre><ol start="4"><li>启动服务，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 即可看到生成的接口文档，我这里的端口号用的80，根据自己的需求改</li></ol><p><img src="image-20231020105144839.png" alt="image-20231020105144839"></p><h4 id="3-3-常用注解"><a href="#3-3-常用注解" class="headerlink" title="3.3 常用注解"></a>3.3 常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Api</td><td align="center">用在请求的类上，例如Controller，表示对类的说明</td></tr><tr><td align="center">@ApiModel</td><td align="center">用在类上，通常是个实体类，表示一个返回响应数据的信息</td></tr><tr><td align="center">@ApiModelProperty</td><td align="center">用在属性上，描述响应类的属性</td></tr><tr><td align="center">@ApiOperation</td><td align="center">用在请求的方法上，说明方法的用途、作用</td></tr><tr><td align="center">@ApilmplicitParams</td><td align="center">用在请求的方法上，表示一组参数说明</td></tr><tr><td align="center">@ApilmplicitParam</td><td align="center">用在@ApilmplicitParams注解中，指定一个请求参数的各个方面</td></tr></tbody></table><ul><li>加上这些注解，可以将我们生成的接口文档更规范</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@ApiModel(&quot;用户&quot;)public class User implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    @ApiModelProperty(&quot;主键&quot;)    private Long id;    &#x2F;&#x2F;姓名    @ApiModelProperty(&quot;姓名&quot;)    private String name;    &#x2F;&#x2F;手机号    @ApiModelProperty(&quot;手机号&quot;)    private String phone;    &#x2F;&#x2F;性别 0 女 1 男    @ApiModelProperty(&quot;性别 0 女 1 男&quot;)    private String sex;    &#x2F;&#x2F;身份证号    @ApiModelProperty(&quot;身份证号&quot;)    private String idNumber;    &#x2F;&#x2F;头像    @ApiModelProperty(&quot;头像&quot;)    private String avatar;    &#x2F;&#x2F;状态 0:禁用，1:正常    @ApiModelProperty(&quot;状态 0:禁用，1:正常&quot;)    private Integer status;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@Slf4j@RequestMapping(&quot;&#x2F;user&quot;)@Api(tags &#x3D; &quot;用户相关接口&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private RedisTemplate redisTemplate;    @PostMapping(&quot;&#x2F;sendMsg&quot;)    @ApiOperation(&quot;发送验证邮件接口&quot;)    public Result&lt;String&gt; sendMsg(@RequestBody User user) throws MessagingException &#123;        String phone &#x3D; user.getPhone();        if (!phone.isEmpty()) &#123;            &#x2F;&#x2F;随机生成一个验证码            String code &#x3D; MailUtils.achieveCode();            log.info(code);            &#x2F;&#x2F;这里的phone其实就是邮箱，code是我们生成的验证码            MailUtils.sendTestMail(phone, code);            &#x2F;&#x2F;验证码缓存到Redis，设置存活时间5分钟            redisTemplate.opsForValue().set(phone, code,5, TimeUnit.MINUTES);            return Result.success(&quot;验证码发送成功&quot;);        &#125;        return Result.error(&quot;验证码发送失败&quot;);    &#125;    @PostMapping(&quot;&#x2F;login&quot;)    @ApiOperation(&quot;用户登录接口&quot;)    @ApiImplicitParam(name &#x3D; &quot;map&quot;,value &#x3D; &quot;map集合接收数据&quot;,required &#x3D; true)    public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) &#123;        log.info(map.toString());        String phone &#x3D; map.get(&quot;phone&quot;).toString();        String code &#x3D; map.get(&quot;code&quot;).toString();        &#x2F;&#x2F;把Redis中缓存的code拿出来        Object codeInRedis &#x3D; redisTemplate.opsForValue().get(phone);        &#x2F;&#x2F;看看接收到用户输入的验证码是否和redis中的验证码相同        log.info(&quot;你输入的code&#123;&#125;，redis中的code&#123;&#125;，计算结果为&#123;&#125;&quot;, code, codeInRedis, (code !&#x3D; null &amp;&amp; code.equals(codeInRedis)));        if (code !&#x3D; null &amp;&amp; code.equals(codeInRedis)) &#123;            LambdaQueryWrapper&lt;User&gt; queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(User::getPhone, phone);            User user &#x3D; userService.getOne(queryWrapper);            if (user &#x3D;&#x3D; null) &#123;                user &#x3D; new User();                user.setPhone(phone);                user.setName(&quot;用户&quot; + codeInRedis);                userService.save(user);            &#125;            session.setAttribute(&quot;user&quot;, user.getId());            &#x2F;&#x2F;如果登陆成功，则删除Redis中的验证码            redisTemplate.delete(phone);            return Result.success(user);        &#125;        return Result.error(&quot;登录失败&quot;);    &#125;    @PostMapping(&quot;&#x2F;loginout&quot;)    @ApiOperation(&quot;用户登出接口&quot;)    public Result&lt;String&gt; logout(HttpServletRequest request) &#123;        request.getSession().removeAttribute(&quot;user&quot;);        return Result.success(&quot;退出成功&quot;);    &#125;&#125;</code></pre><ul><li>重新启动服务器，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 查看新生成的接口文档，可读性比之前提高了</li></ul><p><img src="052f1c67j00rk1ih8003pd001hc00qtp.jpg" alt="img"></p><h3 id="4-项目部署"><a href="#4-项目部署" class="headerlink" title="4. 项目部署"></a>4. 项目部署</h3><h4 id="4-1-配置环境说明"><a href="#4-1-配置环境说明" class="headerlink" title="4.1 配置环境说明"></a>4.1 配置环境说明</h4><p>一共需要三台服务器</p><ul><li>192.168.138.100（服务器A）<ul><li>Nginx：部署前端项目、配置反向代理</li><li>MySql：主从复制结构中的主库</li></ul></li><li>192.168.138.101（服务器B）<ul><li>jdk：运行java项目</li><li>git：版本控制工具</li><li>maven：项目构建工具</li><li>jar：Spring Boot 项目打成jar包基于内置Tomcat运行</li><li>MySql：主从复制结构中的从库</li></ul></li><li>101.xxx.xxx.160（服务器C，我用的我的云服务器）<ul><li>Redis：缓存中间件</li></ul></li></ul><p><img src="image-20231020111216958.png" alt="image-20231020111216958"></p><h4 id="4-2-部署前端项目"><a href="#4-2-部署前端项目" class="headerlink" title="4.2 部署前端项目"></a>4.2 部署前端项目</h4><ol><li>在服务器A中安装Nginx，将前端项目<code>打包</code>目录上传到Nginx的html目录下</li><li>修改Nginx配置文件nginx.conf，新增如下配置</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server &#123;    listen 80;    server_name localhost;    location &#x2F; &#123;        root html&#x2F;dist;        index index.html;    &#125;    location ^~ &#x2F;api&#x2F; &#123;        rewrite ^&#x2F;api&#x2F;(.*)$ &#x2F;$1 break;        proxy_pass http:&#x2F;&#x2F;192.168.238.132;    &#125;&#125;</code></pre><p><img src="image-20231020150600309.png" alt="image-20231020150600309"></p><p>请求 <a href="http://192.168.138.100/api/employee/login">http://192.168.138.100/api/employee/login</a> 转到 <a href="http://192.168..138.101:8080/employee/login">http://192.168..138.101:8080/employee/login</a></p><h4 id="4-3-部署后端项目"><a href="#4-3-部署后端项目" class="headerlink" title="4.3 部署后端项目"></a>4.3 部署后端项目</h4><ul><li>在服务器B中安装JDK，Git，MySql</li><li>将项目打成jar包，手动上传并部署（当然你也可以选择git拉取代码，然后shell脚本自动部署）</li><li>部署完后端项目之后，我们就能完成正常的登录功能了，也能进入到后台系统进行增删改查操作</li><li>图片上传路径可以修改为：&#x2F;usr&#x2F;local&#x2F;img</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/10/hello-world/"/>
      <url>/2022/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
