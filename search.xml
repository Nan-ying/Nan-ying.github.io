<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql主从复制报错：Authentication</title>
      <link href="/2023/10/19/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%8A%A5%E9%94%99%EF%BC%9AAuthentication/"/>
      <url>/2023/10/19/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%8A%A5%E9%94%99%EF%BC%9AAuthentication/</url>
      
        <content type="html"><![CDATA[<p> 在进行mysql主从复制时，</p><p> start slave 后查看slave状态发现报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> Slave_IO_State: Waiting for source to send event                  Master_Host: 192.168.71.100                  Master_User: nanying                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 694               Relay_Log_File: localhost-relay-bin.000002                Relay_Log_Pos: 324        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:            Replicate_Do_Table:        Replicate_Ignore_Table:       Replicate_Wild_Do_Table:   Replicate_Wild_Ignore_Table:                    Last_Errno: 0                   Last_Error:                  Skip_Counter: 0          Exec_Master_Log_Pos: 694              Relay_Log_Space: 537              Until_Condition: None               Until_Log_File:                 Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:            Master_SSL_CA_Path:               Master_SSL_Cert:             Master_SSL_Cipher:                Master_SSL_Key:         Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:                Last_SQL_Errno: 0               Last_SQL_Error:   Replicate_Ignore_Server_Ids:              Master_Server_Id: 100                  Master_UUID: b37a7ef2-1717-11ee-ac70-000c296a60f2             Master_Info_File: mysql.slave_master_info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:       Last_IO_Error_Timestamp:      Last_SQL_Error_Timestamp:                Master_SSL_Crl:            Master_SSL_Crlpath:            Retrieved_Gtid_Set:             Executed_Gtid_Set:                 Auto_Position: 0         Replicate_Rewrite_DB:                  Channel_Name:            Master_TLS_Version:        Master_public_key_path:         Get_master_public_key: 1            Network_Namespace: </code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这是由于mysql8.0的默认认证方式改变造成的</p><p>mysql 8.0之后默认的认证方式变为<code>caching_sha2_password</code></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong><code>解决办法</code></strong></h2><p>在mysql中执行</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHANGE MASTER TO GET_MASTER_PUBLIC_KEY=1;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show slave status\G</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> Slave_IO_State: Waiting for source to send event                  Master_Host: 192.168.71.100                  Master_User: nanying                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 694               Relay_Log_File: localhost-relay-bin.000002                Relay_Log_Pos: 324        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:            Replicate_Do_Table:        Replicate_Ignore_Table:       Replicate_Wild_Do_Table:   Replicate_Wild_Ignore_Table:                    Last_Errno: 0                   Last_Error:                  Skip_Counter: 0          Exec_Master_Log_Pos: 694              Relay_Log_Space: 537              Until_Condition: None               Until_Log_File:                 Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:            Master_SSL_CA_Path:               Master_SSL_Cert:             Master_SSL_Cipher:                Master_SSL_Key:         Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:                Last_SQL_Errno: 0               Last_SQL_Error:   Replicate_Ignore_Server_Ids:              Master_Server_Id: 100                  Master_UUID: b37a7ef2-1717-11ee-ac70-000c296a60f2             Master_Info_File: mysql.slave_master_info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:       Last_IO_Error_Timestamp:      Last_SQL_Error_Timestamp:                Master_SSL_Crl:            Master_SSL_Crlpath:            Retrieved_Gtid_Set:             Executed_Gtid_Set:                 Auto_Position: 0         Replicate_Rewrite_DB:                  Channel_Name:            Master_TLS_Version:        Master_public_key_path:         Get_master_public_key: 1            Network_Namespace: 1 row in set, 1 warning (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2023/10/15/RabbitMQ/"/>
      <url>/2023/10/15/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p><p>我们先来看看什么是同步通讯和异步通讯。如图：</p><p><img src="169856878783363.png" alt="img"></p><p>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。 </p><p>同步调用的方式我们已经学过了，之前的OpenFeign调用就是。但是：</p><ul><li>异步调用又该如何实现？</li><li>哪些业务适合用异步调用来实现呢？</li></ul><p>通过今天的学习你就能明白这些问题了。</p><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1.同步调用"></a>1.1.同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？</p><p>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：</p><p><img src="image-20231029164236813.png" alt="image-20231029164236813"></p><p>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。</p><p>这其中就存在3个问题：</p><p><strong>第一</strong>，<strong>拓展性差</strong></p><p>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。</p><p>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？</p><p>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？</p><p>。。。</p><p>最终你的支付业务会越来越臃肿：</p><p><img src="image-20231029164259412.png" alt="image-20231029164259412"></p><p>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p><p><strong>第二</strong>，<strong>性能下降</strong></p><p>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：</p><p><img src="image-20231029164346611.png" alt="image-20231029164346611"></p><p>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</p><p><strong>第三，级联失败</strong></p><p>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</p><p>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。</p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2.异步调用"></a>1.2.异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方（外卖员）</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器（外卖柜）</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方（上课的学生）</li></ul><p><img src="image-20231029164515505.png" alt="image-20231029164515505"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：</p><p><img src="image-20231029164541380.png" alt="image-20231029164541380"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><p><img src="image-20231029164555705.png" alt="image-20231029164555705"></p><p>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3.技术选型"></a>1.3.技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.</p><p>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：</p><p><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1.安装"></a>2.1.安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker run \ -e RABBITMQ_DEFAULT_USER=nanying \ -e RABBITMQ_DEFAULT_PASS=123456 \ -v mq-plugins:/plugins \ --name mq \ --hostname mq \ -p 15672:15672 \ -p 5672:5672 \ --network hm-net\ -d \ rabbitmq:3.8-management</code></pre><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：</p><p><img src="16985687878192.png" alt="img"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a></p><p>登录后即可看到管理控制台总览页面：</p><p><img src="16985687878203.png" alt="img"></p><p>RabbitMQ对应的架构如图：</p><p><img src="16985687878214.png" alt="img"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="2-2-收发消息"><a href="#2-2-收发消息" class="headerlink" title="2.2.收发消息"></a>2.2.收发消息</h2><h3 id="2-2-1-交换机"><a href="#2-2-1-交换机" class="headerlink" title="2.2.1.交换机"></a>2.2.1.交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：</p><p><img src="16985687878215.png" alt="img"></p><p>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：</p><p><img src="16985687878216.png" alt="img"></p><p><img src="16985687878217.png" alt="img"></p><p>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2.队列"></a>2.2.2.队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：</p><p><img src="16985687878228.png" alt="img"></p><p>命名为<code>hello.queue1</code>：</p><p><img src="16985687878229.png" alt="img"></p><p>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：</p><p><img src="169856878782210.png" alt="img"></p><p>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！</p><p>怎么回事呢？</p><p>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="2-2-3-绑定关系"><a href="#2-2-3-绑定关系" class="headerlink" title="2.2.3.绑定关系"></a>2.2.3.绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：</p><p><img src="169856878782311.png" alt="img"></p><p>相同的方式，将hello.queue2也绑定到改交换机。</p><p>最终，绑定结果如下：</p><p><img src="169856878782312.png" alt="img"></p><h3 id="2-2-4-发送消息"><a href="#2-2-4-发送消息" class="headerlink" title="2.2.4.发送消息"></a>2.2.4.发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：</p><p><img src="169856878782413.png" alt="img"></p><p>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：</p><p><img src="169856878782414.png" alt="img"></p><p>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：</p><p><img src="169856878782515.png" alt="img"></p><p>可以看到消息到达队列了：</p><p><img src="169856878782516.png" alt="img"></p><p>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3.数据隔离"></a>2.3.数据隔离</h2><h3 id="2-3-1-用户管理"><a href="#2-3-1-用户管理" class="headerlink" title="2.3.1.用户管理"></a>2.3.1.用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：</p><p><img src="169856878782517.png" alt="img"></p><p>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：</p><p><img src="169856878782518.png" alt="img"></p><p>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：</p><p><img src="169856878782519.png" alt="img"></p><p>别急，接下来我们就来授权。</p><h3 id="2-3-2-virtual-host"><a href="#2-3-2-virtual-host" class="headerlink" title="2.3.2.virtual host"></a>2.3.2.virtual host</h3><p>我们先退出登录：</p><p><img src="169856878782620.png" alt="img"></p><p>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：</p><p><img src="169856878782721.png" alt="img"></p><p>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。</p><p> 我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。</p><p><img src="169856878782722.png" alt="img"></p><p>创建完成后如图：</p><p><img src="169856878782823.png" alt="img"></p><p>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：</p><p><img src="169856878782824.png" alt="img"></p><p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：</p><p><img src="169856878782825.png" alt="img"></p><p>然后再次查看queues选项卡，会发现之前的队列已经看不到了：</p><p><img src="169856878782826.png" alt="img"></p><p>这就是基于<code>virtual host </code>的隔离效果。</p><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：</p><p><a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><p>这一章我们就一起学习一下，如何利用SpringAMQP实现对RabbitMQ的消息收发。</p><h2 id="3-1-导入Demo工程"><a href="#3-1-导入Demo工程" class="headerlink" title="3.1.导入Demo工程"></a>3.1.导入Demo工程</h2><p>在课前资料给大家提供了一个Demo工程，方便我们学习SpringAMQP的使用：</p><p><img src="169856878782827.png" alt="img"></p><p>将其复制到你的工作空间，然后用Idea打开，项目结构如图：</p><p><img src="169856878782828.png" alt="img"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在mq-demo这个父工程中，已经配置好了SpringAMQP相关的依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;    &lt;artifactId&gt;mq-demo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;publisher&lt;/module&gt;        &lt;module&gt;consumer&lt;/module&gt;    &lt;/modules&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.7.12&lt;/version&gt;        &lt;relativePath/&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--AMQP依赖，包含RabbitMQ--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>因此，子工程中就可以直接使用SpringAMQP了。</p><h2 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2.快速入门"></a>3.2.快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。</p><p>在入门案例中，我们就演示这样的简单模型，如图：</p><p><img src="image-20231101162747611.png" alt="image-20231101162747611"></p><p>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><blockquote><p><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。</p></blockquote><p>为了方便测试，我们现在控制台新建一个队列：simple.queue</p><p><img src="169856878782929.png" alt="img"></p><p>添加成功：</p><p><img src="169856878782930.png" alt="img"></p><p>接下来，我们就可以利用Java代码收发消息了。</p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    host: 192.168.150.101 # 你的虚拟机IP    port: 5672 # 端口    virtual-host: /hmall # 虚拟主机    username: hmall # 用户名    password: 123 # 密码</code></pre><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.publisher.amqp;import org.junit.jupiter.api.Test;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class SpringAmqpTest {    @Autowired    private RabbitTemplate rabbitTemplate;    @Test    public void testSimpleQueue() {        // 队列名称        String queueName = "simple.queue";        // 消息        String message = "hello, spring amqp!";        // 发送消息        rabbitTemplate.convertAndSend(queueName, message);    }}</code></pre><p>打开控制台，可以看到消息已经发送到队列中：</p><p><img src="169856878782931.png" alt="img"></p><p>接下来，我们再来实现消息接收。</p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    host: 192.168.150.101 # 你的虚拟机IP    port: 5672 # 端口    virtual-host: /hmall # 虚拟主机    username: hmall # 用户名    password: 123 # 密码</code></pre><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.listener;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class SpringRabbitListener {        // 利用RabbitListener来声明要监听的队列信息    // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。    // 可以看到方法体中接收的就是消息体的内容    @RabbitListener(queues = "simple.queue")    public void listenSimpleQueueMessage(String msg) throws InterruptedException {        System.out.println("spring 消费者接收到消息：【" + msg + "】");    }}</code></pre><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：</p><p><img src="169856878782932.png" alt="img"></p><h2 id="3-3-WorkQueues模型"><a href="#3-3-WorkQueues模型" class="headerlink" title="3.3.WorkQueues模型"></a>3.3.WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="image-20231101162826321.png" alt="image-20231101162826321"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。</p><p>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：</p><p><img src="169856878782933.png" alt="img"></p><h3 id="3-3-1-消息发送"><a href="#3-3-1-消息发送" class="headerlink" title="3.3.1.消息发送"></a>3.3.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */@Testpublic void testWorkQueue() throws InterruptedException {    // 队列名称    String queueName = "simple.queue";    // 消息    String message = "hello, message_";    for (int i = 0; i &lt; 50; i++) {        // 发送消息，每20毫秒发送一次，相当于每秒发送50条消息        rabbitTemplate.convertAndSend(queueName, message + i);        Thread.sleep(20);    }}</code></pre><h3 id="3-3-2-消息接收"><a href="#3-3-2-消息接收" class="headerlink" title="3.3.2.消息接收"></a>3.3.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "work.queue")public void listenWorkQueue1(String msg) throws InterruptedException {    System.out.println("消费者1接收到消息：【" + msg + "】" + LocalTime.now());    Thread.sleep(20);}@RabbitListener(queues = "work.queue")public void listenWorkQueue2(String msg) throws InterruptedException {    System.err.println("消费者2........接收到消息：【" + msg + "】" + LocalTime.now());    Thread.sleep(200);}</code></pre><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a>3.3.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>最终结果如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">消费者1接收到消息：【hello, message_0】21:06:00.869555300消费者2........接收到消息：【hello, message_1】21:06:00.884518消费者1接收到消息：【hello, message_2】21:06:00.907454400消费者1接收到消息：【hello, message_4】21:06:00.953332100消费者1接收到消息：【hello, message_6】21:06:00.997867300消费者1接收到消息：【hello, message_8】21:06:01.042178700消费者2........接收到消息：【hello, message_3】21:06:01.086478800消费者1接收到消息：【hello, message_10】21:06:01.087476600消费者1接收到消息：【hello, message_12】21:06:01.132578300消费者1接收到消息：【hello, message_14】21:06:01.175851200消费者1接收到消息：【hello, message_16】21:06:01.218533400消费者1接收到消息：【hello, message_18】21:06:01.261322900消费者2........接收到消息：【hello, message_5】21:06:01.287003700消费者1接收到消息：【hello, message_20】21:06:01.304412400消费者1接收到消息：【hello, message_22】21:06:01.349950100消费者1接收到消息：【hello, message_24】21:06:01.394533900消费者1接收到消息：【hello, message_26】21:06:01.439876500消费者1接收到消息：【hello, message_28】21:06:01.482937800消费者2........接收到消息：【hello, message_7】21:06:01.488977100消费者1接收到消息：【hello, message_30】21:06:01.526409300消费者1接收到消息：【hello, message_32】21:06:01.572148消费者1接收到消息：【hello, message_34】21:06:01.618264800消费者1接收到消息：【hello, message_36】21:06:01.660780600消费者2........接收到消息：【hello, message_9】21:06:01.689189300消费者1接收到消息：【hello, message_38】21:06:01.705261消费者1接收到消息：【hello, message_40】21:06:01.746927300消费者1接收到消息：【hello, message_42】21:06:01.789835消费者1接收到消息：【hello, message_44】21:06:01.834393100消费者1接收到消息：【hello, message_46】21:06:01.875312100消费者2........接收到消息：【hello, message_11】21:06:01.889969500消费者1接收到消息：【hello, message_48】21:06:01.920702500消费者2........接收到消息：【hello, message_13】21:06:02.090725900消费者2........接收到消息：【hello, message_15】21:06:02.293060600消费者2........接收到消息：【hello, message_17】21:06:02.493748消费者2........接收到消息：【hello, message_19】21:06:02.696635100消费者2........接收到消息：【hello, message_21】21:06:02.896809700消费者2........接收到消息：【hello, message_23】21:06:03.099533400消费者2........接收到消息：【hello, message_25】21:06:03.301446400消费者2........接收到消息：【hello, message_27】21:06:03.504999100消费者2........接收到消息：【hello, message_29】21:06:03.705702500消费者2........接收到消息：【hello, message_31】21:06:03.906601200消费者2........接收到消息：【hello, message_33】21:06:04.108118500消费者2........接收到消息：【hello, message_35】21:06:04.308945400消费者2........接收到消息：【hello, message_37】21:06:04.511547700消费者2........接收到消息：【hello, message_39】21:06:04.714038400消费者2........接收到消息：【hello, message_41】21:06:04.916192700消费者2........接收到消息：【hello, message_43】21:06:05.116286400消费者2........接收到消息：【hello, message_45】21:06:05.318055100消费者2........接收到消息：【hello, message_47】21:06:05.520656400消费者2........接收到消息：【hello, message_49】21:06:05.723106700</code></pre><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h3 id="3-3-4-能者多劳"><a href="#3-3-4-能者多劳" class="headerlink" title="3.3.4.能者多劳"></a>3.3.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    listener:      simple:        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</code></pre><p>再次测试，发现结果如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">消费者1接收到消息：【hello, message_0】21:12:51.659664200消费者2........接收到消息：【hello, message_1】21:12:51.680610消费者1接收到消息：【hello, message_2】21:12:51.703625消费者1接收到消息：【hello, message_3】21:12:51.724330100消费者1接收到消息：【hello, message_4】21:12:51.746651100消费者1接收到消息：【hello, message_5】21:12:51.768401400消费者1接收到消息：【hello, message_6】21:12:51.790511400消费者1接收到消息：【hello, message_7】21:12:51.812559800消费者1接收到消息：【hello, message_8】21:12:51.834500600消费者1接收到消息：【hello, message_9】21:12:51.857438800消费者1接收到消息：【hello, message_10】21:12:51.880379600消费者2........接收到消息：【hello, message_11】21:12:51.899327100消费者1接收到消息：【hello, message_12】21:12:51.922828400消费者1接收到消息：【hello, message_13】21:12:51.945617400消费者1接收到消息：【hello, message_14】21:12:51.968942500消费者1接收到消息：【hello, message_15】21:12:51.992215400消费者1接收到消息：【hello, message_16】21:12:52.013325600消费者1接收到消息：【hello, message_17】21:12:52.035687100消费者1接收到消息：【hello, message_18】21:12:52.058188消费者1接收到消息：【hello, message_19】21:12:52.081208400消费者2........接收到消息：【hello, message_20】21:12:52.103406200消费者1接收到消息：【hello, message_21】21:12:52.123827300消费者1接收到消息：【hello, message_22】21:12:52.146165100消费者1接收到消息：【hello, message_23】21:12:52.168828300消费者1接收到消息：【hello, message_24】21:12:52.191769500消费者1接收到消息：【hello, message_25】21:12:52.214839100消费者1接收到消息：【hello, message_26】21:12:52.238998700消费者1接收到消息：【hello, message_27】21:12:52.259772600消费者1接收到消息：【hello, message_28】21:12:52.284131800消费者2........接收到消息：【hello, message_29】21:12:52.306190600消费者1接收到消息：【hello, message_30】21:12:52.325315800消费者1接收到消息：【hello, message_31】21:12:52.347012500消费者1接收到消息：【hello, message_32】21:12:52.368508600消费者1接收到消息：【hello, message_33】21:12:52.391785100消费者1接收到消息：【hello, message_34】21:12:52.416383800消费者1接收到消息：【hello, message_35】21:12:52.439019消费者1接收到消息：【hello, message_36】21:12:52.461733900消费者1接收到消息：【hello, message_37】21:12:52.485990消费者1接收到消息：【hello, message_38】21:12:52.509219900消费者2........接收到消息：【hello, message_39】21:12:52.523683400消费者1接收到消息：【hello, message_40】21:12:52.547412100消费者1接收到消息：【hello, message_41】21:12:52.571191800消费者1接收到消息：【hello, message_42】21:12:52.593024600消费者1接收到消息：【hello, message_43】21:12:52.616731800消费者1接收到消息：【hello, message_44】21:12:52.640317消费者1接收到消息：【hello, message_45】21:12:52.663111100消费者1接收到消息：【hello, message_46】21:12:52.686727消费者1接收到消息：【hello, message_47】21:12:52.709266500消费者2........接收到消息：【hello, message_48】21:12:52.725884900消费者1接收到消息：【hello, message_49】21:12:52.746299900</code></pre><p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。</p><p>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5.总结"></a>3.3.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-4-交换机类型"><a href="#3-4-交换机类型" class="headerlink" title="3.4.交换机类型"></a>3.4.交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p><img src="image-20231101162857110.png" alt="image-20231101162857110"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（<strong><strong>交换机</strong></strong>）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="3-5-Fanout交换机"><a href="#3-5-Fanout交换机" class="headerlink" title="3.5.Fanout交换机"></a>3.5.Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p>在广播模式下，消息发送流程是这样的：</p><p><img src="169856878782934.png" alt="img"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><p><img src="169856878782935.png" alt="img"></p><ul><li>创建一个名为<code> hmall.fanout</code>的交换机，类型是<code>Fanout</code></li><li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li></ul><h3 id="3-5-1-声明队列和交换机"><a href="#3-5-1-声明队列和交换机" class="headerlink" title="3.5.1.声明队列和交换机"></a>3.5.1.声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:</p><p><img src="169856878782936.png" alt="img"></p><p>在创建一个队列<code>fanout.queue2</code>：</p><p><img src="169856878782937.png" alt="img"></p><p>然后再创建一个交换机：</p><p><img src="169856878783038.png" alt="img"></p><p>然后绑定两个队列到交换机：</p><p><img src="169856878783039.png" alt="img"></p><p><img src="169856878783040.png" alt="img"></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testpublic void testFanoutExchange() {    // 交换机名称    String exchangeName = "hmall.fanout";    // 消息    String message = "hello, everyone!";    rabbitTemplate.convertAndSend(exchangeName, "", message);}</code></pre><h3 id="3-5-3-消息接收"><a href="#3-5-3-消息接收" class="headerlink" title="3.5.3.消息接收"></a>3.5.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "fanout.queue1")public void listenFanoutQueue1(String msg) {    System.out.println("消费者1接收到Fanout消息：【" + msg + "】");}@RabbitListener(queues = "fanout.queue2")public void listenFanoutQueue2(String msg) {    System.out.println("消费者2接收到Fanout消息：【" + msg + "】");}</code></pre><h3 id="3-5-4-总结"><a href="#3-5-4-总结" class="headerlink" title="3.5.4.总结"></a>3.5.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h2 id="3-6-Direct交换机"><a href="#3-6-Direct交换机" class="headerlink" title="3.6.Direct交换机"></a>3.6.Direct交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="169856878783041.png" alt="img"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如图</strong>：</p><p><img src="169856878783042.png" alt="img"></p><ol><li>声明一个名为<code>hmall.direct</code>的交换机</li><li>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></li><li>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></li><li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 </li><li>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</li></ol><h3 id="3-6-1-声明队列和交换机"><a href="#3-6-1-声明队列和交换机" class="headerlink" title="3.6.1.声明队列和交换机"></a>3.6.1.声明队列和交换机</h3><p>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code>，这里不再展示过程：</p><p><img src="169856878783043.png" alt="img"></p><p>然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:</p><p><img src="169856878783044.png" alt="img"></p><p>然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：</p><p><img src="169856878783045.png" alt="img"></p><p><img src="169856878783046.png" alt="img"></p><p>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略，最终结果：</p><p><img src="169856878783047.png" alt="img"></p><h3 id="3-6-2-消息接收"><a href="#3-6-2-消息接收" class="headerlink" title="3.6.2.消息接收"></a>3.6.2.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "direct.queue1")public void listenDirectQueue1(String msg) {    System.out.println("消费者1接收到direct.queue1的消息：【" + msg + "】");}@RabbitListener(queues = "direct.queue2")public void listenDirectQueue2(String msg) {    System.out.println("消费者2接收到direct.queue2的消息：【" + msg + "】");}</code></pre><h3 id="3-6-3-消息发送"><a href="#3-6-3-消息发送" class="headerlink" title="3.6.3.消息发送"></a>3.6.3.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testpublic void testSendDirectExchange() {    // 交换机名称    String exchangeName = "hmall.direct";    // 消息    String message = "红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！";    // 发送消息    rabbitTemplate.convertAndSend(exchangeName, "red", message);}</code></pre><p>由于使用的red这个key，所以两个消费者都收到了消息：</p><p><img src="169856878783048.png" alt="img"></p><p>我们再切换为blue这个key：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testpublic void testSendDirectExchange() {    // 交换机名称    String exchangeName = "hmall.direct";    // 消息    String message = "最新报道，哥斯拉是居民自治巨型气球，虚惊一场！";    // 发送消息    rabbitTemplate.convertAndSend(exchangeName, "blue", message);}</code></pre><p>你会发现，只有消费者1收到了消息：</p><p><img src="169856878783049.png" alt="img"></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="3-7-Topic交换机"><a href="#3-7-Topic交换机" class="headerlink" title="3.7.Topic交换机"></a>3.7.Topic交换机</h2><h3 id="3-7-1-说明"><a href="#3-7-1-说明" class="headerlink" title="3.7.1.说明"></a>3.7.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p><pre class="line-numbers language-none"><code class="language-none">BindingKey` 一般都是有一个或多个单词组成，多个单词之间以`.`分割，例如： `item.insert</code></pre><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>图示：</p><p><img src="169856878783050.png" alt="img"></p><p>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>接下来，我们就按照上图所示，来演示一下Topic交换机的用法。</p><p>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：</p><p><img src="169856878783051.png" alt="img"></p><h3 id="3-7-2-消息发送"><a href="#3-7-2-消息发送" class="headerlink" title="3.7.2.消息发送"></a>3.7.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * topicExchange */@Testpublic void testSendTopicExchange() {    // 交换机名称    String exchangeName = "hmall.topic";    // 消息    String message = "喜报！孙悟空大战哥斯拉，胜!";    // 发送消息    rabbitTemplate.convertAndSend(exchangeName, "china.news", message);}</code></pre><h3 id="3-7-3-消息接收"><a href="#3-7-3-消息接收" class="headerlink" title="3.7.3.消息接收"></a>3.7.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "topic.queue1")public void listenTopicQueue1(String msg){    System.out.println("消费者1接收到topic.queue1的消息：【" + msg + "】");}@RabbitListener(queues = "topic.queue2")public void listenTopicQueue2(String msg){    System.out.println("消费者2接收到topic.queue2的消息：【" + msg + "】");}</code></pre><h3 id="3-7-4-总结"><a href="#3-7-4-总结" class="headerlink" title="3.7.4.总结"></a>3.7.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <strong><code>.</code></strong> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-8-声明队列和交换机"><a href="#3-8-声明队列和交换机" class="headerlink" title="3.8.声明队列和交换机"></a>3.8.声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。</p><p>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="3-8-1-基本API"><a href="#3-8-1-基本API" class="headerlink" title="3.8.1.基本API"></a>3.8.1.基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：</p><p><img src="169856878783152.png" alt="img"></p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：</p><p><img src="169856878783153.png" alt="img"></p><p>我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="169856878783154.png" alt="img"></p><p>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</p><p><img src="169856878783255.png" alt="img"></p><h3 id="3-8-2-fanout示例"><a href="#3-8-2-fanout示例" class="headerlink" title="3.8.2.fanout示例"></a>3.8.2.fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutConfig {    /**     * 声明交换机     * @return Fanout类型交换机     */    @Bean    public FanoutExchange fanoutExchange(){        return new FanoutExchange("hmall.fanout");    }    /**     * 第1个队列     */    @Bean    public Queue fanoutQueue1(){        return new Queue("fanout.queue1");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);    }    /**     * 第2个队列     */    @Bean    public Queue fanoutQueue2(){        return new Queue("fanout.queue2");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);    }}</code></pre><h3 id="3-8-2-direct示例"><a href="#3-8-2-direct示例" class="headerlink" title="3.8.2.direct示例"></a>3.8.2.direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.config;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DirectConfig {    /**     * 声明交换机     * @return Direct类型交换机     */    @Bean    public DirectExchange directExchange(){        return ExchangeBuilder.directExchange("hmall.direct").build();    }    /**     * 第1个队列     */    @Bean    public Queue directQueue1(){        return new Queue("direct.queue1");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithRed(Queue directQueue1, DirectExchange directExchange){        return BindingBuilder.bind(directQueue1).to(directExchange).with("red");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithBlue(Queue directQueue1, DirectExchange directExchange){        return BindingBuilder.bind(directQueue1).to(directExchange).with("blue");    }    /**     * 第2个队列     */    @Bean    public Queue directQueue2(){        return new Queue("direct.queue2");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithRed(Queue directQueue2, DirectExchange directExchange){        return BindingBuilder.bind(directQueue2).to(directExchange).with("red");    }    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithYellow(Queue directQueue2, DirectExchange directExchange){        return BindingBuilder.bind(directQueue2).to(directExchange).with("yellow");    }}</code></pre><h3 id="3-8-4-基于注解声明"><a href="#3-8-4-基于注解声明" class="headerlink" title="3.8.4.基于注解声明"></a>3.8.4.基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如，我们同样声明Direct模式的交换机和队列：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = "direct.queue1"),    exchange = @Exchange(name = "hmall.direct", type = ExchangeTypes.DIRECT),    key = {"red", "blue"}))public void listenDirectQueue1(String msg){    System.out.println("消费者1接收到direct.queue1的消息：【" + msg + "】");}@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = "direct.queue2"),    exchange = @Exchange(name = "hmall.direct", type = ExchangeTypes.DIRECT),    key = {"red", "yellow"}))public void listenDirectQueue2(String msg){    System.out.println("消费者2接收到direct.queue2的消息：【" + msg + "】");}</code></pre><p>是不是简单多了。</p><p>再试试Topic模式：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = "topic.queue1"),    exchange = @Exchange(name = "hmall.topic", type = ExchangeTypes.TOPIC),    key = "china.#"))public void listenTopicQueue1(String msg){    System.out.println("消费者1接收到topic.queue1的消息：【" + msg + "】");}@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = "topic.queue2"),    exchange = @Exchange(name = "hmall.topic", type = ExchangeTypes.TOPIC),    key = "#.news"))public void listenTopicQueue2(String msg){    System.out.println("消费者2接收到topic.queue2的消息：【" + msg + "】");}</code></pre><h2 id="3-9-消息转换器"><a href="#3-9-消息转换器" class="headerlink" title="3.9.消息转换器"></a>3.9.消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：</p><p><img src="169856878783256.png" alt="img"></p><p>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-9-1-测试默认转换器"><a href="#3-9-1-测试默认转换器" class="headerlink" title="3.9.1.测试默认转换器"></a>3.9.1.测试默认转换器</h3><p>1）创建测试队列</p><p>首先，我们在consumer服务中声明一个新的配置类：</p><p><img src="169856878783257.png" alt="img"></p><p>利用@Bean的方式创建一个队列，</p><p>具体代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.config;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MessageConfig {    @Bean    public Queue objectQueue() {        return new Queue("object.queue");    }}</code></pre><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p><p>重启consumer服务以后，该队列就会被自动创建出来了：</p><p><img src="169856878783258.png" alt="img"></p><p>2）发送消息</p><p>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testpublic void testSendMap() throws InterruptedException {    // 准备消息    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();    msg.put("name", "柳岩");    msg.put("age", 21);    // 发送消息    rabbitTemplate.convertAndSend("object.queue", msg);}</code></pre><p>发送消息后查看控制台：</p><p><img src="169856878783259.png" alt="img"></p><p>可以看到消息格式非常不友好。</p><h3 id="3-9-2-配置JSON转换器"><a href="#3-9-2-配置JSON转换器" class="headerlink" title="3.9.2.配置JSON转换器"></a>3.9.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;    &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic MessageConverter messageConverter(){    // 1.定义消息转换器    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息    jackson2JsonMessageConverter.setCreateMessageIds(true);    return jackson2JsonMessageConverter;}</code></pre><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：</p><p><img src="169856878783260.png" alt="img"></p><h3 id="3-9-3-消费者接收Object"><a href="#3-9-3-消费者接收Object" class="headerlink" title="3.9.3.消费者接收Object"></a>3.9.3.消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "object.queue")public void listenSimpleQueueMessage(Map&lt;String, Object&gt; msg) throws InterruptedException {    System.out.println("消费者接收到object.queue消息：【" + msg + "】");}</code></pre><h1 id="4-业务改造"><a href="#4-业务改造" class="headerlink" title="4.业务改造"></a>4.业务改造</h1><p>案例需求：改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用，改为基于RabbitMQ的异步通知。</p><p>如图：</p><p><img src="169856878783261.png" alt="img"></p><p>说明，我们只关注交易服务，步骤如下：</p><ul><li>定义topic类型交换机，命名为<code>pay.topic</code></li><li>定义消息队列，命名为<code>mark.order.pay.queue</code></li><li>将<code>mark.order.pay.queue</code>与<code>pay.topic</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li><li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.topic</code>，发送消息的<code>RoutingKey</code>  为<code>pay.success</code>，消息内容是订单id</li><li>交易服务监听<code>mark.order.pay.queue</code>队列，接收到消息后更新订单状态为已支付</li></ul><h2 id="4-1-配置MQ"><a href="#4-1-配置MQ" class="headerlink" title="4.1.配置MQ"></a>4.1.配置MQ</h2><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：</p><p>1）添加依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--消息发送--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）配置MQ地址：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    host: 192.168.150.101 # 你的虚拟机IP    port: 5672 # 端口    virtual-host: /hmall # 虚拟主机    username: hmall # 用户名    password: 123 # 密码</code></pre><h2 id="4-1-接收消息"><a href="#4-1-接收消息" class="headerlink" title="4.1.接收消息"></a>4.1.接收消息</h2><p>在trade-service服务中定义一个消息监听类：</p><p><img src="169856878783262.png" alt="img"></p><p>其代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.trade.listener;import com.hmall.trade.service.IOrderService;import lombok.RequiredArgsConstructor;import org.springframework.amqp.core.ExchangeTypes;import org.springframework.amqp.rabbit.annotation.Exchange;import org.springframework.amqp.rabbit.annotation.Queue;import org.springframework.amqp.rabbit.annotation.QueueBinding;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RequiredArgsConstructorpublic class PayStatusListener {    private final IOrderService orderService;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(name = "mark.order.pay.queue", durable = "true"),            exchange = @Exchange(name = "pay.topic", type = ExchangeTypes.TOPIC),            key = "pay.success"    ))    public void listenPaySuccess(Long orderId){        orderService.markOrderPaySuccess(orderId);    }}</code></pre><h2 id="4-2-发送消息"><a href="#4-2-发送消息" class="headerlink" title="4.2.发送消息"></a>4.2.发送消息</h2><p>修改<code>pay-service</code>服务下的<code>com.hmall.pay.service.impl.PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final RabbitTemplate rabbitTemplate;@Override@Transactionalpublic void tryPayOrderByBalance(PayOrderDTO payOrderDTO) {    // 1.查询支付单    PayOrder po = getById(payOrderDTO.getId());    // 2.判断状态    if(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus())){        // 订单不是未支付，状态异常        throw new BizIllegalException("交易已支付或关闭！");    }    // 3.尝试扣减余额    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());    // 4.修改支付单状态    boolean success = markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());    if (!success) {        throw new BizIllegalException("交易已支付或关闭！");    }    // 5.修改订单状态    // tradeClient.markOrderPaySuccess(po.getBizOrderNo());    try {        rabbitTemplate.convertAndSend("pay.topic", "pay.success", po.getBizOrderNo());    } catch (Exception e) {        log.error("支付成功的消息发送失败，支付单id：{}， 交易单id：{}", po.getId(), po.getBizOrderNo(), e);    }}</code></pre><h1 id="5-练习"><a href="#5-练习" class="headerlink" title="5.练习"></a>5.练习</h1><h2 id="5-1-抽取共享的MQ配置"><a href="#5-1-抽取共享的MQ配置" class="headerlink" title="5.1.抽取共享的MQ配置"></a>5.1.抽取共享的MQ配置</h2><p>将MQ配置抽取到Nacos中管理，微服务中直接使用共享配置。</p><h2 id="5-2-改造下单功能"><a href="#5-2-改造下单功能" class="headerlink" title="5.2.改造下单功能"></a>5.2.改造下单功能</h2><p>改造下单功能，将基于OpenFeign的清理购物车同步调用，改为基于RabbitMQ的异步通知：</p><ul><li>定义topic类型交换机，命名为<code>trade.topic</code></li><li>定义消息队列，命名为<code>cart.clear.queue</code></li><li>将<code>cart.clear.queue</code>与<code>trade.topic</code>绑定，<code>BindingKey</code>为<code>order.create</code></li><li>下单成功时不再调用清理购物车接口，而是发送一条消息到<code>trade.topic</code>，发送消息的<code>RoutingKey</code>  为<code>order.create</code>，消息内容是下单的具体商品、当前登录用户信息</li><li>购物车服务监听<code>cart.clear.queue</code>队列，接收到消息后清理指定用户的购物车中的指定商品</li></ul><h2 id="5-3-登录信息传递优化"><a href="#5-3-登录信息传递优化" class="headerlink" title="5.3.登录信息传递优化"></a>5.3.登录信息传递优化</h2><p>某些业务中，需要根据登录用户信息处理业务，而基于MQ的异步调用并不会传递登录用户信息。前面我们的做法比较麻烦，至少要做两件事：</p><ul><li>消息发送者在消息体中传递登录用户</li><li>消费者获取消息体中的登录用户，处理业务</li></ul><p>这样做不仅麻烦，而且编程体验也不统一，毕竟我们之前都是使用UserContext来获取用户。</p><p>大家思考一下：有没有更优雅的办法传输登录用户信息，让使用MQ的人无感知，依然采用UserContext来随时获取用户。</p><p>参考资料：</p><p><a href="https://docs.spring.io/spring-amqp/docs/2.4.14/reference/html/#post-processing">https://docs.spring.io/spring-amqp/docs/2.4.14/reference/html/#post-processing</a></p><h2 id="5-4-改造项目一"><a href="#5-4-改造项目一" class="headerlink" title="5.4.改造项目一"></a>5.4.改造项目一</h2><p>思考一下，项目一中的哪些业务可以由同步方式改为异步方式调用？试着改造一下。</p><p>举例：短信发送</p><hr><p>在昨天的练习作业中，我们改造了余额支付功能，在支付成功后利用RabbitMQ通知交易服务，更新业务订单状态为已支付。</p><p>但是大家思考一下，如果这里MQ通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。</p><p>此时前端发送请求查询支付状态时，肯定是查询交易服务状态，会发现业务订单未支付，而用户自己知道已经支付成功，这就导致用户体验不一致。</p><p>因此，这里我们必须尽可能确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><p>那么问题来了：</p><ul><li><strong>我们该如何确保MQ消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在今天的学习中都会找到答案。</p><h1 id="1-发送者的可靠性"><a href="#1-发送者的可靠性" class="headerlink" title="1.发送者的可靠性"></a>1.发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。</p><p>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：</p><p><img src="image-20231101163122123.png" alt="image-20231101163122123"></p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到MQ。</p><h2 id="1-1-生产者重试机制"><a href="#1-1-生产者重试机制" class="headerlink" title="1.1.生产者重试机制"></a>1.1.生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断。</p><p>为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    connection-timeout: 1s # 设置MQ的连接超时时间    template:      retry:        enabled: true # 开启超时重试机制        initial-interval: 1000ms # 失败后的初始等待时间        multiplier: 1 # 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier        max-attempts: 3 # 最大重试次数</code></pre><p>我们利用命令停掉RabbitMQ服务：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker stop mq</code></pre><p>然后测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次。消息发送的超时重试机制配置成功了！</p><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h2 id="1-2-生产者确认机制"><a href="#1-2-生产者确认机制" class="headerlink" title="1.2.生产者确认机制"></a>1.2.生产者确认机制</h2><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。</p><p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p>具体如图所示：</p><p><img src="1698568827922190.png" alt="img"></p><p>总结如下：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h2 id="1-3-实现生产者确认"><a href="#1-3-实现生产者确认" class="headerlink" title="1.3.实现生产者确认"></a>1.3.实现生产者确认</h2><h3 id="1-3-1-开启生产者确认"><a href="#1-3-1-开启生产者确认" class="headerlink" title="1.3.1.开启生产者确认"></a>1.3.1.开启生产者确认</h3><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    publisher-confirm-type: correlated # 开启publisher confirm机制，并设置confirm类型    publisher-returns: true # 开启publisher return机制</code></pre><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h3 id="1-3-2-定义ReturnCallback"><a href="#1-3-2-定义ReturnCallback" class="headerlink" title="1.3.2.定义ReturnCallback"></a>1.3.2.定义ReturnCallback</h3><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：</p><p><img src="1698568827922191.png" alt="img"></p><p>内容如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.publisher.config;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.ReturnedMessage;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.context.annotation.Configuration;import javax.annotation.PostConstruct;@Slf4j@AllArgsConstructor@Configurationpublic class MqConfig {    private final RabbitTemplate rabbitTemplate;    @PostConstruct    public void init(){        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {            @Override            public void returnedMessage(ReturnedMessage returned) {                log.error("触发return callback,");                log.debug("exchange: {}", returned.getExchange());                log.debug("routingKey: {}", returned.getRoutingKey());                log.debug("message: {}", returned.getMessage());                log.debug("replyCode: {}", returned.getReplyCode());                log.debug("replyText: {}", returned.getReplyText());            }        });    }}</code></pre><h3 id="1-3-3-定义ConfirmCallback"><a href="#1-3-3-定义ConfirmCallback" class="headerlink" title="1.3.3.定义ConfirmCallback"></a>1.3.3.定义ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：</p><p><img src="1698568827922192.png" alt="img"></p><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：</p><p><img src="1698568827922193.png" alt="img"></p><p>我们新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testvoid testPublisherConfirm() {    // 1.创建CorrelationData    CorrelationData cd = new CorrelationData();    // 2.给Future添加ConfirmCallback    cd.getFuture().addCallback(new ListenableFutureCallback&lt;CorrelationData.Confirm&gt;() {        @Override        public void onFailure(Throwable ex) {            // 2.1.Future发生异常时的处理逻辑，基本不会触发（是指Spring出现错误）            log.error("send message fail", ex);        }        @Override        public void onSuccess(CorrelationData.Confirm result) { // success指回调成功            // 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容            if(result.isAck()){ // result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执                log.debug("发送消息成功，收到 ack!");            }else{ // result.getReason()，String类型，返回nack时的异常描述                log.error("发送消息失败，收到 nack, reason : {}", result.getReason());            }        }    });    // 3.发送消息    rabbitTemplate.convertAndSend("hmall.direct", "q", "hello", cd);}</code></pre><p>执行结果如下：</p><p><img src="1698568827922194.png" alt="img"></p><p>可以看到，由于传递的<code>RoutingKey</code>是错误的，路由失败后，触发了<code>return callback</code>，同时也收到了ack。</p><p>当我们修改为正确的<code>RoutingKey</code>以后，就不会触发<code>return callback</code>了，只收到ack。</p><p>而如果连交换机都是错误的，则只会收到nack。</p><blockquote><p><strong>注意</strong>：</p><p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</li></ul></blockquote><h1 id="2-MQ的可靠性"><a href="#2-MQ的可靠性" class="headerlink" title="2.MQ的可靠性"></a>2.MQ的可靠性</h1><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h2 id="2-1-数据持久化"><a href="#2-1-数据持久化" class="headerlink" title="2.1.数据持久化"></a>2.1.数据持久化</h2><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="2-1-1-交换机持久化"><a href="#2-1-1-交换机持久化" class="headerlink" title="2.1.1.交换机持久化"></a>2.1.1.交换机持久化</h3><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：</p><p><img src="1698568827923195.png" alt="img"></p><p>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><h3 id="2-1-2-队列持久化"><a href="#2-1-2-队列持久化" class="headerlink" title="2.1.2.队列持久化"></a>2.1.2.队列持久化</h3><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：</p><p><img src="1698568827923196.png" alt="img"></p><p>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="2-1-3-消息持久化"><a href="#2-1-3-消息持久化" class="headerlink" title="2.1.3.消息持久化"></a>2.1.3.消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：</p><p><img src="1698568827923197.png" alt="img"></p><blockquote><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p></blockquote><h2 id="2-2-LazyQueue"><a href="#2-2-LazyQueue" class="headerlink" title="2.2.LazyQueue"></a>2.2.LazyQueue</h2><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>. <code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="2-2-1-控制台配置Lazy模式"><a href="#2-2-1-控制台配置Lazy模式" class="headerlink" title="2.2.1.控制台配置Lazy模式"></a>2.2.1.控制台配置Lazy模式</h3><p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为Lazy模式：</p><p><img src="1698568827923198.png" alt="img"></p><h3 id="2-2-2-代码配置Lazy模式"><a href="#2-2-2-代码配置Lazy模式" class="headerlink" title="2.2.2.代码配置Lazy模式"></a>2.2.2.代码配置Lazy模式</h3><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic Queue lazyQueue(){    return QueueBuilder            .durable("lazy.queue")            .lazy() // 开启Lazy模式            .build();}</code></pre><p>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下：</p><p><img src="1698568827923199.png" alt="img"></p><p>当然，我们也可以基于注解来声明队列并设置为Lazy模式：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queuesToDeclare = @Queue(        name = "lazy.queue",        durable = "true",        arguments = @Argument(name = "x-queue-mode", value = "lazy")))public void listenLazyQueue(String msg){    log.info("接收到 lazy.queue的消息：{}", msg);}</code></pre><h3 id="2-2-3-更新已有队列为lazy模式"><a href="#2-2-3-更新已有队列为lazy模式" class="headerlink" title="2.2.3.更新已有队列为lazy模式"></a>2.2.3.更新已有队列为lazy模式</h3><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues  </code></pre><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>"^lazy-queue$"</code> ：用正则表达式匹配队列的名字</li><li><code>'{"queue-mode":"lazy"}'</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="1698568827923200.png" alt="img"></p><h1 id="3-消费者的可靠性"><a href="#3-消费者的可靠性" class="headerlink" title="3.消费者的可靠性"></a>3.消费者的可靠性</h1><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><p>但问题来了：RabbitMQ如何得知消费者的处理状态呢？</p><p>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p><h2 id="2-1-消费者确认机制"><a href="#2-1-消费者确认机制" class="headerlink" title="2.1.消费者确认机制"></a>2.1.消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p>返回Reject的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<foo> but Message<bar> is received.</bar></foo></li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: none # 不做处理</code></pre><p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理的异常：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "simple.queue")public void listenSimpleQueueMessage(String msg) throws InterruptedException {    log.info("spring 消费者接收到消息：【" + msg + "】");    if (true) {        throw new MessageConversionException("故意的");    }    log.info("消息处理完成");}</code></pre><p>测试可以发现：当消息处理发生异常时，消息依然被RabbitMQ删除了。</p><p>我们再次把确认机制修改为auto：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    listener:      simple:        acknowledge-mode: auto # 自动ack</code></pre><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：</p><p><img src="1698568827923201.png" alt="img"></p><p>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此Spring会自动返回<code>reject</code>，所以消息依然会被删除：</p><p><img src="1698568827923202.png" alt="img"></p><p>我们将异常改为RuntimeException类型：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(queues = "simple.queue")public void listenSimpleQueueMessage(String msg) throws InterruptedException {    log.info("spring 消费者接收到消息：【" + msg + "】");    if (true) {        throw new RuntimeException("故意的");    }    log.info("消息处理完成");}</code></pre><p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：</p><p><img src="1698568827923203.png" alt="img"></p><p>放行以后，由于抛出的是业务异常，所以Spring返回<code>ack</code>，最终消息恢复至<code>Ready</code>状态，并且没有被RabbitMQ删除：</p><p><img src="1698568827923204.png" alt="img"></p><p>当我们把配置改为<code>auto</code>时，消息处理失败后，会回到RabbitMQ，并重新投递到消费者。</p><h2 id="2-2-失败重试机制"><a href="#2-2-失败重试机制" class="headerlink" title="2.2.失败重试机制"></a>2.2.失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力：</p><p><img src="1698568827923205.png" alt="img"></p><p>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p>修改consumer服务的application.yml文件，添加内容：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    listener:      simple:        retry:          enabled: true # 开启消费者失败重试          initial-interval: 1000ms # 初识的失败等待时长为1秒          multiplier: 1 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval          max-attempts: 3 # 最大重试次数          stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false</code></pre><p>重启consumer服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h2 id="2-3-失败处理策略"><a href="#2-3-失败处理策略" class="headerlink" title="2.3.失败处理策略"></a>2.3.失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队 </li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在consumer服务中定义处理失败消息的交换机和队列</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic DirectExchange errorMessageExchange(){    return new DirectExchange("error.direct");}@Beanpublic Queue errorQueue(){    return new Queue("error.queue", true);}@Beanpublic Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){    return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");}</code></pre><p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){    return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");}</code></pre><p>完整代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.retry.MessageRecoverer;import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;import org.springframework.context.annotation.Bean;@Configuration@ConditionalOnProperty(name = "spring.rabbitmq.listener.simple.retry.enabled", havingValue = "true")public class ErrorMessageConfig {    @Bean    public DirectExchange errorMessageExchange(){        return new DirectExchange("error.direct");    }    @Bean    public Queue errorQueue(){        return new Queue("error.queue", true);    }    @Bean    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");    }    @Bean    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");    }}</code></pre><h2 id="2-4-业务幂等性"><a href="#2-4-业务幂等性" class="headerlink" title="2.4.业务幂等性"></a>2.4.业务幂等性</h2><p>何为幂等性？</p><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。</p><p>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h3 id="2-4-1-唯一消息ID"><a href="#2-4-1-唯一消息ID" class="headerlink" title="2.4.1.唯一消息ID"></a>2.4.1.唯一消息ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？</p><p>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic MessageConverter messageConverter(){    // 1.定义消息转换器    Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter();    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息    jjmc.setCreateMessageIds(true);    return jjmc;}</code></pre><h3 id="2-4-2-业务判断"><a href="#2-4-2-业务判断" class="headerlink" title="2.4.2.业务判断"></a>2.4.2.业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic void markOrderPaySuccess(Long orderId) {    // 1.查询订单    Order old = getById(orderId);    // 2.判断订单状态    if (old == null || old.getStatus() != 1) {        // 订单不存在或者订单状态不是1，放弃处理        return;    }    // 3.尝试更新订单    Order order = new Order();    order.setId(orderId);    order.setStatus(2);    order.setPayTime(LocalDateTime.now());    updateById(order);}</code></pre><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic void markOrderPaySuccess(Long orderId) {    // UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1    lambdaUpdate()            .set(Order::getStatus, 2)            .set(Order::getPayTime, LocalDateTime.now())            .eq(Order::getId, orderId)            .eq(Order::getStatus, 1)            .update();}</code></pre><p>注意看，上述代码等同于这样的SQL语句：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</code></pre><p>我们在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。</p><h2 id="2-5-兜底方案"><a href="#2-5-兜底方案" class="headerlink" title="2.5.兜底方案"></a>2.5.兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？</p><p>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。</p><p>流程如下：</p><p><img src="image-20231101163315219.png" alt="image-20231101163315219"></p><p>图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p><p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。</p><p>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p><p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。</p><p>定时任务大家之前学习过，具体的实现这里就不再赘述了。</p><p>至此，消息可靠性的问题已经解决了。</p><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4.延迟消息"></a>4.延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p><p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p><p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p><h2 id="4-1-死信交换机和延迟消息"><a href="#4-1-死信交换机和延迟消息" class="headerlink" title="4.1.死信交换机和延迟消息"></a>4.1.死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="4-1-1-死信交换机"><a href="#4-1-1-死信交换机" class="headerlink" title="4.1.1.死信交换机"></a>4.1.1.死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h3 id="4-1-2-延迟消息"><a href="#4-1-2-延迟消息" class="headerlink" title="4.1.2.延迟消息"></a>4.1.2.延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，大家设想一下这样的场景：</p><p>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue：</p><p><img src="1698568827923206.png" alt="img"></p><p>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的<strong>有效期</strong>为5000毫秒：</p><p><img src="1698568827924207.png" alt="img"></p><blockquote><p><strong>注意</strong>：尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息。</p></blockquote><p>消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：</p><p><img src="1698568827924208.png" alt="img"></p><p>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>：</p><p><img src="1698568827924209.png" alt="img"></p><p>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：</p><p><img src="1698568827925210.png" alt="img"></p><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="4-1-3-总结"><a href="#4-1-3-总结" class="headerlink" title="4.1.3.总结"></a>4.1.3.总结</h3><blockquote><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确。</p></blockquote><h2 id="4-2-DelayExchange插件"><a href="#4-2-DelayExchange插件" class="headerlink" title="4.2.DelayExchange插件"></a>4.2.DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。</p><p>官方文档说明：</p><p><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1.下载"></a>4.2.1.下载</h3><p>插件下载地址：</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>由于我们安装的MQ是<code>3.8</code>版本，因此这里下载<code>3.8.17</code>版本：</p><p><img src="1698568827925211.png" alt="img"></p><p>当然，也可以直接使用课前资料提供好的插件：</p><p><img src="1698568827926212.png" alt="img"></p><h3 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2.安装"></a>4.2.2.安装</h3><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker volume inspect mq-plugins</code></pre><p>结果如下：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">[    {        "CreatedAt": "2024-06-19T09:22:59+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/mq-plugins/_data",        "Name": "mq-plugins",        "Options": null,        "Scope": "local"    }]</code></pre><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code></pre><p>运行结果如下：</p><p><img src="1698568827927213.png" alt="img"></p><h3 id="4-2-3-声明延迟交换机"><a href="#4-2-3-声明延迟交换机" class="headerlink" title="4.2.3.声明延迟交换机"></a>4.2.3.声明延迟交换机</h3><p>基于注解方式：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RabbitListener(bindings = @QueueBinding(        value = @Queue(name = "delay.queue", durable = "true"),        exchange = @Exchange(name = "delay.direct", delayed = "true"),        key = "delay"))public void listenDelayMessage(String msg){    log.info("接收到delay.queue的延迟消息：{}", msg);}</code></pre><p>基于<code>@Bean</code>的方式：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.consumer.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Slf4j@Configurationpublic class DelayExchangeConfig {    @Bean    public DirectExchange delayExchange(){        return ExchangeBuilder                .directExchange("delay.direct") // 指定交换机类型和名称                .delayed() // 设置delay的属性为true                .durable(true) // 持久化                .build();    }    @Bean    public Queue delayedQueue(){        return new Queue("delay.queue");    }        @Bean    public Binding delayQueueBinding(){        return BindingBuilder.bind(delayedQueue()).to(delayExchange()).with("delay");    }}</code></pre><h3 id="4-2-4-发送延迟消息"><a href="#4-2-4-发送延迟消息" class="headerlink" title="4.2.4.发送延迟消息"></a>4.2.4.发送延迟消息</h3><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Testvoid testPublisherDelayMessage() {    // 1.创建消息    String message = "hello, delayed message";    // 2.发送消息，利用消息后置处理器添加消息头    rabbitTemplate.convertAndSend("delay.direct", "delay", message, new MessagePostProcessor() {        @Override        public Message postProcessMessage(Message message) throws AmqpException {            // 添加延迟消息属性            message.getMessageProperties().setDelay(5000);            return message;        }    });}</code></pre><blockquote><p><strong>注意：</strong></p><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。</p></blockquote><h2 id="4-3-超时订单问题"><a href="#4-3-超时订单问题" class="headerlink" title="4.3.超时订单问题"></a>4.3.超时订单问题</h2><p>接下来，我们就在交易服务中利用延迟消息实现订单超时取消功能。其大概思路如下：</p><p><img src="1698568827927214.jpeg" alt="img"></p><p>假如订单超时支付时间为30分钟，理论上说我们应该在下单时发送一条延迟消息，延迟时间为30分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。</p><p>但是大多数情况下用户支付都会在1分钟内完成，我们发送的消息却要在MQ中停留30分钟，额外消耗了MQ的资源。因此，我们最好多检测几次订单支付状态，而不是在最后第30分钟才检测。</p><p>例如：我们在用户下单后的第10秒、20秒、30秒、45秒、60秒、1分30秒、2分、…30分分别设置延迟消息，如果提前发现订单已经支付，则后续的检测取消即可。</p><p>这样就可以有效避免对MQ资源的浪费了。</p><p>优化后的实现思路如下：</p><p><img src="1698568827927215.jpeg" alt="img"></p><p>由于我们要多次发送延迟消息，因此需要先定义一个记录消息延迟时间的消息体，处于通用性考虑，我们将其定义到<code>hm-common</code>模块下：</p><p><img src="1698568827927216.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.common.domain;import com.hmall.common.utils.CollUtils;import lombok.Data;import java.util.List;@Datapublic class MultiDelayMessage&lt;T&gt; {    /**     * 消息体     */    private T data;    /**     * 记录延迟时间的集合     */    private List&lt;Long&gt; delayMillis;    public MultiDelayMessage(T data, List&lt;Long&gt; delayMillis) {        this.data = data;        this.delayMillis = delayMillis;    }    public static &lt;T&gt; MultiDelayMessage&lt;T&gt; of(T data, Long ... delayMillis){        return new MultiDelayMessage&lt;&gt;(data, CollUtils.newArrayList(delayMillis));    }    /**     * 获取并移除下一个延迟时间     * @return 队列中的第一个延迟时间     */    public Long removeNextDelay(){        return delayMillis.remove(0);    }    /**     * 是否还有下一个延迟时间     */    public boolean hasNextDelay(){        return !delayMillis.isEmpty();    }}</code></pre><h3 id="4-3-1-定义常量"><a href="#4-3-1-定义常量" class="headerlink" title="4.3.1.定义常量"></a>4.3.1.定义常量</h3><p>无论是消息发送还是接收都是在交易服务完成，因此我们在<code>trade-service</code>中定义一个常量类，用于记录交换机、队列、RoutingKey等常量：</p><p><img src="1698568827928217.png" alt="img"></p><p>内容如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.trade.constants;public interface MqConstants {    String DELAY_EXCHANGE = "trade.delay.topic";    String DELAY_ORDER_QUEUE = "trade.order.delay.queue";    String DELAY_ORDER_ROUTING_KEY = "order.query";}</code></pre><h3 id="4-3-2-抽取共享mq配置"><a href="#4-3-2-抽取共享mq配置" class="headerlink" title="4.3.2.抽取共享mq配置"></a>4.3.2.抽取共享mq配置</h3><p>我们将mq的配置抽取到nacos中，方便各个微服务共享配置。</p><p>在nacos中定义一个名为<code>shared-mq.xml</code>的配置文件，内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  rabbitmq:    host: ${hm.mq.host:192.168.150.101} # 主机名    port: ${hm.mq.port:5672} # 端口    virtual-host: ${hm.mq.vhost:/hmall} # 虚拟主机    username: ${hm.mq.un:hmall} # 用户名    password: ${hm.mq.pw:123} # 密码    listener:      simple:        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</code></pre><p>这里只添加一些基础配置，至于生产者确认，消费者确认配置则由微服务根据业务自己决定。</p><p>在<code>trade-service</code>模块添加共享配置：</p><p><img src="1698568827928218.png" alt="img"></p><h3 id="4-3-3-改造下单业务"><a href="#4-3-3-改造下单业务" class="headerlink" title="4.3.3.改造下单业务"></a>4.3.3.改造下单业务</h3><p>接下来，我们改造下单业务，在下单完成后，发送延迟消息，查询支付状态。</p><p>1）引入依赖</p><p>在<code>trade-service</code>模块的<code>pom.xml</code>中引入amqp的依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--amqp--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）改造下单业务</p><p>修改<code>trade-service</code>模块的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类的<code>createOrder</code>方法，添加消息发送的代码：</p><p><img src="1698568827928219.png" alt="img"></p><h3 id="4-3-4-编写查询支付状态接口"><a href="#4-3-4-编写查询支付状态接口" class="headerlink" title="4.3.4.编写查询支付状态接口"></a>4.3.4.编写查询支付状态接口</h3><p>由于MQ消息处理时需要查询支付状态，因此我们要在pay-service模块定义一个这样的接口，并提供对应的FeignClient.</p><p>首先，在hm-api模块定义三个类：</p><p><img src="1698568827928220.png" alt="img"></p><p>说明：</p><ul><li>PayOrderDTO：支付单的数据传输实体</li><li>PayClient：支付系统的Feign客户端</li><li>PayClientFallback：支付系统的fallback逻辑</li></ul><p>PayOrderDTO代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.dto;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.time.LocalDateTime;/** * &lt;p&gt; * 支付订单 * &lt;/p&gt; */@Data@ApiModel(description = "支付单数据传输实体")public class PayOrderDTO {    @ApiModelProperty("id")    private Long id;    @ApiModelProperty("业务订单号")    private Long bizOrderNo;    @ApiModelProperty("支付单号")    private Long payOrderNo;    @ApiModelProperty("支付用户id")    private Long bizUserId;    @ApiModelProperty("支付渠道编码")    private String payChannelCode;    @ApiModelProperty("支付金额，单位分")    private Integer amount;    @ApiModelProperty("付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付")    private Integer payType;    @ApiModelProperty("付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功")    private Integer status;    @ApiModelProperty("拓展字段，用于传递不同渠道单独处理的字段")    private String expandJson;    @ApiModelProperty("第三方返回业务码")    private String resultCode;    @ApiModelProperty("第三方返回提示信息")    private String resultMsg;    @ApiModelProperty("支付成功时间")    private LocalDateTime paySuccessTime;    @ApiModelProperty("支付超时时间")    private LocalDateTime payOverTime;    @ApiModelProperty("支付二维码链接")    private String qrCodeUrl;    @ApiModelProperty("创建时间")    private LocalDateTime createTime;    @ApiModelProperty("更新时间")    private LocalDateTime updateTime;}</code></pre><p>PayClient代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.client;import com.hmall.api.client.fallback.PayClientFallback;import com.hmall.api.dto.PayOrderDTO;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = "pay-service", fallbackFactory = PayClientFallback.class)public interface PayClient {    /**     * 根据交易订单id查询支付单     * @param id 业务订单id     * @return 支付单信息     */    @GetMapping("/pay-orders/biz/{id}")    PayOrderDTO queryPayOrderByBizOrderNo(@PathVariable("id") Long id);}</code></pre><p>PayClientFallback代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.client.fallback;import com.hmall.api.client.PayClient;import com.hmall.api.dto.PayOrderDTO;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.openfeign.FallbackFactory;@Slf4jpublic class PayClientFallback implements FallbackFactory&lt;PayClient&gt; {    @Override    public PayClient create(Throwable cause) {        return new PayClient() {            @Override            public PayOrderDTO queryPayOrderByBizOrderNo(Long id) {                return null;            }        };    }}</code></pre><p>最后，在pay-service模块的PayController中实现该接口：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@ApiOperation("根据id查询支付单")@GetMapping("/biz/{id}")public PayOrderDTO queryPayOrderByBizOrderNo(@PathVariable("id") Long id){    PayOrder payOrder = payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();    return BeanUtils.copyBean(payOrder, PayOrderDTO.class);}</code></pre><h3 id="4-3-5-消息监听"><a href="#4-3-5-消息监听" class="headerlink" title="4.3.5.消息监听"></a>4.3.5.消息监听</h3><p>接下来，我们在trader-service编写一个监听器，监听延迟消息，查询订单支付状态：</p><p><img src="1698568827928221.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.trade.listener;import com.hmall.api.client.PayClient;import com.hmall.api.dto.PayOrderDTO;import com.hmall.common.domain.MultiDelayMessage;import com.hmall.trade.constants.MqConstants;import com.hmall.trade.domain.po.Order;import com.hmall.trade.service.IOrderService;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.ExchangeTypes;import org.springframework.amqp.rabbit.annotation.Exchange;import org.springframework.amqp.rabbit.annotation.Queue;import org.springframework.amqp.rabbit.annotation.QueueBinding;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.stereotype.Component;@Slf4j@Component@RequiredArgsConstructorpublic class OrderStatusListener {    private final IOrderService orderService;    private final PayClient payClient;    private final RabbitTemplate rabbitTemplate;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(name = MqConstants.DELAY_ORDER_QUEUE, durable = "true"),            exchange = @Exchange(name = MqConstants.DELAY_EXCHANGE, type = ExchangeTypes.TOPIC),            key = MqConstants.DELAY_ORDER_ROUTING_KEY    ))    public void listenOrderCheckDelayMessage(MultiDelayMessage&lt;Long&gt; msg) {        // 1.获取消息中的订单id        Long orderId = msg.getData();        // 2.查询订单，判断状态：1是未支付，大于1则是已支付或已关闭        Order order = orderService.getById(orderId);        if (order == null || order.getStatus() &gt; 1) {            // 订单不存在或交易已经结束，放弃处理            return;        }        // 3.可能是未支付，查询支付服务        PayOrderDTO payOrder = payClient.queryPayOrderByBizOrderNo(orderId);        if (payOrder != null &amp;&amp; payOrder.getStatus() == 3) {            // 支付成功，更新订单状态            orderService.markOrderPaySuccess(orderId);            return;        }        // 4.确定未支付，判断是否还有剩余延迟时间        if (msg.hasNextDelay()) {            // 4.1.有延迟时间，需要重发延迟消息，先获取延迟时间的int值            int delayVal = msg.removeNextDelay().intValue();            // 4.2.发送延迟消息            rabbitTemplate.convertAndSend(MqConstants.DELAY_EXCHANGE, MqConstants.DELAY_ORDER_ROUTING_KEY, msg,                    message -&gt; {                        message.getMessageProperties().setDelay(delayVal);                        return message;                    });            return;        }        // 5.没有剩余延迟时间了，说明订单超时未支付，需要取消订单        orderService.cancelOrder(orderId);    }}</code></pre><p>注意，这里要在OrderServiceImpl中实现cancelOrder方法，留作作业大家自行实现。</p><h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a>5.作业</h1><h2 id="5-1-取消订单"><a href="#5-1-取消订单" class="headerlink" title="5.1.取消订单"></a>5.1.取消订单</h2><p>在处理超时未支付订单时，如果发现订单确实超时未支付，最终需要关闭该订单。</p><p>关闭订单需要完成两件事情：</p><ul><li>将订单状态修改为已关闭</li><li>恢复订单中已经扣除的库存</li></ul><p>这部分功能尚未实现。</p><p>大家要在<code>IOrderService</code>接口中定义<code>cancelOrder</code>方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void cancelOrder(Long orderId);</code></pre><p>并且在<code>OrderServiceImpl</code>中实现该方法。实现过程中要注意业务幂等性判断。</p><h2 id="5-2-抽取MQ工具"><a href="#5-2-抽取MQ工具" class="headerlink" title="5.2.抽取MQ工具"></a>5.2.抽取MQ工具</h2><p>MQ在企业开发中的常见应用我们就学习完毕了，除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码还是相对比较复杂的。</p><p>因此，我们需要将这些常用的操作封装为工具，方便在项目中使用。要求如下：</p><ul><li>在<code>hm-commom</code>模块下编写发送消息的工具类<code>RabbitMqHelper</code></li><li>定义一个自动配置类<code>MqConsumeErrorAutoConfiguration</code>，内容包括：<ul><li>声明一个交换机，名为<code>error.direct</code>，类型为<code>direct</code></li><li>声明一个队列，名为：<code>微服务名 + error.queue</code>，也就是说要动态获取</li><li>将队列与交换机绑定，绑定时的<code>RoutingKey</code>就是<code>微服务名</code></li><li>声明<code>RepublishMessageRecoverer</code>，消费失败消息投递到上述交换机</li><li>给配置类添加条件，当<code>spring.rabbitmq.listener.simple.retry.enabled</code>为<code>true</code>时触发</li></ul></li></ul><p>RabbitMqHelper的结构如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class RabbitMqHelper {    private final RabbitTemplate rabbitTemplate;    public void sendMessage(String exchange, String routingKey, Object msg){    }    public void sendDelayMessage(String exchange, String routingKey, Object msg, int delay){    }    public void sendMessageWithConfirm(String exchange, String routingKey, Object msg, int maxRetries){            }}</code></pre><h2 id="5-3-改造业务"><a href="#5-3-改造业务" class="headerlink" title="5.3.改造业务"></a>5.3.改造业务</h2><p>利用你编写的工具，改造支付服务、购物车服务、交易服务中消息发送功能，并且添加消息确认或消费者重试机制，确保消息的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2023/10/07/SpringCloud/"/>
      <url>/2023/10/07/SpringCloud/</url>
      
        <content type="html"><![CDATA[<p>之前我们学习的项目一是单体项目，可以满足小型项目或传统项目的开发。而在互联网时代，越来越多的一线互联网公司都在使用微服务技术。</p><p>从谷歌搜索指数来看，国内从自2016年底开始，微服务热度突然暴涨：</p><p><img src="169796321521770.png" alt="img"></p><p>那么：</p><ul><li>到底什么是微服务？</li><li>企业该不该引入微服务？</li><li>微服务技术该如何在企业落地？</li></ul><p>接下来几天，我们就一起来揭开它的神秘面纱。</p><p>计划是这样的，课前资料中给大家准备了一个<strong>单体</strong>的电商小项目：黑马商城，我们会基于这个单体项目来演示从单体架构到微服务架构的演变过程、分析其中存在的问题，以及微服务技术是如何解决这些问题的。</p><p>你会发现每一个微服务技术都是在解决服务化过程中产生的问题，你对于每一个微服务技术具体的应用场景和使用方式都会有更深层次的理解。</p><p>今天作为课程的第一天，我们要完成下面的内容：</p><ul><li>知道单体架构的特点</li><li>知道微服务架构的特点</li><li>学会拆分微服务</li><li>会使用Nacos实现服务治理</li><li>会使用OpenFeign实现远程调用</li></ul><h1 id="0-导入黑马商城项目"><a href="#0-导入黑马商城项目" class="headerlink" title="0.导入黑马商城项目"></a>0.导入黑马商城项目</h1><p>在课前资料中给大家提供了黑马商城项目的资料，我们需要先导入这个单体项目。不过需要注意的是，本篇及后续的微服务学习都是基于Centos7系统下的Docker部署，因此你必须做好一些准备：</p><ul><li>Centos7的环境及一个好用的SSH客户端</li><li>安装好Docker</li><li>会使用Docker</li></ul><p>如果你没有这样的Linux环境，或者不是Centos7的话，那么这里有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc">Linux环境搭建</a></li></ul><p>建议按照上面的文档来搭建虚拟机环境，使用其它版本会出现一些环境问题，比较痛苦。</p><p>如果已经有Linux环境，但是没有安装Docker的话，那么这里还有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">安装Docker</a></li></ul><p>如果不会使用Docker的话可以参考黑马的微服务前置Docker课程，B站地址如下：</p><p><a href="https://www.bilibili.com/video/BV1HP4118797/?share_source=copy_web&amp;vd_source=3362e6914fb759983690e6e0f1072453">https://www.bilibili.com/video/BV1HP4118797/?share_source=copy_web&amp;vd_source=3362e6914fb759983690e6e0f1072453</a></p><p>注意：</p><p>如果是学习过上面Docker课程的同学，虚拟机中已经有了黑马商城项目及MySQL数据库了，不过为了跟其他同学保持一致，可以先将整个项目移除。使用下面的命令：</p><p>cd /root</p><p>docker compose down</p><h2 id="0-1-安装MySQL"><a href="#0-1-安装MySQL" class="headerlink" title="0.1.安装MySQL"></a>0.1.安装MySQL</h2><p>在课前资料提供好了MySQL的一个目录：</p><p><img src="169796321521771.png" alt="img"></p><p>其中有MySQL的配置文件和初始化脚本：</p><p><img src="169796321521872.png" alt="img"></p><p>我们将其复制到虚拟机的<code>/root</code>目录。如果<code>/root</code>下已经存在<code>mysql</code>目录则删除旧的，如果不存在则直接复制本地的：</p><p><img src="169796321521873.png" alt="img"></p><p>然后创建一个通用网络：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker network create hm-net</code></pre><p>使用下面的命令来安装MySQL：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  -v /root/mysql/data:/var/lib/mysql \  -v /root/mysql/conf:/etc/mysql/conf.d \  -v /root/mysql/init:/docker-entrypoint-initdb.d \  --network hm-net\  mysql</code></pre><p>此时，通过命令查看mysql容器：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker ps</code></pre><p>如图：</p><p><img src="169796321521874.png" alt="img"></p><p>发现mysql容器正常运行。</p><blockquote><p>注：图片中的dps命令是我设置的别名，等同于docker ps –format，可以简化命令格式。你可以参考黑马的<a href="https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec">day02-Docker</a> 的2.1.3小节来配置。</p></blockquote><p>此时，如果我们使用MySQL的客户端工具连接MySQL，应该能发现已经创建了黑马商城所需要的表：</p><p><img src="169796321521875.png" alt="img"></p><h2 id="0-2-后端"><a href="#0-2-后端" class="headerlink" title="0.2.后端"></a>0.2.后端</h2><p>然后是Java代码，在课前资料提供了一个hmall目录：</p><p><img src="169796321521876.png" alt="img"></p><p>将其复制到你的工作空间，然后利用Idea打开。</p><p>项目结构如下：</p><p><img src="169796321521877.png" alt="img"></p><p>按下<code>ALT</code> + <code>8</code>键打开services窗口，新增一个启动项：</p><p><img src="169796321521878.png" alt="img"></p><p>在弹出窗口中鼠标向下滚动，找到<code>Spring Boot</code>:</p><p><img src="169796321521879.png" alt="img"></p><p>点击后应该会在services中出现hmall的启动项：</p><p><img src="169796321521880.png" alt="img"></p><p>点击对应按钮，即可实现运行或DEBUG运行。</p><p><strong>不过别着急！！</strong></p><p>我们还需要对这个启动项做简单配置，在<code>HMallApplication</code>上点击鼠标右键，会弹出窗口，然后选择<code>Edit Configuration</code>：</p><p><img src="169796321521881.png" alt="img"></p><p>在弹出窗口中配置SpringBoot的启动环境为local：</p><p><img src="169796321521882.png" alt="img"></p><p>点击OK配置完成。接下来就可以运行了！</p><p>启动完成后，试试看访问下 <a href="http://localhost:8080/hi">http://localhost:8080/hi</a> 吧！</p><h2 id="0-3-前端"><a href="#0-3-前端" class="headerlink" title="0.3.前端"></a>0.3.前端</h2><p>在课前资料中还提供了一个hmall-nginx的目录：</p><p><img src="169796321521883.png" alt="img"></p><p>其中就是一个nginx程序以及我们的前端代码，直接在windows下将其复制到一个非中文、不包含特殊字符的目录下。然后进入hmall-nginx后，利用cmd启动即可：</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># 启动nginxstart nginx.exe# 停止nginx.exe -s stop# 重新加载配置nginx.exe -s reload# 重启nginx.exe -s restart</code></pre><p>特别注意：</p><p>nginx.exe 不要双击启动，而是打开cmd窗口，通过命令行启动。停止的时候也一样要是用命令停止。如果启动失败不要重复启动，而是查看logs目录中的error.log日志，查看是否是端口冲突。如果是端口冲突则自行修改端口解决。</p><p>启动成功后，访问<a href="http://localhost:18080，应该能看到我们的门户页面：">http://localhost:18080，应该能看到我们的门户页面：</a></p><p><img src="169796321521884.png" alt="img"></p><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>这一章我们从单体架构的优缺点来分析，看看开发大型项目采用单体架构存在哪些问题，而微服务架构又是如何解决这些问题的。</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p>单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。</p><p><img src="169796321521885.jpeg" alt="img"></p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>在上述问题中，前两点相信大家在实战过程中应该深有体会。对于第三点系统可用性问题，很多同学可能感触不深。接下来我们就通过黑马商城这个项目，给大家做一个简单演示。</p><p>首先，我们修改hm-service模块下的<code>com.hmall.controller.HelloController</code>中的<code>hello</code>方法，模拟方法执行时的耗时：</p><p><img src="169796321521886.png" alt="img"></p><p>接下来，启动项目，目前有两个接口是无需登录即可访问的：</p><ul><li><code>http://localhost:8080/hi</code></li><li><code>http://localhost:8080/search/list</code></li></ul><p>经过测试，目前<code>/search/list</code> 是比较正常的，访问耗时在30毫秒左右。</p><p>接下来，我们假设<code>/hi</code>这个接口是一个并发较高的热点接口，我们通过Jemeter来模拟500个用户不停访问。在课前资料中已经提供了Jemeter的测试脚本：</p><p><img src="169796321521887.png" alt="img"></p><p>导入Jemeter并测试：</p><p><img src="169796321521888.png" alt="img"></p><p>这个脚本会开启500个线程并发请求<code>http://localhost/hi</code>这个接口。由于该接口存在执行耗时（500毫秒），这就服务端导致每秒能处理的请求数量有限，最终会有越来越多请求积压，直至Tomcat资源耗尽。这样，其它本来正常的接口（例如<code>/search/list</code>）也都会被拖慢，甚至因超时而无法访问了。</p><p>我们测试一下，启动测试脚本，然后在浏览器访问<code>http://localhost:8080/search/list</code>这个接口，会发现响应速度非常慢：</p><p><img src="169796321521889.png" alt="img"></p><p>如果进一步提高<code>/hi</code>这个接口的并发，最终会发现<code>/search/list</code>接口的请求响应速度会越来越慢。</p><p>可见，单体架构的可用性是比较差的，功能之间相互影响比较大。</p><p>当然，有同学会说我们可以做水平扩展。</p><p>此时如果我们对系统做水平扩展，增加更多机器，资源还是会被这样的热点接口占用，从而影响到其它接口，并不能从根本上解决问题。这也就是单体架构的扩展性差的一个原因。</p><p>而要想解决这些问题，就需要使用微服务架构了。</p><h2 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2.微服务"></a>1.2.微服务</h2><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>例如，黑马商城项目，我们就可以把商品、用户、购物车、交易等模块拆分，交给不同的团队去开发，并独立部署：</p><p><img src="169796321521890.jpeg" alt="img"></p><p>那么，单体架构存在的问题有没有解决呢？</p><ul><li>团队协作成本高？<ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li></ul></li><li>系统发布效率低？<ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li>系统可用性差？<ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务。</li></ul></li></ul><p>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正式分布式架构的一种最佳实践的方案。</p><p>当然，微服务架构虽然能解决单体架构的各种问题，但在拆分的过程中，还会面临很多其它问题。比如：</p><ul><li>如果出现跨服务的业务该如何处理？</li><li>页面请求到底该访问哪个服务？</li><li>如何实现各个服务之间的服务隔离？</li></ul><p>这些问题，我们在后续的学习中会给大家逐一解答。</p><h2 id="1-3-SpringCloud"><a href="#1-3-SpringCloud" class="headerlink" title="1.3.SpringCloud"></a>1.3.SpringCloud</h2><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合了。</p><p><img src="169796321521891.png" alt="img"></p><p>而且SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择了！</p><p><a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p>目前SpringCloud最新版本为<code>2022.0.x</code>版本，对应的SpringBoot版本为<code>3.x</code>版本，但它们全部依赖于JDK17，目前在企业中使用相对较少。</p><table><thead><tr><th align="center"><strong>SpringCloud版本</strong></th><th align="center"><strong>SpringBoot版本</strong></th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">2022.0.x</a> aka Kilburn</td><td align="center">3.0.x</td></tr><tr><td align="center"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td align="center">2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td align="center"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td align="center">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td align="center"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="center">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="center"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="center">2.1.x</td></tr><tr><td align="center"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="center">2.0.x</td></tr><tr><td align="center"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="center">1.5.x</td></tr><tr><td align="center"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="center">1.5.x</td></tr></tbody></table><p>因此，我们推荐使用次新版本：Spring Cloud 2021.0.x以及Spring Boot 2.7.x版本。</p><p>另外，Alibaba的微服务产品SpringCloudAlibaba目前也成为了SpringCloud组件中的一员，我们课堂中也会使用其中的部分组件。</p><p>在我们的父工程hmall中已经配置了SpringCloud以及SpringCloudAlibaba的依赖：</p><p><img src="169796321521892.png" alt="img"></p><p>对应的版本：</p><p><img src="169796321521993.png" alt="img"></p><p>这样，我们在后续需要使用SpringCloud或者SpringCloudAlibaba组件时，就无需单独指定版本了。</p><h1 id="2-微服务拆分"><a href="#2-微服务拆分" class="headerlink" title="2.微服务拆分"></a>2.微服务拆分</h1><p>接下来，我们就一起将黑马商城这个单体项目拆分为微服务项目，并解决其中出现的各种问题。</p><h2 id="2-1-熟悉黑马商城"><a href="#2-1-熟悉黑马商城" class="headerlink" title="2.1.熟悉黑马商城"></a>2.1.熟悉黑马商城</h2><p>首先，我们需要熟悉黑马商城项目的基本结构：</p><p><img src="169796321521994.png" alt="img"></p><p>大家可以直接启动该项目，测试效果。不过，需要修改数据库连接参数，在application-local.yaml中：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:  db:    host: 192.168.150.101 # 修改为你自己的虚拟机IP地址    pw: 123 # 修改为docker中的MySQL密码</code></pre><p>同时配置启动项激活的是local环境：</p><p><img src="169796321521995.png" alt="img"></p><h3 id="2-1-1-登录"><a href="#2-1-1-登录" class="headerlink" title="2.1.1.登录"></a>2.1.1.登录</h3><p>首先来看一下登录业务流程：</p><p><img src="image-20231022163148663.png" alt="image-20231022163148663"></p><p>登录入口在<code>com.hmall.controller.UserController</code>中的<code>login</code>方法：</p><p><img src="169796321521996.png" alt="img"></p><h3 id="2-2-2-搜索商品"><a href="#2-2-2-搜索商品" class="headerlink" title="2.2.2.搜索商品"></a>2.2.2.搜索商品</h3><p>在首页搜索框输入关键字，点击搜索即可进入搜索列表页面：</p><p><img src="169796321521997.png" alt="img"></p><p>该页面会调用接口：<code>/search/list</code>，对应的服务端入口在<code>com.hmall.controller.SearchController</code>中的<code>search</code>方法：</p><p><img src="169796321521998.png" alt="img"></p><p>这里目前是利用数据库实现了简单的分页查询。</p><h3 id="2-2-3-购物车"><a href="#2-2-3-购物车" class="headerlink" title="2.2.3.购物车"></a>2.2.3.购物车</h3><p>在搜索到的商品列表中，点击按钮<code>加入购物车</code>，即可将商品加入购物车：</p><p><img src="169796321521999.png" alt="img"></p><p>加入成功后即可进入购物车列表页，查看自己购物车商品列表：</p><p><img src="1697963215219100.png" alt="img"></p><p>同时这里还可以对购物车实现修改、删除等操作。</p><p>相关功能全部在<code>com.hmall.controller.CartController</code>中：</p><p><img src="1697963215219101.png" alt="img"></p><p>其中，查询购物车列表时，由于要判断商品最新的价格和状态，所以还需要查询商品信息，业务流程如下：</p><p>暂时无法在飞书文档外展示此内容</p><h3 id="2-2-4-下单"><a href="#2-2-4-下单" class="headerlink" title="2.2.4.下单"></a>2.2.4.下单</h3><p>在购物车页面点击<code>结算</code>按钮，会进入订单结算页面：</p><p><img src="1697963215220102.png" alt="img"></p><p>点击提交订单，会提交请求到服务端，服务端做3件事情：</p><ul><li>创建一个新的订单</li><li>扣减商品库存</li><li>清理购物车中商品</li></ul><p>业务入口在<code>com.hmall.controller.OrderController</code>中的<code>createOrder</code>方法：</p><p><img src="1697963215220103.png" alt="img"></p><h3 id="2-2-5-支付"><a href="#2-2-5-支付" class="headerlink" title="2.2.5.支付"></a>2.2.5.支付</h3><p>下单完成后会跳转到支付页面，目前只支持<strong>余额支付</strong>：</p><p><img src="1697963215220104.png" alt="img"></p><p>在选择<strong>余额支付</strong>这种方式后，会发起请求到服务端，服务端会立刻创建一个支付流水单，并返回支付流水单号到前端。</p><p>当用户输入用户密码，然后点击确认支付时，页面会发送请求到服务端，而服务端会做几件事情：</p><ul><li>校验用户密码</li><li>扣减余额</li><li>修改支付流水状态</li><li>修改交易订单状态</li></ul><p>请求入口在<code>com.hmall.controller.PayController</code>中：</p><p><img src="1697963215220105.png" alt="img"></p><h2 id="2-2-服务拆分原则"><a href="#2-2-服务拆分原则" class="headerlink" title="2.2.服务拆分原则"></a>2.2.服务拆分原则</h2><p>服务拆分一定要考虑几个问题：</p><ul><li>什么时候拆？</li><li>如何拆？</li></ul><h3 id="2-2-1-什么时候拆"><a href="#2-2-1-什么时候拆" class="headerlink" title="2.2.1.什么时候拆"></a>2.2.1.什么时候拆</h3><p>一般情况下，对于一个初创的项目，首先要做的是验证项目的可行性。因此这一阶段的首要任务是敏捷开发，快速产出生产可用的产品，投入市场做验证。为了达成这一目的，该阶段项目架构往往会比较简单，很多情况下会直接采用单体架构，这样开发成本比较低，可以快速产出结果，一旦发现项目不符合市场，损失较小。</p><p>如果这一阶段采用复杂的微服务架构，投入大量的人力和时间成本用于架构设计，最终发现产品不符合市场需求，等于全部做了无用功。</p><p>所以，对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为****微服务架构</strong>。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）。</p><p>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）。</p><h3 id="2-2-2-怎么拆"><a href="#2-2-2-怎么拆" class="headerlink" title="2.2.2.怎么拆"></a>2.2.2.怎么拆</h3><p>之前我们说过，微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析：</p><ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li><li><strong>低****耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li></ul><p><strong>高内聚</strong>首先是<strong>单一职责，</strong>但不能说一个微服务就一个接口，而是要保证微服务内部业务的完整性为前提。目标是当我们要修改某个业务时，最好就只修改当前微服务，这样变更的成本更低。</p><p>一旦微服务做到了高内聚，那么服务之间的<strong>耦合度</strong>自然就降低了。</p><p>当然，微服务之间不可避免的会有或多或少的业务交互，比如下单时需要查询商品数据。这个时候我们不能在订单服务直接查询商品数据库，否则就导致了数据耦合。而应该由商品服务对应暴露接口，并且一定要保证微服务对外<strong>接口的稳定性</strong>（即：尽量保证接口外观不变）。虽然出现了服务间调用，但此时无论你如何在商品服务做内部修改，都不会影响到订单微服务，服务间的耦合度就降低了。</p><p>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：</p><ul><li><strong>纵向</strong>拆分</li><li><strong>横向</strong>拆分</li></ul><p>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</p><p>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</p><p>当然，由于黑马商城并不是一个完整的项目，其中的短信发送、风控管理并没有实现，这里就不再考虑了。而其它的业务按照纵向拆分，可以分为以下几个微服务：</p><ul><li>用户服务</li><li>商品服务</li><li>订单服务</li><li>购物车服务</li><li>支付服务</li></ul><h2 id="2-3-拆分购物车、商品服务"><a href="#2-3-拆分购物车、商品服务" class="headerlink" title="2.3.拆分购物车、商品服务"></a>2.3.拆分购物车、商品服务</h2><p>接下来，我们先把商品管理功能、购物车功能抽取为两个独立服务。</p><p>一般微服务项目有两种不同的工程结构：</p><ul><li>完全解耦：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li>Maven聚合：整个项目为一个Project，然后每个微服务是其中的一个Module<ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><p><strong>注意</strong>：</p><p>为了授课方便，我们会采用Maven聚合工程，大家以后到了企业，可以根据需求自由选择工程结构。</p><p>在hmall父工程之中，我已经提前定义了SpringBoot、SpringCloud的依赖版本，所以为了方便期间，我们直接在这个项目中创建微服务module.</p><h3 id="2-3-1-商品服务"><a href="#2-3-1-商品服务" class="headerlink" title="2.3.1.商品服务"></a>2.3.1.商品服务</h3><p>在hmall中创建module：</p><p><img src="1697963215220106.png" alt="img"></p><p>选择maven模块，并设定JDK版本为11：</p><p>商品模块，我们起名为<code>item-service</code>：</p><p><img src="image-20231022171923810.png" alt="image-20231022171923810"></p><p>引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;hmall&lt;/artifactId&gt;        &lt;groupId&gt;com.heima&lt;/groupId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;item-service&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--common--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.heima&lt;/groupId&gt;            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--web--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--数据库--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>编写启动类：</p><p><img src="1697963215220109.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.item;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan("com.hmall.item.mapper")@SpringBootApplicationpublic class ItemApplication {    public static void main(String[] args) {        SpringApplication.run(ItemApplication.class, args);    }}</code></pre><p>接下来是配置文件，可以从<code>hm-service</code>中拷贝：</p><p><img src="1697963215220110.png" alt="img"></p><p>其中，<code>application.yaml</code>内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8081spring:  application:    name: item-service  profiles:    active: dev  datasource:    url: jdbc:mysql://${hm.db.host}:3306/hm-item?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai # 这里为方便，用同一sql中不同的数据库来代替在不同的sql中配置    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: ${hm.db.pw}mybatis-plus:  configuration:    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler  global-config:    db-config:      update-strategy: not_null      id-type: autologging:  level:    com.hmall: debug  pattern:    dateformat: HH:mm:ss:SSS  file:    path: "logs/${spring.application.name}"knife4j:  enable: true  openapi:    title: 商品服务接口文档    description: "信息"    email: zhanghuyi@itcast.cn    concat: 虎哥    url: https://www.itcast.cn    version: v1.0.0    group:      default:        group-name: default        api-rule: package        api-rule-resources:          - com.hmall.item.controller</code></pre><p>剩下的<code>application-dev.yaml</code>和<code>application-local.yaml</code>直接从hm-service拷贝即可。</p><p>然后拷贝<code>hm-service</code>中与商品管理有关的代码到<code>item-service</code>，如图：</p><p><img src="1697963215220111.png" alt="img"></p><p>这里有一个地方的代码需要改动，就是<code>ItemServiceImpl</code>中的<code>deductStock</code>方法：</p><p><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1/SpringCloud/img/1697963215220112.png" alt="img"><img src="1697963215220113.png" alt="img"></p><p><strong>改动前</strong></p><p><strong>改动后</strong></p><p>这也是因为ItemMapper的所在包发生了变化，因此这里代码必须修改包路径。</p><p>最后，还要导入数据库表。默认的数据库连接的是虚拟机，在你docker数据库执行课前资料提供的SQL文件：</p><p><img src="1697963215220114.png" alt="img"></p><p>最终，会在数据库创建一个名为hm-item的database，将来的每一个微服务都会有自己的一个database：</p><p><img src="1697963215220115.png" alt="img"></p><p><strong>注意</strong>：在企业开发的生产环境中，每一个微服务都应该有自己的<strong>独立数据库服务</strong>，而不仅仅是database，课堂我们用database来代替。</p><p>接下来，就可以启动测试了，在启动前我们要配置一下启动项，让默认激活的配置为<code>local</code>而不是<code>dev</code>：</p><p><img src="1697963215220116.png" alt="img"></p><p>在打开的编辑框填写<code>active profiles</code>:</p><p><img src="1697963215220117.png" alt="img"></p><p>接着，启动<code>item-service</code>，访问商品微服务的swagger接口文档：<a href="http://localhost:8081/doc.html">http://localhost:8081/doc.html</a></p><p>然后测试其中的根据id批量查询商品这个接口：</p><p><img src="1697963215220118.png" alt="img"></p><p>测试参数：100002672302,100002624500,100002533430，结果如下：</p><p><img src="1697963215221119.png" alt="img"></p><p>说明商品微服务抽取成功了。</p><h3 id="2-3-2-购物车服务"><a href="#2-3-2-购物车服务" class="headerlink" title="2.3.2.购物车服务"></a>2.3.2.购物车服务</h3><p>与商品服务类似，在hmall下创建一个新的<code>module</code>，起名为<code>cart-service</code>:</p><p><img src="1697963215221120.png" alt="img"></p><p>然后是依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;hmall&lt;/artifactId&gt;        &lt;groupId&gt;com.heima&lt;/groupId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cart-service&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--common--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.heima&lt;/groupId&gt;            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--web--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--数据库--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>然后是启动类：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan("com.hmall.cart.mapper")@SpringBootApplicationpublic class CartApplication {    public static void main(String[] args) {        SpringApplication.run(CartApplication.class, args);    }}</code></pre><p>然后是配置文件，同样可以拷贝自<code>item-service</code>，不过其中的<code>application.yaml</code>需要修改：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8082spring:  application:    name: cart-service  profiles:    active: dev  datasource:    url: jdbc:mysql://${db.host}:3306/hm-cart?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: ${db.pw}mybatis-plus:  configuration:    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler  global-config:    db-config:      update-strategy: not_null      id-type: autologging:  level:    com.hmall: debug  pattern:    dateformat: HH:mm:ss:SSS  file:    path: "logs/${spring.application.name}"knife4j:  enable: true  openapi:    title: 商品服务接口文档    description: "信息"    email: zhanghuyi@itcast.cn    concat: 虎哥    url: https://www.itcast.cn    version: v1.0.0    group:      default:        group-name: default        api-rule: package        api-rule-resources:          - com.hmall.cart.controller</code></pre><p>最后，把hm-service中的与购物车有关功能拷贝过来，最终的项目结构如下：</p><p><img src="1697963215221121.png" alt="img"></p><p>特别注意的是<code>com.hmall.cart.service.impl.CartServiceImpl</code>，其中有两个地方需要处理：</p><ul><li>需要<strong>获取登录用户信息</strong>，但登录校验功能目前没有复制过来，先写死固定用户id</li><li>查询购物车时需要<strong>查询商品信息</strong>，而商品信息不在当前服务，需要先将这部分代码注释</li></ul><p><img src="1697963215221122.png" alt="img"></p><p>我们对这部分代码做如下修改：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.service.impl;import cn.hutool.core.util.StrUtil;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmall.cart.domain.dto.CartFormDTO;import com.hmall.cart.domain.po.Cart;import com.hmall.cart.domain.vo.CartVO;import com.hmall.cart.mapper.CartMapper;import com.hmall.cart.service.ICartService;import com.hmall.common.exception.BizIllegalException;import com.hmall.common.utils.BeanUtils;import com.hmall.common.utils.CollUtils;import com.hmall.common.utils.UserContext;import lombok.RequiredArgsConstructor;import org.springframework.stereotype.Service;import java.util.Collection;import java.util.List;/** * &lt;p&gt; * 订单详情表 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2023-05-05 */@Service@RequiredArgsConstructorpublic class CartServiceImpl extends ServiceImpl&lt;CartMapper, Cart&gt; implements ICartService {    // private final IItemService itemService;    @Override    public void addItem2Cart(CartFormDTO cartFormDTO) {        // 1.获取登录用户        Long userId = UserContext.getUser();        // 2.判断是否已经存在        if (checkItemExists(cartFormDTO.getItemId(), userId)) {            // 2.1.存在，则更新数量            baseMapper.updateNum(cartFormDTO.getItemId(), userId);            return;        }        // 2.2.不存在，判断是否超过购物车数量        checkCartsFull(userId);        // 3.新增购物车条目        // 3.1.转换PO        Cart cart = BeanUtils.copyBean(cartFormDTO, Cart.class);        // 3.2.保存当前用户        cart.setUserId(userId);        // 3.3.保存到数据库        save(cart);    }    @Override    public List&lt;CartVO&gt; queryMyCarts() {        // 1.查询我的购物车列表        List&lt;Cart&gt; carts = lambdaQuery().eq(Cart::getUserId, 1L /*TODO UserContext.getUser()*/).list();        if (CollUtils.isEmpty(carts)) {            return CollUtils.emptyList();        }        // 2.转换VO        List&lt;CartVO&gt; vos = BeanUtils.copyList(carts, CartVO.class);        // 3.处理VO中的商品信息        handleCartItems(vos);        // 4.返回        return vos;    }    private void handleCartItems(List&lt;CartVO&gt; vos) {        // 1.获取商品id TODO 处理商品信息        /*Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());        // 2.查询商品        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);        if (CollUtils.isEmpty(items)) {            throw new BadRequestException("购物车中商品不存在！");        }        // 3.转为 id 到 item的map        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));        // 4.写入vo        for (CartVO v : vos) {            ItemDTO item = itemMap.get(v.getItemId());            if (item == null) {                continue;            }            v.setNewPrice(item.getPrice());            v.setStatus(item.getStatus());            v.setStock(item.getStock());        }*/    }    @Override    public void removeByItemIds(Collection&lt;Long&gt; itemIds) {        // 1.构建删除条件，userId和itemId        QueryWrapper&lt;Cart&gt; queryWrapper = new QueryWrapper&lt;Cart&gt;();        queryWrapper.lambda()                .eq(Cart::getUserId, UserContext.getUser())                .in(Cart::getItemId, itemIds);        // 2.删除        remove(queryWrapper);    }    private void checkCartsFull(Long userId) {        int count = lambdaQuery().eq(Cart::getUserId, userId).count();        if (count &gt;= 10) {            throw new BizIllegalException(StrUtil.format("用户购物车课程不能超过{}", 10));        }    }    private boolean checkItemExists(Long itemId, Long userId) {        int count = lambdaQuery()                .eq(Cart::getUserId, userId)                .eq(Cart::getItemId, itemId)                .count();        return count &gt; 0;    }}</code></pre><p>最后，还是要导入数据库表，在本地数据库直接执行课前资料对应的SQL文件：</p><p><img src="1697963215221123.png" alt="img"></p><p>在数据库中会出现名为<code>hm-cart</code>的<code>database</code>，以及其中的<code>cart</code>表，代表购物车：</p><p><img src="1697963215221124.png" alt="img"></p><p>接下来，就可以测试了。不过在启动前，同样要配置启动项的<code>active profile</code>为<code>local</code>：</p><p><img src="1697963215221125.png" alt="img"></p><p>然后启动<code>CartApplication</code>，访问swagger文档页面：<a href="http://localhost:8082/doc.html">http://localhost:8082/doc.html</a></p><p>我们测试其中的<code>查询我的购物车列表</code>接口：</p><p><img src="1697963215221126.png" alt="img"></p><p>无需填写参数，直接访问：</p><p><img src="1697963215221127.png" alt="img"></p><p>我们注意到，其中与商品有关的几个字段值都为空！这就是因为刚才我们注释掉了查询购物车时，查询商品信息的相关代码。</p><p>那么，我们该如何在<code>cart-service</code>服务中实现对<code>item-service</code>服务的查询呢？</p><h2 id="2-4-服务调用"><a href="#2-4-服务调用" class="headerlink" title="2.4.服务调用"></a>2.4.服务调用</h2><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询。</p><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>因此，现在查询购物车列表的流程变成了这样：</p><p><img src="image-20231022181345024.png" alt="image-20231022181345024"></p><p>代码中需要变化的就是这一步：</p><p><img src="1697963215221128.png" alt="img"></p><p>那么问题来了：我们该如何跨服务调用，准确的说，如何在<code>cart-service</code>中获取<code>item-service</code>服务中的提供的商品数据呢？</p><p>大家思考一下，我们以前有没有实现过类似的远程查询的功能呢？</p><p>答案是肯定的，我们前端向服务端查询数据，其实就是从浏览器远程查询服务端数据。比如我们刚才通过Swagger测试商品查询接口，就是向<code>http://localhost:8081/items</code>这个接口发起的请求：</p><p><img src="1697963215221129.png" alt="img"></p><p>而这种查询就是通过http请求的方式来完成的，不仅仅可以实现远程查询，还可以实现新增、删除等各种远程请求。</p><p>假如我们在cart-service中能模拟浏览器，发送http请求到item-service，是不是就实现了跨微服务的<strong>远程调用</strong>了呢？</p><p>那么：我们该如何用Java代码发送Http的请求呢？</p><h3 id="2-4-1-RestTemplate"><a href="#2-4-1-RestTemplate" class="headerlink" title="2.4.1.RestTemplate"></a>2.4.1.RestTemplate</h3><p>Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。</p><blockquote><p>org.springframework.web.client public class RestTemplate</p><p>extends InterceptingHttpAccessor</p><p>implements RestOperations</p><p>-—————————————————————————————————————</p><p>同步客户端执行HTTP请求，在底层HTTP客户端库(如JDK HttpURLConnection、Apache HttpComponents等)上公开一个简单的模板方法API。RestTemplate通过HTTP方法为常见场景提供了模板，此外还提供了支持不太常见情况的通用交换和执行方法。 RestTemplate通常用作共享组件。然而，它的配置不支持并发修改，因此它的配置通常是在启动时准备的。如果需要，您可以在启动时创建多个不同配置的RestTemplate实例。如果这些实例需要共享HTTP客户端资源，它们可以使用相同的底层ClientHttpRequestFactory。 注意:从5.0开始，这个类处于维护模式，只有对更改和错误的小请求才会被接受。请考虑使用org.springframework.web.react .client. webclient，它有更现代的API，支持同步、异步和流场景。  </p><p>-—————————————————————————————————————</p><p>自: 3.0 参见: HttpMessageConverter, RequestCallback, ResponseExtractor, ResponseErrorHandler</p></blockquote><p>其中提供了大量的方法，方便我们发送Http请求，例如：</p><p><img src="1697963215221130.png" alt="img"></p><p>可以看到常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p><p>我们在<code>cart-service</code>服务中定义一个配置类：</p><p><img src="1697963215221131.png" alt="img"></p><p>先将RestTemplate注册为一个Bean：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class RemoteCallConfig {    @Bean    public RestTemplate restTemplate() {        return new RestTemplate();    }}</code></pre><h3 id="2-4-2-远程调用"><a href="#2-4-2-远程调用" class="headerlink" title="2.4.2.远程调用"></a>2.4.2.远程调用</h3><p>接下来，我们修改<code>cart-service</code>中的<code>com.hmall.cart.service.impl.CartServiceImpl</code>的<code>handleCartItems</code>方法，发送http请求到<code>item-service</code>：</p><p><img src="1697963215221132.png" alt="img"></p><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li>① 请求方式</li><li>② 请求路径</li><li>③ 请求参数</li><li>④  返回值类型</li></ul><p><code>handleCartItems</code>方法的完整代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void handleCartItems(List&lt;CartVO&gt; vos) {    // TODO 1.获取商品id    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());    // 2.查询商品    // List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);    // 2.1.利用RestTemplate发起http请求，得到http的响应    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(            "http://localhost:8081/items?ids={ids}",            HttpMethod.GET,            null,            new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() {            },            Map.of("ids", CollUtil.join(itemIds, ","))    );    // 2.2.解析响应    if(!response.getStatusCode().is2xxSuccessful()){        // 查询失败，直接结束        return;    }    List&lt;ItemDTO&gt; items = response.getBody();    if (CollUtils.isEmpty(items)) {        return;    }    // 3.转为 id 到 item的map    Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));    // 4.写入vo    for (CartVO v : vos) {        ItemDTO item = itemMap.get(v.getItemId());        if (item == null) {            continue;        }        v.setNewPrice(item.getPrice());        v.setStatus(item.getStatus());        v.setStock(item.getStock());    }}</code></pre><p>好了，现在重启<code>cart-service</code>，再次测试查询我的购物车列表接口：</p><p><img src="1697963215221133.png" alt="img"></p><p>可以发现，所有商品相关数据都已经查询到了。</p><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>什么时候需要拆分微服务？</p><ul><li>如果是创业型公司，最好先用单体架构快速迭代开发，验证市场运作模型，快速试错。当业务跑通以后，随着业务规模扩大、人员规模增加，再考虑拆分微服务。</li><li>如果是大型企业，有充足的资源，可以在项目开始之初就搭建微服务架构。</li></ul><p>如何拆分？</p><ul><li>首先要做到高内聚、低耦合</li><li>从拆分方式来说，有横向拆分和纵向拆分两种。纵向就是按照业务功能模块，横向则是拆分通用性业务，提高复用性</li></ul><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><p>我们课堂中使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可，更符合微服务的需要。</p><p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li>exchange：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><h1 id="3-服务注册和发现Nacos"><a href="#3-服务注册和发现Nacos" class="headerlink" title="3.服务注册和发现Nacos"></a>3.服务注册和发现Nacos</h1><p>在上一章我们实现了微服务拆分，并且通过Http请求实现了跨微服务的远程调用。不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，我们进行了多实例部署，如图：</p><p><img src="image-20231023143148876.png" alt="image-20231023143148876"></p><p>此时，每个<code>item-service</code>的实例其IP或端口不同，问题来了：</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h2 id="3-1-注册中心原理"><a href="#3-1-注册中心原理" class="headerlink" title="3.1.注册中心原理"></a>3.1.注册中心原理</h2><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="image-20231023143848783.png" alt="image-20231023143848783"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="3-2-Nacos注册中心"><a href="#3-2-Nacos注册中心" class="headerlink" title="3.2.Nacos注册中心"></a>3.2.Nacos注册中心</h2><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SPringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多，课堂中我们会Nacos为例来学习。</p><p>官方网站：<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p><p>我们基于Docker来部署Nacos的注册中心，首先我们要准备MySQL数据库表，用来存储Nacos的数据。由于是Docker部署，所以大家需要将资料中的SQL文件导入到你<strong>Docker中的MySQL容器</strong>中：</p><p><img src="1697963215221135.png" alt="img"></p><p>最终表结构如下：</p><p><img src="1697963215221136.png" alt="img"></p><p>然后，找到课前资料下的nacos文件夹：</p><p><img src="1697963215221137.png" alt="img"></p><p>其中的<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为你自己的虚拟机IP地址：</p><p><img src="1697963215221138.png" alt="img"></p><p>然后，将课前资料中的<code>nacos</code>目录上传至虚拟机的<code>/root</code>目录。</p><p>进入root目录，然后执行下面的docker命令：</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \--name nacos \--env-file ./nacos/custom.env \-p 8848:8848 \-p 9848:9848 \-p 9849:9849 \--restart=always \nacos/nacos-server:v2.1.0-slim</code></pre><p>启动完成后，访问下面地址：<a href="http://192.168.71.100:8848/nacos/%E3%80%82">http://192.168.71.100:8848/nacos/。</a></p><p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p><p><img src="1697963215222139.png" alt="img"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>接下来，我们把<code>item-service</code>注册到Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><h3 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1.添加依赖"></a>3.3.1.添加依赖</h3><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos 服务注册发现--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="3-3-2-配置Nacos"><a href="#3-3-2-配置Nacos" class="headerlink" title="3.3.2.配置Nacos"></a>3.3.2.配置Nacos</h3><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  application:    name: item-service # 服务名称  cloud:    nacos:      server-addr: 192.168.150.101:8848 # nacos地址</code></pre><h3 id="3-3-3-启动服务实例"><a href="#3-3-3-启动服务实例" class="headerlink" title="3.3.3.启动服务实例"></a>3.3.3.启动服务实例</h3><p>为了测试一个服务多个实例的情况，我们再配置一个<code>item-service</code>的部署实例：</p><p><img src="1697963215222140.png" alt="img"></p><p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p><p><img src="1697963215222141.png" alt="img"></p><p>重启<code>item-service</code>的两个实例：</p><p><img src="1697963215222142.png" alt="img"></p><p>访问nacos控制台，可以发现服务注册成功：</p><p><img src="1697963215222143.png" alt="img"></p><p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p><p><img src="1697963215222144.png" alt="img"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos 服务注册发现--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p><h3 id="3-4-2-配置Nacos地址"><a href="#3-4-2-配置Nacos地址" class="headerlink" title="3.4.2.配置Nacos地址"></a>3.4.2.配置Nacos地址</h3><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    nacos:      server-addr: 192.168.150.101:8848</code></pre><h3 id="3-4-3-发现并调用服务"><a href="#3-4-3-发现并调用服务" class="headerlink" title="3.4.3.发现并调用服务"></a>3.4.3.发现并调用服务</h3><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IP的hash</li><li>最近最少访问</li><li>…</li></ul><p>这里我们可以选择最简单的随机负载均衡。</p><p>另外，服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</p><p><img src="1697963215222145.png" alt="img"></p><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口：</p><p><img src="1697963215222146.png" alt="img"></p><p>但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><p><img src="1697963215222147.png" alt="img"></p><p>经过swagger测试，发现没有任何问题。</p><h1 id="4-OpenFeign"><a href="#4-OpenFeign" class="headerlink" title="4.OpenFeign"></a>4.OpenFeign</h1><p>在上一章，我们利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了：</p><p><img src="1697963215222148.png" alt="img"></p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p>接下来，我们就通过一个快速入门的案例来体验一下OpenFeign的便捷吧。</p><h2 id="4-1-快速入门"><a href="#4-1-快速入门" class="headerlink" title="4.1.快速入门"></a>4.1.快速入门</h2><p>我们还是以cart-service中的查询我的购物车为例。因此下面的操作都是在cart-service中进行。</p><h3 id="4-1-1-引入依赖"><a href="#4-1-1-引入依赖" class="headerlink" title="4.1.1.引入依赖"></a>4.1.1.引入依赖</h3><p>在<code>cart-service</code>服务的pom.xml中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--openFeign--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--负载均衡器--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="4-1-2-启用OpenFeign"><a href="#4-1-2-启用OpenFeign" class="headerlink" title="4.1.2.启用OpenFeign"></a>4.1.2.启用OpenFeign</h3><p>接下来，我们在<code>cart-service</code>的<code>CartApplication</code>启动类上添加注解，启动OpenFeign功能：</p><p><img src="1697963215222149.png" alt="img"></p><h3 id="4-1-3-编写OpenFeign客户端"><a href="#4-1-3-编写OpenFeign客户端" class="headerlink" title="4.1.3.编写OpenFeign客户端"></a>4.1.3.编写OpenFeign客户端</h3><p>在<code>cart-service</code>中，定义一个新的接口，编写Feign客户端：</p><p>其中代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.client;import com.hmall.cart.domain.dto.ItemDTO;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import java.util.List;@FeignClient("item-service")public interface ItemClient {    @GetMapping("/items")    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam("ids") Collection&lt;Long&gt; ids);}</code></pre><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient("item-service")</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping("/items")</code> ：声明请求路径</li><li><code>@RequestParam("ids") Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h3 id="4-1-4-使用FeignClient"><a href="#4-1-4-使用FeignClient" class="headerlink" title="4.1.4.使用FeignClient"></a>4.1.4.使用FeignClient</h3><p>最后，我们在<code>cart-service</code>的<code>com.hmall.cart.service.impl.CartServiceImpl</code>中改造代码，直接调用<code>ItemClient</code>的方法：</p><p><img src="1697963215222150.png" alt="img"></p><p>feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作，是不是看起来优雅多了。</p><p>而且，这里我们不再需要RestTemplate了，还省去了RestTemplate的注册。</p><h2 id="4-2-连接池"><a href="#4-2-连接池" class="headerlink" title="4.2.连接池"></a>4.2.连接池</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h3 id="4-2-1-引入依赖"><a href="#4-2-1-引入依赖" class="headerlink" title="4.2.1.引入依赖"></a>4.2.1.引入依赖</h3><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--OK http 的依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="4-2-2-开启连接池"><a href="#4-2-2-开启连接池" class="headerlink" title="4.2.2.开启连接池"></a>4.2.2.开启连接池</h3><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">feign:  okhttp:    enabled: true # 开启OKHttp功能</code></pre><p>重启服务，连接池就生效了。</p><h3 id="4-2-3-验证"><a href="#4-2-3-验证" class="headerlink" title="4.2.3.验证"></a>4.2.3.验证</h3><p>我们可以打断点验证连接池是否生效，在<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>中的<code>execute</code>方法中打断点：</p><p><img src="1697963215222151.png" alt="img"></p><p>Debug方式启动cart-service，请求一次查询我的购物车方法，进入断点：</p><p><img src="1697963215222152.png" alt="img"></p><p>可以发现这里底层的实现已经改为<code>OkHttpClient</code></p><h2 id="4-3-最佳实践"><a href="#4-3-最佳实践" class="headerlink" title="4.3.最佳实践"></a>4.3.最佳实践</h2><p>将来我们要把与下单有关的业务抽取为一个独立微服务:<code>trade-service</code>，不过我们先来看一下<code>hm-service</code>中原本与下单有关的业务逻辑。</p><p>入口在<code>com.hmall.controller.OrderController</code>的<code>createOrder</code>方法，然后调用了<code>IOrderService</code>中的<code>createOrder</code>方法。</p><p>由于下单时前端提交了商品id，为了计算订单总价，需要查询商品信息：</p><p><img src="1697963215223153.png" alt="img"></p><p>也就是说，如果拆分了交易微服务（<code>trade-service</code>），它也需要远程调用<code>item-service</code>中的根据id批量查询商品功能。这个需求与<code>cart-service</code>中是一样的。</p><p>因此，我们就需要在<code>trade-service</code>中再次定义<code>ItemClient</code>接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？</p><h3 id="4-3-1-思路分析"><a href="#4-3-1-思路分析" class="headerlink" title="4.3.1.思路分析"></a>4.3.1.思路分析</h3><p>相信大家都能想到，避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p>如图：</p><p><img src="1697963215223154.jpeg" alt="img"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.</p><h3 id="4-3-2-抽取Feign客户端"><a href="#4-3-2-抽取Feign客户端" class="headerlink" title="4.3.2.抽取Feign客户端"></a>4.3.2.抽取Feign客户端</h3><p>在<code>hmall</code>下定义一个新的module，命名为hm-api</p><p><img src="1697963215223155.png" alt="img"></p><p>其依赖如下：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;hmall&lt;/artifactId&gt;        &lt;groupId&gt;com.heima&lt;/groupId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;hm-api&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--open feign--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- load balancer--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- swagger 注解依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.swagger&lt;/groupId&gt;            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;            &lt;version&gt;1.6.6&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>然后把ItemDTO和ItemClient都拷贝过来，最终结构如下：</p><p><img src="1697963215223156.png" alt="img"></p><p>现在，任何微服务要调用<code>item-service</code>中的接口，只需要引入<code>hm-api</code>模块依赖即可，无需自己编写Feign客户端了。</p><h3 id="4-3-3-扫描包"><a href="#4-3-3-扫描包" class="headerlink" title="4.3.3.扫描包"></a>4.3.3.扫描包</h3><p>接下来，我们在<code>cart-service</code>的<code>pom.xml</code>中引入<code>hm-api</code>模块：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--feign模块--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;artifactId&gt;hm-api&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>删除<code>cart-service</code>中原来的ItemDTO和ItemClient，重启项目，发现报错了：</p><p><img src="1697963215223157.png" alt="img"></p><p>这里因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而cart-service的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错了。</p><p>解决办法很简单，在cart-service的启动类上添加声明即可，两种方式：</p><ul><li>方式1：声明扫描包：</li></ul><p><img src="1697963215223158.png" alt="img"></p><ul><li>方式2：声明要用的FeignClient</li></ul><p><img src="1697963215223159.png" alt="img"></p><h2 id="4-4-日志配置"><a href="#4-4-日志配置" class="headerlink" title="4.4.日志配置"></a>4.4.日志配置</h2><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p><h3 id="4-4-1-定义日志级别"><a href="#4-4-1-定义日志级别" class="headerlink" title="4.4.1.定义日志级别"></a>4.4.1.定义日志级别</h3><p>在hm-api模块下新建一个配置类，定义Feign的日志级别：</p><p><img src="1697963215223160.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.config;import feign.Logger;import org.springframework.context.annotation.Bean;public class DefaultFeignConfig {    @Bean    public Logger.Level feignLogLevel(){        return Logger.Level.FULL;    }}</code></pre><h3 id="4-4-2-配置"><a href="#4-4-2-配置" class="headerlink" title="4.4.2.配置"></a>4.4.2.配置</h3><p>接下来，要让日志级别生效，还需要配置这个类。有两种方式：</p><ul><li><strong>局部</strong>生效：在某个<code>FeignClient</code>中配置，只对当前<code>FeignClient</code>生效</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@FeignClient(value = "item-service", configuration = DefaultFeignConfig.class)</code></pre><ul><li><strong>全局</strong>生效：在<code>@EnableFeignClients</code>中配置，针对所有<code>FeignClient</code>生效。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</code></pre><p>日志格式：</p><pre class="line-numbers language-Plain" data-language="Plain"><code class="language-Plain">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; GET http://item-service/items?ids=100000006163 HTTP/1.117:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; END HTTP (0-byte body)17:35:32:278 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- HTTP/1.1 200  (127ms)17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] connection: keep-alive17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] content-type: application/json17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] date: Fri, 26 May 2023 09:35:32 GMT17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] keep-alive: timeout=6017:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] transfer-encoding: chunked17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] 17:35:32:280 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] [{"id":100000006163,"name":"巴布豆(BOBDOG)柔薄悦动婴儿拉拉裤XXL码80片(15kg以上)","price":67100,"stock":10000,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t23998/350/2363990466/222391/a6e9581d/5b7cba5bN0c18fb4f.jpg!q70.jpg.webp","category":"拉拉裤","brand":"巴布豆","spec":"{}","sold":11,"commentCount":33343434,"isAD":false,"status":2}]17:35:32:281 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- END HTTP (369-byte body)</code></pre><h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a>5.作业</h1><h2 id="5-1-拆分微服务"><a href="#5-1-拆分微服务" class="headerlink" title="5.1.拆分微服务"></a>5.1.拆分微服务</h2><p>将hm-service中的其它业务也都拆分为微服务，包括：</p><ul><li>user-service：用户微服务，包含用户登录、管理等功能</li><li>trade-service：交易微服务，包含订单相关功能</li><li>pay-service：支付微服务，包含支付相关功能</li></ul><p>其中交易服务、支付服务、用户服务中的业务都需要知道当前登录用户是谁，目前暂未实现，先将用户id写死。</p><p><strong>思考</strong>：如何才能在每个微服务中都拿到用户信息？如何在微服务之间传递用户信息？</p><h2 id="5-2-定义FeignClient"><a href="#5-2-定义FeignClient" class="headerlink" title="5.2.定义FeignClient"></a>5.2.定义FeignClient</h2><p>在上述业务中，包含大量的微服务调用，将被调用的接口全部定义为FeignClient，将其与对应的DTO放在hm-api模块</p><h2 id="5-3-将微服务与前端联调"><a href="#5-3-将微服务与前端联调" class="headerlink" title="5.3.将微服务与前端联调"></a>5.3.将微服务与前端联调</h2><p>课前资料提供了一个<code>hmall-nginx</code>目录，其中包含了Nginx以及我们的前端代码：</p><p><img src="1697963215223161.png" alt="img"></p><p>将其拷贝到一个不包含中文、空格、特殊字符的目录，启动后即可访问到页面：</p><ul><li>18080是用户端页面</li><li>18081是管理端页面</li></ul><p>之前<code>nginx</code>内部会将发向服务端请求全部代理到8080端口，但是现在拆分了N个微服务，8080不可用了。请通过<code>Nginx</code>配置，完成对不同微服务的反向代理。</p><p><strong>认真思考这种方式存在哪些问题</strong>，<strong>有什么好的解决方案</strong>？</p><p><a href="https://b11et3un53m.feishu.cn/wiki/NNAtw4CFQijiYakX8tgczWvWn0b?create_from=create_doc_to_wiki">https://b11et3un53m.feishu.cn/wiki/NNAtw4CFQijiYakX8tgczWvWn0b?create_from=create_doc_to_wiki</a></p><hr><p>在昨天的作业中，我们将黑马商城拆分为5个微服务：</p><ul><li>用户服务</li><li>商品服务</li><li>购物车服务</li><li>交易服务</li><li>支付服务</li></ul><p>由于每个微服务都有不同的地址或端口，入口不同，相信大家在与前端联调的时候发现了一些问题：</p><ul><li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li><li>前端无法调用nacos，无法实时更新服务列表</li></ul><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>不要着急，这些问题都可以在今天的学习中找到答案，我们会通过<strong>网关</strong>技术解决上述问题。今天的内容会分为3章：</p><ul><li>第一章：网关路由，解决前端请求入口的问题。</li><li>第二章：网关鉴权，解决统一登录校验和用户信息获取的问题。</li><li>第三章：统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li></ul><p>通过今天的学习你将掌握下列能力：</p><ul><li>会利用微服务网关做请求路由</li><li>会利用微服务网关做登录身份校验</li><li>会利用Nacos实现统一配置管理</li><li>会利用Nacos实现配置热更新</li></ul><p>好了，接下来我们就一起进入今天的学习吧。</p><h1 id="1-网关路由"><a href="#1-网关路由" class="headerlink" title="1.网关路由"></a>1.网关路由</h1><h2 id="1-1-认识网关"><a href="#1-1-认识网关" class="headerlink" title="1.1.认识网关"></a>1.1.认识网关</h2><p>什么是网关？</p><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p><ul><li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li><li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li></ul><p><img src="169811723298744.jpeg" alt="img"></p><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="16981172328811.jpeg" alt="img"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>课堂中我们以SpringCloudGateway为例来讲解，官方网站：</p><p><a href="https://spring.io/projects/spring-cloud-gateway#learn">https://spring.io/projects/spring-cloud-gateway#learn</a></p><h2 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2.快速入门"></a>1.2.快速入门</h2><p>接下来，我们先看下如何利用网关实现请求路由。由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h3 id="1-2-1-创建项目"><a href="#1-2-1-创建项目" class="headerlink" title="1.2.1.创建项目"></a>1.2.1.创建项目</h3><p>首先，我们要在hmall下创建一个新的module，命名为hm-gateway，作为网关微服务：</p><p><img src="16981172328812.png" alt="img"></p><h3 id="1-2-2-引入依赖"><a href="#1-2-2-引入依赖" class="headerlink" title="1.2.2.引入依赖"></a>1.2.2.引入依赖</h3><p>在<code>hm-gateway</code>模块的<code>pom.xml</code>文件中引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;hmall&lt;/artifactId&gt;        &lt;groupId&gt;com.heima&lt;/groupId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;hm-gateway&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--common--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.heima&lt;/groupId&gt;            &lt;artifactId&gt;hm-common&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--网关--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--nacos discovery--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--负载均衡--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="1-2-3-启动类"><a href="#1-2-3-启动类" class="headerlink" title="1.2.3.启动类"></a>1.2.3.启动类</h3><p>在<code>hm-gateway</code>模块的<code>com.hmall.gateway</code>包下新建一个启动类：</p><p><img src="16981172328823.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication {    public static void main(String[] args) {        SpringApplication.run(GatewayApplication.class, args);    }}</code></pre><h3 id="1-2-4-配置路由"><a href="#1-2-4-配置路由" class="headerlink" title="1.2.4.配置路由"></a>1.2.4.配置路由</h3><p>接下来，在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8080spring:  application:    name: gateway  cloud:    nacos:      server-addr: 192.168.150.101:8848    gateway:      routes:        - id: item # 路由规则id，自定义，唯一          uri: lb://item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表          predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务            - Path=/items/**,/search/** # 这里是以请求路径作为判断规则        - id: cart          uri: lb://cart-service          predicates:            - Path=/carts/**        - id: user          uri: lb://user-service          predicates:            - Path=/users/**,/addresses/**        - id: trade          uri: lb://trade-service          predicates:            - Path=/orders/**        - id: pay          uri: lb://pay-service          predicates:            - Path=/pay-orders/**</code></pre><h3 id="1-2-5-测试"><a href="#1-2-5-测试" class="headerlink" title="1.2.5.测试"></a>1.2.5.测试</h3><p>启动GatewayApplication，以 <a href="http://localhost:8080/">http://localhost:8080</a> 拼接微服务接口路径来测试。例如：</p><p><a href="http://localhost:8080/items/page?pageNo=1&amp;pageSize=1">http://localhost:8080/items/page?pageNo=1&amp;pageSize=1</a></p><p><img src="16981172328824.png" alt="img"></p><p>此时，启动UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了：</p><h2 id="1-3-路由过滤"><a href="#1-3-路由过滤" class="headerlink" title="1.3.路由过滤"></a>1.3.路由过滤</h2><p>路由规则的定义语法如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      routes:        - id: item          uri: lb://item-service          predicates:            - Path=/items/**,/search/**</code></pre><p>其中routes对应的类型如下：</p><p><img src="16981172328825.png" alt="img"></p><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><p><img src="16981172328826.png" alt="img"></p><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里我们重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center">After</td><td align="center">是某个时间点后的请求</td><td align="center">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="center">Before</td><td align="center">是某个时间点之前的请求</td><td align="center">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td align="center">Between</td><td align="center">是某两个时间点之前的请求</td><td align="center">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="center">Cookie</td><td align="center">请求必须包含某些cookie</td><td align="center">- Cookie=chocolate, ch.p</td></tr><tr><td align="center">Header</td><td align="center">请求必须包含某些header</td><td align="center">- Header=X-Request-Id, \d+</td></tr><tr><td align="center">Host</td><td align="center">请求必须是访问某个host（域名）</td><td align="center">- Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="center">Method</td><td align="center">请求方式必须是指定方式</td><td align="center">- Method=GET,POST</td></tr><tr><td align="center">Path</td><td align="center">请求路径必须符合指定规则</td><td align="center">- Path=/red/{segment},/blue/**</td></tr><tr><td align="center">Query</td><td align="center">请求参数必须包含指定参数</td><td align="center">- Query=name, Jack或者- Query=name</td></tr><tr><td align="center">RemoteAddr</td><td align="center">请求者的ip必须是指定范围</td><td align="center">- RemoteAddr=192.168.1.1/24</td></tr><tr><td align="center">weight</td><td align="center">权重处理</td><td align="center"></td></tr></tbody></table><h1 id="2-网关登录校验"><a href="#2-网关登录校验" class="headerlink" title="2.网关登录校验"></a>2.网关登录校验</h1><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h2 id="2-1-鉴权思路分析"><a href="#2-1-鉴权思路分析" class="headerlink" title="2.1.鉴权思路分析"></a>2.1.鉴权思路分析</h2><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>此时，登录校验的流程如图：</p><p><img src="image-20231024145816082.png" alt="image-20231024145816082"></p><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？</li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><p><img src="image-20231024150701922.png" alt="image-20231024150701922"></p><p>这些问题将在接下来几节一一解决。</p><h2 id="2-2-网关过滤器"><a href="#2-2-网关过滤器" class="headerlink" title="2.2.网关过滤器"></a>2.2.网关过滤器</h2><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="image-20231024145848148.png" alt="image-20231024145848148"></p><p>如图所示：</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求了！</p><p>那么，该如何实现一个网关过滤器呢？</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>. </li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置。</li></ul><p><strong>注意</strong>：过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务。</p><p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * 处理请求并将其传递给下一个过滤器 * @param exchange 当前请求的上下文，其中包含request、response等各种数据 * @param chain 过滤器链，基于它向下传递请求 * @return 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。 */Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);</code></pre><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><p><img src="image-20231024151952293.png" alt="image-20231024151952293"></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>使用的使用只需要在application.yaml中这样配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      routes:      - id: test_route        uri: lb://test-service        predicates:          -Path=/test/**        filters:          - AddRequestHeader=key, value # 逗号之前是请求头的key，逗号之后是value</code></pre><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      default-filters: # default-filters下的过滤器可以作用于所有路由        - AddRequestHeader=key, value      routes:      - id: test_route        uri: lb://test-service        predicates:          -Path=/test/**</code></pre><h2 id="2-3-自定义过滤器"><a href="#2-3-自定义过滤器" class="headerlink" title="2.3.自定义过滤器"></a>2.3.自定义过滤器</h2><p>无论是<code>GatewayFilter</code>还是<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p><h3 id="2-3-1-自定义GatewayFilter"><a href="#2-3-1-自定义GatewayFilter" class="headerlink" title="2.3.1.自定义GatewayFilter"></a>2.3.1.自定义GatewayFilter</h3><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。最简单的方式是这样的：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Componentpublic class PrintAnyGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt; {    @Override    public GatewayFilter apply(Object config) {        return new GatewayFilter() {            @Override            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {                // 获取请求                ServerHttpRequest request = exchange.getRequest();                // 编写过滤器逻辑                System.out.println("过滤器执行了");                // 放行                return chain.filter(exchange);            }        };    }}</code></pre><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！</p><p>然后在yaml配置中这样使用：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      default-filters:            - PrintAny # 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</code></pre><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Componentpublic class PrintAnyGatewayFilterFactory // 父类泛型是内部类的Config类型                extends AbstractGatewayFilterFactory&lt;PrintAnyGatewayFilterFactory.Config&gt; {    @Override    public GatewayFilter apply(Config config) {        // OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：        // - GatewayFilter：过滤器        // - int order值：值越小，过滤器执行优先级越高        return new OrderedGatewayFilter(new GatewayFilter() {            @Override            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {                // 获取config值                String a = config.getA();                String b = config.getB();                String c = config.getC();                // 编写过滤器逻辑                System.out.println("a = " + a);                System.out.println("b = " + b);                System.out.println("c = " + c);                // 放行                return chain.filter(exchange);            }        }, 100);    }    // 自定义配置属性，成员变量名称很重要，下面会用到    @Data    static class Config{        private String a;        private String b;        private String c;    }    // 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取    @Override    public List&lt;String&gt; shortcutFieldOrder() {        return List.of("a", "b", "c");    }        // 返回当前配置类的类型，也就是内部的Config    @Override    public Class&lt;Config&gt; getConfigClass() {        return Config.class;    }}</code></pre><p>然后在yaml文件中使用：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      default-filters:            - PrintAny=1,2,3 # 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</code></pre><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      default-filters:            - name: PrintAny              args: # 手动指定参数名，无需按照参数顺序                a: 1                b: 2                c: 3</code></pre><h3 id="2-3-2-自定义GlobalFilter"><a href="#2-3-2-自定义GlobalFilter" class="headerlink" title="2.3.2.自定义GlobalFilter"></a>2.3.2.自定义GlobalFilter</h3><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Componentpublic class PrintAnyGlobalFilter implements GlobalFilter, Ordered {    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        // 编写过滤器逻辑        System.out.println("未登录，无法访问");        // 放行        // return chain.filter(exchange);        // 拦截        ServerHttpResponse response = exchange.getResponse();        response.setRawStatusCode(401);        return response.setComplete();    }    @Override    public int getOrder() {        // 过滤器执行顺序，值越小，优先级越高        return 0;    }}</code></pre><h2 id="2-4-登录校验"><a href="#2-4-登录校验" class="headerlink" title="2.4.登录校验"></a>2.4.登录校验</h2><p>接下来，我们就利用自定义<code>GlobalFilter</code>来完成登录校验。</p><h3 id="2-4-1-JWT工具"><a href="#2-4-1-JWT工具" class="headerlink" title="2.4.1.JWT工具"></a>2.4.1.JWT工具</h3><p>登录校验需要用到JWT，而且JWT的加密需要秘钥和加密工具。这些在<code>hm-service</code>中已经有了，我们直接拷贝过来：</p><p><img src="16981172328827.png" alt="img"></p><p>具体作用如下：</p><ul><li><code>AuthProperties</code>：配置登录校验需要拦截的路径，因为不是所有的路径都需要登录才能访问</li><li><code>JwtProperties</code>：定义与JWT工具有关的属性，比如秘钥文件位置</li><li><code>SecurityConfig</code>：工具的自动装配</li><li><code>JwtTool</code>：JWT工具，其中包含了校验和解析<code>token</code>的功能</li><li><code>hmall.jks</code>：秘钥文件</li></ul><p>其中<code>AuthProperties</code>和<code>JwtProperties</code>所需的属性要在<code>application.yaml</code>中配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:  jwt:    location: classpath:hmall.jks # 秘钥地址    alias: hmall # 秘钥别名    password: hmall123 # 秘钥文件密码    tokenTTL: 30m # 登录有效期  auth:    excludePaths: # 无需登录校验的路径      - /search/**      - /users/login      - /items/**</code></pre><h3 id="2-4-2-登录校验过滤器"><a href="#2-4-2-登录校验过滤器" class="headerlink" title="2.4.2.登录校验过滤器"></a>2.4.2.登录校验过滤器</h3><p>接下来，我们定义一个登录校验的过滤器：</p><p><img src="16981172328828.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway.filter;import com.hmall.common.exception.UnauthorizedException;import com.hmall.common.utils.CollUtils;import com.hmall.gateway.config.AuthProperties;import com.hmall.gateway.util.JwtTool;import lombok.RequiredArgsConstructor;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.util.AntPathMatcher;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.List;@Component@RequiredArgsConstructor@EnableConfigurationProperties(AuthProperties.class)public class AuthGlobalFilter implements GlobalFilter, Ordered {    private final JwtTool jwtTool;    private final AuthProperties authProperties;    private final AntPathMatcher antPathMatcher = new AntPathMatcher();    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        // 1.获取Request        ServerHttpRequest request = exchange.getRequest();        // 2.判断是否不需要拦截        if(isExclude(request.getPath().toString())){            // 无需拦截，直接放行            return chain.filter(exchange);        }        // 3.获取请求头中的token        String token = null;        List&lt;String&gt; headers = request.getHeaders().get("authorization");        if (!CollUtils.isEmpty(headers)) {            token = headers.get(0);        }        // 4.校验并解析token        Long userId = null;        try {            userId = jwtTool.parseToken(token);        } catch (UnauthorizedException e) {            // 如果无效，拦截            ServerHttpResponse response = exchange.getResponse();            response.setRawStatusCode(401);            return response.setComplete();        }        // TODO 5.如果有效，传递用户信息        System.out.println("userId = " + userId);        // 6.放行        return chain.filter(exchange);    }    private boolean isExclude(String antPath) {        for (String pathPattern : authProperties.getExcludePaths()) {            if(antPathMatcher.match(pathPattern, antPath)){                return true;            }        }        return false;    }    @Override    public int getOrder() {        return 0;    }}</code></pre><p>重启测试，会发现访问/items开头的路径，未登录状态下不会被拦截：</p><p><img src="16981172328839.png" alt="img"></p><p>访问其他路径则，未登录状态下请求会被拦截，并且返回<code>401</code>状态码：</p><p><img src="169811723288310.png" alt="img"></p><h2 id="2-5-微服务获取用户"><a href="#2-5-微服务获取用户" class="headerlink" title="2.5.微服务获取用户"></a>2.5.微服务获取用户</h2><p>现在，网关已经可以完成登录校验并获取登录用户身份信息。但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><p>据图流程图如下：</p><p><img src="169811723288411.jpeg" alt="img"></p><p>因此，接下来我们要做的事情有：</p><ul><li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务</li><li>编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行</li></ul><h3 id="2-5-1-保存用户到请求头"><a href="#2-5-1-保存用户到请求头" class="headerlink" title="2.5.1.保存用户到请求头"></a>2.5.1.保存用户到请求头</h3><p>首先，我们修改网关登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><p><img src="169811723288412.png" alt="img"></p><h3 id="2-5-2-拦截器获取用户"><a href="#2-5-2-拦截器获取用户" class="headerlink" title="2.5.2.拦截器获取用户"></a>2.5.2.拦截器获取用户</h3><p>在hm-common中已经有一个用于保存登录用户的ThreadLocal工具：</p><p><img src="169811723288413.png" alt="img"></p><p>其中已经提供了保存和获取用户的方法：</p><p><img src="169811723288414.png" alt="img"></p><p>接下来，我们只需要编写拦截器，获取用户信息并保存到<code>UserContext</code>，然后放行即可。</p><p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在<code>hm-common</code>中，并写好自动装配。这样微服务只需要引入<code>hm-common</code>就可以直接具备拦截器功能，无需重复编写。</p><p>我们在<code>hm-common</code>模块下定义一个拦截器：</p><p><img src="169811723288415.png" alt="img"></p><p>具体代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.common.interceptor;import cn.hutool.core.util.StrUtil;import com.hmall.common.utils.UserContext;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserInfoInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        // 1.获取请求头中的用户信息        String userInfo = request.getHeader("user-info");        // 2.判断是否为空        if (StrUtil.isNotBlank(userInfo)) {            // 不为空，保存到ThreadLocal                UserContext.setUser(Long.valueOf(userInfo));        }        // 3.放行        return true;    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        // 移除用户        UserContext.removeUser();    }}</code></pre><p>接着在<code>hm-common</code>模块下编写<code>SpringMVC</code>的配置类，配置登录拦截器：</p><p><img src="169811723288416.png" alt="img"></p><p>具体代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.common.config;import com.hmall.common.interceptor.UserInfoInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new UserInfoInterceptor());    }}</code></pre><p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是<code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。</p><p>基于SpringBoot的自动装配原理，我们要将其添加到<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中：</p><p><img src="169811723288417.png" alt="img"></p><p>内容如下：</p><pre class="line-numbers language-Properties" data-language="Properties"><code class="language-Properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\  com.hmall.common.config.MyBatisConfig,\  com.hmall.common.config.MvcConfig</code></pre><h3 id="2-5-3-恢复购物车代码"><a href="#2-5-3-恢复购物车代码" class="headerlink" title="2.5.3.恢复购物车代码"></a>2.5.3.恢复购物车代码</h3><p>之前我们无法获取登录用户，所以把购物车服务的登录用户写死了，现在需要恢复到原来的样子。</p><p>找到<code>cart-service</code>模块的<code>com.hmall.cart.service.impl.CartServiceImpl</code>：</p><p><img src="169811723288418.png" alt="img"></p><p>修改其中的<code>queryMyCarts</code>方法：</p><p><img src="169811723288419.png" alt="img"></p><h2 id="2-6-OpenFeign传递用户"><a href="#2-6-OpenFeign传递用户" class="headerlink" title="2.6.OpenFeign传递用户"></a>2.6.OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src="169811723288520.jpeg" alt="img"></p><p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface RequestInterceptor {  /**   * Called for every request.    * Add data using methods on the supplied {@link RequestTemplate}.   */  void apply(RequestTemplate template);}</code></pre><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><p>由于<code>FeignClient</code>全部都是在<code>hm-api</code>模块，因此我们在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器：</p><p><img src="169811723288521.png" alt="img"></p><p>在<code>com.hmall.api.config.DefaultFeignConfig</code>中添加一个Bean：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Beanpublic RequestInterceptor userInfoRequestInterceptor(){    return new RequestInterceptor() {        @Override        public void apply(RequestTemplate template) {            // 获取登录用户            Long userId = UserContext.getUser();            if(userId == null) {                // 如果为空则直接跳过                return;            }            // 如果不为空则放入请求头中，传递给下游微服务            template.header("user-info", userId.toString());        }    };}</code></pre><p>好了，现在微服务之间通过OpenFeign调用时也会传递登录用户信息了。</p><h4 id="整体拦截如下"><a href="#整体拦截如下" class="headerlink" title="整体拦截如下"></a>整体拦截如下</h4><p>主要有三个部分：</p><ol><li>网关</li><li>所有微服务前的拦截器</li><li>微服务间调用，基于OpenFeign的拦截器</li></ol><p><img src="image-20231025153012770.png" alt="image-20231025153012770"></p><h1 id="3-配置管理"><a href="#3-配置管理" class="headerlink" title="3.配置管理"></a>3.配置管理</h1><p>到目前为止我们已经解决了微服务相关的几个问题：</p><ul><li>微服务远程调用</li><li>微服务注册、发现</li><li>微服务请求路由、负载均衡</li><li>微服务登录用户信息传递</li></ul><p>不过，现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="169811723288522.jpeg" alt="img"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h2 id="3-1-配置共享"><a href="#3-1-配置共享" class="headerlink" title="3.1.配置共享"></a>3.1.配置共享</h2><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h3 id="3-1-1-添加共享配置"><a href="#3-1-1-添加共享配置" class="headerlink" title="3.1.1.添加共享配置"></a>3.1.1.添加共享配置</h3><p>以cart-service为例，我们看看有哪些配置是重复的，可以抽取的：</p><p>首先是jdbc相关配置：</p><p><img src="169811723288523.png" alt="img"></p><p>然后是日志配置：</p><p><img src="169811723288524.png" alt="img"></p><p>然后是swagger以及OpenFeign的配置：</p><p><img src="169811723288525.png" alt="img"></p><p>我们在nacos控制台分别添加这些配置。</p><p>首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p><p><img src="169811723288526.png" alt="img"></p><p>在弹出的表单中填写信息：</p><p><img src="169811723288527.png" alt="img"></p><p>其中详细的配置如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    url: jdbc:mysql://${hm.db.host:192.168.150.101}:${hm.db.port:3306}/${hm.db.database}?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai    driver-class-name: com.mysql.cj.jdbc.Driver    username: ${hm.db.un:root}    password: ${hm.db.pw:123}mybatis-plus:  configuration:    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler  global-config:    db-config:      update-strategy: not_null      id-type: auto</code></pre><p>注意这里的jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>${hm.db.host:192.168.150.101}</code>配置了默认值为<code>192.168.150.101</code>，同时允许通过<code>${hm.db.host}</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>${hm.db.port:3306}</code>配置了默认值为<code>3306</code>，同时允许通过<code>${hm.db.port}</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>${hm.db.database}</code>来设定，无默认值</li></ul><p>然后是统一的日志配置，命名为<code>shared-log.yaml</code>，配置内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">logging:  level:    com.hmall: debug  pattern:    dateformat: HH:mm:ss:SSS  file:    path: "logs/${spring.application.name}"</code></pre><p>然后是统一的swagger配置，命名为<code>shared-swagger.yaml</code>，配置内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">knife4j:  enable: true  openapi:    title: ${hm.swagger.title:黑马商城接口文档}    description: ${hm.swagger.description:黑马商城接口文档}    email: ${hm.swagger.email:zhanghuyi@itcast.cn}    concat: ${hm.swagger.concat:虎哥}    url: https://www.itcast.cn    version: v1.0.0    group:      default:        group-name: default        api-rule: package        api-rule-resources:          - ${hm.swagger.package}</code></pre><p>注意，这里的swagger相关配置我们没有写死，例如：</p><ul><li><code>title</code>：接口文档标题，我们用了<code>${hm.swagger.title}</code>来代替，将来可以有用户手动指定</li><li><code>email</code>：联系人邮箱，我们用了<code>${hm.swagger.email:``zhanghuyi@itcast.cn``}</code>，默认值是<code>zhanghuyi@itcast.cn</code>，同时允许用户利用<code>${hm.swagger.email}</code>来覆盖。</li></ul><h3 id="3-1-2-拉取共享配置"><a href="#3-1-2-拉取共享配置" class="headerlink" title="3.1.2.拉取共享配置"></a>3.1.2.拉取共享配置</h3><p>接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了。</p><p><img src="169811723288528.jpeg" alt="img"></p><p>因此，微服务整合Nacos配置管理的步骤如下：</p><p>1）引入依赖：</p><p>在cart-service模块引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--nacos配置管理--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--读取bootstrap文件--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）新建bootstrap.yaml</p><p>在cart-service中的resources目录新建一个bootstrap.yaml文件：</p><p><img src="169811723288529.png" alt="img"></p><p>内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  application:    name: cart-service # 服务名称  profiles:    active: dev  cloud:    nacos:      server-addr: 192.168.150.101 # nacos地址      config:        file-extension: yaml # 文件后缀名        shared-configs: # 共享配置          - dataId: shared-jdbc.yaml # 共享mybatis配置          - dataId: shared-log.yaml # 共享日志配置          - dataId: shared-swagger.yaml # 共享日志配置</code></pre><p>3）修改application.yaml</p><p>由于一些配置挪到了bootstrap.yaml，因此application.yaml需要修改为：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8082feign:  okhttp:    enabled: true # 开启OKHttp连接池支持hm:  swagger:    title: 购物车服务接口文档    package: com.hmall.cart.controller  db:    database: hm-cart</code></pre><p>重启服务，发现所有配置都生效了。</p><h2 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2.配置热更新"></a>3.2.配置热更新</h2><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10，对应代码如下：</p><p><img src="169811723288530.png" alt="img"></p><p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p><p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h3 id="3-2-1-添加配置到Nacos"><a href="#3-2-1-添加配置到Nacos" class="headerlink" title="3.2.1.添加配置到Nacos"></a>3.2.1.添加配置到Nacos</h3><p>首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：</p><p><img src="169811723288631.png" alt="img"></p><p>注意文件的dataId格式：</p><pre class="line-numbers language-Plain" data-language="Plain"><code class="language-Plain">[服务名]-[spring.active.profile].[后缀名]</code></pre><p>文件名称由三部分组成：</p><ul><li>**<code>服务名</code>**：我们是购物车服务，所以是<code>cart-service</code></li><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li>**<code>后缀名</code>**：例如yaml</li></ul><p>这里我们直接使用<code>cart-service.yaml</code>这个名称，则不管是dev还是local环境都可以共享该配置。</p><p>配置内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">hm:  cart:    maxAmount: 1 # 购物车商品数量上限</code></pre><p>提交配置，在控制台能看到新添加的配置：</p><p><img src="169811723288632.png" alt="img"></p><h3 id="3-2-2-配置热更新"><a href="#3-2-2-配置热更新" class="headerlink" title="3.2.2.配置热更新"></a>3.2.2.配置热更新</h3><p>接着，我们在微服务中读取配置，实现配置热更新。</p><p>在<code>cart-service</code>中新建一个属性读取类：</p><p><img src="169811723288633.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.cart.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Data@Component@ConfigurationProperties(prefix = "hm.cart")public class CartProperties {    private Integer maxAmount;}</code></pre><p>接着，在业务中使用该属性加载类：</p><p><img src="169811723288634.png" alt="img"></p><p>测试，向购物车中添加多个商品：</p><p><img src="169811723288635.png" alt="img"></p><p>我们在nacos控制台，将购物车上限配置为5：</p><p><img src="169811723288636.png" alt="img"></p><p>无需重启，再次测试购物车功能：</p><p><img src="169811723288637.png" alt="img"></p><p>加入成功！</p><p>无需重启服务，配置热更新就生效了！</p><h2 id="3-3-动态路由（少用）"><a href="#3-3-动态路由（少用）" class="headerlink" title="3.3.动态路由（少用）"></a>3.3.动态路由（少用）</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p><p><img src="image-20231025172754428.png" alt="image-20231025172754428"></p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="3-3-1-监听Nacos配置变更"><a href="#3-3-1-监听Nacos配置变更" class="headerlink" title="3.3.1.监听Nacos配置变更"></a>3.3.1.监听Nacos配置变更</h3><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：</p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void addListener(String dataId, String group, Listener listener)</code></pre><p>请求参数说明：</p><table><thead><tr><th align="center"><strong>参数名</strong></th><th align="center"><strong>参数类型</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">dataId</td><td align="center">string</td><td align="center">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节。</td></tr><tr><td align="center">group</td><td align="center">string</td><td align="center">配置分组，一般是默认的DEFAULT_GROUP。</td></tr><tr><td align="center">listener</td><td align="center">Listener</td><td align="center">监听器，配置变更进入监听器的回调函数。</td></tr></tbody></table><p>示例代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String serverAddr = "{serverAddr}";String dataId = "{dataId}";String group = "{group}";// 1.创建ConfigService，连接NacosProperties properties = new Properties();properties.put("serverAddr", serverAddr);ConfigService configService = NacosFactory.createConfigService(properties);// 2.读取配置String content = configService.getConfig(dataId, group, 5000);// 3.添加配置监听器configService.addListener(dataId, group, new Listener() {        @Override        public void receiveConfigInfo(String configInfo) {        // 配置变更的通知处理                System.out.println("recieve1:" + configInfo);        }        @Override        public Executor getExecutor() {                return null;        }});</code></pre><p>这里核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p><p><img src="169811723288638.png" alt="img"></p><p>NacosConfigManager中是负责管理Nacos的ConfigService的，具体代码如下：</p><p><img src="169811723288639.png" alt="img"></p><p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String getConfigAndSignListener(    String dataId, // 配置文件id    String group, // 配置组，走默认    long timeoutMs, // 读取配置的超时时间    Listener listener // 监听器) throws NacosException;</code></pre><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="3-3-2-更新路由"><a href="#3-3-2-更新路由" class="headerlink" title="3.3.2.更新路由"></a>3.3.2.更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package org.springframework.cloud.gateway.route;import reactor.core.publisher.Mono;/** * @author Spencer Gibb */public interface RouteDefinitionWriter {        /**     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由     */        Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route);        /**     * 根据路由id删除某个路由     */        Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId);}</code></pre><p>这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{  "id": "item",  "predicates": [{    "name": "Path",    "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}  }],  "filters": [],  "uri": "lb://item-service"}</code></pre><p>以上JSON配置就等同于：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    gateway:      routes:        - id: item          uri: lb://item-service          predicates:            - Path=/items/**,/search/**</code></pre><p>OK，我们所需要用到的SDK已经齐全了。</p><h3 id="3-3-3-实现动态路由"><a href="#3-3-3-实现动态路由" class="headerlink" title="3.3.3.实现动态路由"></a>3.3.3.实现动态路由</h3><p>首先， 我们在网关gateway引入依赖：</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--统一配置管理--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--加载bootstrap--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  application:    name: gateway  cloud:    nacos:      server-addr: 192.168.150.101      config:        file-extension: yaml        shared-configs:          - dataId: shared-log.yaml # 共享日志配置</code></pre><p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8080 # 端口hm:  jwt:    location: classpath:hmall.jks # 秘钥地址    alias: hmall # 秘钥别名    password: hmall123 # 秘钥文件密码    tokenTTL: 30m # 登录有效期  auth:    excludePaths: # 无需登录校验的路径      - /search/**      - /users/login      - /items/**</code></pre><p>然后，在<code>gateway</code>中定义配置监听器：</p><p><img src="169811723288640.png" alt="img"></p><p>其代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.gateway.route;import cn.hutool.json.JSONUtil;import com.alibaba.cloud.nacos.NacosConfigManager;import com.alibaba.nacos.api.config.listener.Listener;import com.alibaba.nacos.api.exception.NacosException;import com.hmall.common.utils.CollUtils;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionWriter;import org.springframework.stereotype.Component;import reactor.core.publisher.Mono;import javax.annotation.PostConstruct;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.concurrent.Executor;@Slf4j@Component@RequiredArgsConstructorpublic class DynamicRouteLoader {    private final RouteDefinitionWriter writer;    private final NacosConfigManager nacosConfigManager;    // 路由配置文件的id和分组    private final String dataId = "gateway-routes.json";    private final String group = "DEFAULT_GROUP";    // 保存更新过的路由id    private final Set&lt;String&gt; routeIds = new HashSet&lt;&gt;();    @PostConstruct    public void initRouteConfigListener() throws NacosException {        // 1.注册监听器并首次拉取配置        String configInfo = nacosConfigManager.getConfigService()                .getConfigAndSignListener(dataId, group, 5000, new Listener() {                    @Override                    public Executor getExecutor() {                        return null;                    }                    @Override                    public void receiveConfigInfo(String configInfo) {                        updateConfigInfo(configInfo);                    }                });        // 2.首次启动时，更新一次配置        updateConfigInfo(configInfo);    }    private void updateConfigInfo(String configInfo) {        log.debug("监听到路由配置变更，{}", configInfo);        // 1.反序列化        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);        // 2.更新前先清空旧路由        // 2.1.清除旧路由        for (String routeId : routeIds) {            writer.delete(Mono.just(routeId)).subscribe();        }        routeIds.clear();        // 2.2.判断是否有新的路由要更新        if (CollUtils.isEmpty(routeDefinitions)) {            // 无新路由配置，直接结束            return;        }        // 3.更新路由        routeDefinitions.forEach(routeDefinition -&gt; {            // 3.1.更新路由            writer.save(Mono.just(routeDefinition)).subscribe();            // 3.2.记录路由id，方便将来删除            routeIds.add(routeDefinition.getId());        });    }}</code></pre><p>重启网关，任意访问一个接口，比如 <a href="http://localhost:8080/search/list?pageNo=1&amp;pageSize=1%EF%BC%9A">http://localhost:8080/search/list?pageNo=1&amp;pageSize=1：</a></p><p><img src="169811723288741.png" alt="img"></p><p>发现是404，无法访问。</p><p>接下来，我们直接在Nacos控制台添加路由，路由文件名为<code>gateway-routes.json</code>，类型为<code>json</code>：</p><p><img src="169811723288742.png" alt="img"></p><p>配置内容如下：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">[    {        "id": "item",        "predicates": [{            "name": "Path",            "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}        }],        "filters": [],        "uri": "lb://item-service"    },    {        "id": "cart",        "predicates": [{            "name": "Path",            "args": {"_genkey_0":"/carts/**"}        }],        "filters": [],        "uri": "lb://cart-service"    },    {        "id": "user",        "predicates": [{            "name": "Path",            "args": {"_genkey_0":"/users/**", "_genkey_1":"/addresses/**"}        }],        "filters": [],        "uri": "lb://user-service"    },    {        "id": "trade",        "predicates": [{            "name": "Path",            "args": {"_genkey_0":"/orders/**"}        }],        "filters": [],        "uri": "lb://trade-service"    },    {        "id": "pay",        "predicates": [{            "name": "Path",            "args": {"_genkey_0":"/pay-orders/**"}        }],        "filters": [],        "uri": "lb://pau-service"    }]</code></pre><p>无需重启网关，稍等几秒钟后，再次访问刚才的地址：</p><p><img src="169811723288743.png" alt="img"></p><p>网关路由成功了！</p><h1 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h1><p>将项目一拆分为一个微服务项目，并完成下列需求：</p><ul><li>基于OpenFeign实现服务间远程调用</li><li>定义网关，实现对微服务的请求路由</li><li>基于网关实现登录用户校验和用户信息传递</li></ul><p>以苍穹外卖为例，项目可以拆分为：</p><ul><li>业务服务：<ul><li>用户服务：用户、地址、登录等相关业务</li><li>产品服务：店铺、分类、菜品、套餐等业务</li><li>交易服务：订单、购物车业务</li><li>数据服务：工作台、报表统计等业务</li></ul></li><li>基础服务：<ul><li>支付服务：支付相关业务</li><li>文件服务：文件上传功能</li></ul></li></ul><h1 id="0-导言"><a href="#0-导言" class="headerlink" title="0.导言"></a>0.导言</h1><p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有<strong>级联失败</strong>问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p><img src="image-20231026154315958.png" alt="image-20231026154315958"></p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p><img src="image-20231026154336858.png" alt="image-20231026154336858"></p><p>这就是<strong>级联失败</strong>问题，或者叫<strong>雪崩</strong>问题。</p><p>还有跨服务的事务问题：</p><p>比如昨天讲到过的下单业务，下单的过程中需要调用多个微服务：</p><ul><li>商品服务：扣减库存</li><li>订单服务：保存订单</li><li>购物车服务：清理购物车</li></ul><p>这些业务全部都是数据库的写操作，我们必须确保所有操作的同时成功或失败。但是这些操作在不同微服务，也就是不同的Tomcat，这样的情况如何确保事务特性呢？</p><p>这些问题都会在今天找到答案。</p><p>今天的内容会分成几部分：</p><ul><li>微服务保护<ul><li>服务保护方案</li><li>请求限流</li><li>隔离和熔断</li></ul></li><li>分布式事务<ul><li>初识分布式事务</li><li>Seata</li></ul></li></ul><p>通过今天的学习，你将能掌握下面的能力：</p><ul><li>知道雪崩问题产生原因及常见解决方案</li><li>能使用Sentinel实现服务保护</li><li>理解分布式事务产生的原因</li><li>能使用Seata解决分布式事务问题</li><li>理解AT模式基本原理</li></ul><h1 id="1-微服务保护"><a href="#1-微服务保护" class="headerlink" title="1.微服务保护"></a>1.微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。这章我们就一起来学习一下微服务保护的常见方案以及对应的技术。</p><h2 id="1-1-服务保护方案"><a href="#1-1-服务保护方案" class="headerlink" title="1.1.服务保护方案"></a>1.1.服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><p>接下来，我们就逐一了解这些方案的原理。</p><h3 id="1-1-1-请求限流"><a href="#1-1-1-请求限流" class="headerlink" title="1.1.1.请求限流"></a>1.1.1.请求限流</h3><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p><p><img src="169830613916752.jpeg" alt="img"></p><h3 id="1-1-2-线程隔离"><a href="#1-1-2-线程隔离" class="headerlink" title="1.1.2.线程隔离"></a>1.1.2.线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口收到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p><p>线程隔离的思想来自轮船的舱壁模式：</p><p><img src="16983061391081.png" alt="img"></p><p>轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没。</p><p>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><p>暂时无法在飞书文档外展示此内容</p><p>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。</p><h3 id="1-1-3-服务熔断"><a href="#1-1-3-服务熔断" class="headerlink" title="1.1.3.服务熔断"></a>1.1.3.服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。</p><p>所以，我们要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><p>暂时无法在飞书文档外展示此内容</p><h2 id="1-2-Sentinel"><a href="#1-2-Sentinel" class="headerlink" title="1.2.Sentinel"></a>1.2.Sentinel</h2><p>微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel，所以接下来我们学习Sentinel的使用。</p><h3 id="1-2-1-介绍和安装"><a href="#1-2-1-介绍和安装" class="headerlink" title="1.2.1.介绍和安装"></a>1.2.1.介绍和安装</h3><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。官方网站：</p><p><a href="https://sentinelguard.io/zh-cn/">https://sentinelguard.io/zh-cn/</a></p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，我们先把Sentinel的控制台搭建出来。</p><p>1）下载jar包</p><p>下载地址：</p><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p><p>也可以直接使用课前资料提供的版本：</p><p><img src="16983061391092.png" alt="img"></p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下，重命名为<code>sentinel-dashboard.jar</code>：</p><p><img src="16983061391093.png" alt="img"></p><p>然后运行如下命令启动控制台：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</code></pre><p>其它启动时可配置参数可参考官方文档：</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9</a></p><p>3）访问</p><p>访问<a href="http://localhost:8090页面，就可以看到sentinel的控制台了：">http://localhost:8090页面，就可以看到sentinel的控制台了：</a></p><p><img src="16983061391104.png" alt="img"></p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身：</p><p><img src="16983061391105.png" alt="img"></p><h3 id="1-2-2-微服务整合"><a href="#1-2-2-微服务整合" class="headerlink" title="1.2.2.微服务整合"></a>1.2.2.微服务整合</h3><p>我们在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台，步骤如下： 1）引入sentinel依赖</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--sentinel--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2）配置控制台</p><p>修改application.yaml文件，添加下面内容：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:     sentinel:      transport:        dashboard: localhost:8090</code></pre><p>3）访问<code>cart-service</code>的任意端点</p><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息：</p><p><img src="16983061391106.png" alt="img"></p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="16983061391117.png" alt="img"></p><p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）。</p><p>因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径：</p><p><img src="16983061391128.png" alt="img"></p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><p>首先，在<code>cart-service</code>的<code>application.yml</code>中添加下面的配置：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  cloud:    sentinel:      transport:        dashboard: localhost:8090      http-method-specify: true # 开启请求方式前缀</code></pre><p>然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化：</p><p><img src="16983061391129.png" alt="img"></p><h2 id="1-3-请求限流"><a href="#1-3-请求限流" class="headerlink" title="1.3.请求限流"></a>1.3.请求限流</h2><p>在簇点链路后面点击流控按钮，即可对其做限流配置：</p><p><img src="169830613911310.png" alt="img"></p><p>在弹出的菜单中这样填写：</p><p><img src="169830613911311.png" alt="img"></p><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p><p>我们利用Jemeter做限流测试，我们每秒发出10个请求：</p><p><img src="169830613911312.png" alt="img"></p><p>最终监控结果如下：</p><p><img src="169830613911313.png" alt="img"></p><p>可以看出<code>GET:/carts</code>这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合我们的预期。</p><h2 id="1-4-线程隔离"><a href="#1-4-线程隔离" class="headerlink" title="1.4.线程隔离"></a>1.4.线程隔离</h2><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：</p><p><img src="image-20231028105727235.png" alt="image-20231028105727235"></p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p><p>所以，我们要对查询商品的FeignClient接口做线程隔离。</p><h3 id="1-4-1-OpenFeign整合Sentinel"><a href="#1-4-1-OpenFeign整合Sentinel" class="headerlink" title="1.4.1.OpenFeign整合Sentinel"></a>1.4.1.OpenFeign整合Sentinel</h3><p>修改cart-service模块的application.yml文件，开启Feign的sentinel功能：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">feign:  sentinel:    enabled: true # 开启feign对sentinel的支持</code></pre><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源：</p><p><img src="169830613911314.png" alt="img"></p><h3 id="1-4-2-配置线程隔离"><a href="#1-4-2-配置线程隔离" class="headerlink" title="1.4.2.配置线程隔离"></a>1.4.2.配置线程隔离</h3><p>接下来，点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p><p><img src="169830613911415.png" alt="img"></p><p>在弹出的表单中填写下面内容：</p><p><img src="169830613911416.png" alt="img"></p><p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><p><img src="169830613911417.png" alt="img"></p><p>我们利用Jemeter测试，每秒发送100个请求：</p><p><img src="169830613911418.png" alt="img"></p><p>最终测试结果如下：</p><p><img src="169830613911419.png" alt="img"></p><p>进入查询购物车的请求每秒大概在100，而在查询商品时却只剩下每秒10左右，符合我们的预期。</p><p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现不受影响：</p><p><img src="169830613911420.png" alt="img"></p><p>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响到其它接口。</p><h2 id="1-5-服务熔断"><a href="#1-5-服务熔断" class="headerlink" title="1.5.服务熔断"></a>1.5.服务熔断</h2><p>在上节课，我们利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了500毫秒延时），再加上线程隔离限定了线程数为5，导致接口吞吐能力有限，最终QPS只有10左右。这就导致了几个问题：</p><p>第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p><p>第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p><h3 id="1-5-1-编写降级逻辑"><a href="#1-5-1-编写降级逻辑" class="headerlink" title="1.5.1.编写降级逻辑"></a>1.5.1.编写降级逻辑</h3><p>触发限流或熔断后的请求不一定要直接报错，也可以<strong>返回一些默认数据或者友好提示</strong>，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code>：</p><p><img src="169830613911421.png" alt="img"></p><p>代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.hmall.api.client.fallback;import com.hmall.api.client.ItemClient;import com.hmall.api.dto.ItemDTO;import com.hmall.api.dto.OrderDetailDTO;import com.hmall.common.exception.BizIllegalException;import com.hmall.common.utils.CollUtils;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.openfeign.FallbackFactory;import java.util.Collection;import java.util.List;@Slf4jpublic class ItemClientFallback implements FallbackFactory&lt;ItemClient&gt; {    // 自己实现一个FeignClient ItemClient.    // 正常时会调用ItemClient，异常是会调用此fallback    @Override    public ItemClient create(Throwable cause) {        return new ItemClient() {            @Override            public List&lt;ItemDTO&gt; queryItemByIds(Collection&lt;Long&gt; ids) {                log.error("远程调用ItemClient#queryItemByIds方法出现异常，参数：{}", ids, cause);                // 查询购物车允许失败，查询失败，返回空集合                return CollUtils.emptyList();            }            @Override            public void deductStock(List&lt;OrderDetailDTO&gt; items) {                // 库存扣减业务需要触发事务回滚，查询失败，抛出异常                throw new BizIllegalException(cause);            }        };    }}</code></pre><p><strong>步骤二</strong>：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code>：</p><p><img src="169830613911522.png" alt="img"></p><p><strong>步骤三</strong>：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code>：</p><p><img src="169830613911523.png" alt="img"></p><p>重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑：</p><p><img src="169830613911524.png" alt="img"></p><p>但是未被限流的请求延时依然很高：</p><p><img src="169830613911525.png" alt="img"></p><p>导致最终的平局响应时间较长。</p><h3 id="1-5-2-服务熔断"><a href="#1-5-2-服务熔断" class="headerlink" title="1.5.2.服务熔断"></a>1.5.2.服务熔断</h3><p>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。</p><p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了。</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="image-20231029111402854.png" alt="image-20231029111402854"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的**<code>熔断</code>**按钮来配置熔断策略：</p><p><img src="169830613911526.png" alt="img"></p><p>在弹出的表格中这样填写：</p><p><img src="169830613911827.png" alt="img"></p><p>这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><p>配置完成后，再次利用Jemeter测试，可以发现：</p><p><img src="169830613911828.png" alt="img"></p><p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响。</p><p>此时整个购物车查询服务的平均RT影响不大：</p><p><img src="169830613911829.png" alt="img"></p><h1 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2.分布式事务"></a>2.分布式事务</h1><p>首先我们看看项目中的下单业务整体流程：</p><p><img src="image-20231029114703860.png" alt="image-20231029114703860"></p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？</p><p>我们来做一个测试，先进入购物车页面：</p><p><img src="169830613911830.png" alt="img"></p><p>目前有4个购物车，然结算下单，进入订单结算页面：</p><p><img src="169830613911931.png" alt="img"></p><p>然后将购物车中某个商品的库存修改为<code>0</code>：</p><p><img src="169830613911932.png" alt="img"></p><p>然后，提交订单，最终因库存不足导致下单失败：</p><p><img src="169830613911933.png" alt="img"></p><p>然后我们去查看购物车列表，发现购物车数据依然被清空了，并未回滚：</p><p><img src="169830613911934.png" alt="img"></p><p>事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了。</p><p>这就是分布式事务问题，出现以下情况之一就可能产生分布式事务问题：</p><ul><li>业务跨多个服务实现</li><li>业务跨多个数据源实现</li></ul><p>接下来这一章我们就一起来研究下如何解决分布式事务问题。</p><h2 id="2-1-认识Seata"><a href="#2-1-认识Seata" class="headerlink" title="2.1.认识Seata"></a>2.1.认识Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的Seata了。</p><p><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p><p>Seata也不例外，在Seata的事务管理中有三个重要的角色：</p><ul><li><strong>TC</strong> <strong>(Transaction Coordinator) - 事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>Seata的工作架构如图所示：</p><p><img src="169830613911935.png" alt="img"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h2 id="2-2-部署TC服务"><a href="#2-2-部署TC服务" class="headerlink" title="2.2.部署TC服务"></a>2.2.部署TC服务</h2><h3 id="2-2-1-准备数据库表"><a href="#2-2-1-准备数据库表" class="headerlink" title="2.2.1.准备数据库表"></a>2.2.1.准备数据库表</h3><p>Seata支持多种存储模式，但考虑到持久化的需要，我们一般选择基于数据库存储。执行课前资料提供的<code>《seata-tc.sql》</code>，导入数据库表：</p><p><img src="169830613911936.png" alt="img"></p><h3 id="2-2-2-准备配置文件"><a href="#2-2-2-准备配置文件" class="headerlink" title="2.2.2.准备配置文件"></a>2.2.2.准备配置文件</h3><p>课前资料准备了一个seata目录，其中包含了seata运行时所需要的配置文件：</p><p><img src="169830613912037.png" alt="img"></p><p>其中包含中文注释，大家可以自行阅读。</p><p>我们将整个seata文件夹拷贝到虚拟机的<code>/root</code>目录：</p><p><img src="169830613912038.png" alt="img"></p><h3 id="2-2-3-Docker部署"><a href="#2-2-3-Docker部署" class="headerlink" title="2.2.3.Docker部署"></a>2.2.3.Docker部署</h3><p>在虚拟机的<code>/root</code>目录执行下面的命令：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">docker run --name seata \-p 8099:8099 \-p 7099:7099 \-e SEATA_IP=192.168.150.101 \-v ./seata:/seata-server/resources \--privileged=true \--network hmall \-d \seataio/seata-server:1.5.2</code></pre><p>如果镜像下载困难，也可以把课前资料提供的镜像上传到虚拟机并加载：</p><p><img src="169830613912039.png" alt="img"></p><h2 id="2-3-微服务集成Seata"><a href="#2-3-微服务集成Seata" class="headerlink" title="2.3.微服务集成Seata"></a>2.3.微服务集成Seata</h2><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p><h3 id="2-3-1-引入依赖"><a href="#2-3-1-引入依赖" class="headerlink" title="2.3.1.引入依赖"></a>2.3.1.引入依赖</h3><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此<code>trade-service</code>模块不仅仅要引入seata依赖，还要引入nacos依赖:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;!--统一配置管理--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--读取bootstrap文件--&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--seata--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--sentinel--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><h3 id="2-3-2-改造配置"><a href="#2-3-2-改造配置" class="headerlink" title="2.3.2.改造配置"></a>2.3.2.改造配置</h3><p>首先在nacos上添加一个共享的seata配置（避免重复配置），命名为<code>shared-seata.yaml</code>：</p><p><img src="169830613912140.png" alt="img"></p><p>内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">seata:  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址    type: nacos # 注册中心类型 nacos    nacos:      server-addr: 192.168.150.101:8848 # nacos地址      namespace: "" # namespace，默认为空      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP      application: seata-server # seata服务名称      username: nacos      password: nacos  tx-service-group: hmall # 事务组名称  service:    vgroup-mapping: # 事务组与tc集群的映射关系      hmall: "default"</code></pre><p><img src="image-20231029121147697.png" alt="image-20231029121147697"></p><p>然后，改造<code>trade-service</code>模块，添加<code>bootstrap.yaml</code>：</p><p><img src="169830613912141.png" alt="img"></p><p>内容如下:</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  application:    name: trade-service # 服务名称  profiles:    active: dev  cloud:    nacos:      server-addr: 192.168.150.101 # nacos地址      config:        file-extension: yaml # 文件后缀名        shared-configs: # 共享配置          - dataId: shared-jdbc.yaml # 共享mybatis配置          - dataId: shared-log.yaml # 共享日志配置          - dataId: shared-swagger.yaml # 共享日志配置          - dataId: shared-seata.yaml # 共享seata配置</code></pre><p>可以看到这里加载了共享的seata配置。</p><p>然后改造application.yaml文件，内容如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 8085feign:  okhttp:    enabled: true # 开启OKHttp连接池支持  sentinel:    enabled: true # 开启Feign对Sentinel的整合hm:  swagger:    title: 交易服务接口文档    package: com.hmall.trade.controller  db:    database: hm-trade</code></pre><p>参考上述办法分别改造<code>hm-cart</code>和<code>hm-item</code>两个微服务模块。</p><h3 id="2-3-3-添加数据库表"><a href="#2-3-3-添加数据库表" class="headerlink" title="2.3.3.添加数据库表"></a>2.3.3.添加数据库表</h3><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。</p><p>将课前资料的seata-at.sql分别文件导入hm-trade、hm-cart、hm-item三个数据库中：</p><p><img src="169830613912142.png" alt="img"></p><p>结果：</p><p><img src="169830613912143.png" alt="img"></p><p>OK，至此为止，微服务整合的工作就完成了。可以参考上述方式对<code>hm-item</code>和<code>hm-cart</code>模块完成整合改造。</p><h3 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4.测试"></a>2.3.4.测试</h3><p>接下来就是测试的分布式事务的时候了。</p><p>我们找到<code>trade-service</code>模块下的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类中的<code>createOrder</code>方法，也就是下单业务方法。</p><p>将其上的<code>@Transactional</code>注解改为Seata提供的<code>@GlobalTransactional</code>：</p><p><img src="169830613912244.png" alt="img"></p><p><code>@GlobalTransactional</code>注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</p><p>我们重启<code>trade-service</code>、<code>item-service</code>、<code>cart-service</code>三个服务。再次测试，发现分布式事务的问题解决了！</p><p>那么，Seata是如何解决分布式事务的呢？</p><h2 id="2-4-XA模式"><a href="#2-4-XA模式" class="headerlink" title="2.4.XA模式"></a>2.4.XA模式</h2><p>Seata支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p>这里我们以<code>XA</code>模式和<code>AT</code>模式来给大家讲解其实现原理。</p><p><code>XA</code> 规范 是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h3 id="2-4-1-两阶段提交"><a href="#2-4-1-两阶段提交" class="headerlink" title="2.4.1.两阶段提交"></a>2.4.1.两阶段提交</h3><p>A是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>正常情况：</p><p><img src="169830613912245.png" alt="img"></p><p>异常情况：</p><p><img src="169830613912246.png" alt="img"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h3 id="2-4-2-Seata的XA模型"><a href="#2-4-2-Seata的XA模型" class="headerlink" title="2.4.2.Seata的XA模型"></a>2.4.2.Seata的XA模型</h3><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="169830613912447.png" alt="img"></p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h3 id="2-4-3-优缺点"><a href="#2-4-3-优缺点" class="headerlink" title="2.4.3.优缺点"></a>2.4.3.优缺点</h3><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h2 id="2-5-AT模式"><a href="#2-5-AT模式" class="headerlink" title="2.5.AT模式"></a>2.5.AT模式</h2><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><h3 id="2-5-1-Seata的AT模型"><a href="#2-5-1-Seata的AT模型" class="headerlink" title="2.5.1.Seata的AT模型"></a>2.5.1.Seata的AT模型</h3><p>基本流程图：</p><p><img src="169830613912448.png" alt="img"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h3 id="2-5-2-流程梳理"><a href="#2-5-2-流程梳理" class="headerlink" title="2.5.2.流程梳理"></a>2.5.2.流程梳理</h3><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th align="center"><strong>id</strong></th><th align="center"><strong>money</strong></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">update tb_account set money = money - 10 where id = 1</code></pre><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{  "id": 1, "money": 100}</code></pre><ol><li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90</li><li><code>RM</code>报告本地事务状态给<code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol><li>如果都成功，则立即删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><p>流程图：</p><p><img src="169830613912549.png" alt="img"></p><h3 id="2-5-3-AT与XA的区别"><a href="#2-5-3-AT与XA的区别" class="headerlink" title="2.5.3.AT与XA的区别"></a>2.5.3.AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。</p><h1 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h1><h2 id="3-1-编写降级逻辑"><a href="#3-1-编写降级逻辑" class="headerlink" title="3.1.编写降级逻辑"></a>3.1.编写降级逻辑</h2><p>给黑马商城中现有的FeignClient都编写对应的降级逻辑，并且改造项目中每一个微服务，将OpenFeign与Sentinel整合。</p><h2 id="3-2-解决分布式事务"><a href="#3-2-解决分布式事务" class="headerlink" title="3.2.解决分布式事务"></a>3.2.解决分布式事务</h2><p>除了下单业务以外，用户如果选择余额支付，前端会将请求发送到pay-service模块。而这个模块要做三件事情：</p><ul><li>直接从user-service模块调用接口，扣除余额付款</li><li>更新本地（pay-service）交易流水表状态</li><li>通知交易服务（trade-service）更新其中的业务订单状态</li></ul><p>流程如图：</p><p>暂时无法在飞书文档外展示此内容</p><p>显然，这里也存在分布式事务问题。</p><p>对应的页面如下：</p><p><img src="169830613912550.png" alt="img"></p><p>当我们提交订单成功后，进入支付页面，选择余额支付，输入密码后点击确认支付即可。</p><p>前端会提交支付请求，业务接口的入口在<code>com.hmall.pay.controller.PayController</code>类的<code>tryPayOrderByBalance</code>方法：</p><p><img src="169830613912551.png" alt="img"></p><p>对应的service方法如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Override@Transactionalpublic void tryPayOrderByBalance(PayOrderDTO payOrderDTO) {    // 1.查询支付单    PayOrder po = getById(payOrderDTO.getId());    // 2.判断状态    if(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus())){        // 订单不是未支付，状态异常        throw new BizIllegalException("交易已支付或关闭！");    }    // 3.尝试扣减余额    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());    // 4.修改支付单状态    boolean success = markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());    if (!success) {        throw new BizIllegalException("交易已支付或关闭！");    }    // 5.修改订单状态    tradeClient.markOrderPaySuccess(po.getBizOrderNo());}</code></pre><p>利用seata解决这里的分布式事务问题，并思考这个业务实现有没有什么值得改进的地方</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/10/04/Docker/"/>
      <url>/2023/10/04/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h1><p>要想让Docker帮我们安装和部署软件，肯定要保证你的机器上有Docker. 由于大家的操作系统各不相同，安装方式也不同。为了便于大家学习，我们统一在CentOS的虚拟机中安装Docker，统一学习环境。</p><h2 id="1-1-安装-docker"><a href="#1-1-安装-docker" class="headerlink" title="1.1 安装 docker"></a>1.1 安装 docker</h2><h3 id="1-卸载旧版"><a href="#1-卸载旧版" class="headerlink" title="1.卸载旧版"></a>1.卸载旧版</h3><p>首先如果系统中已经存在旧的Docker，则先卸载：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">yum remove docker \    docker-client \    docker-client-latest \    docker-common \    docker-latest \    docker-latest-logrotate \    docker-logrotate \    docker-engine</code></pre><h3 id="2-配置Docker的yum库"><a href="#2-配置Docker的yum库" class="headerlink" title="2.配置Docker的yum库"></a>2.配置Docker的yum库</h3><p>首先要安装一个yum工具</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum install -y yum-utils</code></pre><p>安装成功后，执行命令，配置Docker的yum源：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><h3 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3.安装Docker"></a>3.安装Docker</h3><p>最后，执行命令，安装Docker</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><h3 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4.启动和校验"></a>4.启动和校验</h3><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 启动Dockersystemctl start docker# 停止Dockersystemctl stop docker# 重启systemctl restart docker# 设置开机自启systemctl enable docker# 执行docker ps命令，如果不报错，说明安装启动成功docker ps</code></pre><h3 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5.配置镜像加速"></a>5.配置镜像加速</h3><p>这里以阿里云镜像加速为例。</p><h4 id="5-1-注册阿里云账号"><a href="#5-1-注册阿里云账号" class="headerlink" title="5.1.注册阿里云账号"></a>5.1.注册阿里云账号</h4><p>首先访问阿里云网站:</p><p><a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p><p>注册一个账号。</p><h4 id="5-2-开通镜像服务"><a href="#5-2-开通镜像服务" class="headerlink" title="5.2.开通镜像服务"></a>5.2.开通镜像服务</h4><p>在首页的产品中，找到阿里云的<strong>容器镜像服务</strong>：</p><p><img src="16978611179974.png" alt="img"></p><p>点击后进入控制台：</p><p><img src="16978611179901.png" alt="img"></p><p>首次可能需要选择立刻开通，然后进入控制台。</p><h4 id="5-3-配置镜像加速"><a href="#5-3-配置镜像加速" class="headerlink" title="5.3.配置镜像加速"></a>5.3.配置镜像加速</h4><p>找到<strong>镜像工具</strong>下的<strong>镜像****加速器</strong>：</p><p><img src="16978611179912.png" alt="img"></p><p>页面向下滚动，即可找到配置的文档说明：</p><p><img src="16978611179913.png" alt="img"></p><p>具体命令如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 创建目录mkdir -p /etc/docker# 复制内容，注意把其中的镜像加速地址改成你自己的tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://xxxx.mirror.aliyuncs.com"]}EOF# 重新加载配置systemctl daemon-reload# 重启Dockersystemctl restart docker</code></pre><h2 id="1-2-部署MySQL"><a href="#1-2-部署MySQL" class="headerlink" title="1.2 部署MySQL"></a>1.2 部署MySQL</h2><p>首先，我们利用Docker来安装一个MySQL软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用CV大法）：</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  mysql</code></pre><p>运行效果如图：</p><p><img src="169786244539613.png" alt="img"></p><p>MySQL安装完毕！通过任意客户端工具即可连接到MySQL.</p><p>大家可以发现，当我们执行命令后，Docker做的第一件事情，是去自动搜索并下载了MySQL，然后会自动运行MySQL，我们完全不用插手，是不是非常方便。</p><p>而且，这种安装方式你完全不用考虑运行的操作系统环境，它不仅仅在CentOS系统是这样，在Ubuntu系统、macOS系统、甚至是装了WSL的Windows下，都可以使用这条命令来安装MySQL。</p><p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p><p>而使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL。注意：这里下载的不是安装包，而是<strong>镜像（image）。</strong>镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器（container）</strong>。</p><blockquote><p>因此，Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程。</p></blockquote><p>Docker会根据命令中的镜像名称自动搜索并下载镜像。Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p>像这种提供存储、管理Docker镜像的服务器，被称为DockerRegistry，可以翻译为镜像仓库。DockerHub网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库。</p><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。而企业内部的机密项目，往往会采用私有镜像仓库。</p><p>总之，镜像的来源有两种：</p><ul><li>基于官方基础镜像自己制作</li><li>直接去DockerRegistry下载</li></ul><p><strong>总结一下</strong>：</p><p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p>用一幅图表示如下：</p><p><img src="image-20231021123112214.png" alt="image-20231021123112214"></p><h2 id="1-3-命令解读"><a href="#1-3-命令解读" class="headerlink" title="1.3 命令解读"></a>1.3 命令解读</h2><p>利用Docker快速的安装了MySQL，非常的方便，不过我们执行的命令到底是什么意思呢？</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  mysql</code></pre><blockquote><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数（环境变量）<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul></blockquote><p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p><p>如果我们要安装其它软件，也可以到DockerRegistry中寻找对应的镜像名称和版本，阅读相关配置即可。</p><h1 id="2-Docker基础"><a href="#2-Docker基础" class="headerlink" title="2.Docker基础"></a>2.Docker基础</h1><p>接下来，我们一起来学习Docker使用的一些基础知识，为将来部署项目打下基础。具体用法可以参考Docker官方文档：</p><p><a href="https://docs.docker.com/">https://docs.docker.com/</a></p><h2 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1.常见命令"></a>2.1.常见命令</h2><p>首先我们来学习Docker中的常见命令，可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/cli/">https://docs.docker.com/engine/reference/commandline/cli/</a></p><h3 id="2-1-1-命令介绍"><a href="#2-1-1-命令介绍" class="headerlink" title="2.1.1.命令介绍"></a>2.1.1.命令介绍</h3><p>其中，比较常见的命令有：</p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker pull</td><td align="center">拉取镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="center">docker push</td><td align="center">推送镜像到DockerRegistry</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="center">docker images</td><td align="center">查看本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="center">docker rmi</td><td align="center">删除本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="center">docker run</td><td align="center">创建并运行容器（不能重复创建）</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="center">docker stop</td><td align="center">停止指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="center">docker start</td><td align="center">启动指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="center">docker restart</td><td align="center">重新启动容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="center">docker rm</td><td align="center">删除指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="center">docker ps [-a]</td><td align="center">查看容器 [所有]</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="center">docker logs</td><td align="center">查看容器运行日志</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="center">docker exec</td><td align="center">进入容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="center">docker save</td><td align="center">保存镜像到本地压缩文件</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="center">docker load</td><td align="center">加载本地压缩文件到镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="center">docker inspect</td><td align="center">查看容器详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一副图来表示这些命令的关系：</p><p><img src="image-20231021135820503.png" alt="image-20231021135820503"></p><p>补充：</p><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># Docker开机自启systemctl enable docker# Docker容器开机自启docker update --restart=always [容器名/容器id]</code></pre><h3 id="2-1-2-演示"><a href="#2-1-2-演示" class="headerlink" title="2.1.2.演示"></a>2.1.2.演示</h3><p>教学环节说明：我们以Nginx为例给大家演示上述命令。</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># 第1步，去DockerHub查看nginx镜像仓库及相关信息# 第2步，拉取Nginx镜像docker pull nginx# 第3步，查看镜像docker images# 结果如下：REPOSITORY   TAG       IMAGE ID       CREATED         SIZEnginx        latest    605c77e624dd   16 months ago   141MBmysql        latest    3218b38490ce   17 months ago   516MB# 第4步，创建并允许Nginx容器docker run -d --name nginx -p 80:80 nginx# 第5步，查看运行中容器docker ps# 也可以加格式化方式访问，格式会更加清爽docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"# 第6步，访问网页，地址：http://虚拟机地址# 第7步，停止容器docker stop nginx# 第8步，查看所有容器docker ps -a --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"# 第9步，再次启动nginx容器docker start nginx# 第10步，再次查看容器docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"# 第11步，查看容器详细信息docker inspect nginx# 第12步，进入容器,查看容器内目录docker exec -it nginx bash# 或者，可以进入MySQLdocker exec -it mysql mysql -uroot -p# 第13步，删除容器docker rm nginx# 发现无法删除，因为容器运行中，强制删除容器docker rm -f nginx</code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">docker save -o nginx.tar nginx:latestdocker load -i nginx.tar</code></pre><h3 id="2-1-3-命令别名"><a href="#2-1-3-命令别名" class="headerlink" title="2.1.3.命令别名"></a>2.1.3.命令别名</h3><p>给常用Docker命令起别名，方便我们访问：</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># 修改/root/.bashrc文件vi /root/.bashrc内容如下：# .bashrc# User specific aliases and functionsalias rm='rm -i'alias cp='cp -i'alias mv='mv -i'alias dps='docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"'alias dis='docker images'# Source global definitionsif [ -f /etc/bashrc ]; then        . /etc/bashrcfi</code></pre><p>然后，执行命令使别名生效</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">source /root/.bashrc</code></pre><p>接下来，试试看新的命令吧。</p><h2 id="2-2-数据卷"><a href="#2-2-数据卷" class="headerlink" title="2.2.数据卷"></a>2.2.数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便（未安装vim命令的依赖包）。大家思考几个问题：</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><h3 id="2-2-1-什么是数据卷"><a href="#2-2-1-什么是数据卷" class="headerlink" title="2.2.1.什么是数据卷"></a>2.2.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁。</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p><img src="image-20231021161129440.png" alt="image-20231021161129440"></p><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><p><strong>小提示</strong>：</p><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p><p><strong>为什么不让容器目录直接指向<strong><strong>宿主机</strong></strong>目录呢</strong>？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li></ul><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与<strong><strong>宿主机</strong></strong>目录挂载而不使用数据卷</strong>，具体参考2.2.3小节。</p><h3 id="2-2-2-数据卷命令"><a href="#2-2-2-数据卷命令" class="headerlink" title="2.2.2.数据卷命令"></a>2.2.2.数据卷命令</h3><p>数据卷的相关命令有：</p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker volume create</td><td align="center">创建数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="center">docker volume ls</td><td align="center">查看所有数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker volume rm</td><td align="center">删除指定数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker volume inspect</td><td align="center">查看某个数据卷的详情</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="center">docker volume prune</td><td align="center">清除数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>教学<strong>演示环节</strong>：演示一下nginx的html目录挂载</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx# 2.然后查看数据卷docker volume ls# 结果DRIVER    VOLUME NAMElocal     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459flocal     html# 3.查看数据卷详情docker volume inspect html# 结果[    {        "CreatedAt": "2024-05-17T19:57:08+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/html/_data",        "Name": "html",        "Options": null,        "Scope": "local"    }]# 4.查看/var/lib/docker/volumes/html/_data目录ll /var/lib/docker/volumes/html/_data# 可以看到与nginx的html目录内容一样，结果如下：总用量 8-rw-r--r--. 1 root root 497 12月 28 2021 50x.html-rw-r--r--. 1 root root 615 12月 28 2021 index.html# 5.进入该目录，并随意修改index.html内容cd /var/lib/docker/volumes/html/_datavi index.html# 6.打开页面，查看效果# 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化docker exec -it nginx bash</code></pre><p>教学<strong>演示环节</strong>：演示一下MySQL的匿名数据卷</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell"># 1.查看MySQL容器详细信息docker inspect mysql# 关注其中.Config.Volumes部分和.Mounts部分</code></pre><p>我们关注两部分内容，第一是<code>.Config.Volumes</code>部分：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{  "Config": {    // ... 略    "Volumes": {      "/var/lib/mysql": {}    }    // ... 略  }}</code></pre><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p><p>然后，我们再看结果中的<code>.Mounts</code>部分：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{  "Mounts": [    {      "Type": "volume",      "Name": "29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f",      "Source": "/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data",      "Destination": "/var/lib/mysql",      "Driver": "local",    }  ]}</code></pre><p>可以发现，其中有几个关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><p>接下来，可以查看该目录下的MySQL的data文件：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">ls -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code></pre><p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考DockerHub对应的页面</p><h3 id="2-2-3-挂载本地目录或文件"><a href="#2-2-3-挂载本地目录或文件" class="headerlink" title="2.2.3.挂载本地目录或文件"></a>2.2.3.挂载本地目录或文件</h3><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 挂载本地目录-v 本地目录:容器内目录# 挂载本地文件-v 本地文件:容器内文件</code></pre><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">-v mysql:/var/lib/mysql # 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷-v ./mysql:/var/lib/mysql # 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</code></pre><p><strong>教学演示</strong>，删除并重新创建mysql容器，并完成本地目录挂载：</p><ul><li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li><li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li><li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li></ul><p>在课前资料中已经准备好了mysql的<code>init</code>目录和<code>conf</code>目录：</p><p><img src="16978758606898.png" alt="img"></p><p>以及对应的初始化SQL脚本和配置文件：</p><p><img src="16978758606751.png" alt="img"></p><p><img src="16978758606762.png" alt="img"></p><p>其中，hm.cnf主要是配置了MySQL的默认编码，改为utf8mb4；而hmall.sql则是后面我们要用到的黑马商城项目的初始化SQL脚本。</p><p>我们直接将整个mysql目录上传至虚拟机的<code>/root</code>目录下：</p><p><img src="16978758606763.png" alt="img"></p><p>接下来，我们演示本地目录挂载：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.删除原来的MySQL容器docker rm -f mysql# 2.进入root目录cd ~# 3.创建并运行新mysql容器，挂载本地目录docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \  mysql# 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了ls -l mysql# 结果：总用量 4drwxr-xr-x. 2 root    root   20 5月  19 15:11 confdrwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 datadrwxr-xr-x. 2 root    root   23 5月  19 15:11 init# 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化ls -l data# 5.查看MySQL容器内数据# 5.1.进入MySQLdocker exec -it mysql mysql -uroot -p123# 5.2.查看编码表show variables like "%char%";# 5.3.结果，发现编码是utf8mb4没有问题+--------------------------+--------------------------------+| Variable_name            | Value                          |+--------------------------+--------------------------------+| character_set_client     | utf8mb4                        || character_set_connection | utf8mb4                        || character_set_database   | utf8mb4                        || character_set_filesystem | binary                         || character_set_results    | utf8mb4                        || character_set_server     | utf8mb4                        || character_set_system     | utf8mb3                        || character_sets_dir       | /usr/share/mysql-8.0/charsets/ |+--------------------------+--------------------------------+# 6.查看数据# 6.1.查看数据库show databases;# 结果，hmall是黑马商城数据库+--------------------+| Database           |+--------------------+| hmall              || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)# 6.2.切换到hmall数据库use hmall;# 6.3.查看表show tables;# 结果：+-----------------+| Tables_in_hmall |+-----------------+| address         || cart            || item            || order           || order_detail    || order_logistics || pay_order       || user            |+-----------------+# 6.4.查看address表数据+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| id | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  || 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  || 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  || 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+4 rows in set (0.00 sec)</code></pre><h2 id="2-3-镜像"><a href="#2-3-镜像" class="headerlink" title="2.3.镜像"></a>2.3.镜像</h2><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p><h3 id="2-3-1-镜像结构"><a href="#2-3-1-镜像结构" class="headerlink" title="2.3.1.镜像结构"></a>2.3.1.镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p><p><img src="16978758606764.png" alt="img"></p><h3 id="2-3-2-Dockerfile"><a href="#2-3-2-Dockerfile" class="headerlink" title="2.3.2.Dockerfile"></a>2.3.2.Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了<strong>自动打包镜像</strong>的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="center"><strong>指令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center"><strong>FROM</strong></td><td align="center">指定基础镜像</td><td align="center"><code>FROM centos:6</code></td></tr><tr><td align="center"><strong>ENV</strong></td><td align="center">设置环境变量，可在后面指令使用</td><td align="center"><code>ENV key value</code></td></tr><tr><td align="center"><strong>COPY</strong></td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="center"><strong>RUN</strong></td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center"><code>RUN yum install gcc</code></td></tr><tr><td align="center"><strong>EXPOSE</strong></td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center"><strong>ENTRYPOINT</strong></td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><pre class="line-numbers language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile"># 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录、容器内时区ENV JAVA_DIR=/usr/localENV TZ=Asia/Shanghai# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 设定时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 安装JDKRUN cd $JAVA_DIR \ &amp;&amp; tar -xf ./jdk8.tar.gz \ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 指定项目监听的端口EXPOSE 8080# 入口，java项目的启动命令ENTRYPOINT ["java", "-jar", "/app.jar"]</code></pre><p>同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><pre class="line-numbers language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile"># 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 拷贝jar包COPY docker-demo.jar /app.jar# 入口ENTRYPOINT ["java", "-jar", "/app.jar"]</code></pre><p>是不是简单多了。</p><h3 id="2-3-3-构建镜像"><a href="#2-3-3-构建镜像" class="headerlink" title="2.3.3.构建镜像"></a>2.3.3.构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>在课前资料中，我们准备好了一个demo项目及对应的Dockerfile：</p><p><img src="16978758606775.png" alt="img"></p><p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="16978758606776.png" alt="img"></p><p>然后，执行命令，构建镜像：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 进入镜像目录cd /root/demo# 开始构建docker build -t docker-demo:1.0 .</code></pre><p>命令说明：</p><ul><li><p><code>docker build </code>: 就是构建一个docker镜像</p></li><li><p><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</p></li><li><p><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p><ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<pre class="line-numbers language-none"><code class="language-none">结果：![img](Docker/16978758606777.png)查看镜像列表：```Bash# 查看镜像列表：docker images# 结果REPOSITORY    TAG       IMAGE ID       CREATED          SIZEdocker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MBnginx         latest    605c77e624dd   16 months ago    141MBmysql         latest    3218b38490ce   17 months ago    516MB</code></pre></code></pre></li></ul></li></ul><p>然后尝试运行该镜像：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.创建并运行容器docker run -d --name dd -p 8090:8090 docker-demo:1.0# 2.查看容器dps# 结果CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   ddf63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql# 3.访问curl localhost:8080/hello/count# 结果：&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;</code></pre><h2 id="2-4-网络"><a href="#2-4-网络" class="headerlink" title="2.4.网络"></a>2.4.网络</h2><p>上节课我们创建了一个Java项目的容器，而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p><p><img src="image-20231021171259646.png" alt="image-20231021171259646"></p><p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.用基本命令，寻找Networks.bridge.IPAddress属性docker inspect mysql# 也可以使用format过滤结果docker inspect --format='{{range .NetworkSettings.Networks}}{{println .IPAddress}}{{end}}' mysql# 得到部分IP信息如下："Networks": {                "bridge": {                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "33787636152bc86a6695dac109d440f48923ffc018aa9bcbee77aa12c39136e5",                    "EndpointID": "2e63b7003705e11acd9435f8b5364fc1fe666c999d110252430cab767bbea66f",                    "Gateway": "172.17.0.1", #默认网关                    "IPAddress": "172.17.0.2", #IP地址                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:11:00:02",                    "DriverOpts": null                }            }# 2.然后通过命令进入dd容器docker exec -it dd bash# 3.在容器内，通过ping命令测试网络ping 172.17.0.2# 结果PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</code></pre><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker network create</td><td align="center">创建一个网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="center">docker network ls</td><td align="center">查看所有网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker network rm</td><td align="center">删除指定网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="center">docker network prune</td><td align="center">清除未使用的网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker network connect</td><td align="center">使指定容器连接加入某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="center">docker network disconnect</td><td align="center">使指定容器连接离开某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="center">docker network inspect</td><td align="center">查看网络详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.首先通过命令创建一个网络docker network create hmall# 2.然后查看网络docker network ls# 结果：NETWORK ID     NAME      DRIVER    SCOPE639bc44d0a87   bridge    bridge    local403f16ec62a2   hmall     bridge    local0dc0f72a0fbb   host      host      localcd8d3e8df47b   none      null      local# 其中，除了hmall以外，其它都是默认的网络# 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名# 这样该网络内的其它容器可以用别名互相访问！# 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名docker network connect hmall mysql --alias db# 3.2.dd容器，也就是我们的java项目docker network connect hmall dd# 4.进入dd容器，尝试利用别名访问db# 4.1.进入容器docker exec -it dd bash# 4.2.用db别名访问ping db# 结果PING db (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms# 4.3.用容器名访问ping mysql# 结果：PING mysql (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</code></pre><p>OK，现在无需记住IP地址也可以实现容器互联（==使用容器名或别名==）了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><h1 id="3-项目部署"><a href="#3-项目部署" class="headerlink" title="3.项目部署"></a>3.项目部署</h1><p>好了，我们已经熟悉了Docker的基本用法，接下来可以尝试部署项目了。</p><p>在课前资料中已经提供了一个黑马商城项目给大家，如图：</p><p>项目说明：</p><ul><li>hmall：商城的后端代码</li><li>hmall-portal：商城用户端的前端代码</li><li>hmall-admin：商城管理端的前端代码</li></ul><p>部署的容器及端口说明：</p><table><thead><tr><th align="center"><strong>项目</strong></th><th align="center"><strong>容器名</strong></th><th align="center"><strong>端口</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">hmall</td><td align="center">hmall</td><td align="center">8080</td><td align="center">黑马商城后端API入口</td></tr><tr><td align="center">hmall-portal</td><td align="center">nginx</td><td align="center">18080</td><td align="center">黑马商城用户端入口</td></tr><tr><td align="center">hmall-admin</td><td align="center">18081</td><td align="center">黑马商城管理端入口</td><td align="center"></td></tr><tr><td align="center">mysql</td><td align="center">mysql</td><td align="center">3306</td><td align="center">数据库</td></tr></tbody></table><p>在正式部署前，我们先删除之前的nginx、dd两个容器：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker rm -f nginx dd</code></pre><p>mysql容器中已经准备好了商城的数据，所以就不再删除了。</p><h2 id="3-1-部署Java项目"><a href="#3-1-部署Java项目" class="headerlink" title="3.1.部署Java项目"></a>3.1.部署Java项目</h2><p><code>hmall</code>项目是一个maven聚合项目，使用IDEA打开<code>hmall</code>项目，查看项目结构如图：</p><p><img src="169788039304925.png" alt="img"></p><p>我们要部署的就是其中的<code>hm-service</code>，其中的配置文件采用了多环境的方式：</p><p><img src="169788039305126.png" alt="img"></p><p>其中的<code>application-dev.yaml</code>是部署到开发环境的配置，<code>application-local.yaml</code>是本地运行时的配置。</p><p>查看application.yaml，你会发现其中的JDBC地址并未写死，而是读取变量：</p><p><img src="169788039305127.png" alt="img"></p><p>这两个变量在<code>application-dev.yaml</code>和<code>application-local.yaml</code>中并不相同：</p><p><img src="169788039305128.png" alt="img"></p><p>在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问。</p><p>我们将项目打包：</p><p><img src="169788039305129.png" alt="img"></p><p>结果：</p><p><img src="169788039305230.png" alt="img"></p><p>将<code>hm-service</code>目录下的<code>Dockerfile</code>和<code>hm-service/target</code>目录下的<code>hm-service.jar</code>一起上传到虚拟机的<code>root</code>目录：</p><p><img src="169788039305231.png" alt="img"></p><p>部署项目：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.构建项目镜像，不指定tag，则默认为latestdocker build -t hmall .# 2.查看镜像docker images# 结果REPOSITORY    TAG       IMAGE ID       CREATED          SIZEhmall         latest    0bb07b2c34b9   43 seconds ago   362MBdocker-demo   1.0       49743484da68   24 hours ago     327MBnginx         latest    605c77e624dd   16 months ago    141MBmysql         latest    3218b38490ce   17 months ago    516MB# 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysqldocker run -d --name hmall --network hmall -p 8080:8080 hmall</code></pre><p>测试，通过浏览器访问：http://你的虚拟机地址:8080/search/list</p><h2 id="3-2-部署前端"><a href="#3-2-部署前端" class="headerlink" title="3.2.部署前端"></a>3.2.部署前端</h2><p><code>hmall-portal</code>和<code>hmall-admin</code>是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录：</p><p><img src="169788039305332.png" alt="img"></p><p>其中：</p><ul><li><code>html</code>是静态资源目录，我们需要把<code>hmall-portal</code>以及<code>hmall-admin</code>都复制进去</li><li><code>nginx.conf</code>是nginx的配置文件，主要是完成对<code>html</code>下的两个静态资源目录做代理</li></ul><p>我们现在要做的就是把整个nginx目录上传到虚拟机的<code>/root</code>目录下：</p><p><img src="169788039305333.png" alt="img"></p><p>然后创建nginx容器并完成两个挂载：</p><ul><li>把<code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li><li>把<code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li></ul><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口：</p><ul><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ul><p>命令如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker run -d \  --name nginx \  -p 18080:18080 \  -p 18081:18081 \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \  --network hmall \  nginx</code></pre><p>测试，通过浏览器访问：http://你的虚拟机ip:18080</p><p><img src="169788039305334.png" alt="img"></p><h2 id="3-3-DockerCompose"><a href="#3-3-DockerCompose" class="headerlink" title="3.3.DockerCompose"></a>3.3.DockerCompose</h2><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><p><img src="image-20231021180703285.png" alt="image-20231021180703285"></p><h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker run -d \  --name mysql \  -p 3306:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=123 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \  --network hmall  mysql</code></pre><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">version: "3.8"services:  mysql:    image: mysql    container_name: mysql    ports:      - "3306:3306"    environment:      TZ: Asia/Shanghai      MYSQL_ROOT_PASSWORD: 123    volumes:      - "./mysql/conf:/etc/mysql/conf.d"      - "./mysql/data:/var/lib/mysql"    networks:      - newnetworks:  new:    name: hmall</code></pre><p>对比如下：</p><table><thead><tr><th align="center"><strong>docker run 参数</strong></th><th align="center"><strong>docker compose 指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">–name</td><td align="center">container_name</td><td align="center">容器名称</td></tr><tr><td align="center">-p</td><td align="center">ports</td><td align="center">端口映射</td></tr><tr><td align="center">-e</td><td align="center">environment</td><td align="center">环境变量</td></tr><tr><td align="center">-v</td><td align="center">volumes</td><td align="center">数据卷配置</td></tr><tr><td align="center">–network</td><td align="center">networks</td><td align="center">网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p><p>黑马商城部署文件：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">version: "3.8"services:  mysql:    image: mysql    container_name: mysql    ports:      - "3306:3306"    environment:      TZ: Asia/Shanghai      MYSQL_ROOT_PASSWORD: 123    volumes:      - "./mysql/conf:/etc/mysql/conf.d"      - "./mysql/data:/var/lib/mysql"      - "./mysql/init:/docker-entrypoint-initdb.d"    networks:      - hm-net  hmall:    build:       context: .      dockerfile: Dockerfile    container_name: hmall    ports:      - "8080:8080"    networks:      - hm-net    depends_on: #表明hmall依赖mysql，创建时会先创建mysql后创建hmall      - mysql  nginx:    image: nginx    container_name: nginx    ports:      - "18080:18080"      - "18081:18081"    volumes:      - "./nginx/nginx.conf:/etc/nginx/nginx.conf"      - "./nginx/html:/usr/share/nginx/html"    depends_on:      - hmall    networks:      - hm-netnetworks:  hm-net:    name: hmall #此时会自动创建网络</code></pre><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker compose [OPTIONS] [COMMAND]</code></pre><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>参数或指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Options</td><td align="center">-f</td><td align="center">指定compose文件的路径和名称</td></tr><tr><td align="center">-p</td><td align="center">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="center"></td></tr><tr><td align="center">Commands</td><td align="center">up</td><td align="center">创建并启动所有service容器</td></tr><tr><td align="center">down</td><td align="center">停止并移除所有容器、网络</td><td align="center"></td></tr><tr><td align="center">ps</td><td align="center">列出所有启动的容器</td><td align="center"></td></tr><tr><td align="center">logs</td><td align="center">查看指定容器的日志</td><td align="center"></td></tr><tr><td align="center">stop</td><td align="center">停止容器</td><td align="center"></td></tr><tr><td align="center">start</td><td align="center">启动容器</td><td align="center"></td></tr><tr><td align="center">restart</td><td align="center">重启容器</td><td align="center"></td></tr><tr><td align="center">top</td><td align="center">查看运行的进程</td><td align="center"></td></tr><tr><td align="center">exec</td><td align="center">在指定的运行中容器中执行命令</td><td align="center"></td></tr></tbody></table><p>教学演示：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 1.进入root目录cd /root# 2.删除旧容器docker rm -f $(docker ps -qa)# 3.删除hmall镜像docker rmi hmall# 4.清空MySQL数据rm -rf mysql/data# 5.启动所有, -d 参数是后台启动docker compose up -d# 结果：[+] Building 15.5s (8/8) FINISHED =&gt; [internal] load build definition from Dockerfile                                    0.0s =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s =&gt; [internal] load .dockerignore                                                       0.0s =&gt; =&gt; transferring context: 2B                                                         0.0s =&gt; [internal] load metadata for docker.io/library/openjdk:11.0-jre-buster             15.4s =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s =&gt; [internal] load build context                                                       0.0s =&gt; =&gt; transferring context: 98B                                                        0.0s =&gt; CACHED [2/3] RUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo   0.0s =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s =&gt; exporting to image                                                                  0.0s =&gt; =&gt; exporting layers                                                                 0.0s =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s[+] Running 4/4 ✔ Network hmall    Created                                                             0.2s ✔ Container mysql  Started                                                             0.5s ✔ Container hmall  Started                                                             0.9s ✔ Container nginx  Started                                                             1.5s# 6.查看镜像docker compose images# 结果CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZEhmall               root-hmall          latest              32eebee16acd        362MBmysql               mysql               latest              3218b38490ce        516MBnginx               nginx               latest              605c77e624dd        141MB# 7.查看容器docker compose ps# 结果NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTShmall               root-hmall          "java -jar /app.jar"     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcpmysql               mysql               "docker-entrypoint.s…"   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcpnginx               nginx               "/docker-entrypoint.…"   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</code></pre><p>打开浏览器，访问：<a href="http://yourip:8080/">http://yourIp:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Linux系统git clone失败或超时问题</title>
      <link href="/2023/09/21/%E8%A7%A3%E5%86%B3Linux%E7%B3%BB%E7%BB%9Fgit-clone%E5%A4%B1%E8%B4%A5%E6%88%96%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/21/%E8%A7%A3%E5%86%B3Linux%E7%B3%BB%E7%BB%9Fgit-clone%E5%A4%B1%E8%B4%A5%E6%88%96%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p> 使用git clone常常不成功，以下是解决办法，亲测有效</p><p>\1. 修改hosts</p><p>首先使用 sudo vim /etc/hosts 进入hosts，此时是查看模式</p><p>按下 i 进入编辑模式，此时需要插入两个IP地址</p><p>使用 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 查找两个地址：</p><pre class="line-numbers language-none"><code class="language-none">github.comgithub.global.ssl.fastly.net</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后将地址和名字粘贴进hosts文件中：</p><pre class="line-numbers language-none"><code class="language-none">140.82.11.4 github.com151.101.193.194 github.global.ssl.fastly.net </code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> \2. 重启网络和服务器</p><pre class="line-numbers language-none"><code class="language-none"># 重启网络sudo /etc/init.d/network-manager restart# 重启机器sudo reboot</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>完成啦~ </p><p><img src="f9e3529e94c44a71b5dfb787afe30f0b.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>]]></content>
      
      
      <categories>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Tomcat并部署项目</title>
      <link href="/2023/09/17/Linux%E5%AE%89%E8%A3%85Tomcat%E5%B9%B6%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/09/17/Linux%E5%AE%89%E8%A3%85Tomcat%E5%B9%B6%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>关于安装这里就不过多介绍了，安装版本是<code>CentOS 7</code>，选择<code>最小安装</code>即可</p><h3 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h3><p>由于启动服务器的时候未加载网卡，所以这里我们要手动修改一下配置文件</p><ul><li>进入到对应的目录</li></ul><pre class="line-numbers language-none"><code class="language-none">BASHcd /etc/sysconfig/network-scripts</code></pre><ul><li>编辑<code>ifcfg-ens33</code>文件</li></ul><pre class="line-numbers language-none"><code class="language-none">BASHvi ifcfg-ens33</code></pre><ul><li>输入<code>i</code>进入编辑</li><li>修改<code>ONBOOT=yes</code></li><li>按ESC</li><li>输入<code>:wq</code>保存并退出</li><li>输入<code>ip addr</code>，查看到类似下图的ip地址即可<br><a href="https://pic1.imgdb.cn/item/634a19f016f2c2beb1a8a501.jpg"><img src="634a19f016f2c2beb1a8a501.jpg" alt="img"></a></li></ul><h3 id="安装SSH连接工具"><a href="#安装SSH连接工具" class="headerlink" title="安装SSH连接工具"></a>安装SSH连接工具</h3><ul><li>为啥要安装这个呢？<ul><li>因为实际工作的时候，Linux操作系统都是安装在物理机上，而不是像我们现在使用的虚拟机</li><li>所以我们需要SSH连接工具，远程连接到物理机上</li></ul></li><li>这里安装的是<code>FinalShell</code>，具体的安装与连接操作，这里就不过多叙述了</li><li>成功连接之后的效果如图<br><a href="https://pic1.imgdb.cn/item/634a1b3516f2c2beb1aa6c8b.jpg"><img src="634a1b3516f2c2beb1aa6c8b.jpg" alt="img"></a></li></ul><h3 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h3><p><a href="https://pic1.imgdb.cn/item/634a234916f2c2beb1b6f85c.jpg"><img src="634a234916f2c2beb1b6f85c.jpg" alt="img"></a></p><table><thead><tr><th align="center">目录</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">/bin</td><td align="center">存放二进制可执行文件</td></tr><tr><td align="center">/boot</td><td align="center">存放系统引导时使用的各种文件</td></tr><tr><td align="center">/dev</td><td align="center">存放设备文件</td></tr><tr><td align="center">/etc</td><td align="center">存放系统配置文件</td></tr><tr><td align="center">/home</td><td align="center">存放系统用户的文件</td></tr><tr><td align="center">/lib</td><td align="center">存放程序运行所需的共享库和内核模块</td></tr><tr><td align="center">/opt</td><td align="center">额外安装的可选应用程序包所放置的位置</td></tr><tr><td align="center">/root</td><td align="center">超级用户目录</td></tr><tr><td align="center">/sbin</td><td align="center">存放二进制可执行文件，只有root用户才能访问</td></tr><tr><td align="center">/tmp</td><td align="center">存放临时文件</td></tr><tr><td align="center">/usr</td><td align="center">存放系统应用程序</td></tr><tr><td align="center">/var</td><td align="center">存放运行时需要改变数据的文件，例如日志文件</td></tr></tbody></table><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="Linux命令常用技巧"><a href="#Linux命令常用技巧" class="headerlink" title="Linux命令常用技巧"></a>Linux命令常用技巧</h3><ul><li>Tab键自动补全</li><li>连续按两次Tab键，给出操作提示</li><li>使用上下箭头快速调出曾经使用过的命令</li><li>使用Clear命令或者快捷键Ctrl+L实现清屏</li></ul><h3 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h3><ul><li>Linux命令格式如下</li></ul><pre class="line-numbers language-none"><code class="language-none">BASHcommand [-options] [parameter]</code></pre><p>说明：</p><ul><li><code>command</code>：命令名</li><li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li><li><code>[parameter]</code>：传给命令的参数，可以是0个，1个或多个</li></ul><p>注意：</p><ul><li><code>[]</code>代表可选命令名</li><li>选项，参数之间需要用空格进行分隔</li></ul><h3 id="文件目录操作命令"><a href="#文件目录操作命令" class="headerlink" title="文件目录操作命令"></a>文件目录操作命令</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><ul><li>作用：显示指定目录下的内容</li><li>语法：<code>ls [-al] [dir]</code></li></ul><p>说明：</p><ul><li><code>-a</code>：显示所有文件及目录（以<code>.</code>开头的隐藏文件也会列出）</li><li><code>-l</code>：除文件名外，还会讲文件的形态、权限、拥有者、文件大小等详细信息列出</li></ul><p>注意：由于我们使用<code>ls</code>命令时，经常会加上<code>-l</code>选项，所以Linux很人性化的为我们提供了<code>ll</code>命令来作为<code>ls -l</code>命令的简写，使用<code>ll -a</code>也可以替代<code>ls -al</code></p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><ul><li>作用：用户切换当前工作目录，即进入指定目录</li><li>语法<code>cd [dirName]</code></li></ul><p>说明：</p><ul><li><code>~</code>表示用户的home目录</li><li><code>.</code>表示当前所在的目录</li><li><code>..</code>表示当前位置的上级目录</li></ul><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><ul><li>作用：用于显示文件内容</li><li>语法：<code>cat [-n] fileName</code></li></ul><p>说明：</p><ul><li><code>-n</code>：由1开始对所有输出的行数编号</li></ul><p>举例：</p><ul><li><pre><code>cat /etc/profile<pre class="line-numbers language-none"><code class="language-none">  - 查看`/etc`目录下的`profile`文件内容- ```  cat -n /etc/profile</code></pre>- 查看`/etc`目录下的`profile`文件内容，显示行号</code></pre></li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li>作用：以分页的形式显示文件内容</li><li>语法：<code>more fileName</code></li></ul><p>说明：</p><ul><li>回车键：向下滚动一行</li><li>空格键：向下滚动一屏</li><li>b：返回上一屏</li><li>q或者Ctrl+C：退出more</li></ul><p>举例：</p><ul><li><pre><code>more /etc/profile<pre class="line-numbers language-none"><code class="language-none">  - 以分页方式显示`/etc`目录下的`profile`文件内容#### tail- 作用：查看文件末尾的内容- 语法：`tail [-f] fileName`说明：- `-f`：动态读取文件末尾内容并显示，通常用于日志文件的内容输出举例：- ```  tail /etc/profile</code></pre>- 显示`/etc`目录下的`profile`文件末尾10行的内容</code></pre></li><li><pre><code>tail -20 /etc/profile<pre class="line-numbers language-none"><code class="language-none">  - 显示`/etc`目录下的`profile`文件末尾20行的内容- ```  tail -f /kyle/blog.log</code></pre>- 动态读取`/kyle`目录下的`blog.log`文件末尾内容并显示</code></pre></li></ul><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><ul><li>作用：创建目录</li><li>语法：<code>mkdir[-p] dirName</code></li></ul><p>说明：</p><ul><li><code>-p</code>：确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建</li></ul><p>举例：</p><ul><li><pre><code>mkdir linuxCast<pre class="line-numbers language-none"><code class="language-none">  - 在当前目录下，建立一个名为linuxCast的子目录- ```  mkdir-p linuxCast/test</code></pre>- 在工作目录下的linuxCast目录中建立一个名为test的子目录，若linuxCast目录不存在，则建立一个</code></pre></li></ul><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><ul><li>作用：删除空目录</li><li>语法：<code>rmdir [-p] dirName</code></li></ul><p>说明：</p><ul><li><code>-p</code>：当子目录被删除后使父目录为空目录的话，则一并删除</li></ul><p>举例：</p><ul><li><code>rmdir linuxCast</code>删除名为linuxCast的空目录</li><li><code>rmdir -p linuxCast/test</code>删除linuxCast目录中名为test的子目录，若test目录删除后linuxCast目录变为空目录，则也被删除</li><li><code>rmdir linuxCast*</code>删除名称以linuxCast开始的空目录</li></ul><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><ul><li>作用：删除文件或者目录</li><li>语法：<code>rm [-rf] name</code></li></ul><p>说明：</p><ul><li><code>-r</code>：将目录及目录中所有文件（目录）逐一删除，即递归删除</li><li><code>-f</code>：无需确认，直接删除</li><li><code>name</code>：要删除的文件/目录，支持通配符</li></ul><h3 id="拷贝移动命令"><a href="#拷贝移动命令" class="headerlink" title="拷贝移动命令"></a>拷贝移动命令</h3><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>作用：用于复制文件或目录<br>语法：cp [-r] source dest</p><p>说明：</p><ul><li><code>-r</code>：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</li><li><code>source</code>：要复制的资源（文件/目录）</li><li><code>dest</code>：要移动到的位置</li></ul><p>举例：</p><ul><li><pre><code>cp hello.txt linuxCast/<pre class="line-numbers language-none"><code class="language-none">  - 将hello.txt复制到linuxCast目录中- ```  cp hello.txt ./ hi.txt</code></pre>- 将hello.txt复制到当前目录，并改名为hi.txt</code></pre></li><li><p>c</p><pre class="line-numbers language-none"><code class="language-none">p -r linuxCast/ ./blog/</code></pre><ul><li>将linuxCast目录和目录下所有文件复制到blog目录下</li></ul></li><li><pre><code>cp -r linuxCast/* ./blog/<pre class="line-numbers language-none"><code class="language-none">  - 将linuxCast目录下所有文件复制blog目录下#### mv作用：为文件或目录改名、或将文件或目录移动到其它位置语法：mv source dest说明：- `source`：要移动的资源（文件/目录）- `dest`：要移动到的位置举例：- ```  mv hello.txt hi.txt</code></pre>- 将hello.txt改名为hi.txt</code></pre></li><li><pre><code>mv hi.txt blogl<pre class="line-numbers language-none"><code class="language-none">  - 将文件hi.txt移动到blog目录中- ```  mv hi.txt blog/hello.txt</code></pre>- 将hi.txt移动到blog目录中，并改名为hello.txt</code></pre></li><li><pre><code>mv linuxCast/ blogl<pre class="line-numbers language-none"><code class="language-none">  - 如果blog目录不存在，将linuxCast目录改名为blog- ```  mv linuxCast/ blogl</code></pre>- 如果blog目录存在，将linuxCast目录移动到blog目录中</code></pre></li></ul><h3 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>作用：对文件进行打包、解包、压缩、解压<br>语法：<code>tar [-zcxvf] fileName [files]</code><br>包文件后缀为<code>.tar</code>表示只是完成了打包，并没有压缩<br>包文件后缀为<code>.tar.gz</code>表示打包的同时还进行了压缩，也可以用<code>.tgz</code>作为简写</p><p>说明：</p><ul><li><code>-z</code>： 代表的是gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压</li><li><code>-c</code>： 代表的是create，即创建新的包文件</li><li><code>-x</code>： 代表的是extract，实现从包文件中还原文件</li><li><code>-v</code>： 代表的是verbose，显示命令的执行过程</li><li><code>-f</code>： 代表的是file，用于指定包文件的名称</li><li><code>c</code>和<code>x</code>是互斥的，解压和压缩不能同时进行</li></ul><p>举例 ：</p><ul><li><pre><code>tar -cvf hello.tar ./*<pre class="line-numbers language-none"><code class="language-none">  - 将当前目录下所有文件打包，打包后的文件名为hello.tar- ```  tar -czvf hello.tar.gz ./*</code></pre>- 将当前目录下所有文件打包并压缩，打包后的文件名为hello.tar.gz</code></pre></li><li><pre><code>tar -zxvf hello.tar.gz<pre class="line-numbers language-none"><code class="language-none">  - 将`hello.tar.gz`中的文件解压缩### 文本编辑命令#### vi作用：`vi`命令是`Linux`系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于`windows`中的记事本语法：`vi fileName`说明：1. `vim`是从`vi`发展来的一个功能更加强大的文本编辑工具，在编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中`vim`更加常用。2. 要使用`vim`命令，需要我们自己完成安装。可以使用下面的命令来完成安装：`yum install vim`#### vim作用：对文件内容进行编辑，vim其实就是一个文本编辑器语法：`vim fileName`说明：1. 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。2. vim在进行文本编辑时共分为三种模式，分别是`命令模式`（Command mode），`插入模式`（Insert mode）和`底行模式`（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。针对vim中的三种模式说明如下：1. 命令模式   命令模式下可以查看文件内容、移动光标（上下左右箭头、`gg`(开头)、`G`（末尾））   通过vim命令打开文件后，默认进入命令模式   另外两种模式需要首先进入命令模式，才能进入彼此2. 插入模式   插入模式下可以对文件内容进行编辑   在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现`INSERT`字样   在插入模式下按下ESC键，回到命令模式3. 底行模式   底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作   在命令模式下按下[:,/]任意一个，可以进入底行模式   通过 `/` 方式进入底行模式后，可以对文件内容进行查找   通过 `:` 方式进入底行模式后，可以输入`wq`（保存并退出）、`q！`（不保存退出）、`set nu`（显示行号）### 查找命令#### find作用：在指定目录下查找文件语法：`find dirName -option fileName`说明：- `dirName`：指定目录- `-option`：一般指定`-name`（根据文件名称来查找）- `fileName`：可以使用通配符的方式举例：- ```  find / -name helloworld.log</code></pre>- 在所有文件夹下查找helloworld.log文件</code></pre></li><li><pre><code>find . -name "*.java"<pre class="line-numbers language-none"><code class="language-none">  - 在当前目录及其子目录下查找.java结尾文件- ```  find /linuxCast -name "*.java"</code></pre>- 在/linuxCast目录及其子目录下查找.java结尾的文件</code></pre></li></ul><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>作用：从指定文件中查找指定的文本内容<br>语法：<code>grep word fileName</code></p><p>说明：</p><ul><li><code>word：</code>查找的文本</li><li><code>fileName：</code>从哪个文件中种找</li></ul><p>举例：</p><ul><li><pre><code>grep Hello Helloworld.java<pre class="line-numbers language-none"><code class="language-none">  - 查找Helloworld.java文件中出现的Hello字符串的位置- ```  grep hello *.java</code></pre>- 查找当前目录中所有.java结尾的文件中包含hello字符串的位置</code></pre></li></ul><h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><h3 id="软件安装方式"><a href="#软件安装方式" class="headerlink" title="软件安装方式"></a>软件安装方式</h3><ol><li>二进制发布包安装<ul><li>软件已经针对具体平台编译打包发布，只要解压，修改配置即可</li></ul></li><li>rpm安装<ul><li>软件已经按照redhat的包管理规范进行打包，使用rpm命令进行安装，不能自行解决库依赖问题</li></ul></li><li>yum安装<ul><li>一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题</li></ul></li><li>源码编译安装<ul><li>软件以源码工程的形式发布，需要自己编译打包</li></ul></li></ol><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>操作步骤：</p><ol><li><p>使用FinalShell自带的上传工具将jdk的二进制发布包上传到Linux</p></li><li><p>解压安装包，命令为</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local</code></pre><ul><li>这个解压缩命令在前面也说过了，注意将jdk换成你自己的版本，<code>-C /path</code>是解压到指定目录，不过我们自己安装软件的话，一般都放在<code>/usr/local</code>目录下</li></ul></li><li><p>配置环境变量，使用vim命令修改</p><pre class="line-numbers language-none"><code class="language-none">/etc/profile</code></pre><p>文件，或者使用</p><pre class="line-numbers language-none"><code class="language-none">echo</code></pre><p>追加文件内容，在文件末尾添加如下配置</p><pre class="line-numbers language-none"><code class="language-none">PROPERTIESJAVA_HOME=/usr/local/jdk1.8.0_171PATH=$JAVA_HOME/bin:$PATH</code></pre><ul><li>追加<ul><li><code>echo 'JAVA_HOME=/usr/local/jdk1.8.0_171' &gt;&gt; /etc/profile</code></li><li><code>echo 'PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profile</code></li></ul></li><li>查看<ul><li><code>tail /etc/profile</code></li></ul></li></ul></li><li><p>重新加载profile文件，使更改的配置立即生效</p><ul><li>命令为<code>source /etc/profile</code></li></ul></li><li><p>检查安装是否成功</p><ul><li>命令为<code>java -version</code></li></ul></li><li><p>看到jdk版本号则说明安装成功</p></li></ol><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost local]## java -versionjava version "1.8.0_171"Java(TM) SE Runtime Environment (build 1.8.0_171-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</code></pre><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p>操作步骤：</p><ol><li><p>使用<code>FinalShell</code>自带的上传工具将<code>Tomcat</code>的二进制发布包上传到Linux</p></li><li><p>解压安装包</p><ul><li>命令为<code>tar -zxvf apache-tomcat-7.0.57.tar.gz-C /usr/local</code></li></ul></li><li><p>进入Tomcat的bin目录启动服务，命令为<code>sh startup.sh</code>或者<code>./startup.sh</code></p></li><li><p>验证Tomcat是否启动成功</p><ul><li><p>查看进程</p><ul><li><code>ps -ef | grep tomcat</code></li></ul><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost bin]## ps -ef | grep tomcatroot      71967      1  4 16:05 pts/0    00:00:02 /usr/local/jdk1.8.0_171/bin/java -Djava.util.logging.config.file=/usr/local/apache-tomcat-7.0.57/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/usr/local/apache-tomcat-7.0.57/endorsed -classpath /usr/local/apache-tomcat-7.0.57/bin/bootstrap.jar:/usr/local/apache-tomcat-7.0.57/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/apache-tomcat-7.0.57 -Dcatalina.home=/usr/local/apache-tomcat-7.0.57 -Djava.io.tmpdir=/usr/local/apache-tomcat-7.0.57/temp org.apache.catalina.startup.Bootstrap startroot      73174  42704  0 16:06 pts/0    00:00:00 grep --color=auto tomcat</code></pre></li><li><p>查看日志</p><ul><li><code>more /usr/local/ apache-tomcat-7.0.57/logs/catalina.out</code></li><li><code>tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out</code></li></ul></li></ul></li><li><p>停止Tomcat</p><ul><li>运行Tomcat的bin目录中提供的停止服务的脚本文件shutdowno.sh<ul><li><code>./shutdown.sh</code></li><li><code>sh shutdown.sh</code></li></ul></li><li>结束Tomcat进程<ul><li><code>kill -9 71967</code></li><li>注意这里的<code>71967</code>是Tomcat的<code>进程id</code>，是我们上面<code>查看进程</code>查出来的</li></ul></li></ul></li></ol><p>虽然Tomcat服务器启动了，但是我们暂时还是无法访问的，因为防火墙是开启的，而且我们也没有开放8080端口，继续往下看</p><h3 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h3><ul><li>查看防火墙状态<ul><li>systemctl status firewalld、 firewall-cmd –state</li></ul></li><li>暂时关闭防火墙<ul><li>systemctl stop firewalld</li></ul></li><li>永久关闭防火墙<ul><li>systemctl disable firewalld</li></ul></li><li>开启防火墙<ul><li>systemctl start firewalld</li></ul></li><li>开放指定端口<ul><li>firewall-cmd –zone=public –add-port=8080/tcp –permanent</li></ul></li><li>关闭指定端口<ul><li>firewall-cmd –zone=public –remove-port=8080/tcp –permanent</li></ul></li><li>立即生效<ul><li>firewall-cmd –reload</li></ul></li><li>查看开放的端口<ul><li>firewall-cmd –zone=public –list-ports</li></ul></li></ul><ol><li>systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作</li><li>firewall-cmd是Linux中专门用于控制防火墙的命令</li><li>为了保证系统安全，服务器的防火墙不建议关闭</li></ol><ul><li>查看防火墙状态，这里是running的</li></ul><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost ~]## firewall-cmd --staterunning</code></pre><ul><li>那我们暂时关闭一下，测试能否访问Tomcat服务器</li></ul><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost ~]## firewall-cmd --statenot running</code></pre><ul><li>关了之后就能访问了，但是防火墙都没了，不安全<br><a href="https://pic1.imgdb.cn/item/634a6ddf16f2c2beb1357daf.jpg"><img src="634a6ddf16f2c2beb1357daf.jpg" alt="img"></a></li><li>但是我们可以只开放一个8080端口</li></ul><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost ~]## firewall-cmd --zone=public --add-port=8080/tcp --permanentsuccess</code></pre><ul><li>并设置立即生效</li></ul><pre class="line-numbers language-none"><code class="language-none">BASH[root@localhost ~]## firewall-cmd --reloadsuccess</code></pre><ul><li>刷新页面，尝试访问Tomcat服务器，依旧可以正常访问</li></ul><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><h4 id="检查冲突"><a href="#检查冲突" class="headerlink" title="检查冲突"></a>检查冲突</h4><p>检测当前系统中是否安装MySQL数据库</p><ul><li><pre><code>rpm -qa<pre class="line-numbers language-none"><code class="language-none">  - 查询当前系统中安装的所有软件- ```  rpm -qa | grep mysql</code></pre>- 查询当前系统中安装的名称带mysql的软件</code></pre></li><li><pre><code>rpm -qa | grep mariadb<pre class="line-numbers language-none"><code class="language-none">  - 查询当前系统中安装的名称带mariadb的软件RPM (Red-Hat Package Manager)RPM软件包管理器，是红帽Linux用于管理和安装软件的工具如果当前系统中已经安装有MySQL数据库，安装将失败。CentOS7自带mariadb，与MySQL数据库冲突#### 解决冲突- 如果发现有</code></pre>mariadb<pre class="line-numbers language-none"><code class="language-none">  ，那么我们把它卸载掉  - `rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64`- 然后看一下是不是真的卸掉了  - `rpm -qa | grep mariadb`#### 解压MySQL- 先创建要解压到的目录  - `mkdir /usr/local/mysql`- 随后解压  - `tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql`- 按顺序安装rpm包</code></pre>BASHrpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpmyum install net-toolsrpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm<pre class="line-numbers language-none"><code class="language-none">#### 启动MySQL- 查看MySQL服务状态  - `systemctl status mysqld`- 启动MySQL服务  - `system start mysqld`- 查看已经启动的服务  - `netstat -tunlp`  - `netstat -tunlp | grep mysql`- 查看MySQL进程  - `ps -df | grep mysql`说明：- 可以设置开机时自动启动MySQL服务，避免每次开机都要启动MySQL  - `systemctl enable mysqld`#### 登录MySQL- 查看日志内容中包含password的行信息  - `cat /var/log/mysqld.log |grep 'A temporary password is generated'`- 根据查询到的密码来登录MySQL  - `mysql -uroot -p`- 登录成功之后修改密码  - 设置密码长度最低位数    - `set global validate_password_length=4;`  - 设置密码安全等级低，便于密码可修改为root    - `set global validate_password_policy=LOW;`  - 设置密码为root    - `set password = password('root');`  - 开启访问权限    - `grant all on *.* to 'root'@'%' identified by 'root';`  - 刷新权限    - `flush privileges;`#### 外部连接- 使用Navicat或者SQLyog就可以连接到我们的数据库了，主机名就是ip地址，用户名和密码就是刚刚设置的如果在查看`MySQL服务状态`时出现了问题，请查看3306端口是否被占用（我找了俩小时才发现原因，呜呜呜）### 安装 lrzsz操作步骤1. 搜索lrzsz安装包   - yum list lrzsz2. 使用yum命令在线安装   - yum install lrzsz.x86_64Yum(全称为Yellow dog Updater, Modified)是一个在Fedora和RedHat以及Cent05中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。- 安装完后输入 `rz` ，就会跳出一个窗口，选择文件后即可上传## 项目部署### 手动部署操作步骤1. 在IDEA上将项目打包成jar包   - 通过IDEA自带的Maven面板的package指令打包即可   - 打完的包会放在target目录下2. 将jar包上传到linux服务器   - 最好还是创建一个对应的目录     - mkdir `/usr/local/app`     - cd `/usr/local/app`   - 然后使用`rz`命令上传打包好的jar包3. 启动项目   - `java -jar [打包好的jar包名]`   - 我这里试着上传了前面做的瑞吉外卖的项目     - `java -jar reggie-0.0.1-SNAPSHOT.jar`4. 检查防火墙   - 确保</code></pre>   8080   <pre class="line-numbers language-none"><code class="language-none">和</code></pre>   3306   <pre class="line-numbers language-none"><code class="language-none">     端口是开放的     - `firewall-cmd --zone=public --list-ports`5. 测试   - 在浏览器访问`ip:端口/路径`[![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/634b61bc16f2c2beb18d3547.jpg)### 通过Shell脚本自动部署操作步骤1. 在Linux安装Git   - 列出git安装包     - yum list git   - 在线安装git     - yum install git   - 使用git克隆代码（在此之前随便编写一个boot项目，然后push到仓库里，controller层写一个GetMapping，随便写个方法返回字符串</code></pre>   Shell脚本部署测试   <pre class="line-numbers language-none"><code class="language-none">     ，方便我们启动服务器的时候查看）     - git clone [仓库地址]2. 在Linux安装Maven   - 切换到</code></pre>   /usr/local   <pre class="line-numbers language-none"><code class="language-none">  目录  - cd `/usr/local`- 上传maven的安装包  - 使用`rz`命令- 解压到当前位置  - `tar zxvf apache-maven-3.5.4-bin.tar.gz`- 编辑配置文件</code></pre>   /etc/profile   <pre class="line-numbers language-none"><code class="language-none">  - `vim /etc/profile`  - 加入以下两行配置  &gt; export MAVEN_HOME=/usr/local/apache-maven-3.5.4  &gt; export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH- 编辑maven的</code></pre>   settings.xml   <pre class="line-numbers language-none"><code class="language-none">- 创建目录  - `mkdir /usr/local/repo`- 进入到对应目录修改文件  - ```    cd /usr/local/apache-maven-3.5.4/conf</code></pre>       - `vim settings.xml`       - 在`settings`标签下加上这句话设置仓库位置       &gt; `&lt;localRepository&gt;/usr/local/repo&lt;/localRepository&gt;`</code></pre></li></ul><ol start="3"><li>编写Shell脚本（拉取代码、编译、打包、启动）<br>这部分暂时不需要我们自己写，体验一下用Shell脚本部署就好了</li></ol><pre class="line-numbers language-none"><code class="language-none">SHELL#!/bin/shecho =================================echo  自动化部署脚本启动echo ================================= echo 停止原来运行中的工程APP_NAME=helloworld tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk '{print $2}'`if [ ${tpid} ]; then    echo 'Stop Process...'    kill -15 $tpidfisleep 2tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk '{print $2}'`if [ ${tpid} ]; then    echo 'Kill Process!'    kill -9 $tpidelse    echo 'Stop Success!'fi echo 准备从Git仓库拉取最新代码cd /usr/local/HelloWorld echo 开始从Git仓库拉取最新代码git pullecho 代码拉取完成 echo 开始打包output=`mvn clean package -Dmaven.test.skip=true` cd target echo 启动项目nohup java -jar HelloWorld-1.0-SNAPSHOT.jar &amp;&gt; helloworld.log &amp;echo 项目启动完成</code></pre><ol><li><p>为用户授予执行Shell脚本的权限</p><ul><li>7表示rwx三个权限都有，现在我们把权限都给了方便测试<ul><li><code>chmod 777 bootStart.sh</code></li></ul></li></ul></li><li><p>执行Shell脚本</p><ul><li><code>./bootStart.sh</code></li></ul></li><li><p>设置静态ip（可选）</p><ul><li><p>首先进入到对应目录</p><ul><li><code>cd /etc/sysconfig/network-scripts/</code></li></ul></li><li><p>然后编辑</p><pre class="line-numbers language-none"><code class="language-none">ifcfg-ens33</code></pre><p>文件</p><ul><li><code>vim ifcfg-ens33</code></li><li>修改添加以下内容（改成你自己的子网IP）</li></ul><blockquote><p>BOOTPROTO=static<br>IPADDR=192.168.28.100<br>NETMASK=255.255.255.0<br>NM_CONTROLLED=no</p><p>DNS1=8.8.8.8<br>DNS2=8.8.4.4</p></blockquote></li></ul></li><li><p>重启网络服务</p><ul><li><code>systemctl restart network</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/2023/09/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/"/>
      <url>/2023/09/01/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>先建表，然后创建一个SpringBoot的工程，勾选<code>Spring Web</code>，<code>MySQL</code>，然后在pom中引入其他</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.76&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-lang&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.20&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>导入前端资源，放在<code>resources</code>目录下。直接放在<code>resources</code>目录下，需要配置一下资源映射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        log.info("开始进行静态资源映射...");        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");    }}</code></pre><p>之后配置一下yml文件就能访问静态页面了</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8080spring:  application:    name: reggie_take_out  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true      username: root      password: 123456mybatis-plus:  configuration:    map-underscore-to-camel-case: true    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    db-config:      id-type: ASSIGN_ID</code></pre><p>打开浏览器，访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a> 可以看到登录页面，不过此时无法登录</p><h2 id="2-后台系统登录功能分析"><a href="#2-后台系统登录功能分析" class="headerlink" title="2. 后台系统登录功能分析"></a>2. 后台系统登录功能分析</h2><h3 id="2-1-创建对应的实体类"><a href="#2-1-创建对应的实体类" class="headerlink" title="2.1 创建对应的实体类"></a>2.1 创建对应的实体类</h3><p>创建一个Employee类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    private LocalDateTime createTime;    private LocalDateTime updateTime;    private Long createUser;    private Long updateUser;}</code></pre><h3 id="2-2-创建对应的Mapper和Service"><a href="#2-2-创建对应的Mapper和Service" class="headerlink" title="2.2 创建对应的Mapper和Service"></a>2.2 创建对应的Mapper和Service</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface EmployeeMapper extends BaseMapper&lt;Employee&gt; {}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EmployeeService extends IService&lt;Employee&gt; {}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper, Employee&gt; implements EmployeeService {}</code></pre><h3 id="2-3-统一结果封装"><a href="#2-3-统一结果封装" class="headerlink" title="2.3 统一结果封装"></a>2.3 统一结果封装</h3><p>编写一个Result类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Result&lt;T&gt; {    private Integer code;  // 编码：1成功。0和其他数字失败    private String errMsg;  // 错误信息    private T data; // 数据    private Map map = new HashMap();  // 动态数据    public static &lt;T&gt; Result&lt;T&gt; success(T data) {        Result&lt;T&gt; r = new Result&lt;&gt;();        r.code = 1;  //成功状态码        r.data = data;        return r;    }    public static &lt;T&gt; Result&lt;T&gt; error(String errMsg) {        Result&lt;T&gt; r = new Result&lt;&gt;();        r.errMsg = errMsg; //设置错误信息        r.code = 0;  //默认失败状态码，后期我们可以根据自己的需求来设置其他状态码        return r;    }    public Result&lt;T&gt; add(String msg, String value) {        this.map.put(msg, value);        return this;    }}</code></pre><h3 id="2-4-编写Controller"><a href="#2-4-编写Controller" class="headerlink" title="2.4 编写Controller"></a>2.4 编写Controller</h3><p>给EmployeeController类添加一个login方法</p><ul><li><code>@RequestBody</code> 主要用于接收前端传递给后端的json字符串（请求体中的数据）</li><li><code>HttpServletRequest</code> 作用：如果登录成功，将员工对应的id存到session一份，这样想获取一份登录用户的信息就可以随时获取出来</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/employee")public class EmployeeController {    @Autowired    private EmployeeService employeeService;    /**     * 登入功能     * @param request        * @param employee     * @return     */    //发送post请求    @PostMapping("/login")    public Result&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee) {        String password = employee.getPassword();        password = DigestUtils.md5DigestAsHex(password.getBytes());        //这部分就是MP        LambdaQueryWrapper&lt;Employee&gt; lqw = new LambdaQueryWrapper&lt;&gt;();        //相当于sql里面的where        lqw.eq(Employee::getUsername, employee.getUsername());        Employee emp = employeeService.getOne(lqw);        if (emp == null) {            return Result.error("登陆失败");        }        if (!emp.getPassword().equals(password)) {            return Result.error("登录失败");        }        if (emp.getStatus() == 0) {            return Result.error("该用户已被禁用");        }        //存个Session，只存个id就行了        request.getSession().setAttribute("employee",emp.getId());        return Result.success(emp);    }        /**     * 登出功能     * @param request     * @return     */    @PostMapping("/logout")    public Result&lt;String&gt; logout(HttpServletRequest request) {        request.getSession().removeAttribute("employee");        return Result.success("退出成功");    }}</code></pre><h3 id="2-5-登录测试"><a href="#2-5-登录测试" class="headerlink" title="2.5 登录测试"></a>2.5 登录测试</h3><p>数据库中目前只有一条用户信息，username为<code>admin</code>，password为<code>123456</code>（已经经过MD5加密了）<br>现在我们访问 <a href="http://localhost/backend/page/login/login.html">http://localhost/backend/page/login/login.html</a><br>输入正确的用户名和密码，正常登录，并跳转至<code>http://localhost/backend/index.html</code><br>输入错误的用户名或密码，会显示登陆失败<br>对应的HTML代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">methods: {    async handleLogin() {        this.$refs.loginForm.validate(async (valid) =&gt; {        if (valid) {            this.loading = true            let res = await loginApi(this.loginForm)            if (String(res.code) === '1') {            localStorage.setItem('userInfo',JSON.stringify(res.data))            window.location.href= '/backend/index.html'            } else {            this.$message.error(res.msg)            this.loading = false            }        }        })    }}</code></pre><p>对应的JS代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function loginApi(data) {  return $axios({    'url': '/employee/login',    'method': 'post',    data  })}function logoutApi(){  return $axios({    'url': '/employee/logout',    'method': 'post',  })}</code></pre><h3 id="2-6-登出功能"><a href="#2-6-登出功能" class="headerlink" title="2.6 登出功能"></a>2.6 登出功能</h3><p>先·简单分析一下前端代码<br>登出的功能是在index页面的，右上角有一个按钮，点击就能登出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div class="right-menu"&gt;    &lt;!--这里动态的显示登录的用户名--&gt;    &lt;div class="avatar-wrapper"&gt;{{ userInfo.name }}&lt;/div&gt;    &lt;!--这里就是登出的按钮--&gt;    &lt;img src="images/icons/btn_close@2x.png" class="outLogin" alt="退出" @click="logout" /&gt;&lt;/div&gt;</code></pre><p>对应的函数如下，这里的logoutApi是用来发送post请求的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">logout() {    logoutApi().then((res)=&gt;{        if(res.code === 1){        localStorage.removeItem('userInfo')        window.location.href = '/backend/page/login/login.html'        }    })}function logoutApi(){  return $axios({    'url': '/employee/logout',    'method': 'post',  })}</code></pre><p>登出功能的后端操作很简单，只要删除session就好了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * 登出功能    * @param request    * @return    */@PostMapping("/logout")public Result&lt;String&gt; logout(HttpServletRequest request) {    request.getSession().removeAttribute("employee");    return Result.success("退出成功");}</code></pre><h3 id="2-7-完善登录功能"><a href="#2-7-完善登录功能" class="headerlink" title="2.7 完善登录功能"></a>2.7 完善登录功能</h3><p>问题分析：</p><ul><li>之前的登录功能，我们不登录，直接访问 <a href="http://localhost/backend/index.html">http://localhost/backend/index.html</a> 也可以正常访问，这显然是不合理的</li><li>我们希望看到的效果是，只有登录成功才能看到页面，未登录状态则跳转到登录页面</li><li>那么具体改如何实现呢？使用过滤器或拦截器，在过滤器或拦截器中判断用户是否登录，然后在选择是否跳转到对应页面</li></ul><h4 id="2-7-1-测试Filter拦截路径"><a href="#2-7-1-测试Filter拦截路径" class="headerlink" title="2.7.1 测试Filter拦截路径"></a>2.7.1 测试Filter拦截路径</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")public class LoginCheckFilter implements Filter {    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        //将拦截到的URI输出到日志，{}是占位符，将自动填充request.getRequestURI()的内容        log.info("拦截到的URI：{}", request.getRequestURI());        //放行        filterChain.doFilter(request, response);    }}</code></pre><p>并在启动类上加入注解<code>@ServletComponentScan</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ServletComponentScanpublic class ReggieApplication {public static void main(String[] args) {SpringApplication.run(ReggieApplication.class, args);}}</code></pre><p>启动服务器，访问index页面，查看日志，现在可以拦截到URI了</p><blockquote><p>2022-09-29 18:05:53.190 …… : 拦截到的URI：/backend/index.html<br>2022-09-29 18:06:01.174 …… : 拦截到的URI：/employee/page</p></blockquote><h4 id="2-7-2-编写Filter逻辑"><a href="#2-7-2-编写Filter逻辑" class="headerlink" title="2.7.2 编写Filter逻辑"></a>2.7.2 编写Filter逻辑</h4><p>首先看一下JS代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 响应拦截器service.interceptors.response.use(res =&gt; {    if (res.data.code === 0 &amp;&amp; res.data.msg === 'NOTLOGIN') { // 返回登录页面格式    console.log('---/backend/page/login/login.html---')    localStorage.removeItem('userInfo')    window.top.location.href = '/backend/page/login/login.html'    } else {    return res.data    }}</code></pre><p>知道了拦截的返回格式后，开始编写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@WebFilter(filterName = "LoginCheckFilter", urlPatterns = "/*")public class LoginCheckFilter implements Filter {    //路径匹配器，支持通配符    private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        // 1.获取本次请求的URI        String uri = request.getRequestURI();        // 定义不需要处理的请求路径        String[] urls = new String[]{                "/employee/login",                "/employee/logout",                // /** 拦截所有的文件夹及里面的子文件夹                // 即所有静态页面可以访问（只有骨架没有数据）                "/backend/**",                "/front/**"        };        // 2.判断本次请求是否需要拦截处理        boolean check = check(urls, uri);        // 3.如果不需要处理直接放行        if (check) {            log.info("本次请求：{}，不需要处理",uri);            filterChain.doFilter(request, response);            return;        }        // 4.如果需要处理，判定登录状态，若登录则放行        if (request.getSession().getAttribute("employee") != null) {            log.info("用户已登录，id为{}",request.getSession().getAttribute("employee"));            filterChain.doFilter(request, response);            return;        }        // 5.如果未登录则返回未登录结果,通过输出流方式向客户端页面响应数据        log.info("本次请求：{}",uri);        log.info("用户未登录");        log.info("用户id{}",request.getSession().getAttribute("employee"));        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));    }    //检查是否匹配    private boolean check(String[] urls, String uri) {        for (String url : urls) {            boolean match = PATH_MATCHER.match(url, uri);            if (match) return true;        }        return false;    }}</code></pre><h4 id="2-7-3-测试登录"><a href="#2-7-3-测试登录" class="headerlink" title="2.7.3 测试登录"></a>2.7.3 测试登录</h4><p>当我们直接访问 <a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a> 时，日志输出如下</p><pre class="line-numbers language-none"><code class="language-none">：拦截到请求：/employee/page: 用户未登录: 用户id为：null</code></pre><p>随后将自动跳转至登录页面</p><pre class="line-numbers language-none"><code class="language-none">: 拦截到请求：/employee/login: 本次请求：/employee/login，不需要处理</code></pre><blockquote><p>自动跳转是因为：访问<a href="http://localhost:8080/backend/index.html%E6%97%B6%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AEpage/member/list.html%EF%BC%8Clist.html%E5%8F%88%E8%AE%BF%E9%97%AE/employee/page">http://localhost:8080/backend/index.html时会默认访问page/member/list.html，list.html又访问/employee/page</a></p></blockquote><h1 id="员工管理"><a href="#员工管理" class="headerlink" title="员工管理"></a>员工管理</h1><h2 id="3-添加员工"><a href="#3-添加员工" class="headerlink" title="3. 添加员工"></a>3. 添加员工</h2><h3 id="3-1-流程分析"><a href="#3-1-流程分析" class="headerlink" title="3.1 流程分析"></a>3.1 流程分析</h3><p>实现功能之前，我们先梳理一下整个执行流程</p><ol><li>页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据进行保存</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231002125855639.png"></p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>新增的员工信息只有部分数据，id，password，status，createTime等都还没有指定。</p><ul><li><code>id</code> 这个就用自动生成的就好了（雪花算法/自动递增）</li><li><code>password</code> 当你注册某些教育网站的时候，一般都会给你默认指定一个密码（身份证后六位，123456等），所以我们这里的解决策略就直接指定一个123456了，但是这个密码不能直接在数据库中设为默认值，因为数据库设置的默认值无法加密</li><li><code>status</code> 设定员工的状态，1表示启用，0表示禁用，这个表里直接设置了默认值</li><li><code>createTime</code> 创建时间，这个就指定当前时间就好了</li><li><code>updateTime</code> 作用同上</li><li><code>createUser</code> 这个是创建人的ID，我们首先需要一个管理员账号登录到后台管理界面，然后才能添加员工信息，所以我们也需要对这个员工信息的创建人，进行设置，避免出现莫名的员工账号，依靠这个可以溯源</li><li><code>updateUser</code> 作用同上</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic R&lt;String&gt; save(HttpServletRequest request, @RequestBody Employee employee) {    // 设置员工的password，createTime，updateTime,createUser,updateUser    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));    employee.setCreateTime(LocalDateTime.now());    employee.setUpdateTime(LocalDateTime.now());    // 从session获取当前登录用户    Long employee1 = (Long) request.getSession().getAttribute("employee");    employee.setCreateUser(employee1);    employee.setUpdateUser(employee1);    employeeService.save(employee);    return R.success("添加员工成功");}</code></pre><blockquote><p>值得注意的一点是，username不能重复，因为在建表的时候设定了unique，只能存在唯一的username，如果存入相同的username则会报错。</p><p>这个报错目前也不太人性化，咱也不知道具体为啥添加失败了，所以我们还得继续完善一下，那么具体该怎么完善呢？可以使用全局统一异常处理</p></blockquote><h3 id="3-3-完善全局异常处理器并测试"><a href="#3-3-完善全局异常处理器并测试" class="headerlink" title="3.3 完善全局异常处理器并测试"></a>3.3 完善全局异常处理器并测试</h3><p>在<code>com.blog.common</code>包下创建一个全局异常处理类<code>GlobalExceptionHandler</code>，并添加exceptionHandler方法用来捕获异常，并返回结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ControllerAdvice(annotations = {RestController.class, Controller.class})@ResponseBody@Slf4jpublic class GlobalExceptionHandler {    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex) {        log.error(ex.getMessage());        //如果包含Duplicate entry，则说明有条目重复        if (ex.getMessage().contains("Duplicate entry")) {            //对字符串切片            String[] s = ex.getMessage().split(" ");            //报错字符串格式是固定的，s[2]这个位置必然是username            return R.error("用户名" + s[2] + "已存在");        }        return R.error("未知错误");    }}</code></pre><h2 id="4-员工信息分页查询"><a href="#4-员工信息分页查询" class="headerlink" title="4. 员工信息分页查询"></a>4. 员工信息分页查询</h2><p><img src="image-20231002163302249.png" alt="image-20231002163302249"></p><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p><ol><li>页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务</li><li>服务端Controller接收页面提交的数据并调用Service查询数据</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收到分页数据并通过ElementUI的Table组件展示到页面上</li></ol><h3 id="4-1-前端代码分析"><a href="#4-1-前端代码分析" class="headerlink" title="4.1 前端代码分析"></a>4.1 前端代码分析</h3><p><img src="image-20231002163457504.png" alt="image-20231002163457504"></p><p>关于数据显示的功能，就是由这部分代码完成的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () {    const params = {        page: this.page,        pageSize: this.pageSize,        name: this.input ? this.input : undefined    }    await getMemberList(params).then(res =&gt; {        if (String(res.code) === '1') {        this.tableData = res.data.records || [] // 返回的列表数据在这里        this.counts = res.data.total        }    }).catch(err =&gt; {        this.$message.error('请求出错了：' + err)    })}function getMemberList (params) {  return $axios({    url: '/employee/page',    method: 'get',    params  })}</code></pre><h3 id="4-2-配置MyBatisPlus分页插件"><a href="#4-2-配置MyBatisPlus分页插件" class="headerlink" title="4.2 配置MyBatisPlus分页插件"></a>4.2 配置MyBatisPlus分页插件</h3><p>新建<code>com.itheima.config</code>包，并在其中新建<code>MybatisPlusConfig</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() {        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mybatisPlusInterceptor;    }}</code></pre><h3 id="4-3-编写具体的业务逻辑"><a href="#4-3-编写具体的业务逻辑" class="headerlink" title="4.3 编写具体的业务逻辑"></a>4.3 编写具体的业务逻辑</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    log.info("page={},pageSize={},name={}", page, pageSize, name);        //构造分页构造器    Page&lt;Employee&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //构造条件构造器    LambdaQueryWrapper&lt;Employee&gt; lqw = new LambdaQueryWrapper&lt;&gt;();    //添加过滤条件（当我们没有输入name时，就相当于查询所有了）    lqw.like(!(name == null || "".equals(name)), Employee::getName, name);    //并对查询的结果进行降序排序，根据更新时间    lqw.orderByDesc(Employee::getUpdateTime);        //执行查询    employeeService.page(pageInfo, wrapper);    return Result.success(pageInfo);}</code></pre><h2 id="5-启用-禁用员工账号"><a href="#5-启用-禁用员工账号" class="headerlink" title="5. 启用/禁用员工账号"></a>5. 启用/禁用员工账号</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><ol><li>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。</li><li>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。</li><li>管理员admin登录系统可以对所有员工账号进行启用、禁用操作。</li><li>如果某个员工账号状态为正常，则按钮显示为“禁用”，如果员工账号状态为已禁用，则按钮显示为“启用”</li></ol><p><img src="20230412044305_357.jpg" alt="img"></p><h3 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h3><ol><li><p>页面发送ajax请求，将参数(id、status)提交到服务端</p><p><img src="image-20231002182702506.png" alt="image-20231002182702506"></p></li><li><p>服务端Controller接收页面提交的数据并调用Service更新数据</p></li><li><p>Service调用Mapper操作数据库</p></li></ol><p><img src="image-20231002182232130.png" alt="image-20231002182232130"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) {    log.info(employee.toString());    Long id = (Long) request.getSession().getAttribute("employee");    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success("员工信息修改成功");}</code></pre><p>查看数据库，我们发现status并没有被修改<br>通过查看日志，我们发现更新操作并没有完成，这是怎么回事呢？</p><blockquote><p>==&gt; Preparing: UPDATE employee SET status=?, update_time=?, update_user=? WHERE id=?<br>==&gt; Parameters: 0(Integer), 2022-10-04T09:37:21.459(LocalDateTime), 1(Long), 1575840690817011700(Long)<br>==&gt; Updates: 0</p><ul><li>仔细观察这里的id值为<code>1575840690817011700</code>，而实际的id值为<code>1575840690817011713</code></li><li>问题的原因：</li><li>JS对Long型数据进行处理时丢失精度，导致提交的id和数据库中的id不一致。</li><li>如何解决这个问题?</li><li>我们可以在服务端给页面响应json数据时进行处理，将Long型数据统一转为String字符串</li></ul></blockquote><h3 id="5-3-配置状态转换器"><a href="#5-3-配置状态转换器" class="headerlink" title="5.3 配置状态转换器"></a>5.3 配置状态转换器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import java.math.BigInteger;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper {    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";    public JacksonObjectMapper() {        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(BigInteger.class, ToStringSerializer.instance)                .addSerializer(Long.class, ToStringSerializer.instance)                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    }}</code></pre><p>扩展Mvc框架的消息转换器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4jpublic class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");    }    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();        //设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        //将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    }}</code></pre><p>此时可以修改成功</p><h2 id="6-编辑员工信息"><a href="#6-编辑员工信息" class="headerlink" title="6. 编辑员工信息"></a>6. 编辑员工信息</h2><p>在开发代码之前，我们先来梳理一下整个操作流程与对应程序的执行顺序</p><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code></li><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li><li>服务端接受请求，并根据<code>员工id</code>查询员工信息，并将员工信息以<code>json</code>形式响应给页面</li><li>页面接收服务端响应的<code>json</code>数据，并通过Vue的<code>双向绑定</code>进行员工信息回显</li><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li><li>服务端接受员工信息，并进行处理，完成后给页面响应</li><li>页面接收到服务端响应信息后进行相应处理</li></ol><h3 id="6-1-页面根据id回显功能实现"><a href="#6-1-页面根据id回显功能实现" class="headerlink" title="6.1 页面根据id回显功能实现"></a>6.1 页面根据id回显功能实现</h3><h4 id="6-1-1-前端分析"><a href="#6-1-1-前端分析" class="headerlink" title="6.1.1 前端分析"></a>6.1.1 前端分析</h4><ol><li>点击编辑按钮时，页面将跳转到<code>add.html</code>，并在url中携带参数<code>员工id</code><br>编辑按钮绑定的点击事件为<code>addMemberHandle(scope.row.id)</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="text"    size="small"    class="blueBug"    @click="addMemberHandle(scope.row.id)"    :class="{notAdmin:user !== 'admin'}"&gt;    编辑&lt;/el-button&gt;addMemberHandle (st) {    if (st === 'add'){        window.parent.menuHandle({        id: '2',        url: '/backend/page/member/add.html',        name: '添加员工'        },true)    } else {        window.parent.menuHandle({        id: '2',        url: '/backend/page/member/add.html?id='+st, //这里        name: '修改员工'        },true)    }}</code></pre><ol start="2"><li>在<code>add.html</code>页面中获取url中的参数<code>员工id</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() {    this.id = requestUrlParam('id')    this.actionType = this.id ? 'edit' : 'add'    if (this.id) {    this.init()    }}//获取url地址上面的参数function requestUrlParam(argname){  var url = location.href  var arrStr = url.substring(url.indexOf("?")+1).split("&amp;")  for(var i =0;i&lt;arrStr.length;i++)  {      var loc = arrStr[i].indexOf(argname+"=")      if(loc!=-1){          return arrStr[i].replace(argname+"=","").replace("?","")      }  }  return ""}</code></pre><ol start="3"><li>发送<code>ajax</code>请求，请求服务端，同时提交<code>员工id</code>参数</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async init () {    queryEmployeeById(this.id).then(res =&gt; {        console.log(res)        if (String(res.code) === '1') {            console.log(res.data)            this.ruleForm = res.data            this.ruleForm.sex = res.data.sex === '0' ? '女' : '男'            // this.ruleForm.password = ''        } else {            this.$message.error(res.msg || '操作失败')        }    })}// 修改页面反查详情接口function queryEmployeeById (id) {  return $axios({    url: `/employee/${id}`,    method: 'get'  })}</code></pre><h4 id="6-1-2-具体实现"><a href="#6-1-2-具体实现" class="headerlink" title="6.1.2 具体实现"></a>6.1.2 具体实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/{id}")public R&lt;Employee&gt; getById(@PathVariable Long id) {    log.info("根据id查询员工信息...");    Employee employee = employeeService.getById(id);    if (employee != null) {        return R.success(employee);    }    return R.error("没有查询到对应员工信息");}</code></pre><h3 id="6-2-保存功能实现"><a href="#6-2-保存功能实现" class="headerlink" title="6.2 保存功能实现"></a>6.2 保存功能实现</h3><ol><li>点击保存按钮，发送ajax请求，将页面中的员工信息以json形式提交给服务端</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="primary"    @click="submitForm('ruleForm', false)"&gt;    保存&lt;/el-button&gt;submitForm (formName, st) {    this.$refs[formName].validate((valid) =&gt; {        if (valid) {        if (this.actionType === 'add') {            const params = {            ...this.ruleForm,            sex: this.ruleForm.sex === '女' ? '0' : '1'            }            addEmployee(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('员工添加成功！')                if (!st) {                this.goBack()                } else {                this.ruleForm = {                    username: '',                    'name': '',                    'phone': '',                    // 'password': '',                    // 'rePassword': '',/                    'sex': '男',                    'idNumber': ''                }                }            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        } else {            const params = {            ...this.ruleForm,            sex: this.ruleForm.sex === '女' ? '0' : '1'            }            editEmployee(params).then(res =&gt; { // 这里            if (res.code === 1) {                this.$message.success('员工信息修改成功！')                this.goBack()            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        }        } else {        console.log('error submit!!')        return false        }    })}// 修改---添加员工function editEmployee (params) {  return $axios({    url: '/employee',    method: 'put',    data: { ...params }  })}</code></pre><p>由于修改员工信息也是发送的PUT请求，与之前启用/禁用员工账号是一致的，而且前面我们已经写过了PUT请求的Controller层<br>所以当我们点击保存按钮时，调用<code>submitForm</code>函数，而在<code>submitForm</code>函数中我们又调用了<code>editEmployee</code>函数，发送PUT请求，实现修改功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Employee employee, HttpServletRequest request) {    log.info(employee.toString());    Long id = (Long) request.getSession().getAttribute("employee");    employee.setUpdateUser(id);    employee.setUpdateTime(LocalDateTime.now());    employeeService.updateById(employee);    return Result.success("员工信息修改成功");}</code></pre><h1 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h1><p><img src="image-20231003152635364.png" alt="image-20231003152635364"></p><h2 id="7-公共字段自动填充"><a href="#7-公共字段自动填充" class="headerlink" title="7. 公共字段自动填充"></a>7. 公共字段自动填充</h2><h3 id="7-1-问题分析"><a href="#7-1-问题分析" class="headerlink" title="7.1 问题分析"></a>7.1 问题分析</h3><ul><li>前面我们已经完成了对员工数据的添加与修改，在添加/修改员工数据的时候，都需要指定一下创建人、创建时间、修改人、修改时间等字段，而这些字段又属于公共字段，不仅员工表有这些字段，在菜品表、分类表等其他表中，也拥有这些字段。</li><li>那我们有没有办法让这些字段在一个地方统一管理呢？这样可以简化我们的开发<ul><li>答案就是使用<code>MybatisPlus</code>给我们提供的公共字段自动填充功能</li></ul></li></ul><h3 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h3><ol><li>在实体类的属性上方加入<code>@TableFiled</code>注解，指定自动填充的策略</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Employee implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    private String username;    private String name;    private String password;    private String phone;    private String sex;    private String idNumber;    private Integer status;    @TableField(fill = FieldFill.INSERT)//插入时填充字段值    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段值    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)//插入时填充字段值    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段值    private Long updateUser;}</code></pre><ol start="2"><li>按照框架要求编写元数据对象处理器，在此类中统一对公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口<br>实现接口之后，重写两个方法，一个是插入时填充，一个是修改时填充<br>关于字段填充方式，使用metaObject的<code>setValue</code>来实现</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        log.info("公共字段自动填充(insert)...");        log.info(metaObject.toString());        metaObject.setValue("createTime", LocalDateTime.now());        metaObject.setValue("updateTime", LocalDateTime.now());    }    @Override    public void updateFill(MetaObject metaObject) {        log.info("公共字段自动填充(update)...");        log.info(metaObject.toString());        metaObject.setValue("updateTime", LocalDateTime.now());    }}</code></pre><h3 id="7-3-功能完善"><a href="#7-3-功能完善" class="headerlink" title="7.3 功能完善"></a>7.3 功能完善</h3><ul><li><p>关于id的获取，我们之前是存到session里的，但在<code>MyMetaObjectHandler</code>类中不能获得HttpSession对象，所以我们需要用其他方式来获取登录用户Id。</p><ul><li>可以使用<code>ThreadLocal</code>来解决这个问题</li></ul></li><li><p>在学习ThreadLocal之前，我们需要先确认一个事情，就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程:</p><ol><li><code>LocalCheekFilter</code>中的<code>doFilter</code>方法</li><li><code>EmployeeController</code>中的<code>update</code>方法</li><li><code>MyMetaObjectHandler</code>中的<code>updateFill</code>方法</li></ol></li></ul><p>那么什么是ThreadLocal?</p><ul><li>ThreadLocal并不是一个Thread，而是<strong>Thread的局部变量</strong></li><li>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本</li><li>所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li></ul><p>ThreadLocal常用方法:</p><ul><li><code>public void set(T value)</code> 设置当前线程的线程局部变量的值</li><li><code>public T get()</code> 返回当前线程所对应的线程局部变量的值</li></ul><p>那么我们如何用ThreadLocal来解决我们上述的问题呢？</p><ul><li>我们可以在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中获取当前登录用户id，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值（用户id)，然后在<code>MyMetaObjectHandler</code>的<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值（用户id)。</li></ul><p>具体实现</p><ul><li>在com.blog.common包下新建BaseContext类</li><li>作用：基于ThreadLocal的封装工具类，用于保护和获取当前用户id</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BaseContext {    // 用户保存、获取当前登录用户id    private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) {        threadLocal.set(id);    }    public static Long getCurrentId() {        return threadLocal.get();    }}</code></pre><ul><li>随后在LoginCheckFilter类中添加代码<br>使用<code>request.getSession</code>来获取当前登录用户的id值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//4.判断登录状态，如果已登录，则直接放行if (request.getSession().getAttribute("employee") != null) {    log.info("用户已登录，id为{}", request.getSession().getAttribute("employee"));        //根据session来获取之前我们存的id值    Long empId = (Long) request.getSession().getAttribute("employee");    //使用BaseContext封装id    BaseContext.setCurrentId(empId);        filterChain.doFilter(request, response);    return;}</code></pre><ul><li>在MyMetaObjectHandler类中，添加设置id的代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Slf4jpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        log.info("公共字段填充（create）...");        metaObject.setValue("createTime", LocalDateTime.now());        metaObject.setValue("updateTime", LocalDateTime.now());        //设置创建人id        metaObject.setValue("createUser", BaseContext.getCurrentId());        metaObject.setValue("updateUser", BaseContext.getCurrentId());    }    @Override    public void updateFill(MetaObject metaObject) {        log.info("公共字段填充（insert）...");        metaObject.setValue("updateTime", LocalDateTime.now());        //设置更新人id        metaObject.setValue("updateUser", BaseContext.getCurrentId());    }}</code></pre><h2 id="8-新增菜品分类"><a href="#8-新增菜品分类" class="headerlink" title="8. 新增菜品分类"></a>8. 新增菜品分类</h2><h3 id="8-1-需求分析"><a href="#8-1-需求分析" class="headerlink" title="8.1 需求分析"></a>8.1 需求分析</h3><ul><li>后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类</li><li>当我们在后台系统中添加菜品时，需要选择一个菜品分类</li><li>当我们在后台系统中天啊及一个套餐时，需要选择一个套餐分类</li><li>在移动端也会按照菜品分类和套餐分类来战士对应的菜品和套餐</li></ul><p>可以在后台系统的分类管理页面分别添加菜品分类和套餐分类，如下:</p><p>分类管理页面</p><p><img src="image-20231003171449686.png" alt="image-20231003171449686"></p><p>新增菜品分类表单</p><p><img src="image-20231003171506896.png" alt="image-20231003171506896"></p><p>新增套餐分类表单</p><p><img src="image-20231003171539212.png" alt="image-20231003171539212"></p><h3 id="8-2-数据模型"><a href="#8-2-数据模型" class="headerlink" title="8.2 数据模型"></a>8.2 数据模型</h3><p>简单浏览一下category表中的数据</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center">类型 1 菜品分类 2 套餐分类</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">分类名称</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr></tbody></table><p>id是主键，name分类名称是unique唯一的，type为1表示菜品分类，type为2表示套餐分类</p><h3 id="8-3-准备工作"><a href="#8-3-准备工作" class="headerlink" title="8.3 准备工作"></a>8.3 准备工作</h3><p>在开发业务之前，先将需要用到的类和接口的基本结构先创建好</p><ol><li>实体类Category，对应上表来创建<br>菜品分类也有<code>createUser</code>和<code>createTime</code>等字段，也可以用上面的公共字段自动填充</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Category implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //类型 1 菜品分类 2 套餐分类    private Integer type;    //分类名称    private String name;    //顺序    private Integer sort;    //创建时间    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    //更新时间    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    //创建人    @TableField(fill = FieldFill.INSERT)    private Long createUser;    //修改人    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><ol start="2"><li>Mapper接口CategoryMapper</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface CategoryMapper extends BaseMapper&lt;Category&gt; {}</code></pre><ol start="3"><li>业务层接口CategoryService</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; {}</code></pre><ol start="4"><li>业务层实现类CatrgoryServiceImpl</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService {}</code></pre><ol start="5"><li>控制层CategoryController</li></ol><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Slf4j@RestController@RequestMapping("/category")public class CategoryController {    @Autowired    private CategoryService categoryService;}</code></pre><h3 id="8-4-流程分析"><a href="#8-4-流程分析" class="headerlink" title="8.4 流程分析"></a>8.4 流程分析</h3><p>在编写代码之前，我们还是先来分析一下整个流程</p><ol><li>页面发送ajax请求，将新增分类窗口输入的数据以json形式提交给服务端</li><li>服务端Controller接收页面提交的数据并调用Service将数据存储到数据库</li><li>Service调用Mapper操作数据库，保存数据</li></ol><p><img src="image-20231003173637383.png" alt="image-20231003173637383"></p><h3 id="8-5-代码实现"><a href="#8-5-代码实现" class="headerlink" title="8.5 代码实现"></a>8.5 代码实现</h3><p>服务端只需要将接收到的json数据添加到数据库中，并响应一个成功的提示信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody Category category) {    log.info("category:{}", category);    categoryService.save(category);    return Result.success("新增分类成功");}</code></pre><h2 id="9-分类信息分页查询"><a href="#9-分类信息分页查询" class="headerlink" title="9. 分类信息分页查询"></a>9. 分类信息分页查询</h2><p>与之前的员工信息分页查询类似</p><h3 id="9-1-流程分析"><a href="#9-1-流程分析" class="headerlink" title="9.1 流程分析"></a>9.1 流程分析</h3><p>按照惯例，我们还是先来分析一下流程</p><ol><li>页面发送Ajax请求，将分页查询的参数（page、pageSize）提交到服务端</li><li>服务端Controller接受到页面提交的数据之后，调用Service进行查询</li><li>Service调用Mapper操作数据库，查询分页数据</li><li>Controller将查询到的分页数据响应给页面</li><li>页面接收分页数据，并通过ElementUI的Table组件战士到页面上</li></ol><p><img src="image-20231003174931272.png" alt="image-20231003174931272"></p><h3 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h3><p>在CategoryController类中编写page方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize) {    //分页构造器    Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //条件查询器    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加排序条件    queryWrapper.orderByDesc(Category::getSort);    //分页查询    categoryService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);}</code></pre><h2 id="10-删除分类"><a href="#10-删除分类" class="headerlink" title="10. 删除分类"></a>10. 删除分类</h2><h3 id="10-1-需求分析"><a href="#10-1-需求分析" class="headerlink" title="10.1 需求分析"></a>10.1 需求分析</h3><ul><li>在分类管理列表页面，可以对某个分类进行删除操作</li><li>需要注意的是：当分类关联了菜品或者套餐时，此分类将不允许被删除</li></ul><h3 id="10-2-流程分析"><a href="#10-2-流程分析" class="headerlink" title="10.2 流程分析"></a>10.2 流程分析</h3><p>按照惯例，继续分析一遍流程</p><ol><li>页面发送ajax请求，将参数(id)提交给服务端</li><li>服务端Controller接收页面提交的数据，并调用Service删除数据</li><li>Service调用Mapper操作数据库</li></ol><p><img src="image-20231003181059718.png" alt="image-20231003181059718"></p><h3 id="10-3-前端代码分析"><a href="#10-3-前端代码分析" class="headerlink" title="10.3 前端代码分析"></a>10.3 前端代码分析</h3><p>删除按钮绑定了<code>deleteHandle</code>函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">HTML&lt;el-button    type="text"    size="small"    class="delBut non"    @click="deleteHandle(scope.row.id)"&gt;    删除&lt;/el-button&gt;deleteHandle(id) {    this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {        'confirmButtonText': '确定',        'cancelButtonText': '取消',        'type': 'warning'    }).then(() =&gt; {        deleCategory(id).then(res =&gt; {        if (res.code === 1) {            this.$message.success('删除成功！')            this.handleQuery()        } else {            this.$message.error(res.msg || '操作失败')        }        }).catch(err =&gt; {        this.$message.error('请求出错了：' + err)        })    })}// 删除当前列的接口const deleCategory = (id) =&gt; {  return $axios({    url: '/category',    method: 'delete',    params: {id}  })}</code></pre><h3 id="10-4-代码实现"><a href="#10-4-代码实现" class="headerlink" title="10.4 代码实现"></a>10.4 代码实现</h3><p>在CategoryController类上添加delete方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingprivate Result&lt;String&gt; delete(Long id) {    log.info("将被删除的id：{}", id);    categoryService.removeById(id);    return Result.success("分类信息删除成功");}</code></pre><h3 id="10-5-功能完善"><a href="#10-5-功能完善" class="headerlink" title="10.5 功能完善"></a>10.5 功能完善</h3><p>当菜品分类或套餐分类关联了其他菜品或套餐时，该分类将不允许被删除</p><ul><li>那么我们如何实现这个功能呢？<ul><li>其实也很简单，我们只需要在删除的时候，拿着当前分类的id值，去对应的菜品/套餐表中进行查询，如果能查询到数据，则说明该分类关联了菜品，不允许被删除，否则则可以删除</li></ul></li></ul><p>那么明确了思路之后，我们就来写代码</p><ul><li>首先我们需要根据数据表创建菜品和套餐对应的模型类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** 菜品 */@Datapublic class Dish implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //商品码    private String code;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //顺序    private Integer sort;    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 套餐 */@Datapublic class Setmeal implements Serializable {    private static final long serialVersionUID = 1L;    private Long id;    //分类id    private Long categoryId;    //套餐名称    private String name;    //套餐价格    private BigDecimal price;    //状态 0:停用 1:启用    private Integer status;    //编码    private String code;    //描述信息    private String description;    //图片    private String image;    @TableField(fill = FieldFill.INSERT)    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE)    private LocalDateTime updateTime;    @TableField(fill = FieldFill.INSERT)    private Long createUser;    @TableField(fill = FieldFill.INSERT_UPDATE)    private Long updateUser;}</code></pre><ul><li><p>随后编写对应的Mapper接口</p></li><li><p>编写对应的Service接口及Impl实现类</p></li><li><p>在common包下新增<code>CustomException</code>类<br>该类用于<strong>封装我们的自定义异常</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CustomException extends RuntimeException{    public CustomException(String msg){        super(msg);    }}</code></pre><ul><li>在我们的全局异常处理器类中，使用<code>exceptionHandler</code>处理<code>CustomerException</code>异常</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ExceptionHandler(CustomException.class)public Result&lt;String&gt; exceptionHandler(CustomException ex) {    log.error(ex.getMessage());    return Result.error(ex.getMessage());}</code></pre><ul><li>在CategoryService接口中自己写一个<code>remove</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CategoryService extends IService&lt;Category&gt; {    void remove(Long id);}</code></pre><ul><li>在CategoryServiceImpl中来写具体业务逻辑<br>我们需要在删除数据之前，根据<code>id</code>值，去<code>Dish</code>表和<code>Setmeal</code>表中查询是否关联了数据<br>如果存在关联数据，则不能删除，并抛一个异常<br>如果不存在关联数据（也就是查询到的数据条数为0），正常删除即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service@Slf4jpublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService {    @Autowired    DishService dishService;    @Autowired    SetmealService setmealService;    /**     * 根据id删除分类，删除之前需要进行判断     * @param id     */    @Override    public void remove(Long id) {        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //添加dish查询条件，根据分类id进行查询        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);        int count1 = dishService.count(dishLambdaQueryWrapper);        //方便Debug用的        log.info("dish查询条件，查询到的条目数为：{}",count1);        //查看当前分类是否关联了菜品，如果已经关联，则抛出异常        if (count1 &gt; 0){            //已关联菜品，抛出一个业务异常            throw new CustomException("当前分类下关联了菜品，不能删除");        }        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //添加dish查询条件，根据分类id进行查询        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);        int count2 = setmealService.count(setmealLambdaQueryWrapper);        //方便Debug用的        log.info("setmeal查询条件，查询到的条目数为：{}",count2);        //查看当前分类是否关联了套餐，如果已经关联，则抛出异常        if (count2 &gt; 0){            //已关联套餐，抛出一个业务异常            throw new CustomException("当前分类下关联了套餐，不能删除");        }                //正常删除        super.removeById(id);    }}</code></pre><ul><li>最后记得在controller中调用我们新写的remove方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; delete(Long id){    log.info("将要删除的分类id:{}",id);    categoryService.remove(id);    return Result.success("分类信息删除成功");}</code></pre><h2 id="11-修改分类"><a href="#11-修改分类" class="headerlink" title="11. 修改分类"></a>11. 修改分类</h2><h3 id="11-1-需求分析"><a href="#11-1-需求分析" class="headerlink" title="11.1 需求分析"></a>11.1 需求分析</h3><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p><p><img src="20230412035047_459.jpg" alt="img"></p><h3 id="11-2-前端分析"><a href="#11-2-前端分析" class="headerlink" title="11.2 前端分析"></a>11.2 前端分析</h3><p>数据回显</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;el-button    type="text"    size="small"    class="blueBug"    @click="editHandle(scope.row)"&gt;    修改&lt;/el-button&gt;        editHandle(dat) {    this.classData.title = '修改分类'    this.action = 'edit'    this.classData.name = dat.name    this.classData.sort = dat.sort    this.classData.id = dat.id    this.classData.dialogVisible = true}classData: {    'title': '添加菜品分类',    'dialogVisible': false,    'categoryId': '',    'name': '',    sort: ''}// 数据双向绑定，回显&lt;el-form    class="demo-form-inline"    label-width="100px"    &gt;    &lt;el-form-item label="分类名称："&gt;        &lt;el-input            v-model="classData.name" //这里            placeholder="请输入分类名称"            maxlength="14"        /&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label="排序："&gt;        &lt;el-input v-model="classData.sort"  type="number" placeholder="请输入排序" /&gt; //这里    &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><p>数据提交是采用的一个通用的<code>submitForm</code>函数，由于我们是修改操作，所以直接从<code>else</code>开始往后看就行了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//数据提交submitForm(st) {    const classData = this.classData    const valid = (classData.name === 0 ||classData.name)  &amp;&amp; (classData.sort === 0 || classData.sort)    if (this.action === 'add') {        if (valid) {            const reg = /^\d+$/            if (reg.test(classData.sort)) {            addCategory({'name': classData.name,'type':this.type, sort: classData.sort}).then(res =&gt; {                console.log(res)                if (res.code === 1) {                this.$message.success('分类添加成功！')                if (!st) {                    this.classData.dialogVisible = false                } else {                    this.classData.name = ''                    this.classData.sort = ''                }                this.handleQuery()                } else {                this.$message.error(res.msg || '操作失败')                }            }).catch(err =&gt; {                this.$message.error('请求出错了：' + err)            })            } else {            this.$message.error('排序只能输入数字类型')            }        } else {            this.$message.error('请输入分类名称或排序')        }    } else if (valid) {        const reg = /^\d+$/        if (reg.test(this.classData.sort)) {            editCategory({'id':this.classData.id,'name': this.classData.name, sort: this.classData.sort}).then(res =&gt; {                if (res.code === 1) {                    this.$message.success('分类修改成功！')                    this.classData.dialogVisible = false                    this.handleQuery()                } else {                    this.$message.error(res.msg || '操作失败')                }            }).catch(err =&gt; {                    this.$message.error('请求出错了：' + err)            })        } else {            this.$message.error('排序只能输入数字类型')        }    } else {        this.$message.error('请输入分类名称或排序')    }}// 修改接口const editCategory = (params) =&gt; {  return $axios({    url: '/category',    method: 'put',    data: { ...params }  })}</code></pre><h3 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody Category category) {    log.info("修改分类信息为：{}", category);    categoryService.updateById(category);    return Result.success("修改分类信息成功");}</code></pre><h1 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h1><p><img src="image-20231004112854643.png" alt="image-20231004112854643"></p><h2 id="12-文件上传与下载"><a href="#12-文件上传与下载" class="headerlink" title="12. 文件上传与下载"></a>12. 文件上传与下载</h2><h3 id="12-1-文件上传简介"><a href="#12-1-文件上传简介" class="headerlink" title="12.1 文件上传简介"></a>12.1 文件上传简介</h3><ul><li><p>文件上传，也叫upload，是指将本地图片、视频、音频等文件上传到服务器中，可以供其他用户浏览或下载的过程</p></li><li><p>文件上传时，对页面的form表单有如下要求：</p><ol><li><code>method="post"</code>，采用post方式提交数据</li><li><code>enctype="multipart/form-data"</code>，采用multipart格式上传文件</li><li><code>type="file"</code>，使用input的file控件上传</li></ol></li><li><p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传，这里我们就用提供好的组件就行了<br>我们把这段代码放在<code>backend/demo</code>目录下，命名为<code>upload.html</code></p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;文件上传&lt;/title&gt;  &lt;!-- 引入样式 --&gt;  &lt;link rel="stylesheet" href="../../plugins/element-ui/index.css" /&gt;  &lt;link rel="stylesheet" href="../../styles/common.css" /&gt;  &lt;link rel="stylesheet" href="../../styles/page.css" /&gt;&lt;/head&gt;&lt;body&gt;   &lt;div class="addBrand-container" id="food-add-app"&gt;    &lt;div class="container"&gt;        &lt;el-upload class="avatar-uploader"                action="/common/upload"                :show-file-list="false"                :on-success="handleAvatarSuccess"                :before-upload="beforeUpload"                ref="upload"&gt;            &lt;img v-if="imageUrl" :src="imageUrl" class="avatar"&gt;&lt;/img&gt;            &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt;        &lt;/el-upload&gt;    &lt;/div&gt;  &lt;/div&gt;    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;    &lt;script src="../../plugins/vue/vue.js"&gt;&lt;/script&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src="../../plugins/element-ui/index.js"&gt;&lt;/script&gt;    &lt;!-- 引入axios --&gt;    &lt;script src="../../plugins/axios/axios.min.js"&gt;&lt;/script&gt;    &lt;script src="../../js/index.js"&gt;&lt;/script&gt;    &lt;script&gt;      new Vue({        el: '#food-add-app',        data() {          return {            imageUrl: ''          }        },        methods: {          handleAvatarSuccess (response, file, fileList) {              this.imageUrl = `/common/download?name=${response.data}`          },          beforeUpload (file) {            if(file){              const suffix = file.name.split('.')[1]              const size = file.size / 1024 / 1024 &lt; 2              if(['png','jpeg','jpg'].indexOf(suffix) &lt; 0){                this.$message.error('上传图片只支持 png、jpeg、jpg 格式！')                this.$refs.upload.clearFiles()                return false              }              if(!size){                this.$message.error('上传文件大小不能超过 2MB!')                return false              }              return file            }          }        }      })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:<ul><li><code>commons-fileupload</code></li><li><code>commons-io</code></li></ul></li><li>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中<strong>声明一个MultipartFile类型的参数</strong>即可接收上传的文件，例如</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/common")@Slf4jpublic class CommonController {    @PostMapping("/upload")    public Result&lt;String&gt; upload(MultipartFile file) {        log.info("获取文件：{}", file.toString());        return null;    }}</code></pre><h3 id="12-2-文件下载简介"><a href="#12-2-文件下载简介" class="headerlink" title="12.2 文件下载简介"></a>12.2 文件下载简介</h3><ul><li>文件下载，也成为了download，是指将文件从服务器传输到本地计算机的过程</li><li>通过浏览器进行文件下载，通常有两种表现形式<ol><li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li><li>直接在浏览器中打开</li></ol></li><li>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程</li></ul><h3 id="12-3-文件上传代码实现"><a href="#12-3-文件上传代码实现" class="headerlink" title="12.3 文件上传代码实现"></a>12.3 文件上传代码实现</h3><p>将我们上传的临时文件<strong>转存到指定位置</strong></p><ul><li><p>文件转存的位置改为动态可配置的，通过配置文件的方式指定，我们在application.yml文件中加入以下内容</p><ul><li><pre><code class="yml">reggie:  path: D:\\reggie\\imgs\\<pre class="line-numbers language-none"><code class="language-none">- 使用 @Value(“${reggie.path}”)读取到配置文件中的动态转存位置- 使用uuid方式重新生成文件名，避免文件名重复造成文件覆盖- 通过获取原文件名来截取文件后缀```java@RestController@RequestMapping("/common")@Slf4jpublic class CommonController {    //导入yml中配置的属性    @Value("${reggie.path}")    private String basepath;    @PostMapping("/upload")    //file是个临时文件，我们在断点调试的时候可以看到，但是执行完整个方法之后就消失了    public Result&lt;String&gt; upload(MultipartFile file) {        log.info("获取文件：{}", file.toString());        //判断一下当前目录是否存在，不存在则创建        File dir = new File(basepath);        if (!dir.exists()) {            dir.mkdirs();        }        //获取一下传入的原文件名        String originalFilename = file.getOriginalFilename();        //我们只需要获取一下格式后缀，取子串，起始点为最后一个.        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));        //为了防止出现重复的文件名，我们需要使用UUID        String fileName = UUID.randomUUID() + suffix;        try {            //我们将其转存到我们的指定目录下            file.transferTo(new File(basepath + fileName));        } catch (IOException e) {            throw new RuntimeException(e);        }        //将文件名返回给前端，便于后期的开发        return Result.success(fileName);    }}</code></pre></code></pre></li></ul></li></ul><h3 id="12-4-文件下载代码实现"><a href="#12-4-文件下载代码实现" class="headerlink" title="12.4 文件下载代码实现"></a>12.4 文件下载代码实现</h3><ul><li>前端页面的ElementUI的upload组件会在上传完图片后，触发img组件发送请求，服务端以流的方式（输出流）将文件写回给浏览器，在浏览器中展示图片</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;el-upload class="avatar-uploader"        action="/common/upload"        :show-file-list="false"        :on-success="handleAvatarSuccess"        :before-upload="beforeUpload"        ref="upload"&gt;    &lt;img v-if="imageUrl" :src="imageUrl" class="avatar"&gt;&lt;/img&gt;    &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt;&lt;/el-upload&gt;</code></pre><ul><li>定义前端发送回显图片请求的地址<br>通过这个url我们可以看出，请求路径为<code>/common/download</code>，且发送的是GET请求</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">handleAvatarSuccess (response, file, fileList) {    this.imageUrl = `/common/download?name=${response.data}`}</code></pre><h2 id="13-新增菜品"><a href="#13-新增菜品" class="headerlink" title="13. 新增菜品"></a>13. 新增菜品</h2><h3 id="13-1-需求分析"><a href="#13-1-需求分析" class="headerlink" title="13.1 需求分析"></a>13.1 需求分析</h3><ol><li>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品</li><li>在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传当前的菜品图片</li><li>在移动端会按照菜品分类来展示对应的菜品信息（前端的活儿，跟咱没啥太大关系）</li></ol><p><img src="image-20231004164529518.png" alt="image-20231004164529518"></p><h3 id="13-2-数据模型"><a href="#13-2-数据模型" class="headerlink" title="13.2 数据模型"></a>13.2 数据模型</h3><p>dish表，最后一条字段is_deleted是逻辑删除</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">菜品名称</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品价格</td></tr><tr><td align="center">code</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">商品码</td></tr><tr><td align="center">image</td><td align="center">varchar(200)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">description</td><td align="center">varchar(400)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">0 停售 1 起售</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">顺序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><p>dish_flavor表</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味名称</td></tr><tr><td align="center">value</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味数据list</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="13-3-代码开发"><a href="#13-3-代码开发" class="headerlink" title="13.3 代码开发"></a>13.3 代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>按照惯例，在开发代码之前，我们先来梳理一下整个流程</p><ol><li>页面（backend/page/food/add.html）发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器</li><li>页面发送请求进行图片下载，并回显上传的图片</li><li>点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</li></ol><p>所以开发新增菜品功能，其实就是在服务端编写代码去处理前端发送的这4次请求即可</p><h4 id="查询菜品分类数据"><a href="#查询菜品分类数据" class="headerlink" title="查询菜品分类数据"></a>查询菜品分类数据</h4><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">created() {    this.getDishList()    // 口味临时数据    this.getFlavorListHand()    this.id = requestUrlParam('id')    this.actionType = this.id ? 'edit' : 'add'    if (this.id) {    this.init()    }}getDishList () {    getCategoryList({ 'type': 1 }).then(res =&gt; {        if (res.code === 1) {        this.dishList = res.data        } else {        this.$message.error(res.msg || '操作失败')        }    })}// 获取菜品分类列表const getCategoryList = (params) =&gt; {  return $axios({    url: '/category/list',    method: 'get',    params  })}//下拉框&lt;el-select    v-model="ruleForm.categoryId"    placeholder="请选择菜品分类"&gt;    &lt;el-option v-for="(item,index) in dishList" :key="index" :label="item.name" :value="item.id" /&gt;&lt;/el-select&gt;</code></pre><ul><li>后端实现</li></ul><p>在<code>CategoryController</code>类中，添加list方法<br>我们只需要发送get请求，将数据返回给前端即可，操作很简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Category&gt;&gt; list(Category category) {    //条件构造器    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件，这里只需要判断是否为菜品（type为1是菜品，type为2是套餐）    queryWrapper.eq(category.getType() != null,Category::getType,category.getType());    //添加排序条件    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);    //查询数据    List&lt;Category&gt; list = categoryService.list(queryWrapper);    //返回数据    return Result.success(list);}</code></pre><h4 id="接收与回显图片"><a href="#接收与回显图片" class="headerlink" title="接收与回显图片"></a>接收与回显图片</h4><p>这个功能再刚刚我们已经实现了，到现在可以直接用</p><h4 id="提交数据到服务端"><a href="#提交数据到服务端" class="headerlink" title="提交数据到服务端"></a>提交数据到服务端</h4><p><img src="20230412045403_688.jpg" alt="img"></p><ul><li>接收数据分析</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">{name: "啊", price: 32100, code: "", image: "1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg",…}categoryId:"1397844263642378242"code:""description:"好吃的彩虹"flavors:[{name: "甜味", value: "["无糖","少糖","半糖","多糖","全糖"]", showOption: false},…]0:{name: "甜味", value: "["无糖","少糖","半糖","多糖","全糖"]", showOption: false}1:{name: "温度", value: "["热饮","常温","去冰","少冰","多冰"]", showOption: false}image:"1eefc77c-12b6-4cd0-8e6e-347d8f92ae84.jpg"name:"啊"price:32100status:1</code></pre><ul><li>因为Dish实体类无法接收flavor参数，即需要导入DishDto，用于封装页面提交的数据</li><li>DTO，全称为<code>Data Transfer Object</code>，即数据传输对象，一般用于展示层与服务层之间的数据传输。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class DishDto extends Dish {    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();    //后面这两条属性暂时没用，这里只需要用第一条属性    private String categoryName;    private Integer copies;}</code></pre><ul><li>前端分析</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">submitForm(formName, st) {    this.$refs[formName].validate((valid) =&gt; {        if (valid) {        let params = {...this.ruleForm}        // params.flavors = this.dishFlavors        params.status = this.ruleForm ? 1 : 0        params.price *= 100        params.categoryId = this.ruleForm.categoryId        params.flavors = this.dishFlavors.map(obj =&gt; ({ ...obj, value: JSON.stringify(obj.value) }))        delete params.dishFlavors        if(!this.imageUrl){            this.$message.error('请上传菜品图片')            return         }        if (this.actionType == 'add') {            delete params.id            addDish(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('菜品添加成功！') //这里                if (!st) {                this.goBack()                } else {                this.dishFlavors = []                // this.dishFlavorsData = []                this.imageUrl = ''                this.ruleForm = {                    'name': '',                    'id': '',                    'price': '',                    'code': '',                    'image': '',                    'description': '',                    'dishFlavors': [],                    'status': true,                    categoryId: ''                }                }            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        } else {            delete params.updateTime            editDish(params).then(res =&gt; {            if (res.code === 1) {                this.$message.success('菜品修改成功！')                this.goBack()            } else {                this.$message.error(res.msg || '操作失败')            }            }).catch(err =&gt; {            this.$message.error('请求出错了：' + err)            })        }        } else {        return false        }    })}// 新增接口const addDish = (params) =&gt; {  return $axios({    url: '/dish',    method: 'post',    data: { ...params }  })}</code></pre><ul><li>后端实现</li></ul><p>在<code>DishController</code>类中添加<code>save</code>方法，重启服务器，断点调试一下看看是否封装好了数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}",dishDto);    return null;}</code></pre><p><img src="20230412063714_358.jpg" alt="img"></p><p>从图中我们可以看出，DishFlavor 中的 dishId 为 null<br>但是我们需要对 DishFlavor 中的 dishId 进行赋值<br>所以我们要取出 dishDto 的 dishId，然后对每一组 flavor 的 dishId 赋值</p><ul><li>这里进行一下小结，我们需要做的有以下几点<ul><li>将菜品数据保存到<code>dish</code>表</li><li>将菜品口味数据保存到<code>dish_flavor </code>表<ul><li>但是<code>dish_flavor</code>表中需要一个<code>dishId</code>字段值，这个字段值需要我们从<code>dishDto</code>中获取</li><li>获取方式为：取出<code>dishDto</code>的<code>dishId</code>，对每一组<code>flavor</code>的<code>dishId</code>赋值</li></ul></li></ul></li><li>梳理完毕之后，那么我们就在<code>DishFlavorService</code>中编写一个<code>saveWithFlavor</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface DishService extends IService&lt;Dish&gt; {    void saveWithFlavor(DishDto dishDto);}</code></pre><ul><li>同时在<code>DishFlavorServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService {    @Autowired    private DishFlavorService dishFlavorService;    @Override    @Transactional // 涉及多表联查，开启事务管理，同时需要在启动类上加入@EnableTransactionManagement    public void saveWithFlavor(DishDto dishDto) {        //将菜品数据保存到dish表        this.save(dishDto);        //获取dishId        Long dishId = dishDto.getId();        //将获取到的dishId赋值给dishFlavor的dishId属性        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();        for (DishFlavor dishFlavor : flavors) {            dishFlavor.setDishId(dishId);        }        //同时将菜品口味数据保存到dish_flavor表        dishFlavorService.saveBatch(flavors);    }}</code></pre><h2 id="14-菜品信息分页查询"><a href="#14-菜品信息分页查询" class="headerlink" title="14. 菜品信息分页查询"></a>14. 菜品信息分页查询</h2><h3 id="14-1-需求分析"><a href="#14-1-需求分析" class="headerlink" title="14.1 需求分析"></a>14.1 需求分析</h3><ul><li>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>所以一般的系统中都会以分页的方式来展示列表数据。</li><li>其中图片列和菜品分类列比较特殊<ul><li>图片列：会用到文件的下载功能</li><li>菜品分类列：由于我们的菜品表只保存了category_id，所以我们需要查询category_id对应的菜品分类名称，从而回显数据</li></ul></li></ul><p><img src="20230412065920_105.jpg" alt="img"></p><h3 id="14-2-梳理交互过程"><a href="#14-2-梳理交互过程" class="headerlink" title="14.2 梳理交互过程"></a>14.2 梳理交互过程</h3><p>按照惯例，我们还是先来梳理一遍流程</p><ol><li>页面(backend/page/food/list.html)发送ajax请求，将分页查询参数(<code>page</code>、<code>pageSize</code>、<code>name</code>)，提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示</li></ol><p>那么开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p><h3 id="14-3-代码开发"><a href="#14-3-代码开发" class="headerlink" title="14.3 代码开发"></a>14.3 代码开发</h3><ul><li>在<code>DishController</code>下添加<code>page</code>方法，进行分页查询</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    //构造分页构造器对象    Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.like(name != null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    //执行分页查询    dishService.page(pageInfo, queryWrapper);    return Result.success(pageInfo);}</code></pre><ul><li>由于有菜品分类数据<ul><li>我们传递的是一个Dish对象，dish对象没有菜品分类名称属性，但是有菜品分类id</li><li>那我们就可以根据这个菜品分类id，去菜品分类表中查询对应的菜品分类名称</li></ul></li><li>所以我们之前的DishDto类中的另外一个属性就派上用场了，我们返回一个DishDto对象就有菜品分类名称数据了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    //构造分页构造器对象    Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    //这个就是我们到时候返回的结果    Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;(page, pageSize);        //条件构造器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.like(name != null, Dish::getName, name);    queryWrapper.orderByDesc(Dish::getUpdateTime);    //执行分页查询    dishService.page(pageInfo, queryWrapper);//结果为pageInfo    //对象拷贝，这里只需要拷贝一下查询到的条目数    BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");// 忽略结果数据集records    //获取原records数据    List&lt;Dish&gt; records = pageInfo.getRecords();    //遍历records的每一条Dish数据，为categoryName赋值，封装成DishDto数据    List&lt;DishDto&gt; list = records.stream().map((item) -&gt; {        DishDto dishDto = new DishDto();        //将数据赋给dishDto对象        BeanUtils.copyProperties(item, dishDto);        //然后获取一下dish对象的category_id属性        Long categoryId = item.getCategoryId();  //分类id        //根据这个属性，获取到Category对象（这里需要用@Autowired注入一个CategoryService对象）        Category category = categoryService.getById(categoryId);        //随后获取Category对象的name属性，也就是菜品分类名称        String categoryName = category.getName();        //最后将菜品分类名称赋给dishDto对象就好了        dishDto.setCategoryName(categoryName);        //结果返回一个dishDto对象        return dishDto;        //并将dishDto对象封装成一个集合，作为我们的最终结果    }).collect(Collectors.toList());    dishDtoPage.setRecords(list);    return Result.success(dishDtoPage);}</code></pre><h2 id="15-修改菜品"><a href="#15-修改菜品" class="headerlink" title="15. 修改菜品"></a>15. 修改菜品</h2><h3 id="15-1-梳理交互过程"><a href="#15-1-梳理交互过程" class="headerlink" title="15.1 梳理交互过程"></a>15.1 梳理交互过程</h3><p>按照惯例，还是先来梳理一下整个流程</p><ol><li>页面发送ajax请求，请求服务器获取分类数据，用于菜品分类下拉框的数据回显（之前我们已经实现过了）</li><li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片回显（之前我们已经实现过了）</li><li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li></ol><p><img src="20230412030551_672.jpg" alt="img"></p><h3 id="15-2-查询菜品信息"><a href="#15-2-查询菜品信息" class="headerlink" title="15.2 查询菜品信息"></a>15.2 查询菜品信息</h3><ul><li>菜品信息回显功能，需要我们先根据id来查询到对应的菜品信息才能回显</li><li>但修改表单中有一个菜品口味属性，普通的Dish类没有这个属性，所以还是要用到DishDto</li><li>那我们这里先在 DishServiceImpl 中编写一个<code>getByIdWithFlavor</code>方法</li><li>菜品口味需要根据<code>dish_id</code>去<code>dish_flavor</code>表中查询，将查询到的菜品口味数据赋给我们的<code>DishDto</code>对象即可</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic DishDto getByIdWithFlavor(Long id) {    //先根据id查询到对应的dish对象    Dish dish = this.getById(id);    //创建一个dishDao对象    DishDto dishDto = new DishDto();    //拷贝对象    BeanUtils.copyProperties(dish, dishDto);    //条件构造器，对DishFlavor表查询    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据dish_id来查询对应的菜品口味数据    queryWrapper.eq(DishFlavor::getDishId, id);    //获取查询的结果    List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);    //并将其赋给dishDto    dishDto.setFlavors(flavors);    //作为结果返回给前端    return dishDto;}</code></pre><ul><li>在<code>DishController</code>中添加get方法，实现添加在<code>DishServicelmpl</code>中的逻辑代码，返回查询到的数据信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/{id}")public Result&lt;DishDto&gt; getByIdWithFlavor(@PathVariable Long id) {    DishDto dishDto = dishService.getByIdWithFlavor(id);    log.info("查询到的数据为：{}", dishDto);    return Result.success(dishDto);}</code></pre><h3 id="15-3-修改菜品信息"><a href="#15-3-修改菜品信息" class="headerlink" title="15.3 修改菜品信息"></a>15.3 修改菜品信息</h3><p>由于Dish表中没有Flavor这个属性，所以修改的时候，我们也是需要修改两张表</p><p>首先去DishService中创建<code>updateWithFlavor</code>方法，然后在<code>DishServiceImpl</code>中重写方法</p><ul><li>根据<code>id</code>修改菜品的基本信息</li><li>通过<code>dish_id</code>,删除菜品的<code>flavor</code></li><li>获取前端提交的<code>flavor</code>数据</li><li>为条<code>flavor</code>的<code>dishId</code>属性赋值</li><li>将数据批量保存到<code>dish_flavor</code>数据库</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void updateWithFlavor(DishDto dishDto) {    //更新当前菜品数据（dish表）    this.updateById(dishDto);    //下面是更新当前菜品的口味数据    //条件构造器    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //条件是当前菜品id    queryWrapper.eq(DishFlavor::getDishId, dishDto.getId());    //将其删除掉    dishFlavorService.remove(queryWrapper);    //获取传入的新的口味数据    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();    //这些口味数据还是没有dish_id，所以需要赋予其dishId    flavors = flavors.stream().map((item) -&gt; {        item.setDishId(dishDto.getId());        return item;    }).collect(Collectors.toList());    //再重新加入到表中    dishFlavorService.saveBatch(flavors);}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.updateWithFlavor(dishDto);    return Result.success("修改菜品成功");}</code></pre><h1 id="套餐管理"><a href="#套餐管理" class="headerlink" title="套餐管理"></a>套餐管理</h1><h2 id="16-新增套餐"><a href="#16-新增套餐" class="headerlink" title="16. 新增套餐"></a>16. 新增套餐</h2><h3 id="16-1-需求分析"><a href="#16-1-需求分析" class="headerlink" title="16.1 需求分析"></a>16.1 需求分析</h3><ul><li>套餐就是菜品的集合</li><li>后台系统中可以管理套餐信息，通过新增套餐来添加一个新的套餐</li><li>在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片</li></ul><h3 id="16-2-数据模型"><a href="#16-2-数据模型" class="headerlink" title="16.2 数据模型"></a>16.2 数据模型</h3><ul><li>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表中，而且还要向setmeal_dish表中插入套餐和菜品关联数据</li><li>所以在新增套餐时，需要对两张表进行操作<ol><li>setmeal表 –&gt; 套餐表</li><li>setmeal_dish表 –&gt; 套餐菜品关系表</li></ol></li><li>setmeal表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">category_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品分类id</td></tr><tr><td align="center">name</td><td align="center">varchar(64)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center">UNI</td><td align="center">(NULL)</td><td align="center">套餐名称</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐价格</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">状态 0:停用 1:启用</td></tr><tr><td align="center">code</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">编码</td></tr><tr><td align="center">description</td><td align="center">varchar(512)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">描述信息</td></tr><tr><td align="center">image</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><ul><li>setmeal_dish表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">setmeal_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_id</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">name</td><td align="center">varchar(32)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品名称 （冗余字段）</td></tr><tr><td align="center">price</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品原价（冗余字段）</td></tr><tr><td align="center">copies</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">份数</td></tr><tr><td align="center">sort</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">排序</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="16-3-梳理交互过程"><a href="#16-3-梳理交互过程" class="headerlink" title="16.3 梳理交互过程"></a>16.3 梳理交互过程</h3><p>在开发代码之前，我们先来梳理一下新增套餐时前端页面与服务端的交互过程</p><ol><li>页面发送ajax请求，请求服务端，获取套餐分类数据并展示到下拉框中（这个之前做过）</li><li>页面发送ajax请求，请求服务端，获取菜品分类数据并展示到添加菜品窗口中</li><li>页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器（已完成）</li><li>页面发送请求进行图片下载，将上传的图片进行回显（已完成）</li><li>点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</li></ol><p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求</p><h3 id="16-4-代码开发"><a href="#16-4-代码开发" class="headerlink" title="16.4 代码开发"></a>16.4 代码开发</h3><p>新增套餐页面，现在的套餐分类下拉框中已经能显示套餐分类了，这个功能在之前我们已经实现过了</p><p><img src="20230412050217_118.jpg" alt="img"></p><ul><li>添加菜品页面，这个页面是发送的GET请求，且路径为<code>dish/list?categoryId=xxx</code></li></ul><p><img src="20230412063516_850.jpg" alt="img"></p><ul><li>所以我们先去DishController中编写对应的get方法来正确显示菜品数据</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Dish&gt;&gt; get(Dish dish) {    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（启售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    return Result.success(list);}</code></pre><ul><li>编写save方法<br>我们先打个断点，看看提交的数据是啥样的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    return Result.success("套餐添加成功");}</code></pre><p><img src="6342946616f2c2beb19f11db.jpg" alt="img"></p><p>需要注意的是这个setmealId为null，我们具体的代码中，要对其进行赋值</p><ul><li>具体业务逻辑如下</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success("套餐添加成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService {    @Autowired    protected SetmealDishService setmealDishService;    @Override    public void saveWithDish(SetmealDto setmealDto) {        //保存套餐setmeal基本信息        this.save(setmealDto);                List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();        setmealDishes = setmealDishes.stream().map((item) -&gt; {            item.setSetmealId(setmealDto.getId());            return item;        }).collect(Collectors.toList());        //保存套餐和菜品关联信息到setmeal_dish        setmealDishService.saveBatch(setmealDishes);    }}</code></pre><h2 id="17-套餐信息分页查询"><a href="#17-套餐信息分页查询" class="headerlink" title="17. 套餐信息分页查询"></a>17. 套餐信息分页查询</h2><h3 id="17-1-需求分析"><a href="#17-1-需求分析" class="headerlink" title="17.1 需求分析"></a>17.1 需求分析</h3><ul><li>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看</li><li>一般的系统中都会以分页的方式来展示列表数据</li></ul><p><img src="image-20231006174357620.png" alt="image-20231006174357620"></p><h3 id="17-2-梳理交互过程"><a href="#17-2-梳理交互过程" class="headerlink" title="17.2 梳理交互过程"></a>17.2 梳理交互过程</h3><ol><li>页面发送ajax请求，将分页查询参数（page，pageSize，name）提交到服务端，获取分页数据</li><li>页面发送请求，请求服务端进行图片下载，用于页面图片展示（已完成）</li></ol><p><img src="image-20231006174558812.png" alt="image-20231006174558812"></p><h3 id="17-3-代码开发"><a href="#17-3-代码开发" class="headerlink" title="17.3 代码开发"></a>17.3 代码开发</h3><ul><li>SetmealController类中，添加list方法<br>其实跟前面的菜品信息分页查询代码几乎一模一样，这遍就当review了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/page")public Result&lt;Page&gt; page(int page, int pageSize, String name) {    Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize);    Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;(page, pageSize);        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(name != null, Setmeal::getName, name);    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    setmealService.page(pageInfo, queryWrapper);        // 通过categoryId查询categoryName    BeanUtils.copyProperties(pageInfo, dtoPage, "records");    List&lt;Setmeal&gt; records = pageInfo.getRecords();    List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; {        SetmealDto setmealDto = new SetmealDto();        BeanUtils.copyProperties(item, setmealDto);        Long categoryId = item.getCategoryId();        Category category = categoryService.getById(categoryId);        if (category != null) {            setmealDto.setCategoryName(category.getName());        }        return setmealDto;    }).collect(Collectors.toList());    dtoPage.setRecords(list);    return Result.success(dtoPage);}</code></pre><h2 id="18-删除套餐"><a href="#18-删除套餐" class="headerlink" title="18. 删除套餐"></a>18. 删除套餐</h2><h3 id="18-1-需求分析"><a href="#18-1-需求分析" class="headerlink" title="18.1 需求分析"></a>18.1 需求分析</h3><ul><li>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息</li><li>也可以通过复选框选择多个套餐，选择批量删除一次性删除多个套餐</li></ul><p>注意：对于<code>在售</code>中的套餐不能删除，需要先<code>停售</code>，然后才能删除</p><h3 id="18-2-梳理交互过程"><a href="#18-2-梳理交互过程" class="headerlink" title="18.2 梳理交互过程"></a>18.2 梳理交互过程</h3><ol><li>删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</li><li>删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐开发删除套餐功能<ul><li>请求网址: <a href="http://localhost/setmeal?ids=1579044544635232258,1415580119015145474">http://localhost/setmeal?ids=1579044544635232258,1415580119015145474</a></li><li>请求方法: DELETE</li></ul></li></ol><ul><li>删除单个套餐和批量删除这两种请求的地址和请求方式都是相同的</li><li>不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</li></ul><h3 id="18-3-代码开发"><a href="#18-3-代码开发" class="headerlink" title="18.3 代码开发"></a>18.3 代码开发</h3><ul><li>在SetmealController中添加delete方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMappingpublic Result&lt;String&gt; deleteByIds(@RequestParam List&lt;Long&gt; ids) {    log.info("要删除的套餐id为：{}",ids);    setmealService.removeWithDish(ids);    return Result.success("删除成功");}</code></pre><ul><li>在<code>SetmealServiceImpl</code>中重写方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override@Transactionalpublic void removeWithDish(List&lt;Long&gt; ids) {    //先判断一下能不能删，如果status为1，则套餐在售，不能删    //select * from setmeal where id in (ids) and status = 1    LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();    setmealLambdaQueryWrapper.in(Setmeal::getId, ids);    setmealLambdaQueryWrapper.eq(Setmeal::getStatus, 1);        int count = this.count(setmealLambdaQueryWrapper);    if (count &gt; 0) {        throw new CustomException("套餐正在售卖中，请先停售再进行删除");    }    //如果没有在售套餐，则直接删除    this.removeByIds(ids);        //继续删除    LambdaQueryWrapper&lt;SetmealDish&gt; setmealDishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();    setmealDishLambdaQueryWrapper.in(SetmealDish::getSetmealId, ids);    setmealDishService.remove(setmealDishLambdaQueryWrapper);}</code></pre><h1 id="用户端操作"><a href="#用户端操作" class="headerlink" title="用户端操作"></a>用户端操作</h1><h2 id="19-邮件发送（替换手机验证）"><a href="#19-邮件发送（替换手机验证）" class="headerlink" title="19. 邮件发送（替换手机验证）"></a>19. 邮件发送（替换手机验证）</h2><p>其实黑马这里用的是短信业务，但咱也没那条件，所以我只能自己换成QQ邮箱验证码了，这个简单，具体操作我们也只需要开启POP3/STMP服务，获取一个16位的授权码：oblbemkgmircebfj</p><p><img src="20230412053436_681.jpg" alt="img"></p><h3 id="19-1-需求分析"><a href="#19-1-需求分析" class="headerlink" title="19.1 需求分析"></a>19.1 需求分析</h3><ul><li>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能(咱平替成邮箱验证码)</li><li>手机（邮箱）验证码登录的优点：<ul><li>方便快捷，无需注册，直接登录</li><li>使用短信验证码作为登录凭证，无需记忆密码</li><li>安全</li></ul></li><li>登录流程:<ul><li>输入手机号（邮箱） &gt; 获取验证码 &gt; 输入验证码 &gt; 点击登录 &gt; 登录成功</li></ul></li><li>用户登录界面</li></ul><p><img src="20230412034549_543.jpg" alt="img"></p><h3 id="19-2-数据模型"><a href="#19-2-数据模型" class="headerlink" title="19.2 数据模型"></a>19.2 数据模型</h3><p>这里的手机号也是varchar类型，所以我们就不用动它了，咱就用它存咱自己邮箱号就行（动手能力强的自己改一下也无所谓，大不了改出BUG再自己修）</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">sex</td><td align="center">varchar(2)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别</td></tr><tr><td align="center">id_number</td><td align="center">varchar(18)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">身份证号</td></tr><tr><td align="center">avatar</td><td align="center">varchar(500)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">头像</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">0</td><td align="center">状态 0:禁用，1:正常</td></tr></tbody></table><ul><li>手机号（邮箱）是区分不同用户的标识，在用户登录的时候判断所输入的手机号（邮箱）是否存储在表中</li><li>如果不在表中，说明该用户为一个新的用户，将该用户自动保在user表中</li></ul><h3 id="19-3-准备工作"><a href="#19-3-准备工作" class="headerlink" title="19.3 准备工作"></a>19.3 准备工作</h3><p>在开发业务功能之前，我们先将要用到的类和接口的基本结构都创建好</p><ul><li><p>实体类User</p></li><li><p>Mapper接口UserMapper</p></li><li><p>业务层接口UserService</p></li><li><p>业务层实现类UserServiceImpl</p></li><li><p>控制层UserController</p></li><li><p>工具类（我们自己造自己的邮箱工具类）</p><ul><li>首先导入坐标</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.activation&lt;/groupId&gt;    &lt;artifactId&gt;activation&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.mail&lt;/groupId&gt;    &lt;artifactId&gt;mail&lt;/artifactId&gt;    &lt;version&gt;1.4.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-email&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li><ul><li>然后编写一个工具类，用于发送邮件验证码</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Properties;import javax.mail.Authenticator;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class MailUtils {    public static void main(String[] args) throws MessagingException {        //可以在这里直接测试方法，填自己的邮箱即可        sendTestMail("2442926123@qq.com", new MailUtils().achieveCode());    }    public static void sendTestMail(String email, String code) throws MessagingException {        // 创建Properties 类用于记录邮箱的一些属性        Properties props = new Properties();        // 表示SMTP发送邮件，必须进行身份验证        props.put("mail.smtp.auth", "true");        //此处填写SMTP服务器        props.put("mail.smtp.host", "smtp.qq.com");        //端口号，QQ邮箱端口587        props.put("mail.smtp.port", "587");        // 此处填写，写信人的账号        props.put("mail.user", "2442926123@qq.com");        // 此处填写16位STMP口令        props.put("mail.password", "oblbemkgmircebfj");        // 构建授权信息，用于进行SMTP进行身份验证        Authenticator authenticator = new Authenticator() {            protected PasswordAuthentication getPasswordAuthentication() {                // 用户名、密码                String userName = props.getProperty("mail.user");                String password = props.getProperty("mail.password");                return new PasswordAuthentication(userName, password);            }        };        // 使用环境属性和授权信息，创建邮件会话        Session mailSession = Session.getInstance(props, authenticator);        // 创建邮件消息        MimeMessage message = new MimeMessage(mailSession);        // 设置发件人        InternetAddress form = new InternetAddress(props.getProperty("mail.user"));        message.setFrom(form);        // 设置收件人的邮箱        InternetAddress to = new InternetAddress(email);        message.setRecipient(RecipientType.TO, to);        // 设置邮件标题        message.setSubject("【瑞吉外卖】验证码");        // 设置邮件的内容体        message.setContent("尊敬的用户:你好!\n注册验证码为:" + code + "(有效期为一分钟,请勿告知他人)", "text/html;charset=UTF-8");        // 最后当然就是发送邮件啦        Transport.send(message);    }    // 生成验证码    public static String achieveCode() {  //由于数字 1 、 0 和字母 O 、l 有时分不清楚，所以，没有数字 1 、 0        String[] beforeShuffle = new String[]{"2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F","G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a","b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v","w", "x", "y", "z"};        List&lt;String&gt; list = Arrays.asList(beforeShuffle);//将数组转换为集合        Collections.shuffle(list);  //打乱集合顺序        StringBuilder sb = new StringBuilder();        for (String s : list) {            sb.append(s); //将集合转化为字符串        }        return sb.substring(3, 8);    }}</code></pre><h3 id="19-4-修改拦截器"><a href="#19-4-修改拦截器" class="headerlink" title="19.4 修改拦截器"></a>19.4 修改拦截器</h3><ul><li>对用户登录操作放行</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义不需要处理的请求String[] urls = new String[]{        "/employee/login",        "/employee/logout",        "/backend/**",        "/front/**",        "/common/**",        //对用户登陆操作放行        "/user/login",        "/user/sendMsg"};</code></pre><ul><li>判断用户是否登录</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断用户是否登录if(request.getSession().getAttribute("user") != null){    log.info("用户已登录，用户id为：{}",request.getSession().getAttribute("user"));    Long userId = (Long)request.getSession().getAttribute("user");    BaseContext.setCurrentId(userId);    filterChain.doFilter(request,response);    return;}</code></pre><h3 id="19-5-发送验证码"><a href="#19-5-发送验证码" class="headerlink" title="19.5 发送验证码"></a>19.5 发送验证码</h3><ul><li>发送验证码的请求方式是POST，路径为<code>/user/sendMsg</code></li><li>那么我们在UserController控制层中，添加sendMsg方法<br>这个是真滴能发送的奥，邮箱里可以收到的，待会儿我就写校验功能了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/sendMsg")public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException {    String phone = user.getPhone();    if (!phone.isEmpty()) {        //随机生成一个验证码        String code = MailUtils.achieveCode();        log.info(code);        //这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        //验证码存session，方便后面拿出来比对        session.setAttribute(phone, code);        return Result.success("验证码发送成功");    }    return Result.error("验证码发送失败");}</code></pre><h3 id="19-6-登录功能"><a href="#19-6-登录功能" class="headerlink" title="19.6 登录功能"></a>19.6 登录功能</h3><ul><li>输入验证码，点击登录</li></ul><p> 请求路径为:<code>/user/login</code>，数据以json格式返回给服务端</p><p><img src="image-20231013165753060.png" alt="image-20231013165753060"></p><p><img src="image-20231013165802147.png" alt="image-20231013165802147"></p><ul><li>在UserController控制层中，添加<code>login</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/login")public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {    log.info(map.toString());    //获取邮箱    String phone = map.get("phone").toString();    //获取验证码    String code = map.get("code").toString();    //从session中获取验证码    String codeInSession = session.getAttribute(phone).toString();    //比较这用户输入的验证码和session中存的验证码是否一致    if (code != null &amp;&amp; code.equals(codeInSession)) {        //如果输入正确，判断一下当前用户是否存在        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        //判断依据是从数据库中查询是否有其邮箱        queryWrapper.eq(User::getPhone, phone);        User user = userService.getOne(queryWrapper);        //如果不存在，则创建一个，存入数据库        if (user == null) {            user = new User();            user.setPhone(phone);            userService.save(user);            user.setName("用户" + codeInSession);        }        //存个session，表示登录状态        session.setAttribute("user",user.getId());        //并将其作为结果返回        return Result.success(user);    }    return Result.error("登录失败");}</code></pre><h2 id="20-地址簿"><a href="#20-地址簿" class="headerlink" title="20. 地址簿"></a>20. 地址簿</h2><h3 id="20-1-需求分析"><a href="#20-1-需求分析" class="headerlink" title="20.1 需求分析"></a>20.1 需求分析</h3><ul><li>地址簿，指的是移动端消费者用户的地址信息（外卖快递的收货地址）</li><li>用户登录成功后可以维护自己的地址信息（自己修改删除新增等）</li><li>同一个用户可以有多个地址信息，但是只能有一个默认地址。（有默认地址的话会很方便）</li></ul><p><img src="image-20231014115207776.png" alt="image-20231014115207776"></p><h3 id="20-2-数据模型"><a href="#20-2-数据模型" class="headerlink" title="20.2 数据模型"></a>20.2 数据模型</h3><p>注意这里的phone类型为varchar(11)，这显然不够我们邮箱用的，所以我们自己改一下这里，改大一点，不然做到新增地址的时候，会报错<br><code>com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column 'phone' at row 1</code></p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户id</td></tr><tr><td align="center">consignee</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr><tr><td align="center">sex</td><td align="center">tinyint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">性别 0 女 1 男</td></tr><tr><td align="center">phone</td><td align="center">varchar(11)</td><td align="center">utf8_bin</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">province_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级区划编号</td></tr><tr><td align="center">province_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">省级名称</td></tr><tr><td align="center">city_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级区划编号</td></tr><tr><td align="center">city_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">市级名称</td></tr><tr><td align="center">district_code</td><td align="center">varchar(12)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级区划编号</td></tr><tr><td align="center">district_name</td><td align="center">varchar(32)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">区级名称</td></tr><tr><td align="center">detail</td><td align="center">varchar(200)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">详细地址</td></tr><tr><td align="center">label</td><td align="center">varchar(100)</td><td align="center">utf8mb4_0900_ai_ci</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">标签</td></tr><tr><td align="center">is_default</td><td align="center">tinyint(1)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">默认 0 否 1是</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr><tr><td align="center">update_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">更新时间</td></tr><tr><td align="center">create_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建人</td></tr><tr><td align="center">update_user</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">修改人</td></tr><tr><td align="center">is_deleted</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">0</td><td align="center">是否删除</td></tr></tbody></table><h3 id="20-3-准备工作"><a href="#20-3-准备工作" class="headerlink" title="20.3 准备工作"></a>20.3 准备工作</h3><ol><li>创建对应的实体类<code>AddressBook</code></li><li><code>Mapper</code>接口<code>AddressBookMapper</code></li><li>业务层接口<code>AddressBookService</code></li><li>业务层实现类<code>AddressBookServicelmpl</code></li><li>控制层<code>AddressBookController</code></li></ol><h3 id="20-4-新增收货地址"><a href="#20-4-新增收货地址" class="headerlink" title="20.4 新增收货地址"></a>20.4 新增收货地址</h3><p><img src="20230412055617_809.jpg" alt="img"></p><ul><li>修改前端代码<br>这段代码是新增地址的前端代码 address-edit.html ，我们将其中的手机号全部替换成邮箱，判断手机号的正则也换成判断邮箱的正则，懒人就直接Copy我这段代码就好了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=no,minimal-ui"&gt;        &lt;title&gt;菩提阁&lt;/title&gt;        &lt;link rel="icon" href="./../images/favico.ico"&gt;        &lt;!--不同屏幕尺寸根字体设置--&gt;        &lt;script src="./../js/base.js"&gt;&lt;/script&gt;        &lt;!--element-ui的样式--&gt;        &lt;link rel="stylesheet" href="../../backend/plugins/element-ui/index.css" /&gt;        &lt;!--引入vant样式--&gt;        &lt;link rel="stylesheet" href="../styles/vant.min.css"/&gt;        &lt;!-- 引入样式  --&gt;        &lt;link rel="stylesheet" href="../styles/index.css" /&gt;        &lt;!--本页面内容的样式--&gt;        &lt;link rel="stylesheet" href="./../styles/address-edit.css" /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="address_edit" class="app"&gt;            &lt;div class="divHead"&gt;                &lt;div class="divTitle"&gt;                    &lt;i class="el-icon-arrow-left" @click="goBack"&gt;&lt;/i&gt;{{title}}                &lt;/div&gt;            &lt;/div&gt;            &lt;div class="divContent"&gt;                &lt;div class="divItem"&gt;                   &lt;span&gt;联系人：&lt;/span&gt;                    &lt;el-input placeholder=" 请填写收货人的姓名" v-model="form.consignee"  maxlength='10' class="inputUser"/&gt;&lt;/el-input&gt;                   &lt;span class="spanChecked" @click="form.sex = '1'"&gt;                    &lt;i :class="{iActive:form.sex === '1'}"&gt;&lt;/i&gt;                    先生                   &lt;/span&gt;                   &lt;span class="spanChecked" @click="form.sex = '0'"&gt;                    &lt;i :class="{iActive:form.sex === '0'}"&gt;&lt;/i&gt;                    女士                &lt;/span&gt;                &lt;/div&gt;                &lt;div class="divItem"&gt;                    &lt;span&gt;邮箱：&lt;/span&gt;                    &lt;el-input placeholder=" 请填写收货人邮箱" v-model="form.phone"  maxlength='20' style="width: calc(100% - 80rem);"/&gt;&lt;/el-input&gt;                &lt;/div&gt;                &lt;div class="divItem"&gt;                    &lt;span&gt;收货地址：&lt;/span&gt;                     &lt;el-input placeholder=" 请输入收货地址" v-model="form.detail"  maxlength='140'/&gt;&lt;/el-input&gt;                &lt;/div&gt;                &lt;div class="divItem "&gt;                    &lt;span&gt;标签：&lt;/span&gt;                     &lt;span v-for="(item,index) in labelList" :key="index" @click="form.label = item;activeIndex = index" :class="{spanItem:true,spanActiveSchool:activeIndex === index}"&gt;{{item}}&lt;/span&gt;                &lt;/div&gt;                &lt;div class="divSave" @click="saveAddress"&gt;保存地址&lt;/div&gt;                &lt;div class="divDelete" @click="deleteAddress" v-if="id"&gt;删除地址&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 开发环境版本,包含了有帮助的命令行警告 --&gt;        &lt;script src="../../backend/plugins/vue/vue.js"&gt;&lt;/script&gt;        &lt;!-- 引入组件库 --&gt;        &lt;script src="../../backend/plugins/element-ui/index.js"&gt;&lt;/script&gt;        &lt;!-- 引入vant样式 --&gt;        &lt;script src="./../js/vant.min.js"&gt;&lt;/script&gt;               &lt;script src="./../js/common.js"&gt;&lt;/script&gt;        &lt;script src="./../api/address.js"&gt;&lt;/script&gt;        &lt;!-- 引入axios --&gt;        &lt;script src="../../backend/plugins/axios/axios.min.js"&gt;&lt;/script&gt;        &lt;script src="./../js/request.js"&gt;&lt;/script&gt;        &lt;script&gt;            new Vue({                el:"#address_edit",                data(){                    return {                        title:'新增收货地址',                        form:{                            consignee:'',//联系人                            phone:undefined,//手机号                            sex:'1',//0表示女 1 表示男                            detail:'',//收货地址                            label:'公司',//标签                        },                        labelList:[                            '无','公司','家','学校'                        ],                        id:undefined,                        activeIndex :0                    }                },                computed:{},                created(){                    this.initData()                },                mounted(){                },                methods:{                    goBack(){                        history.go(-1)                    },                    async initData(){                        const params = parseUrl(window.location.search)                        this.id = params.id                        if(params.id){                            this.title = '编辑收货地址'                            const res = await addressFindOneApi(params.id)                            if(res.code === 1){                                this.form = res.data                            }else{                                this.$notify({ type:'warning', message:res.msg});                            }                        }                    },                    async saveAddress(){                        const form = this.form                        if(!form.consignee){                            this.$notify({ type:'warning', message:'请输入联系人'});                            return                         }                        if(!form.phone){                            this.$notify({ type:'warning', message:'请输入邮箱'});                            return                         }                        if(!form.detail){                            this.$notify({ type:'warning', message:'请输入收货地址'});                            return                         }                        const reg = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/                        if(!reg.test(form.phone)){                            this.$notify({ type:'warning', message:'邮箱不合法'});                            return                          }                        let res= {}                        if(this.id){                            res = await updateAddressApi(this.form)                        }else{                            res = await addAddressApi(this.form)                        }                                                if(res.code === 1){                            window.requestAnimationFrame(()=&gt;{                                window.location.replace('/front/page/address.html')                            })                        }else{                            this.$notify({ type:'warning', message:res.msg});                        }                    },                    deleteAddress(){                        this.$dialog.confirm({                            title: '确认删除',                            message: '确认要删除当前地址吗？',                        })                        .then( async () =&gt; {                            const res = await deleteAddressApi({ids:this.id })                            if(res.code === 1){                                window.requestAnimationFrame(()=&gt;{                                    window.location.replace('/front/page/address.html')                                })                            }else{                                this.$notify({ type:'warning', message:res.msg});                            }                        })                        .catch(() =&gt; {                        });                    },                }            })            &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>请求路径</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//新增地址function  addAddressApi(data){    return $axios({        'url': '/addressBook',        'method': 'post',        data      })}</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; addAddress(@RequestBody AddressBook addressBook) {    addressBook.setUserId(BaseContext.getCurrentId());    log.info("addressBook:{}", addressBook);    addressBookService.save(addressBook);    return Result.success("添加地址成功");}</code></pre><h3 id="20-5-修改收货地址"><a href="#20-5-修改收货地址" class="headerlink" title="20.5 修改收货地址"></a>20.5 修改收货地址</h3><p><img src="image-20231014131340422.png" alt="image-20231014131340422"></p><ul><li>前端代码分析</li></ul><p>首先点击编辑按钮，回显数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//查询单个地址function addressFindOneApi(id) {  return $axios({    'url': `/addressBook/${id}`,    'method': 'get',  })}</code></pre><p>修改数据之后，点击保存，发送请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//修改地址function  updateAddressApi(data){    return $axios({        'url': '/addressBook',        'method': 'put',        data      })}</code></pre><ul><li>代码实现</li></ul><h3 id="20-6-查询地址"><a href="#20-6-查询地址" class="headerlink" title="20.6 查询地址"></a>20.6 查询地址</h3><ul><li>点击地址管理，查看请求方式与地址</li></ul><p><img src="20230412045510_417.jpg" alt="img"></p><ul><li>请求路径为<code>/addressBook/list</code>，请求方式为GET，那么我们现在来<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public R&lt;List&lt;AddressBook&gt;&gt; list() {    AddressBook addressBook = new AddressBook();    addressBook.setUserId(BaseContext.getCurrentId());    LambdaQueryWrapper&lt;AddressBook&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();    wrapper.eq(addressBook.getUserId() != null, AddressBook::getUserId, addressBook.getUserId());    wrapper.orderByDesc(AddressBook::getUpdateTime);        //SQL:select * from address_book where user_id = ? order by update_time desc    List&lt;AddressBook&gt; list = addressBookService.list(wrapper);    return R.success(list);}</code></pre><h3 id="20-7-设置默认地址"><a href="#20-7-设置默认地址" class="headerlink" title="20.7 设置默认地址"></a>20.7 设置默认地址</h3><ul><li><p>先来想想怎么设置默认地址</p><ul><li><p>默认地址，按理说数据库中，有且仅有一条数据为默认地址，也就是<code>is_default</code>字段为1</p></li><li><p>如何保证整个表中的</p><pre class="line-numbers language-none"><code class="language-none">is_default</code></pre><p>字段只有一条为1</p><ul><li>每次设置默认地址的时候，将当前用户所有地址的<code>is_default</code>字段设为0，随后将当前地址的<code>is_default</code>字段设为1</li></ul></li></ul></li><li><p>当我们点击上图的设为默认按钮的时候，会发送请求</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//设置默认地址function  setDefaultAddressApi(data){  return $axios({      'url': '/addressBook/default',      'method': 'put',      data    })}</code></pre><ul><li>在<code>AddressBookController</code>中编写对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping("/default")public R&lt;String&gt; setDefault(@RequestBody AddressBook addressBook) {    LambdaUpdateWrapper&lt;AddressBook&gt; lambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;();    lambdaUpdateWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());    lambdaUpdateWrapper.set(AddressBook::getIsDefault, 0);    //SQL:update address_book set is_default = 0 where user_id = ?    addressBookService.update(lambdaUpdateWrapper);    addressBook.setIsDefault(1);    //SQL:update address_book set is_default = 1 where id = ?    addressBookService.updateById(addressBook);    return R.success("设置默认地址成功");}</code></pre><h2 id="21-菜品展示"><a href="#21-菜品展示" class="headerlink" title="21. 菜品展示"></a>21. 菜品展示</h2><h3 id="21-1-需求分析"><a href="#21-1-需求分析" class="headerlink" title="21.1 需求分析"></a>21.1 需求分析</h3><ul><li>用户登陆成功之后，跳转到菜品页面，根据菜品分类来展示菜品和套餐</li><li>如果菜品设置了口味信息，则需要展示选择规格按钮，否则只展示+按钮（这部分是前端实现的）</li></ul><p><img src="image-20231014135711064.png" alt="image-20231014135711064"></p><h3 id="21-2-梳理交互过程"><a href="#21-2-梳理交互过程" class="headerlink" title="21.2 梳理交互过程"></a>21.2 梳理交互过程</h3><ol><li>页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类）（已完成）</li><li>页面发送ajax请求，根据具体的菜品/套餐分类，展示对应分类中的具体菜品（已完成）</li></ol><h3 id="21-3-前端分析"><a href="#21-3-前端分析" class="headerlink" title="21.3 前端分析"></a>21.3 前端分析</h3><ul><li><p>启动服务器，登录账号，监测Network选项卡，发现登录到首页会发送两个请求</p><ul><li>分类</li></ul><blockquote><p>请求网址: <a href="http://localhost/category/list">http://localhost/category/list</a><br>请求方法: GET</p></blockquote><ul><li>购物车</li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/list">http://localhost/shoppingCart/list</a><br>请求方法: GET</p></blockquote></li><li><p>其中分类请求我们之前写过了，但是当我们访问页面的时候，并没有加载出来</p><ul><li><p>原因是购物车相关功能还没写，所以这里我们用一个写死了的json数据骗骗它<br>将url换成我们注释掉的那个就好了</p></li><li><pre><code class="js">//获取购物车内商品的集合function cartListApi(data) {    return $axios({        'url': '/shoppingCart/list',        //'url': '/front/cartData.json',        'method': 'get',        params: {...data}    })}<pre class="line-numbers language-none"><code class="language-none">- 那我们再次重启服务器，此时首页已经可以显示分类数据![image-20231014141230596](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/image-20231014141230596.png)获取分类数据：http://localhost/category/list ，之前在分类管理中已完成展示菜品分类中的具体菜品：http://localhost/dish/list ，之前在套餐管理中已完成（新增套餐时需要选择相应的菜品）展示套餐分类中的具体套餐在后面开发![image-20231014151254220](%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/image-20231014151254220.png)### 21.4 选择规格- 但是现在还存在一个问题，我们的菜品是有口味数据的，那么这里的按钮不该是一个`+`，而应该是`选择规格````html&lt;div class="divTypes" v-if="detailsDialog.item.flavors &amp;&amp; detailsDialog.item.flavors.length &gt; 0 &amp;&amp; !detailsDialog.item.number " @click ="chooseFlavorClick(detailsDialog.item)"&gt;选择规格&lt;/div&gt;               </code></pre></code></pre></li></ul></li><li><p>通过代码我们可以看出，选择规格按钮，是根据服务端返回数据中是否有flavors字段来决定的，但我们返回的是一个<code>List&lt;Dish&gt;</code>，其中并没有<code>flavors</code>属性，所以我们需要修改前面的方法返回值为<code>DishDto</code>，<code>DishDto</code>继承了<code>Dish</code>，且新增了<code>flavors</code>属性</p></li><li><p>那么现在我们直接来修改原本的list方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) {    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    log.info("查询到的菜品信息list:{}",list);    //item就是list中的每一条数据，相当于遍历了    List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; {        //创建一个dishDto对象        DishDto dishDto = new DishDto();        //将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);                //然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId = item.getId();        //条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //条件就是菜品id        lambdaQueryWrapper.eq(itemId != null, DishFlavor::getDishId, itemId);        //根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(lambdaQueryWrapper);        //赋给dishDto的对应属性        dishDto.setFlavors(flavors);        //并将dishDto作为结果返回        return dishDto;        //将所有返回结果收集起来，封装成List    }).collect(Collectors.toList());    return Result.success(dishDtoList);}</code></pre><h2 id="22-套餐展示"><a href="#22-套餐展示" class="headerlink" title="22. 套餐展示"></a>22. 套餐展示</h2><ul><li>关于菜品的展示我们就完成了，但是套餐和菜品用的并不是同一个controller，所以我们还需要来完善套餐展示</li></ul><blockquote><p>请求网址: <a href="http://localhost/setmeal/list?categoryId=1413342269393674242&amp;status=1">http://localhost/setmeal/list?categoryId=1413342269393674242&amp;status=1</a><br>请求方法: GET</p></blockquote><ul><li>那么我们现在就在<code>SetmealController</code>中编写对应的方法<br>由于套餐没有口味数据，所以开发起来还是比较简单的</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) {    //条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.eq(setmeal.getCategoryId() != null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() != null, Setmeal::getStatus, 1);    //排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList = setmealService.list(queryWrapper);    return Result.success(setmealList);}</code></pre><h2 id="23-购物车"><a href="#23-购物车" class="headerlink" title="23. 购物车"></a>23. 购物车</h2><h3 id="23-1-需求分析"><a href="#23-1-需求分析" class="headerlink" title="23.1 需求分析"></a>23.1 需求分析</h3><ul><li>移动端用户可以将菜品/套餐添加到购物车</li><li>对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车（前端实现）</li><li>对于套餐来说，可以直接点击当前套餐加入购物车</li><li>在购物车中可以修改菜品/套餐的数量，也可以清空购物车</li></ul><p><img src="image-20231014172121854.png" alt="image-20231014172121854"></p><h3 id="23-2-数据模型"><a href="#23-2-数据模型" class="headerlink" title="23.2 数据模型"></a>23.2 数据模型</h3><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名称</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr><tr><td align="center">create_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">创建时间</td></tr></tbody></table><h3 id="23-3-梳理交互过程"><a href="#23-3-梳理交互过程" class="headerlink" title="23.3 梳理交互过程"></a>23.3 梳理交互过程</h3><ol><li>点击加入购物车按钮，页面发送ajax请求，请求服务端，将菜品/套餐添加到购物车</li><li>点击购物车图标，页面发送ajax请求，请求服务端，查询购物车中的菜品和套餐</li><li>点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</li></ol><h3 id="23-4-准备工作"><a href="#23-4-准备工作" class="headerlink" title="23.4 准备工作"></a>23.4 准备工作</h3><p>在开发业务功能之前，先将需要用到的类和接口的基本结构都创建好</p><ol><li>实体类<code>ShoppingCart</code></li><li><code>Mapper</code>接口<code>ShoppingCartMapper</code></li><li>业务层接口<code>ShoppingCartService</code></li><li>业务层实现类<code>ShoppingCartServiceImpl</code></li><li>控制层<code>ShoppingCartController</code></li></ol><h3 id="23-5-代码开发"><a href="#23-5-代码开发" class="headerlink" title="23.5 代码开发"></a>23.5 代码开发</h3><h4 id="加入购物车"><a href="#加入购物车" class="headerlink" title="加入购物车"></a>加入购物车</h4><ul><li>点击<code>加入购物车</code>，页面发送请求，请求路径<code>/shoppingCart/add</code>，请求方式<code>POST</code></li></ul><blockquote><p>请求网址: <a href="http://localhost/shoppingCart/add">http://localhost/shoppingCart/add</a><br>请求方法: POST</p></blockquote><ul><li>页面将数据以json格式发送给服务端</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/add")public Result&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart) {    log.info("shoppingCart={}", shoppingCart);    //获取当前用户id    Long currentId = BaseContext.getCurrentId();    //设置当前用户id    shoppingCart.setUserId(currentId);    //条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(ShoppingCart::getUserId, currentId);        //获取当前菜品id    Long dishId = shoppingCart.getDishId();    //判断添加的是菜品还是套餐    if (dishId != null) {        queryWrapper.eq(ShoppingCart::getDishId, dishId);    } else {        queryWrapper.eq(ShoppingCart::getSetmealId, shoppingCart.getSetmealId());    }    //查询当前菜品或者套餐是否在购物车中    ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);    if (cartServiceOne != null) {        //如果已存在就在当前的数量上加1        Integer number = cartServiceOne.getNumber();        cartServiceOne.setNumber(number + 1);        shoppingCartService.updateById(cartServiceOne);    } else {        //如果不存在，则还需设置一下创建时间        shoppingCart.setCreateTime(LocalDateTime.now());        //如果不存在，则添加到购物车，数量默认为1        shoppingCartService.save(shoppingCart);        //这里是为了统一结果，最后都返回cartServiceOne会比较方便        cartServiceOne = shoppingCart;    }    return Result.success(cartServiceOne);}</code></pre><h4 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h4><ul><li>之前为了不报错，我们将查看购物车的地址换成了一个死数据<br>那现在我们要做的就是换成真数据</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//获取购物车内商品的集合function cartListApi(data) {    return $axios({        'url': '/shoppingCart/list',        //'url': '/front/cartData.json',        'method': 'get',        params: {...data}    })}</code></pre><ul><li>请求路径为<code>/shoppingCart/list</code>，请求方式为<code>GET</code><br>直接来<code>ShoppingCartController</code>中添加对应的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;ShoppingCart&gt;&gt; list() {    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    Long userId = BaseContext.getCurrentId();    queryWrapper.eq(ShoppingCart::getUserId, userId);    List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(queryWrapper);    return Result.success(shoppingCarts);}</code></pre><h4 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h4><ul><li><p>我们点击上图中的清空按钮，请求路径为<code>/shoppingCart/clean</code>，请求方式为<code>DELETE</code></p></li><li><p>清空购物车的逻辑倒是比较简单，获取用户id，然后去<code>shopping__cart</code>表中删除对应id的数据即可<br>那么我们现在就来<code>ShoppingCartController</code>中编写对应的方法</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMapping("/clean")public Result&lt;String&gt; clean() {    //条件构造器    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //获取当前用户id    Long userId = BaseContext.getCurrentId();    queryWrapper.eq(userId != null, ShoppingCart::getUserId, userId);    //删除当前用户id的所有购物车数据    shoppingCartService.remove(queryWrapper);    return Result.success("成功清空购物车");}</code></pre><h2 id="24-用户下单"><a href="#24-用户下单" class="headerlink" title="24. 用户下单"></a>24. 用户下单</h2><h3 id="24-1-需求分析"><a href="#24-1-需求分析" class="headerlink" title="24.1 需求分析"></a>24.1 需求分析</h3><ul><li>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的<code>去结算</code>按钮，页面跳转到订单确认页面，点击<code>去支付</code>按钮，完成下单操作</li></ul><p><img src="image-20231015113216825.png" alt="image-20231015113216825"></p><h3 id="24-2-数据模型"><a href="#24-2-数据模型" class="headerlink" title="24.2 数据模型"></a>24.2 数据模型</h3><p>户下单业务对应的数据表为<code>orders</code>表和<code>order_detail</code>表</p><ul><li><code>orders</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">number</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单号</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">订单状态 1待付款，2待派送，3已派送，4已完成，5已取消</td></tr><tr><td align="center">user_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单用户</td></tr><tr><td align="center">address_book_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址id</td></tr><tr><td align="center">order_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">下单时间</td></tr><tr><td align="center">checkout_time</td><td align="center">datetime</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">结账时间</td></tr><tr><td align="center">pay_method</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">支付方式 1微信,2支付宝</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">实收金额</td></tr><tr><td align="center">remark</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">备注</td></tr><tr><td align="center">phone</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">手机号</td></tr><tr><td align="center">address</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">地址</td></tr><tr><td align="center">user_name</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">用户名</td></tr><tr><td align="center">consignee</td><td align="center">varchar(255)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">收货人</td></tr></tbody></table><ul><li><code>order_detail</code>表</li></ul><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Collation</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Comment</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center">PRI</td><td align="center">(NULL)</td><td align="center">主键</td></tr><tr><td align="center">name</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">名字</td></tr><tr><td align="center">image</td><td align="center">varchar(100)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">图片</td></tr><tr><td align="center">order_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">订单id</td></tr><tr><td align="center">dish_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">菜品id</td></tr><tr><td align="center">setmeal_id</td><td align="center">bigint</td><td align="center">(NULL)</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">套餐id</td></tr><tr><td align="center">dish_flavor</td><td align="center">varchar(50)</td><td align="center">utf8_bin</td><td align="center">YES</td><td align="center"></td><td align="center">(NULL)</td><td align="center">口味</td></tr><tr><td align="center">number</td><td align="center">int</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">1</td><td align="center">数量</td></tr><tr><td align="center">amount</td><td align="center">decimal(10,2)</td><td align="center">(NULL)</td><td align="center">NO</td><td align="center"></td><td align="center">(NULL)</td><td align="center">金额</td></tr></tbody></table><h3 id="24-3-梳理交互过程"><a href="#24-3-梳理交互过程" class="headerlink" title="24.3 梳理交互过程"></a>24.3 梳理交互过程</h3><ol><li>在购物车中点击<code>去结算</code>按钮，页面跳转到订单确认页面</li><li>在订单确认页面中，发送ajax请求，请求服务端，获取当前登录用户的默认地址</li><li>在订单确认页面，发送ajax请求，请求服务端，获取当前登录用户的购物车数据（已完成）</li><li>在订单确认页面点击<code>去支付</code>按钮，发送ajax请求，请求服务端，完成下单操作</li></ol><h3 id="24-4-准备工作"><a href="#24-4-准备工作" class="headerlink" title="24.4 准备工作"></a>24.4 准备工作</h3><ol><li><p>实体类<code>Orders</code>和<code>OrderDetail</code></p></li><li><p><code>Mapper</code>接口<code>OrderMapper</code>、<code>OrderDetailMapper</code></p></li><li><p>业务层接口<code>OrderService</code>、<code>OrderDetailService</code></p></li><li><p>业务层接口实现类<code>OrderServiceImpl</code>、<code>OrderDetailServiceImpl</code></p></li><li><p>控制层<code>OrderController</code>、<code>OrderDetailController</code></p></li></ol><h3 id="24-5-获取默认地址"><a href="#24-5-获取默认地址" class="headerlink" title="24.5 获取默认地址"></a>24.5 获取默认地址</h3><ul><li>我们点击去结算按钮，然后查看发送的请求url和方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/addressBook/default">http://localhost/addressBook/default</a><br>请求方法: GET</p></blockquote><ul><li>我们根据请求路径<code>/addressBook/default</code>，请求方式<code>GET</code>自己来编写方法，进入到<code>AddressBookController</code>编写</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/default")public Result&lt;AddressBook&gt; defaultAddress() {    //条件构造器    LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //当前用户    queryWrapper.eq(userId != null, AddressBook::getUserId, BaseContext.getCurrentId());    //默认地址    queryWrapper.eq(AddressBook::getIsDefault, 1);        AddressBook addressBook = addressBookService.getOne(queryWrapper);    return Result.success(addressBook);}</code></pre><h3 id="24-6-结算"><a href="#24-6-结算" class="headerlink" title="24.6 结算"></a>24.6 结算</h3><ul><li>点击上图中的去结算按钮，查看发送的请求url与请求方式</li></ul><blockquote><p>请求网址: <a href="http://localhost/order/submit">http://localhost/order/submit</a><br>请求方法: POST</p></blockquote><ul><li>提交给服务端的数据格式为JSON</li></ul><pre class="line-numbers language-none"><code class="language-none">AVRASMaddressBookId: "1579828298672885762",payMethod: 1,remark: ""</code></pre><ul><li><p>请求路径<code>/order/submit</code>，请求方式<code>POST</code>，那么我们现在就去<code>OrderController</code>中开发对应的功能<br>具体的<code>submit</code>方法我们放在<code>OrderService</code>写，<code>OrderController</code>调用写好的<code>submit</code>方法就好了</p></li><li><p>编写具体的submit方法的逻辑代码，我们先来分析一下下单功能，都需要做什么事情</p><ul><li><p>获取当前用户id</p></li><li><p>根据用户id查询其购物车数据</p></li><li><p>根据查询到的购物车数据，对订单表插入数据（1条）</p></li><li><p>根据查询到的购物车数据，对订单明细表插入数据（多条）</p></li><li><p>清空购物车数据</p></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService {    @Autowired    private ShoppingCartService shoppingCartService;    @Autowired    private UserService userService;    @Autowired    private AddressBookService addressBookService;    @Autowired    private OrderDetailService orderDetailService;    @Override    public void submit(Orders orders) {        //获取当前用户id        Long userId = BaseContext.getCurrentId();        //条件构造器        LambdaQueryWrapper&lt;ShoppingCart&gt; shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //根据当前用户id查询其购物车数据        shoppingCartLambdaQueryWrapper.eq(userId != null, ShoppingCart::getUserId, userId);        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(shoppingCartLambdaQueryWrapper);        //判断一下购物车是否为空        if (shoppingCarts == null) {            throw new CustomException("购物车数据为空，不能下单");        }        //判断一下地址是否有误        Long addressBookId = orders.getAddressBookId();        AddressBook addressBook = addressBookService.getById(addressBookId);        if (addressBookId == null) {            throw new CustomException("地址信息有误，不能下单");        }        //获取用户信息，为了后面赋值        User user = userService.getById(userId);        long orderId = IdWorker.getId();        //原子数，更精细计算        AtomicInteger amount = new AtomicInteger(0);        //向订单细节表设置属性        List&lt;OrderDetail&gt; orderDetailList= shoppingCarts.stream().map((item) -&gt; {            OrderDetail orderDetail = new OrderDetail();            orderDetail.setOrderId(orderId);            orderDetail.setName(item.getName());            orderDetail.setImage(item.getImage());            orderDetail.setDishId(item.getDishId());            orderDetail.setSetmealId(item.getSetmealId());            orderDetail.setDishFlavor(item.getDishFlavor());            orderDetail.setNumber(item.getNumber());            orderDetail.setAmount(item.getAmount());            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());            return orderDetail;        }).collect(Collectors.toList());        //向订单表设置属性        orders.setId(orderId);        orders.setNumber(String.valueOf(orderId));        orders.setStatus(2);        orders.setUserId(userId);        orders.setAddressBookId(addressBookId);        orders.setOrderTime(LocalDateTime.now());        orders.setCheckoutTime(LocalDateTime.now());        orders.setAmount(new BigDecimal(amount.get()));        orders.setPhone(addressBook.getPhone());        orders.setUserName(user.getName());        orders.setConsignee(addressBook.getConsignee());        orders.setAddress(                (addressBook.getProvinceName() == null ? "":addressBook.getProvinceName())+                        (addressBook.getCityName() == null ? "":addressBook.getCityName())+                        (addressBook.getDistrictName() == null ? "":addressBook.getDistrictName())+                        (addressBook.getDetail() == null ? "":addressBook.getDetail())        );        //根据查询到的购物车数据，对订单表插入数据（1条）        this.save(orders);        //根据查询到的购物车数据，对订单明细表插入数据（多条）        orderDetailService.saveBatch(orderDetailList);        //清空购物车数据        shoppingCartService.remove(shoppingCartLambdaQueryWrapper);    }}</code></pre><h1 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h1><ul><li>问题说明：<ul><li>当用户数量足够多的时候，系统访问量大</li><li>频繁的访问数据库，系统性能下降，用户体验差</li><li>所以一些通用、常用的数据，我们可以使用Redis来缓存，避免用户频繁访问数据库</li></ul></li></ul><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><h4 id="1-1-导入SpringDataRedis的maven坐标"><a href="#1-1-导入SpringDataRedis的maven坐标" class="headerlink" title="1.1 导入SpringDataRedis的maven坐标"></a>1.1 导入SpringDataRedis的maven坐标</h4><ul><li>这里我们就还是用SpringDataRedis来开发了</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h4><ul><li>配置连接redis的数据，我这里配置的是我的云服务器上装的Redis</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0</code></pre><h4 id="1-3-配置类"><a href="#1-3-配置类" class="headerlink" title="1.3 配置类"></a>1.3 配置类</h4><ul><li>配置一下序列化器，方便我们在图形化界面中查看我们存入的数据，在config包下新建RedisConfig类</li><li>但是也可以不配置RedisConfig，而是直接用<code>SpringRedisConfig</code>，它的默认序列化器就是<code>StringRedisSerializer</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfig extends CachingConfigurerSupport {    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        //默认key序列化器为：JdkSerializationRedisSerializer        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setConnectionFactory(connectionFactory);        return redisTemplate;    }}</code></pre><h3 id="2-缓存短信验证码"><a href="#2-缓存短信验证码" class="headerlink" title="2. 缓存短信验证码"></a>2. 缓存短信验证码</h3><h4 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h4><ul><li>先来回顾一下我们之前的邮件验证码是储存在哪儿的<ul><li>之前我们是存的Session，session的有效期是30分钟</li></ul></li><li>那现在我们学了Redis的基础应用，我们现在就可以把它缓存在Redis里</li><li>具体实现思路如下<ol><li>在服务端UserController中注入RedisTemplate对象，用于操作Redis;</li><li>在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟;</li><li>在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码;</li></ol></li></ul><h4 id="2-2-代码改造"><a href="#2-2-代码改造" class="headerlink" title="2.2 代码改造"></a>2.2 代码改造</h4><ol><li>在UserController中注入RedisTemplate或StringRedisTemplate对象，用于操作Redis</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改UserController中的sendMsg方法，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/sendMsg")public Result&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session) throws MessagingException {    String phone = user.getPhone();    if (!phone.isEmpty()) {        //随机生成一个验证码        String code = MailUtils.achieveCode();        log.info(code);        //这里的phone其实就是邮箱，code是我们生成的验证码        MailUtils.sendTestMail(phone, code);        //验证码缓存到Redis，设置存活时间5分钟        redisTemplate.opsForValue().set("code", code,5, TimeUnit.MINUTES);        return Result.success("验证码发送成功");    }    return Result.error("验证码发送失败");}</code></pre><ol start="3"><li>在服务端的UserController的login方法中，从Redis获取验证码，如果登录成功则删除Redis中的验证码</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/login")public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {    log.info(map.toString());    String phone = map.get("phone").toString();    String code = map.get("code").toString();    //把Redis中缓存的code拿出来    Object codeInRedis = redisTemplate.opsForValue().get(phone);    //看看接收到用户输入的验证码是否和redis中的验证码相同    log.info("你输入的code{}，redis中的code{}，计算结果为{}", code, codeInRedis, (code != null &amp;&amp; code.equals(codeInRedis)));    if (code != null &amp;&amp; code.equals(codeInRedis)) {        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getPhone, phone);        User user = userService.getOne(queryWrapper);        if (user == null) {            user = new User();            user.setPhone(phone);            user.setName("用户" + codeInRedis);            userService.save(user);        }        session.setAttribute("user", user.getId());        //如果登陆成功，则删除Redis中的验证码        redisTemplate.delete(phone);        return Result.success(user);    }    return Result.error("登录失败");}</code></pre><h3 id="3-缓存菜品数据"><a href="#3-缓存菜品数据" class="headerlink" title="3. 缓存菜品数据"></a>3. 缓存菜品数据</h3><ul><li>菜品数据是我们登录移动端之后的展示页面</li><li>所以每当我们访问首页的时候，都会调用数据库查询一遍菜品数据</li><li>对于这种需要频繁访问的数据，我们可以将其缓存到Redis中以减轻服务器的压力</li></ul><h4 id="3-1-实现思路"><a href="#3-1-实现思路" class="headerlink" title="3.1 实现思路"></a>3.1 实现思路</h4><ul><li>移动端对应的菜品查看功能，是DishController中的list方法，此方法会根据前端提交的查询条件进行数据库查询操作（用户选择不同的菜品分类）。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。所以现在我们需要对此方法进行缓存优化，提高系统性能</li><li>但是还有存在一个问题，我们是将所有的菜品缓存一份，还是按照菜品/套餐分类，来进行缓存数据呢？</li><li>答案是后者，当我们点击某一个分类时，只需展示当前分类下的菜品，而其他分类的菜品数据并不需要展示，所以我们在缓存的时候，根据菜品的分类，缓存多分数据，页面在查询时，点击某个分类，则查询对应分类下的菜品的缓存数据</li><li>具体实现思路如下<ol><li>修改DishController中的list方法，先从Redis中获取分类对应的菜品数据，如果有，则直接返回；如果无，则查询数据库，并将查询到的菜品数据存入Redis</li><li>修改DishController的save、update和delete方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改/更新/删除了某些菜品，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="3-2-代码改造"><a href="#3-2-代码改造" class="headerlink" title="3.2 代码改造"></a>3.2 代码改造</h4><ol><li>先在DishController中注入RedisTemplate</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate RedisTemplate redisTemplate;</code></pre><ol start="2"><li>修改DishController的list方法，先从Redis中获取菜品数据</li></ol><ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的菜品数据让Redis缓存</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")public Result&lt;List&lt;DishDto&gt;&gt; get(Dish dish) {    List&lt;DishDto&gt; dishDtoList;    String key = "dish_" + dish.getCategoryId() + "_" + dish.getStatus();    dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);    //如果有，则直接返回    if (dishDtoList != null){        return Result.success(dishDtoList);    }    //如果无，则查询    //条件查询器    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //根据传进来的categoryId查询    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());    //只查询状态为1的菜品（在售菜品）    queryWrapper.eq(Dish::getStatus, 1);    //简单排下序，其实也没啥太大作用    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);    //获取查询到的结果作为返回值    List&lt;Dish&gt; list = dishService.list(queryWrapper);    log.info("查询到的菜品信息list:{}", list);    //item就是list中的每一条数据，相当于遍历了    dishDtoList = list.stream().map((item) -&gt; {        //创建一个dishDto对象        DishDto dishDto = new DishDto();        //将item的属性全都copy到dishDto里        BeanUtils.copyProperties(item, dishDto);        //由于dish表中没有categoryName属性，只存了categoryId        Long categoryId = item.getCategoryId();        //所以我们要根据categoryId查询对应的category        Category category = categoryService.getById(categoryId);        if (category != null) {            //然后取出categoryName，赋值给dishDto            dishDto.setCategoryName(category.getName());        }        //然后获取一下菜品id，根据菜品id去dishFlavor表中查询对应的口味，并赋值给dishDto        Long itemId = item.getId();        //条件构造器        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();        //条件就是菜品id        lambdaQueryWrapper.eq(itemId != null, DishFlavor::getDishId, itemId);        //根据菜品id，查询到菜品口味        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(lambdaQueryWrapper);        //赋给dishDto的对应属性        dishDto.setFlavors(flavors);        //并将dishDto作为结果返回        return dishDto;        //将所有返回结果收集起来，封装成List    }).collect(Collectors.toList());    //将查询的结果让Redis缓存，设置存活时间为60分钟    redisTemplate.opsForValue().set(key,dishDtoList,60, TimeUnit.MINUTES);    return Result.success(dishDtoList);}</code></pre><ol start="3"><li>修改DishController里的save、update和批量修改方法(status)，加入清理缓存的逻辑</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMappingpublic Result&lt;String&gt; save(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.saveWithFlavor(dishDto);    String key = "dish_" + dishDto.getCategoryId() + "_1";    redisTemplate.delete(key);    return Result.success("添加菜品成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMappingpublic Result&lt;String&gt; update(@RequestBody DishDto dishDto) {    log.info("接收到的数据为：{}", dishDto);    dishService.updateWithFlavor(dishDto);    String key = "dish_" + dishDto.getCategoryId() + "_1";    redisTemplate.delete(key);    return Result.success("修改菜品成功");}</code></pre><blockquote><p>注意：这里并不需要我们对删除操作也进行缓存清理，因为删除操作执行之前，必须先将菜品状态修改为<code>停售</code>，而停售状态也会帮我们清理缓存，同时也看不到菜品，随后将菜品删除，仍然看不到菜品，故删除操作不需要进行缓存清理</p></blockquote><h3 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4. SpringCache"></a>4. SpringCache</h3><h4 id="4-1-SpringCache介绍"><a href="#4-1-SpringCache介绍" class="headerlink" title="4.1 SpringCache介绍"></a>4.1 SpringCache介绍</h4><ul><li>SpringCache是一个框架，实现了基本注解的缓存功能，只需要简单的添加一个注解，就能实现缓存功能</li><li>SpringCache提供了一层抽象，底层可以切换不同的cache实现，具体就是通过CacheManager接口来统一不同的缓存技术</li><li>针对不同的缓存技术，需要实现不同的CacheManager</li></ul><table><thead><tr><th align="center">CacheManger</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">EhCacheCacheManager</td><td align="center">使用EhCache作为缓存技术</td></tr><tr><td align="center">GuavaCacheManager</td><td align="center">使用Googke的GuavaCache作为缓存技术</td></tr><tr><td align="center">RedisCacheManager</td><td align="center">使用Redis作为缓存技术</td></tr></tbody></table><h4 id="4-2-SpringCache常用注解"><a href="#4-2-SpringCache常用注解" class="headerlink" title="4.2 SpringCache常用注解"></a>4.2 SpringCache常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能</td></tr><tr><td align="center">@Cacheable</td><td align="center">在方法执行前spring先查看缓存中是否有数据。如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict</td><td align="center">将一条或者多条数据从缓存中删除</td></tr></tbody></table><p> @Cacheable<br><code>@Cacheable</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，其主要参数说明如下</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value=(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“setmealCache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr><tr><td align="center">unless</td><td align="center">满足条件则不缓存</td><td align="center">例如:@Cacheable(value=“testcache”,unless=“#result = =null”)</td></tr></tbody></table><blockquote><p><code>@Cacheable(value=“setmealCache”,key=“#setmeal.categoryId + '_' + #setmeal.status”) </code>在redis中会以<code>setmealCache::setmealCache::1413342269393674242_1</code>的方式存储</p><p><img src="image-20231018170050126.png" alt="image-20231018170050126"></p></blockquote><p>@CachePut<br><code>@CachePut</code>的作用主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和@Cacheable不同的是，它每次都会触发真实方法的调用，其主要参数说明如下（其实跟@Cacheable一样）</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring 配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value=(“cache7”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照 SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“testcache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr></tbody></table><p>@CachEvict<br><code>@CachEvict</code>的作用主要针对方法配置，能够根据一定的条件对缓存进行清空</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">缓存的名称，在 spring配置文件中定义，必须指定至少一个</td><td align="center">例如:@Cacheable(value=“mycache”)或者@Cacheable(value={“cache1”, “cache2”]</td></tr><tr><td align="center">key</td><td align="center">缓存的key，可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如:@Cacheable(value=“testcache”,key=“#userName”)</td></tr><tr><td align="center">condition</td><td align="center">缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true 才进行缓存</td><td align="center">例如:@Cacheable(value=“testcache”,condition=“#userName.length()&gt;2”)</td></tr><tr><td align="center">allEntries</td><td align="center">是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存</td><td align="center">例如:@CachEvict(value=“testcache”,allEntries=true)</td></tr><tr><td align="center">beforelnvocation</td><td align="center">是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td align="center">例如:@CachEvict(value=“testcache”, beforelnvocation=true)</td></tr></tbody></table><h4 id="4-3-SpringCache使用方式"><a href="#4-3-SpringCache使用方式" class="headerlink" title="4.3 SpringCache使用方式"></a>4.3 SpringCache使用方式</h4><ul><li>在SpringBoot项目中，使用缓存技术只需要在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存技术支持即可。</li><li>这里我们使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>随后配置application.yml</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: 101.XXX.XXX.160 #这里换成localhost或者你自己的linux上装的redis    password: root    port: 6379    database: 0  cache:    redis:      time-to-live: 3600000 #设置存活时间为一小时，如果不设置，则一直存活</code></pre><h3 id="5-缓存套餐数据"><a href="#5-缓存套餐数据" class="headerlink" title="5. 缓存套餐数据"></a>5. 缓存套餐数据</h3><h4 id="5-1-实现思路"><a href="#5-1-实现思路" class="headerlink" title="5.1 实现思路"></a>5.1 实现思路</h4><ul><li>前面我们已经实现了移动端查看套餐的功能，对应SetmealController中的list方法</li><li>此方法会根据前端提交的查询条件进行数据库查询操作</li><li>在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增强</li><li>现在需要对此方法进行缓存优化，提高系统性能</li><li>具体实现思路如下<ol><li>修改SetmealController中的list方法，先从Redis缓存中获取套餐数据<ul><li>如果有，则直接返回</li><li>如果无，则查询数据库，并将查询到的套餐数据存入Redis</li></ul></li><li>修改SetmealController的save、update方法，加入清理缓存的逻辑，避免产生脏数据（我们实际已经在后台修改/更新/删除了某些套餐，但由于缓存数据未被清理，未重新查询数据库，用户看到的还是我们修改之前的数据）</li></ol></li></ul><h4 id="5-2-代码修改"><a href="#5-2-代码修改" class="headerlink" title="5.2 代码修改"></a>5.2 代码修改</h4><ol><li><p>导入SpringCache和Redis相关的maven坐标</p></li><li><p>在appilcation.yml中配置缓存数据的过期时间</p></li><li><p>在启动类上加上<code>@EnableCaching</code>注解，开启缓存注解功能</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@ServletComponentScan@EnableTransactionManagement@EnableCaching  //开启缓存注解功能public class ReggieApplication {    public static void main(String[] args) throws Exception {        SpringApplication.run(ReggieApplication.class,args);        log.info("项目启动成功...");    }}</code></pre><ol start="4"><li>在SetmealController的list方法上加上<code>@Cacheable</code>注解<br>该注解的功能是：在方法执行前，Spring先查看缓存中是否有数据；如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping("/list")@Cacheable(value = "setmealCache", key = "#setmeal.categoryId + '_' + #setmeal.status")public Result&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal) {    //条件构造器    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加条件    queryWrapper.eq(setmeal.getCategoryId() != null, Setmeal::getCategoryId, setmeal.getCategoryId());    queryWrapper.eq(setmeal.getStatus() != null, Setmeal::getStatus, 1);    //排序    queryWrapper.orderByDesc(Setmeal::getUpdateTime);    List&lt;Setmeal&gt; setmealList = setmealService.list(queryWrapper);    return Result.success(setmealList);}</code></pre><ol start="5"><li>修改SetmealController的save、update和status方法，加入清理缓存的逻辑</li></ol><p>不用修改delete方法，因为只需要编辑status即可，前面有说过</p><p>实现手段也只需要加上<code>@CacheEvict</code>注解，该注解的功能是：将一条或者多条数据从缓存中删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;String&gt; save(@RequestBody SetmealDto setmealDto) {    log.info("套餐信息：{}", setmealDto);    setmealService.saveWithDish(setmealDto);    return Result.success("套餐添加成功");}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PutMapping//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;Setmeal&gt; updateWithDish(@RequestBody SetmealDto setmealDto) {    List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();    Long setmealId = setmealDto.getId();    //先根据id把setmealDish表中对应套餐的数据删了    LambdaQueryWrapper&lt;SetmealDish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.eq(SetmealDish::getSetmealId, setmealId);    setmealDishService.remove(queryWrapper);    //然后在重新添加    setmealDishes = setmealDishes.stream().map((item) -&gt; {        item.setSetmealId(setmealId);        return item;    }).collect(Collectors.toList());    //更新套餐数据    setmealService.updateById(setmealDto);    //更新套餐对应菜品数据    setmealDishService.saveBatch(setmealDishes);    return Result.success(setmealDto);}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping("/status/{status}")//设置allEntries为true，清空缓存名称为setmealCache的所有缓存@CacheEvict(value = "setmealCache", allEntries = true)public Result&lt;String&gt; status(@PathVariable String status, @RequestParam List&lt;Long&gt; ids) {    LambdaUpdateWrapper&lt;Setmeal&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();    updateWrapper.in(Setmeal::getId, ids);    updateWrapper.set(Setmeal::getStatus, status);    setmealService.update(updateWrapper);    return Result.success("批量操作成功");}</code></pre><blockquote><ul><li>在做完这一步之后，会发现报错:<code>DefaultSerializer requires a Serializable payload but received an object of type</code></li><li>这是因为要缓存的JAVA对象必须实现<code>Serializable</code>接口，因为Spring会先将对象序列化再存入Redis，将缓存实体类继承<code>Serializable</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Result&lt;T&gt; implements Serializable</code></pre></blockquote><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><h3 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h3><ul><li>目前我们所有的读和写的压力都是由一台数据库来承担，</li><li>如果数据库服务器磁盘损坏，则数据会丢失（没有备份）</li><li>解决这个问题，就可以用MySQL的主从复制，写操作交给主库，读操作交给从库</li><li>同时将主库写入的内容，同步到从库中</li></ul><p><img src="7d9f6630j00rjzmok002gd0017r00mjp.jpg" alt="img"></p><h3 id="2-MySQL主从复制"><a href="#2-MySQL主从复制" class="headerlink" title="2. MySQL主从复制"></a>2. MySQL主从复制</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的二进制日志功能。就是一台或多台NysQL数据库（slave，即从库）从另一台MySQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。</li><li>MySQL复制过程分成三步:<ol><li><code>maste</code>r将改变记录到二进制日志(<code>binary log</code>)</li><li><code>slave</code>将<code>master</code>的<code>binary log</code>拷贝到它的中继日志(<code>relay log</code>)</li><li><code>slave</code>重做中继日志中的事件，将改变应用到自己的数据库中</li></ol></li></ul><p><img src="2ee25861j00rjzn78000yd000lf00emp.jpg" alt="img"></p><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><ul><li><p>前置条件<br>准备好两台服务器，分别安装MySQL并启动服务成功，我这里用的两台虚拟机（另一台是克隆的，记得修改克隆虚拟机的MySQL的UUID）</p></li><li><p>修改克隆机的MySQL的uuid</p><ol><li>登录克隆机的MySQL</li><li>执行SQL语句，记住生成的uuid，待会需要用</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; select uuid();+--------------------------------------+| uuid()                               |+--------------------------------------+| aaa9efc9-6e25-11ee-9d03-000c294093b6 |+--------------------------------------+</code></pre><ol start="3"><li>查看配置文件目录</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; show variables like 'datadir';+---------------+-----------------+| Variable_name | Value           |+---------------+-----------------+| datadir       | /var/lib/mysql/ |+---------------+-----------------+</code></pre><ol start="4"><li>编辑配置文件目录，修改uuid为刚刚我们生成的uuid</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi /var/lib/mysql/auto.cnf</code></pre><ol start="5"><li>重启服务</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service mysqld restart</code></pre></li><li><p>配置主库，我这里就用虚拟机上的mysql当主库了</p><ol><li><p>修改MySQL数据库的配置文件，虚拟机是</p><pre class="line-numbers language-none"><code class="language-none">/etc/my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入两行</li></ul><pre class="line-numbers language-none"><code class="language-none">log_bin=mysql-bin #[必须]启用二进制日志server-id=100 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</code></pre></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create user nanying identified by 'Root@123456';grant replication slave on *.* to nanying;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行下面的SQL</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show master status;</code></pre><p>记录下结果中File和Position的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      694 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+</code></pre></li><li><p>配置从库，我这里就用我的另一台克隆的虚拟机了</p><ol><li><p>修改MySQL数据库的配置文件</p><pre class="line-numbers language-none"><code class="language-none">/etc/my.cnf</code></pre><ul><li>找到<code>[mysqld]</code>，在下面插入一行</li></ul><blockquote><p>server-id=130 #[必须]服务器唯一ID,只需要确保其id是唯一的就好</p></blockquote></li><li><p>重启mysql服务</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld</code></pre><ol start="3"><li>登录Mysql数据库,执行下面的SQL，将参数修改为你自己的</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">change master to master_host='192.168.71.100',master_user='nanying',master_password='Root@123456',master_log_file='mysql-bin.000001',master_log_pos=694;CHANGE MASTER TO GET_MASTER_PUBLIC_KEY=1; # 修改mysql 8.0之后默认的认证方式start slave;</code></pre><p>上面的SQL的作用是创建一个用户<code>nanying</code>,密码为<code>Root@123456</code>，并且给<code>nanying</code>用户授予<code>replication slave</code>权限，常用语建立复制时所需要用到的用户权限，也就是<code>slave</code>必须被<code>master</code>授权具有该权限的用户，才能通过该用户复制，这是因为主库和从库之间需要互相通信，处于安全考虑，只有通过验证的从库才能从主库中读取二进制数据</p><ol start="4"><li>登录Mysql数据库,执行SQL，查看从库的状态</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show slave status\G</code></pre></li></ul><p>看到如下如下三行配置相同，则主从连接成功</p><blockquote><p>Slave_IO_State: Waiting for master to send event<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes</p></blockquote><h3 id="3-读写分离案例"><a href="#3-读写分离案例" class="headerlink" title="3. 读写分离案例"></a>3. 读写分离案例</h3><h4 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h4><ul><li>面对日益增加的系统访问量，数据库的吞吐量面临着巨大的瓶颈。</li><li>对于同一时刻有<code>大量并发读操作</code>和<code>较少的写操作</code>类型的应用系统来说，将数据库拆分为<code>主库</code>和<code>从库</code></li><li><code>主库</code>主要负责处理事务性的增删改操作</li><li><code>从库</code>主要负责查询操作</li><li>这样就能有效避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善</li></ul><h4 id="3-2-Sharding-JDBC介绍"><a href="#3-2-Sharding-JDBC介绍" class="headerlink" title="3.2 Sharding-JDBC介绍"></a>3.2 Sharding-JDBC介绍</h4><ul><li>Sharding-JDBC定位为轻量级的JAVA框架，在JAVA的JDBC层提供额外的服务，它使得客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</li><li>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离<ul><li>适用于任何基于JDBC的ORM框架</li><li>支持任何第三方的数据库连接池</li><li>支持任意实现JDBC规范的数据库</li></ul></li><li>使用Sharding-JDBC框架的步骤<ol><li>导入对应的maven坐标</li><li>在配置文件中配置读写分离规则</li><li>在配置文件中配置允许bean定义覆盖配置项</li></ol></li></ul><h3 id="4-项目实现读写分离"><a href="#4-项目实现读写分离" class="headerlink" title="4. 项目实现读写分离"></a>4. 项目实现读写分离</h3><ul><li><p>前面我们已经配置好了主从数据库，那么我们现在就用瑞吉外卖试试读写分离</p><ol><li>导入瑞吉外卖的SQL数据</li><li>Git创建一个新分支<code>v1.1</code>，便于我们提交维护</li><li>导入<code>Sharding-JDBC</code>的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="4"><li>在配置文件中配置读写分离规则,配置允许bean定义覆盖配置项<br>配置项可能会爆红，但是不影响影响项目启动，是IDEA的问题</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  shardingsphere:    datasource:      names:        master,slave      master:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql://192.168.71.100:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true        username: root        password: 123456      slave:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql://192.168.71.130:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true        username: root        password: 123456    masterslave:      load-balance-algorithm-type: round_robin      name: dataSource      master-data-source-name: master      slave-data-source-names: slave    props:      sql:        show: true  main:    allow-bean-definition-overriding: true</code></pre></li></ul><blockquote><p>可能遇到的问题</p><ul><li>启动时不报错，但是登陆功能报<code>500</code>异常</li><li>查看控制台出现<code>SQLFeatureNotSupportedException</code>异常</li></ul><p>解决方案</p><ul><li><p>修改pom.xml中druid的maven坐标为</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul></blockquote><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li>Nginx是一款轻量级的<code>Web</code>/<code>反向代理</code>服务器以及电子邮件(IMAP/POP3)代理服务器，其特点是占有内存少，并发能力强。</li><li>事实上Nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用Nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</li><li>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Pam6nep）开发的，第一个公开版本0.1.0发布于2004年10月4日。</li><li>官网：<a href="https://nginx.org/">https://nginx.org/</a></li></ul><h3 id="2-Nginx的下载和安装"><a href="#2-Nginx的下载和安装" class="headerlink" title="2. Nginx的下载和安装"></a>2. Nginx的下载和安装</h3><ul><li><p>官网下载链接：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p></li><li><p>安装过程：</p><ol><li>Nginx是C语言开发的，所以需要先安装依赖</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</code></pre><ol start="2"><li>下载Nginx安装包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wgetwget https://nginx.org/download/nginx-1.24.0.tar.gz</code></pre><ol start="3"><li>解压，我习惯放在<code>/usr/local</code>目录下</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf nginx-1.24.0.tar.gz -C /usr/local/</code></pre><ol start="4"><li>进入到我们解压完毕后的文件夹内</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx-1.24.0/</code></pre><ol start="5"><li>建安装路径文件夹</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/nginx</code></pre><ol start="6"><li>安装前检查工作</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --prefix=/usr/local/nginx</code></pre><ol start="7"><li>编译并安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make &amp;&amp; make install</code></pre></li></ul><h3 id="3-Nginx目录结构"><a href="#3-Nginx目录结构" class="headerlink" title="3. Nginx目录结构"></a>3. Nginx目录结构</h3><ul><li><p>安装完Nginx后，我们先来熟悉一下Nginx的目录结构</p></li><li><p>重点目录/文件:</p><ul><li>conf/nginx.conf<ul><li>nginx配置文件</li></ul></li><li>html<ul><li>存放静态文件(html、css、Js等)</li></ul></li><li>logs<ul><li>日志目录，存放日志文件</li></ul></li><li>sbin/nginx<ul><li>二进制文件，用于启动、停止Nginx服务</li></ul></li></ul></li><li><p>文件目录树状图如下</p></li><li><p>文件目录树状图如下</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── conf                        &lt;-- Nginx配置文件│   ├── fastcgi.conf│   ├── fastcgi.conf.default│   ├── fastcgi_params│   ├── fastcgi_params.default│   ├── koi-utf│   ├── koi-win│   ├── mime.types│   ├── mime.types.default│   ├── nginx.conf              &lt;-- 这个文件我们经常操作│   ├── nginx.conf.default│   ├── scgi_params│   ├── scgi_params.default│   ├── uwsgi_params│   ├── uwsgi_params.default│   └── win-utf├── html                        &lt;-- 存放静态文件，我们后期部署项目，就要将静态文件放在这│   ├── 50x.html        │   └── index.html              &lt;-- 提供的默认的页面├── logs                        &lt;-- 日志目录，由于我们新装的Nginx，所以现在还没有日志文件└── sbin                        └── nginx                       &lt;-- 这个文件我们也经常操作</code></pre><h3 id="4-Nginx配置文件结构"><a href="#4-Nginx配置文件结构" class="headerlink" title="4. Nginx配置文件结构"></a>4. Nginx配置文件结构</h3><ul><li>Nginx配置文件(conf/nginx.conf)整体分为三部分<ul><li>全局块 和Nginx运行相关的全局配置</li><li>events块 和网络连接相关的配置</li><li>http块 代理、缓存、日志记录、虚拟主机配置<ul><li>http全局块</li><li>Server块<ul><li>Server全局块</li><li>location块</li></ul></li></ul></li></ul></li></ul><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">worker_processes  1;                              &lt;-- 全局块  events {                                          &lt;-- events块    worker_connections  1024;  }    http {                                            &lt;-- http块    include       mime.types;                     &lt;-- http全局块    default_type  application/octet-stream;      sendfile        on;      keepalive_timeout  65;        server {                                      &lt;-- Server块        listen       80;                          &lt;-- Server全局块        server_name  localhost;          location / {                              &lt;-- location块            root   html;            index  index.html index.htm;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><p>注意：http块中可以配置多个Server块，每个Server块中可以配置多个location块</p><h3 id="5-Nginx命令"><a href="#5-Nginx命令" class="headerlink" title="5. Nginx命令"></a>5. Nginx命令</h3><ul><li><p>查看版本</p><ul><li>进入sbin目录，输入<code>./nginx -v</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -vnginx version: nginx/1.22.1</code></pre></li><li><p>检查配置文件正确性</p><ul><li>进入sbin目录，输入<code>./nginx -t</code>，如果有错误会报错，而且也会记日志</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</code></pre></li><li><p>启动与停止</p><ul><li>进入sbin目录，输入<code>./nginx</code>，启动完成后查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx [root@localhost sbin]## ps -ef | grep nginxroot      89623      1  0 22:08 ?        00:00:00 nginx: master process ./nginxnobody    89624  89623  0 22:08 ?        00:00:00 nginx: worker processroot      89921   1696  0 22:08 pts/0    00:00:00 grep --color=auto nginx</code></pre><ul><li>如果想停止Nginx服务，输入<code>./nginx -s stop</code>，停止服务后再次查看进程</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost sbin]## ./nginx -s stop[root@localhost sbin]## ps -ef | grep nginxroot      93772   1696  0 22:11 pts/0    00:00:00 grep --color=auto nginx</code></pre></li><li><p>重新加载配置文件</p><ul><li>当修改Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：<code>./nginx -s reload</code>。</li></ul></li></ul><blockquote><ul><li><p>上面的所有命令，都需要我们在sbin目录下才能运行，比较麻烦，所以我们可以将Nginx的二进制文件配置到环境变量中，这样无论我们在哪个目录下，都能使用上面的命令</p></li><li><p>使用<code>vim /etc/profile</code>命令打开配置文件，并配置环境变量，保存并退出</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- PATH=$JAVA_HOME/bin:$PATH+ PATH=/usr/local/nginx/sbin:$JAVA_HOME/bin:$PATH</code></pre></li><li><p>之后重新加载配置文件，使用<code>source /etc/profile</code>命令，然后我们在任意位置输入<code>nginx</code>即可启动服务，<code>nginx -s stop</code>即可停止服务</p></li></ul></blockquote><ul><li>查看自己IP，启动服务后，浏览器输入ip地址就可以访问Nginx的默认页面<ul><li><code>ip addr</code></li></ul></li></ul><h3 id="6-Nginx具体应用"><a href="#6-Nginx具体应用" class="headerlink" title="6. Nginx具体应用"></a>6. Nginx具体应用</h3><h4 id="6-1-部署静态资源"><a href="#6-1-部署静态资源" class="headerlink" title="6.1 部署静态资源"></a>6.1 部署静态资源</h4><ul><li>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</li><li><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效</strong>，所以在生产环境下，一般都会将静态资源部署到Nginx中。</li><li>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</li></ul><h4 id="6-2-反向代理"><a href="#6-2-反向代理" class="headerlink" title="6.2 反向代理"></a>6.2 反向代理</h4><ul><li><code>正向代理</code><ul><li>正向代理是一个位于客户端和原始服务器（origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</li><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。</li><li>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。（梯子）</li></ul></li></ul><p><img src="b7a9bc05j00rk13jv000id000ld008bp.jpg" alt="img"></p><ul><li><p><code>反向代理</code></p><ul><li><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，<strong>反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。</p><ul><li>便于统一管理多台web服务器</li><li>web服务器可能在公司内网，无法直接访问</li></ul></li><li><p><strong>用户不需要知道目标服务器的地址</strong>，也无须在用户端作任何设定。</p></li></ul></li></ul><p><img src="220be961j00rk13nz000rd000q600avp.jpg" alt="img"></p><ul><li><p><code>举个例子</code></p><ul><li>正向代理：你让舍友去给你带三楼卖的煎饼（你最终会得到一个三楼的煎饼）</li><li>反向代理：你让舍友去给你买煎饼（你最终只会得到一个煎饼，但你不知道煎饼是哪儿卖的）</li><li>和正向代理不同，反向代理相当于是为目标服务器工作的，当你去访问某个网站时，你以为你访问问的是目标服务器，其实不然，当你访问时，其实是由一个代理服务器去接收你的请求，正向代理与反向代理最简单的区别： 正向代理隐藏的是用户（卖煎饼的不知道是你要买），反向代理隐藏的是服务器（你不知道煎饼是谁卖的）。</li><li>正向代理侧重的是用户，用户知道可以通过代理访问无法访问的资源，而反向代理侧重点在服务器这边，用户压根不知道自己访问的是资源时通过代理人去转发的。</li></ul></li><li><p><code>配置反向代理</code><br>这里是在<code>192.168.138.100</code>上配置的，那么访问流程如下<br>客户端 –&gt; <code>192.168.138.100:82</code> –&gt; <code>192.168.138.101/50x.html</code><br>客户端访问反向代理服务器的82端口，而82端口又将请求转发给web服务器的<code>50x.html</code>资源<br>注意这里需要开启反向代理服务器的82端口</p></li></ul><p><img src="image-20231019192535504.png" alt="image-20231019192535504"></p><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">server {    listen       82;    server_name  localhost;    location / {        proxy_pass http://http://192.168.138.101/50x.html;    }}</code></pre><h4 id="6-3-负载均衡"><a href="#6-3-负载均衡" class="headerlink" title="6.3 负载均衡"></a>6.3 负载均衡</h4><ul><li>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</li><li>应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据。</li><li>负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理。</li></ul><p><img src="7bec0435j00rk16la000pd000rd0090p.jpg" alt="img"></p><ul><li>配置负载均衡<br>默认是轮询算法，第一次访问是<code>192.168.138.101</code>，第二次访问是<code>101.XXX.XXX.160</code><br>也可以改用权重方式，权重越大，几率越大，现在的访问三分之二是第一台服务器接收，三分之一是第二台服务器接收<br><code>server 192.168.138.101 weight=10</code><br><code>server 101.XXX.XXX.160 weight=5</code></li></ul><pre class="line-numbers language-PROPERTIES" data-language="PROPERTIES"><code class="language-PROPERTIES">upstream targetServer{    server 192.168.138.101;    server 101.XXX.XXX.160;}server {    listen       82;    server_name  localhost;    location / {        proxy_pass http://targetServer;    }}</code></pre><ul><li>负载均衡策略</li></ul><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">默认方式</td></tr><tr><td align="center">weight</td><td align="center">权重方式</td></tr><tr><td align="center">ip_hash</td><td align="center">依据ip分配方式</td></tr><tr><td align="center">least_conn</td><td align="center">依据最少连接方式</td></tr><tr><td align="center">url_hash</td><td align="center">依据url分配方式</td></tr><tr><td align="center">fair</td><td align="center">依据响应时间方式</td></tr></tbody></table><h3 id="7-Nginx的特点"><a href="#7-Nginx的特点" class="headerlink" title="7. Nginx的特点"></a>7. Nginx的特点</h3><ol><li>跨平台：Nginx可以在大多数操作系统中运行，而且也有Windows的移植版本</li><li>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置</li><li>非阻塞、高并发：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2-3万并发连接数（这得益于Nginx使用了最新的epoll模型）</li><li>事件驱动：通信机制采用epoll模式，支持更大的并发连接数</li><li>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx进程才消耗150M内存（15M*10=150M）</li><li>成本低廉：Nginx作为开源软件，可以免费试用。而购买F5 BIG-IP、NetScaler等硬件负载均衡交换机则需要十多万至几十万人民币</li><li>内置健康检查功能：如果Nginx Proxy后端的某台Web服务器宕机了，不会影响前端访问。</li><li>节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头。</li><li>稳定性高：用于反向代理，宕机的概率微乎其微。</li></ol><h2 id="前后端分离开发"><a href="#前后端分离开发" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h2><ul><li>开发人员同时负责前端和后端代码开发，分工不明确，开发效率低</li><li>前后端代码混合在一个工程中，不便于管理</li><li>对开发人员要求高，人员招聘困难</li><li>所以衍生出了一种前后端分离开发</li></ul><h3 id="1-前后端分离开发"><a href="#1-前后端分离开发" class="headerlink" title="1. 前后端分离开发"></a>1. 前后端分离开发</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li><code>前后端分离开发</code>，就是在项目开发过程中，对前端代码的开发，专门由<code>前端开发人员</code>负责，后端代码由<code>后端开发人员</code>负责，这样可以做到分工明确，各司其职，提高开发效率，前后端代码并行开发，可以加快项目的开发速度。目前，前后端分离开发方式已经被越来越多的公司采用了，成为现在项目开发的主流开发方式。</li><li>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为<code>前端工程和后端工程</code></li></ul><p><img src="74b098faj00rk1epy000md000r80093p.jpg" alt="img"></p><h4 id="1-2-开发流程"><a href="#1-2-开发流程" class="headerlink" title="1.2 开发流程"></a>1.2 开发流程</h4><ul><li>前后端开发人员都参照接口API文档进行开发</li><li>接口（API接口） 就是一个http的请求地址，主要就是去定义：请求路径、请求方式、请求参数、响应参数等内容。</li></ul><p><img src="2583d817j00rk1era000md000oj00byp.jpg" alt="img"></p><h3 id="2-YApi"><a href="#2-YApi" class="headerlink" title="2. YApi"></a>2. YApi</h3><h4 id="2-1-介绍-1"><a href="#2-1-介绍-1" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护API，YApi还为用户提供了优秀的交互体验，开发人员只需要利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</li><li>YApi让接口开发更简单高效，让接口的管理更具有可读性、可维护性，让团队协作更合理。</li><li>Git仓库：<a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></li></ul><h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><p>需要首先在本地配置</p><ul><li>使用YApi，可以执行下面操作：<ul><li>添加项目</li><li>添加分类</li><li>添加接口</li><li>编辑接口</li><li>查看接口</li></ul></li></ul><h3 id="3-Swagger"><a href="#3-Swagger" class="headerlink" title="3. Swagger"></a>3. Swagger</h3><h4 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h4><ul><li>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做成各种格式的接口文档，以及在线接口调试页面等。</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><h4 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h4><ol><li>导入对应的maven坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>导入knife4j相关配置，并配置静态资源映射，否则接口文档页面无法访问，注意将controller的包路径修改为你自己的</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@Slf4j@EnableSwagger2 //+@EnableKnife4j //+public class WebMvcConfig extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        log.info("开始进行静态资源映射...");        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");        // 设置静态资源映射        registry.addResourceHandler("doc.html").addResourceLocations("classpath:/META-INF/resources/");//+        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");//+    }    @Override    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();        //设置对象转化器，底层使用jackson将java对象转为json        messageConverter.setObjectMapper(new JacksonObjectMapper());        //将上面的消息转换器对象追加到mvc框架的转换器集合当中(index设置为0，表示设置在第一个位置，避免被其它转换器接收，从而达不到想要的功能)        converters.add(0, messageConverter);    }    //+    @Bean    public Docket createRestApi() {        //文档类型        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage("com.blog.controller"))                .paths(PathSelectors.any())                .build();    }    //+    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title("瑞吉外卖")                .version("1.0")                .description("瑞吉外卖接口文档")                .build();    }}</code></pre><ol start="3"><li>在拦截器在中设置不需要处理的请求路径</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义不需要处理的请求String[] urls = new String[]{        "/employee/login",        "/employee/logout",        "/backend/**",        "/front/**",        "/common/**",        //对用户登陆操作放行        "/user/login",        "/user/sendMsg",        "/doc.html",        "/webjars/**",        "/swagger-resources",        "/v2/api-docs"};</code></pre><ol start="4"><li>启动服务，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 即可看到生成的接口文档，我这里的端口号用的80，根据自己的需求改</li></ol><p><img src="image-20231020105144839.png" alt="image-20231020105144839"></p><h4 id="3-3-常用注解"><a href="#3-3-常用注解" class="headerlink" title="3.3 常用注解"></a>3.3 常用注解</h4><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Api</td><td align="center">用在请求的类上，例如Controller，表示对类的说明</td></tr><tr><td align="center">@ApiModel</td><td align="center">用在类上，通常是个实体类，表示一个返回响应数据的信息</td></tr><tr><td align="center">@ApiModelProperty</td><td align="center">用在属性上，描述响应类的属性</td></tr><tr><td align="center">@ApiOperation</td><td align="center">用在请求的方法上，说明方法的用途、作用</td></tr><tr><td align="center">@ApilmplicitParams</td><td align="center">用在请求的方法上，表示一组参数说明</td></tr><tr><td align="center">@ApilmplicitParam</td><td align="center">用在@ApilmplicitParams注解中，指定一个请求参数的各个方面</td></tr></tbody></table><ul><li>加上这些注解，可以将我们生成的接口文档更规范</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@ApiModel("用户")public class User implements Serializable {    private static final long serialVersionUID = 1L;    @ApiModelProperty("主键")    private Long id;    //姓名    @ApiModelProperty("姓名")    private String name;    //手机号    @ApiModelProperty("手机号")    private String phone;    //性别 0 女 1 男    @ApiModelProperty("性别 0 女 1 男")    private String sex;    //身份证号    @ApiModelProperty("身份证号")    private String idNumber;    //头像    @ApiModelProperty("头像")    private String avatar;    //状态 0:禁用，1:正常    @ApiModelProperty("状态 0:禁用，1:正常")    private Integer status;}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@Slf4j@RequestMapping("/user")@Api(tags = "用户相关接口")public class UserController {    @Autowired    private UserService userService;    @Autowired    private RedisTemplate redisTemplate;    @PostMapping("/sendMsg")    @ApiOperation("发送验证邮件接口")    public Result&lt;String&gt; sendMsg(@RequestBody User user) throws MessagingException {        String phone = user.getPhone();        if (!phone.isEmpty()) {            //随机生成一个验证码            String code = MailUtils.achieveCode();            log.info(code);            //这里的phone其实就是邮箱，code是我们生成的验证码            MailUtils.sendTestMail(phone, code);            //验证码缓存到Redis，设置存活时间5分钟            redisTemplate.opsForValue().set(phone, code,5, TimeUnit.MINUTES);            return Result.success("验证码发送成功");        }        return Result.error("验证码发送失败");    }    @PostMapping("/login")    @ApiOperation("用户登录接口")    @ApiImplicitParam(name = "map",value = "map集合接收数据",required = true)    public Result&lt;User&gt; login(@RequestBody Map map, HttpSession session) {        log.info(map.toString());        String phone = map.get("phone").toString();        String code = map.get("code").toString();        //把Redis中缓存的code拿出来        Object codeInRedis = redisTemplate.opsForValue().get(phone);        //看看接收到用户输入的验证码是否和redis中的验证码相同        log.info("你输入的code{}，redis中的code{}，计算结果为{}", code, codeInRedis, (code != null &amp;&amp; code.equals(codeInRedis)));        if (code != null &amp;&amp; code.equals(codeInRedis)) {            LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(User::getPhone, phone);            User user = userService.getOne(queryWrapper);            if (user == null) {                user = new User();                user.setPhone(phone);                user.setName("用户" + codeInRedis);                userService.save(user);            }            session.setAttribute("user", user.getId());            //如果登陆成功，则删除Redis中的验证码            redisTemplate.delete(phone);            return Result.success(user);        }        return Result.error("登录失败");    }    @PostMapping("/loginout")    @ApiOperation("用户登出接口")    public Result&lt;String&gt; logout(HttpServletRequest request) {        request.getSession().removeAttribute("user");        return Result.success("退出成功");    }}</code></pre><ul><li>重新启动服务器，访问 <a href="http://localhost/doc.html">http://localhost/doc.html</a> 查看新生成的接口文档，可读性比之前提高了</li></ul><p><img src="052f1c67j00rk1ih8003pd001hc00qtp.jpg" alt="img"></p><h3 id="4-项目部署"><a href="#4-项目部署" class="headerlink" title="4. 项目部署"></a>4. 项目部署</h3><h4 id="4-1-配置环境说明"><a href="#4-1-配置环境说明" class="headerlink" title="4.1 配置环境说明"></a>4.1 配置环境说明</h4><p>一共需要三台服务器</p><ul><li>192.168.138.100（服务器A）<ul><li>Nginx：部署前端项目、配置反向代理</li><li>MySql：主从复制结构中的主库</li></ul></li><li>192.168.138.101（服务器B）<ul><li>jdk：运行java项目</li><li>git：版本控制工具</li><li>maven：项目构建工具</li><li>jar：Spring Boot 项目打成jar包基于内置Tomcat运行</li><li>MySql：主从复制结构中的从库</li></ul></li><li>101.xxx.xxx.160（服务器C，我用的我的云服务器）<ul><li>Redis：缓存中间件</li></ul></li></ul><p><img src="image-20231020111216958.png" alt="image-20231020111216958"></p><h4 id="4-2-部署前端项目"><a href="#4-2-部署前端项目" class="headerlink" title="4.2 部署前端项目"></a>4.2 部署前端项目</h4><ol><li>在服务器A中安装Nginx，将前端项目<code>打包</code>目录上传到Nginx的html目录下</li><li>修改Nginx配置文件nginx.conf，新增如下配置</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server {    listen 80;    server_name localhost;    location / {        root html/dist;        index index.html;    }    location ^~ /api/ {        rewrite ^/api/(.*)$ /$1 break;        proxy_pass http://192.168.238.132;    }}</code></pre><p><img src="image-20231020150600309.png" alt="image-20231020150600309"></p><p>请求 <a href="http://192.168.138.100/api/employee/login">http://192.168.138.100/api/employee/login</a> 转到 <a href="http://192.168..138.101:8080/employee/login">http://192.168..138.101:8080/employee/login</a></p><h4 id="4-3-部署后端项目"><a href="#4-3-部署后端项目" class="headerlink" title="4.3 部署后端项目"></a>4.3 部署后端项目</h4><ul><li>在服务器B中安装JDK，Git，MySql</li><li>将项目打成jar包，手动上传并部署（当然你也可以选择git拉取代码，然后shell脚本自动部署）</li><li>部署完后端项目之后，我们就能完成正常的登录功能了，也能进入到后台系统进行增删改查操作</li><li>图片上传路径可以修改为：/usr/local/img</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/08/29/Redis/"/>
      <url>/2023/08/29/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Redis入门"><a href="#1-Redis入门" class="headerlink" title="1. Redis入门"></a>1. Redis入门</h2><ul><li>Redis是一个基于内存的<code>key-value</code>结构数据库<ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、咨询、新闻）</li></ul></li><li>官网：<a href="https://redis.io/">https://redis.io/</a></li></ul><h3 id="1-1-Redis简介"><a href="#1-1-Redis简介" class="headerlink" title="1.1 Redis简介"></a>1.1 Redis简介</h3><ul><li>Redis是用C语言开发的一个开源的、高性能的键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化NoSql数据库</li><li>NoSql(Not Only Sql)，不仅仅是SQL，泛指非关系型数据库，NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充</li></ul><blockquote><p>关系型数据库(RDBMS)：MySQL、Oracl、DB2、SQLServer<br>非关系型数据库(NoSql)：Redis、Mongo DB、MemCached</p></blockquote><ul><li>Redis应用场景：缓存、消息队列、任务队列、分布式锁</li></ul><h3 id="1-2-下载与安装"><a href="#1-2-下载与安装" class="headerlink" title="1.2 下载与安装"></a>1.2 下载与安装</h3><ul><li>这里我们在Linux和Windows上都装一下<ul><li>Windows 版：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>Linux 版：<a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li></ul></li></ul><h4 id="1-2-1-Windows安装Redis"><a href="#1-2-1-Windows安装Redis" class="headerlink" title="1.2.1 Windows安装Redis"></a>1.2.1 Windows安装Redis</h4><ul><li>Windows 版：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>直接下载对应版本的<code>.zip</code>压缩包，直接解压之后</li></ul><h4 id="1-2-2-Linux安装Redis"><a href="#1-2-2-Linux安装Redis" class="headerlink" title="1.2.2 Linux安装Redis"></a>1.2.2 Linux安装Redis</h4><ul><li><p>Linux系统安装Redis步骤：</p><ol><li>将Redis安装包上传到Linux</li><li>解压安装包，改成你自己的redis版本，路径我习惯解压到<code>/usr/local</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf redisVersion.tar.gz -C /usr/local</code></pre><ol><li>安装Redis的依赖环境gcc，我的云服务器已经装过了，本地的Linux还没装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 安装依赖环境yum install gcc-c++</code></pre><ol><li>进入<code>/usr/local/redis根目录</code>，进行编译</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 进入到根目录cd /usr/local/redis根目录## 编译make</code></pre><ol><li>进入redis的src目录，进行安装</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 进入到src目录cd /usr/local/redis根目录/src## 进行安装make install</code></pre></li></ul><h3 id="1-3-服务启动与停止"><a href="#1-3-服务启动与停止" class="headerlink" title="1.3 服务启动与停止"></a>1.3 服务启动与停止</h3><h4 id="1-3-1-Linux启动与停止"><a href="#1-3-1-Linux启动与停止" class="headerlink" title="1.3.1 Linux启动与停止"></a>1.3.1 Linux启动与停止</h4><ul><li>进入到<code>/src</code>目录下，执行<code>redis-server</code>即可启动服务，默认端口号为<code>6379</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 进入到根目录cd /usr/local/redis根目录/src## 执行redis-server./redis-server</code></pre><h4 id="1-3-2-Linux设置后台运行"><a href="#1-3-2-Linux设置后台运行" class="headerlink" title="1.3.2 Linux设置后台运行"></a>1.3.2 Linux设置后台运行</h4><ul><li>进入到redis根目录下，修改配置redis.conf文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 进入到redis根目录下cd /usr/local/redis根目录## 修改配置文件vim redis.conf</code></pre><ul><li>找到<code>daemonize on</code>字段，将其修改为<code>daemonize yes</code></li><li>在redis根目录以redis.conf作为配置文件在后台运行</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src/redis-server ./redis.conf</code></pre><h4 id="1-3-3-Linux开启密码校验"><a href="#1-3-3-Linux开启密码校验" class="headerlink" title="1.3.3 Linux开启密码校验"></a>1.3.3 Linux开启密码校验</h4><ul><li>还是修改redis.conf配置文件，找到<code>requirepass</code>这行，将其注释去掉，并在后面写上自己的密码</li><li><img src="image-20231017143940579.png" alt="image-20231017143940579"></li><li>然后杀掉原进程再重新启动</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 重新启动src/redis-server ./redis.conf ## 登录时同时进行认证src/redis-cli -h localhost -p 6379 -a 密码</code></pre><ul><li>修改完毕之后还是杀进程，然后重启服务</li></ul><h4 id="1-3-4-Linux开启远程连接"><a href="#1-3-4-Linux开启远程连接" class="headerlink" title="1.3.4 Linux开启远程连接"></a>1.3.4 Linux开启远程连接</h4><ul><li>还是修改redis.conf配置文件，找到<code>bind 127.0.0.1</code>这行，把这行注释掉</li><li>之后设置防火墙，开启6379端口</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 开启6379端口firewall-cmd --zone=public --add-port=6379/tcp --permanent## 设置立即生效firewall-cmd --reload## 查看开放的端口firewall-cmd --zone=public --list-ports</code></pre><ul><li>最后在Windows的redis根目录下，按住Shift+右键打开PowerShell窗口，连接Linux的Redis</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.\redis-cli.exe -h 服务器地址 -p 6379 -a 密码</code></pre><h2 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5中常用的数据类型</p><ul><li>字符串：String</li><li>哈希：Hash</li><li>列表：List</li><li>集合：Set</li><li>有序集合：Sorted Set</li></ul><p><img src="image-20231017151730555.png" alt="image-20231017151730555"></p><h3 id="2-2-字符串-String-常用命令"><a href="#2-2-字符串-String-常用命令" class="headerlink" title="2.2 字符串(String)常用命令"></a>2.2 字符串(String)常用命令</h3><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SET key value</td><td align="center">设置指定key的值</td></tr><tr><td align="center">GET key</td><td align="center">获取指定key的值</td></tr><tr><td align="center">SETEX key seconds value</td><td align="center">设置指定key的值，并将key的过期时间设为seconds秒</td></tr><tr><td align="center">SETNX key value</td><td align="center">只有在key不存在时设置key的值</td></tr></tbody></table><h3 id="2-3-哈希-Hash-常用命令"><a href="#2-3-哈希-Hash-常用命令" class="headerlink" title="2.3 哈希(Hash)常用命令"></a>2.3 哈希(Hash)常用命令</h3><p><code>Redis Hash</code>是一个<code>String</code>类型的<code>Field</code>和<code>Value</code>的映射表，<code>Hash</code>特别适合用于存储对象</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HSET key field value</td><td align="center">将哈希表key 中的字段field的值设为value</td></tr><tr><td align="center">HGET key field</td><td align="center">获取存储在哈希表key中指定字段field的值</td></tr><tr><td align="center">HDEL key field</td><td align="center">删除存储在哈希表key中的指定字段field</td></tr><tr><td align="center">HKEYS key</td><td align="center">获取哈希表key中所有字段</td></tr><tr><td align="center">HVALS key</td><td align="center">获取哈希表key中所有值</td></tr><tr><td align="center">HGETALL key</td><td align="center">获取在哈希表中指定key的所有字段和值</td></tr></tbody></table><h3 id="2-4-列表-List-常用命令"><a href="#2-4-列表-List-常用命令" class="headerlink" title="2.4 列表(List)常用命令"></a>2.4 列表(List)常用命令</h3><p><code>Redis List</code>是简单的字符串列表，按照插入顺序排序</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>LPUSH</code> key value1 [value2]</td><td align="center">将一个或多个值插入到列表key头部</td></tr><tr><td align="center"><code>LRANGE</code> key start stop</td><td align="center">获取列表key指定范围内的元素</td></tr><tr><td align="center"><code>RPOP</code> key</td><td align="center">移除并获取列表key最后一个元素</td></tr><tr><td align="center"><code>LLEN</code> key</td><td align="center">获取列表key长度</td></tr><tr><td align="center"><code>BRPOP</code> key1 [key2] timeout</td><td align="center">移出并获取列表key的最后一个元素（如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）</td></tr></tbody></table><h3 id="2-5-集合-Set-常用命令"><a href="#2-5-集合-Set-常用命令" class="headerlink" title="2.5 集合(Set)常用命令"></a>2.5 集合(Set)常用命令</h3><p><code>Redis set</code>是<code>String</code>类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SADD key member1 [member2]</td><td align="center">向集合添加一个或多个成员</td></tr><tr><td align="center">SMEMBERS key</td><td align="center">返回集合中的所有成员</td></tr><tr><td align="center">SCARD key</td><td align="center">获取集合的成员数</td></tr><tr><td align="center">SINTER key1 [key2]</td><td align="center">返回给定所有集合的交集</td></tr><tr><td align="center">SUNION key1 [key2]</td><td align="center">返回所有给定集合的并集</td></tr><tr><td align="center">SDIFF key1 [key2]</td><td align="center">返回给定所有集合的差集（key1 - key2）</td></tr><tr><td align="center">SREM key member1 [member2]</td><td align="center">移除集合中一个或多个成员</td></tr></tbody></table><h3 id="2-6-有序集合-Sorted-Set-常用命令"><a href="#2-6-有序集合-Sorted-Set-常用命令" class="headerlink" title="2.6 有序集合(Sorted Set)常用命令"></a>2.6 有序集合(Sorted Set)常用命令</h3><p><code>Redis Sorted Set</code>有序集合是<code>String</code>类型元素的集合，且不允许重复的成员。每个元素都会关联一个<code>double</code>类型的分数(<code>score</code>) 。<code>Redis</code>正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ZADD key score1 member1 [score2 member2]</td><td align="center">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="center">ZRANGE key start stop [WITHSCORES]</td><td align="center">通过索引区间返回有序集合中指定区间内的成员【同时展示对应的分数】</td></tr><tr><td align="center">ZINCRBY key increment member</td><td align="center">有序集合中对指定成员的分数加上增量increment</td></tr><tr><td align="center">ZREM key member [member …]</td><td align="center">移除有序集合中的一个或多个成员</td></tr></tbody></table><h3 id="2-7-通用命令"><a href="#2-7-通用命令" class="headerlink" title="2.7 通用命令"></a>2.7 通用命令</h3><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">KEYs pattern</td><td align="center">查找所有符合给定模式(pattern)的key</td></tr><tr><td align="center">EXISTs key</td><td align="center">检查给定key是否存在</td></tr><tr><td align="center">TYPE key</td><td align="center">返回key所储存的值的类型</td></tr><tr><td align="center">TTL key</td><td align="center">返回给定key的剩余生存时间(TTL, time to live)，以秒为单位</td></tr><tr><td align="center">DEL key</td><td align="center">该命令用于在key存在时删除key</td></tr></tbody></table><p>更多详细的命令可以查看官方文档：<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a></p><h2 id="3-在Java中使用Redis"><a href="#3-在Java中使用Redis" class="headerlink" title="3. 在Java中使用Redis"></a>3. 在Java中使用Redis</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul><li>Redis的Java客户端有很多，官方推荐的有三种<ul><li><code>Jedis</code></li><li><code>Lettuce</code></li><li><code>Redisson</code></li></ul></li><li>Spring对Redis客户端进行了整合，提供了SpringDataRedis，在Spring Boot项目中还提供了对应的Starter，即<code>spring-boot-starter-data-redis</code></li></ul><h3 id="3-2-Jedis"><a href="#3-2-Jedis" class="headerlink" title="3.2 Jedis"></a>3.2 Jedis</h3><ul><li>使用Jedis的步骤<ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol></li><li>在此之前我们需要导入一下Jedis的maven坐标</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>编写测试类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass RedisTestApplicationTests {    @Test    void contextLoads() {        //1. 获取连接        Jedis jedis = new Jedis("localhost", 6379);        //2. 执行具体操作        jedis.set("name", "Hades");        jedis.hset("stu", "name", "Jerry");        jedis.hset("stu", "age", "18");        jedis.hset("stu", "num", "4204000400");        Map&lt;String, String&gt; map = jedis.hgetAll("stu");        Set&lt;String&gt; keySet = map.keySet();        for (String key : keySet) {            String value = map.get(key);            System.out.println(key + ":" + value);        }        String name = jedis.get("name");        System.out.println(name);        //3. 关闭连接        jedis.close();    }}</code></pre><ul><li>输出结果</li></ul><blockquote><p>num:4204000400<br>name:Jerry<br>age:18<br>Hades</p></blockquote><ul><li>Jedis我们了解一下即可，大多数情况下我们还是用SpringDataRedis的</li></ul><h3 id="3-3-Spring-Data-Redis"><a href="#3-3-Spring-Data-Redis" class="headerlink" title="3.3 Spring Data Redis"></a>3.3 Spring Data Redis</h3><ul><li>SpringBoot项目中，可以使用SpringDataRedis来简化Redis（常用）</li><li>Spring Data Redis中提供了一个高度封装的类：RedisTemplate，针对jedis客户端中大量api进行了归类封装，将同一类型操作封装为operation接口，具体分类如下：<ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对map类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul></li><li>使用SpringDataRedis，我们首先需要导入它的maven坐标</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Spring Boot-redis的依赖包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>之后重新设置一下序列化器，防止出现乱码，在config包下创建<code>RedisConfig</code>配置类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfig extends CachingConfigurerSupport {    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        //默认的Key序列化器为：JdkSerializationRedisSerializer        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setConnectionFactory(connectionFactory);        return redisTemplate;    }}</code></pre><ul><li>随后配置一下连接redis的相关配置</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379    #password: root    database: 0 #操作的是0号数据库    jedis:      #Redis连接池配置      pool:        max-active: 8 #最大连接数        max-wait: 1ms #连接池最大阻塞等待时间        max-idle: 4 #连接池中的最大空闲连接        min-idle: 0 #连接池中的最小空闲连接</code></pre><ul><li><code>String</code>类型数据操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid stringTest() {    //获取对象    ValueOperations valueOperations = redisTemplate.opsForValue();    //设置name为Hades    valueOperations.set("name","Hades");    String name = (String) valueOperations.get("name");    System.out.println(name);    //设置age为9527，有效时间10秒    valueOperations.set("age", "9527", 10, TimeUnit.SECONDS);    String age = (String) valueOperations.get("age");    System.out.println(age);    //如果不存在，则设置name为Kyle    Boolean aBoolean = valueOperations.setIfAbsent("name", "Kyle");    System.out.println(aBoolean);}</code></pre><p>输出结果如下，由于name已经存在，故Kyle设置失败，最后返回false，10秒过后，我们再去redis中get name，则输出<code>nil</code>，表示不存在</p><blockquote><p>Hades<br>9527<br>false</p></blockquote><ul><li><code>Hash</code>类型数据操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid hashTest() {    HashOperations hashOperations = redisTemplate.opsForHash();    hashOperations.put("4204000400", "name", "Hades");    hashOperations.put("4204000400", "age", "18");    hashOperations.put("4204000400", "hobby", "Apex");    //获取map集合    Map&lt;String, String&gt; map = hashOperations.entries("4204000400");    Set&lt;String&gt; keySet = map.keySet();    for (String hashKey : keySet) {        System.out.println(hashKey + ":" + map.get(hashKey));    }    System.out.println("$$$$$$$$$$$$$$$");    //只获取keys    Set&lt;String&gt; keys = hashOperations.keys("4204000400");    for (String key : keys) {        System.out.println(key);    }    System.out.println("$$$$$$$$$$$$$$$");    //只获取values    List&lt;String&gt; values = hashOperations.values("4204000400");    for (String value : values) {        System.out.println(value);    }}</code></pre><p>输出结果如下</p><blockquote><p>name:Hades<br>age:18<br>hobby:Apex<br>$$$$$$$$$$$$$$$<br>name<br>age<br>hobby<br>$$$$$$$$$$$$$$$<br>Hades<br>18<br>Apex</p></blockquote><ul><li><code>List</code>类型数据操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid listTest() {    ListOperations listOperations = redisTemplate.opsForList();    //存数据    listOperations.leftPush("testData", "A");    listOperations.leftPushAll("testData", "B", "C", "D");    List&lt;String&gt; testDatas = listOperations.range("testData", 0, -1);    //遍历    for (String tableData : testDatas) {        System.out.print(tableData + " ");    }    System.out.println();    //获取当前list长度，用于遍历    Long size = listOperations.size("testData");    int value = size.intValue();    //遍历输出并删除    for (int i = 0; i &lt; value; i++) {        System.out.print(listOperations.leftPop("testData") + " ");    }    //最后输出一下当前list长度    System.out.println();    System.out.println(listOperations.size("testData"));}</code></pre><p>输出结果如下</p><blockquote><p>D C B A<br>D C B A<br>0</p></blockquote><ul><li><code>Set</code>类型数据操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid setTest() {    SetOperations setOperations = redisTemplate.opsForSet();    //存数据，这里存了两个a    setOperations.add("tmp", "a", "b", "c", "d", "a");    遍历输出    Set&lt;String&gt; tmpData = setOperations.members("tmp");    for (String value : tmpData) {        System.out.print(value + " ");    }    System.out.println();    System.out.println("$$$$$$$$$$$$$$$$$$$");    //删除bc    setOperations.remove("tmp", "b", "c");    //再次遍历输出    tmpData = setOperations.members("tmp");    for (String value : tmpData) {        System.out.print(value + " ");    }}</code></pre><p>输出结果如下，符合预期</p><blockquote><p>d b c a<br>$$$$$$$$$$$$$$$$$$$<br>d a</p></blockquote><ul><li><code>ZSet</code>类型数据操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid zsetTest() {    ZSetOperations zSetOperations = redisTemplate.opsForZSet();    //存值    zSetOperations.add("myZset", "a", 0.0);    zSetOperations.add("myZset", "b", 1.0);    zSetOperations.add("myZset", "c", 2.0);    zSetOperations.add("myZset", "a", 3.0);    //取值    Set&lt;String&gt; myZset = zSetOperations.range("myZset", 0, -1);    for (String s : myZset) {        System.out.println(s);    }    //修改分数    zSetOperations.incrementScore("myZset", "b", 4.0);    //取值    System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$");    myZset = zSetOperations.range("myZset", 0, -1);    for (String s : myZset) {        System.out.println(s);    }    //删除成员    zSetOperations.remove("myZset", "a", "b");    //取值    System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$");    myZset = zSetOperations.range("myZset", 0, -1);    for (String s : myZset) {        System.out.println(s);    }}</code></pre><p>输出结果如下</p><blockquote><p>b<br>c<br>a<br>$$$$$$$$$$$$$$$$$$$$$$$$$<br>c<br>a<br>b<br>$$$$$$$$$$$$$$$$$$$$$$$$$<br>c</p></blockquote><ul><li>通用的数据类型操作</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid commonTest() {    //查看所有key    Set&lt;String&gt; keys = redisTemplate.keys("*");    for (String key : keys) {        System.out.println(key);    }    //查看是否存在指定key    System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$");    System.out.println(redisTemplate.hasKey("Random"));    System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$");    //删除指定key，并再次查看    redisTemplate.delete("myZset");    keys = redisTemplate.keys("*");    for (String key : keys) {        System.out.println(key);    }    System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$");    //输出指定key的类型    System.out.println(redisTemplate.type("tmp"));}</code></pre><p>输出结果如下</p><blockquote><p>tmp<br>name<br>4204000400<br>stu<br>myData<br>$$$$$$$$$$$$$$$$$$$$$$$$$<br>false<br>$$$$$$$$$$$$$$$$$$$$$$$$$<br>tmp<br>name<br>4204000400<br>stu<br>myData<br>$$$$$$$$$$$$$$$$$$$$$$$$$<br>SET</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/08/01/SpringBoot/"/>
      <url>/2023/08/01/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是Spring家族中比较重要的一门技术课程——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发Spring程序不用SpringBoot那就是给自己过不去，SpringBoot为我们开发Spring程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。</p><p>​正如上面提到的，这门技术是用来加速开发Spring程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少Spring怎么回事，与Spring配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。</p><h3 id="课程内容说明"><a href="#课程内容说明" class="headerlink" title="课程内容说明"></a>课程内容说明</h3><p>​SpringBoot这门技术课程所包含的技术点其实并不是很多，但是围绕着SpringBoot的周边知识，也就是SpringBoot整合其他技术，这样的知识量很大，例如SpringBoot整合MyBatis等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。</p><table><thead><tr><th>学习者</th><th>归类方式</th></tr></thead><tbody><tr><td><strong>小白</strong></td><td>完全没有用过SpringBoot技术</td></tr><tr><td><strong>初学者</strong></td><td>能使用SpringBoot技术完成基础的SSM整合</td></tr><tr><td><strong>开发者</strong></td><td>能使用SpringBoot技术实现常见的技术整合工作</td></tr></tbody></table><p>​简单说就是你能用SpringBoot做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将SpringBoot技术划分成4个单元，每个单元是针对不同的学习者准备的。</p><table><thead><tr><th>学习者</th><th>课程单元</th></tr></thead><tbody><tr><td><strong>小白</strong></td><td><font color="#ff0000"><b>基础篇</b></font></td></tr><tr><td><strong>初学者</strong></td><td><font color="#cc0000"><b>应用篇</b></font>（  运维实用篇  &amp;  开发实用篇  ）</td></tr><tr><td><strong>开发者</strong></td><td><font color="#990000"><b>原理篇</b></font></td></tr></tbody></table><p>​看完这个划分你就应该有这么个概念，我没有用过SpringBoot技术，所以从基础篇开始学习；或者我会一点SpringBoot技术，那我从实用篇开始学就好了，就是这个意思。</p><p>​每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着<font color="#ff0000"><b>基础篇</b></font>在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了<font color="#990000"><b>原理篇</b></font>讲解了，应用相关的内容统一放到<font color="#cc0000"><b>应用篇</b></font>里面讲解，你在<font color="#ff0000"><b>基础篇</b></font>阶段纠结也没有用，这一部分不讲这些知识，在<font color="#ff0000"><b>基础篇</b></font>先把SpringBoot的基础使用掌握完再说后面的知识吧。</p><p>​此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个<strong>番外篇</strong>。番外篇的设置为了解决如下问题：</p><ul><li>持续更新SpringBoot后续发展出现的新技术</li><li>讲解部分知识点规模较大的支线知识（例如WebFlux）</li><li>扩展非实用性知识，扩展学习者视野</li></ul><p>​每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。</p><table><thead><tr><th>课程单元</th><th>学习目标</th></tr></thead><tbody><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>能够创建SpringBoot工程<br>基于SpringBoot实现ssm/ssmp整合</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>能够掌握SpringBoot程序多环境开发<br>能够基于Linux系统发布SpringBoot工程<br>能够解决线上灵活配置SpringBoot工程的需求<br>能够基于SpringBoot整合任意第三方技术</td></tr><tr><td><font color="#990000"><b>原理篇</b></font></td><td>掌握SpringBoot内部工作流程<br>理解SpringBoot整合第三方技术的原理<br>实现自定义开发整合第三方技术的组件</td></tr><tr><td><strong>番外篇</strong></td><td>掌握SpringBoot整合非常见的第三方技术<br>掌握相同领域的更多的解决方案，并提升同领域方案设计能力</td></tr></tbody></table><p>​整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。</p><h3 id="课程前置知识说明"><a href="#课程前置知识说明" class="headerlink" title="课程前置知识说明"></a>课程前置知识说明</h3><table><thead><tr><th>课程单元</th><th>前置知识</th><th>要求</th></tr></thead><tbody><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Java基础语法</td><td>面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Spring与SpringMVC</td><td>知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Mybatis与Mybatis-Plus</td><td>基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>数据库MySQL</td><td>能够读懂基础CRUD功能的SQL语句</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>服务器</td><td>知道服务器与web工程的关系，熟悉web服务器的基础配置</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>maven</td><td>知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>web技术（含vue，ElementUI)</td><td>知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>Linux（CenterOS7）</td><td>熟悉常用的Linux基础指令，熟悉Linux系统目录结构</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>实用开发技术</td><td>缓存：Redis、MongoDB、……<br>消息中间件:RocketMq、RabbitMq、……</td></tr><tr><td><font color="#990000"><b>原理篇</b></font></td><td>Spring</td><td>了解Spring加载bean的各种方式<br>知道Spring容器底层工作原理，能够阅读简单的Spring底层源码</td></tr></tbody></table><p>​看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。</p><p>​课程安排就说到这里了，下面进入到SpringBoot<font color="#ff0000"><b>基础篇</b></font>的学习</p><h1 id="一、SpringBoot基础篇"><a href="#一、SpringBoot基础篇" class="headerlink" title="一、SpringBoot基础篇"></a>一、SpringBoot基础篇</h1><p>​在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：</p><ul><li>SpringBoot快速入门</li><li>SpringBoot基础配置</li><li>基于SpringBoot整合SSMP</li></ul><h2 id="1-快速上手SpringBoot"><a href="#1-快速上手SpringBoot" class="headerlink" title="1. 快速上手SpringBoot"></a>1. 快速上手SpringBoot</h2><p>​学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说</p><ul><li>Spring程序初始搭建过程</li><li>Spring程序的开发过程</li></ul><p>​通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li></ol><p>​带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。</p><p>​<font color="#f0f"><b>温馨提示</b></font></p><p>​如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。</p><h3 id="1-1-SpringBoot入门（一）官网版"><a href="#1-1-SpringBoot入门（一）官网版" class="headerlink" title="1.1 SpringBoot入门（一）官网版"></a>1.1 SpringBoot入门（一）官网版</h3><p>​下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。</p><p>​下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会<font color="#ff0000"><b>简化</b></font>二字的含义</p><p><strong>步骤①</strong>：创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><p><img src="image-20211116125259385.png" alt="image-20211116125259385"></p><p>​<font color="#ff0000"><b>特别关注</b></font>：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<font color="#ff0000"><b>联网</b></font>转转转</p><p>​<font color="#ff0000"><b>特别关注</b></font>：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11</p><p><strong>步骤②</strong>：选择当前模块需要使用的技术集</p><p><img src="image-20211116125615728.png" alt="image-20211116125615728"></p><p>​按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了</p><p>​<font color="#ff0000"><b>关注</b></font>：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，回头可以到配置文件中修改对应的版本</p><p><strong>步骤③</strong>：开发控制器类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//Rest模式@RestController@RequestMapping("/books")public class BookController {    @GetMapping    public String getById(){        System.out.println("springboot is running...");        return "springboot is running...";    }}</code></pre><p>​入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解</p><p>​<font color="#ff0000"><b>关注</b></font>：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，=-Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程</p><p><strong>步骤④</strong>：运行自动生成的Application类</p><p><img src="image-20211116130152452.png" alt="image-20211116130152452"></p><p>​使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。</p><p>​不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">访问路径：http://localhost:8080/books</code></pre><p>​是不是感觉很神奇？目前的效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前</p><ul><li><p>pom.xml</p><p>​这是maven的配置文件，描述了当前工程构建时相应的配置信息</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;springboot_01_01_quickstart&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说</p></li><li><p>Application类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>​这个类功能很简单，就一句代码，前面运行程序就是运行的这个类</p></li></ul><p>​到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。</p><p>​通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spirng程序相比，SpringBoot程序在开发的过程中各个层面均具有优势</p><table><thead><tr><th><strong>类配置文件</strong></th><th><strong>Spring</strong></th><th><strong>SpringBoot</strong></th></tr></thead><tbody><tr><td>pom文件中的坐标</td><td><strong>手工添加</strong></td><td><strong>勾选添加</strong></td></tr><tr><td>web3.0配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>Spring/SpringMVC配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>控制器</td><td><strong>手工制作</strong></td><td><strong>手工制作</strong></td></tr></tbody></table><p>​一句话总结一下就是<font color="#ff0000"><b>能少写就少写</b></font>，<font color="#ff0000"><b>能不写就不写</b></font>，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了</p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序可以根据向导进行联网快速制作</li><li>SpringBoot程序需要基于JDK8以上版本进行制作</li><li>SpringBoot程序中需要使用何种功能通过勾选选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li><li>运行SpringBoot程序通过运行Application程序入口进行</li></ol><p><strong>思考</strong></p><p>​前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说</p><h3 id="1-2-SpringBoot入门（二）官网包下载版"><a href="#1-2-SpringBoot入门（二）官网包下载版" class="headerlink" title="1.2 SpringBoot入门（二）官网包下载版"></a>1.2 SpringBoot入门（二）官网包下载版</h3><p>​如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序，可以不基于任意的IDE工具进行，其实在SpringBoot的官网里面就可以直接创建SpringBoot程序</p><p>​SpringBoot官网和Spring的官网是在一起的，都是  spring.io  。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容</p><img src="image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;"><p><strong>步骤①</strong>：点击Spring Initializr后进入到创建SpringBoot程序的界面上，下面是输入信息的过程，和前面的一样，只是界面变了而已，根据自己的要求，在左侧选择对应信息和输入对应的信息即可</p><img src="image-20211122150608039.png" alt="image-20211122150608039"><p><strong>步骤②</strong>：右侧的ADD DEPENDENCIES用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面</p><img src="image-20211122161257361.png" alt="image-20211122161257361" style="zoom:50%;"><p><strong>步骤③</strong>：所有信息设置完毕后，点击下面左侧按钮，生成一个文件包</p><p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211122161548022.png" alt="image-20211122161548022"></p><p><strong>步骤④</strong>：保存后得到一个压缩文件，这个文件打开后就是创建的SpringBoot工程文件夹了</p><p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211122161709478.png" alt="image-20211122161709478"></p><p><strong>步骤⑤</strong>：解压缩此文件后，得到工程目录，在Idea中导入即可使用，和之前创建的东西完全一样。下面就可以自己创建一个Controller测试一下是否能用了。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，走的就是这个过程，只不过Idea把界面给整合了一下，读取到了Spring官网给的信息，然后展示到了Idea的界面中而已，不信你可以看看下面这个步骤</p><img src="image-20211122162443035.png" alt="image-20211122162443035" style="zoom: 67%;"><p>​上面描述了连接的网址，再看看SpringBoot官网创建工程的URL地址，是不是一样？</p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211122162820719.png" alt="image-20211122162820719"><p><strong>总结</strong></p><ol><li><p>打开SpringBoot官网，选择Quickstart Your Project</p><img src="image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;"></li><li><p>创建工程</p><img src="image-20211122150608039.png" alt="image-20211122150608039"><p>并保存项目</p><p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211122161548022.png" alt="image-20211122161548022"></p></li><li><p>解压项目，通过IDE导入项目</p></li></ol><p><strong>思考</strong></p><p>​现在创建工程靠的是访问国外的Spring主站，但是互联网访问是可以控制的，如果一天这个网站你在国内都无法访问了，那前面这两种方式都无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说</p><h3 id="1-3-SpringBoot入门（三）阿里云版"><a href="#1-3-SpringBoot入门（三）阿里云版" class="headerlink" title="1.3 SpringBoot入门（三）阿里云版"></a>1.3 SpringBoot入门（三）阿里云版</h3><p>​前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实都是走的同一个地方，也就是SpringBoot的官网创建的SpringBoot工程，那如果我们国内有这么一个网站能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，这个国内的网站有吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样</p><p>​创建工程时，切换选择starter服务路径，然后手工收入阿里云提供给我们的使用地址即可。地址：<a href="http://start.aliyun.com或https//start.aliyun.com">http://start.aliyun.com或https://start.aliyun.com</a></p><p><img src="image-20211122163605950.png" alt="image-20211122163605950"></p><p>​阿里为了便于自己开发使用，因此在依赖坐标中添加了一些阿里相关的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是<font color="#ff0000"><b>2.4.1</b></font>，所以如果你想更换其他的版本，<strong>创建项目后手工修改即可</strong>，别忘了刷新一下，加载新版本信息</p><p><img src="image-20211122163937408.png" alt="image-20211122163937408"></p><p>​阿里云提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。</p><p>​<font color="#ff0000"><b>注意</b></font>：阿里云提供的工程创建地址初始化完毕后和实用SpringBoot官网创建出来的工程略有区别。主要是在配置文件的形式上有区别。这个信息在后面讲解Boot程序的执行流程时给大家揭晓</p><p><strong>总结</strong></p><ol><li>选择start来源为自定义URL</li><li>输入阿里云start地址</li><li>创建项目</li></ol><p><strong>思考</strong></p><p>​做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，整个事情是不是就不能做了呢？咱们下一节再说</p><h3 id="1-4-SpringBoot入门（四）不联网版"><a href="#1-4-SpringBoot入门（四）不联网版" class="headerlink" title="1.4 SpringBoot入门（四）不联网版"></a>1.4 SpringBoot入门（四）不联网版</h3><p>​不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个信息找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。</p><p>​联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程当使用了一些自己需要使用又不存在的东西时，就要去下载。其实SpringBoot工程创建的时候就是去下载一些必要的组件的。你把这些东西给提前准备好就可以了吗？是的，就是这样。</p><p>​下面咱们就一起手工创建一个SpringBoot工程：</p><p><strong>步骤①</strong>：创建工程时，选择手工创建Maven工程</p><img src="image-20211122165341684.png" alt="image-20211122165341684" style="zoom:50%;"><p><strong>步骤②</strong>：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;springboot_01_04_quickstart&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>​用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用</p><p><strong>步骤③</strong>：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称一切修改即可</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        SpringApplication.run(&lt;Application.class);    }}</code></pre><p>​<font color="#ff0000"><b>关注</b></font>：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍</p><p>​<font color="#ff0000"><b>关注</b></font>：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称</p><p><strong>步骤④</strong>：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别了</p><p>​看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的</p><p><strong>总结</strong></p><ol><li>创建普通Maven工程</li><li>继承spring-boot-starter-parent</li><li>添加依赖spring-boot-starter-web</li><li>制作引导类Application</li></ol><p>到这里其实学习了4种创建SpringBoot工程的方式，其实本质是一样的，就是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。</p><h4 id="教你一招：在Idea中隐藏指定文件-文件夹"><a href="#教你一招：在Idea中隐藏指定文件-文件夹" class="headerlink" title="教你一招：在Idea中隐藏指定文件/文件夹"></a>教你一招：在Idea中隐藏指定文件/文件夹</h4><p>​创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p><p>​处理方案无外乎两种，如果你对每一个文件/目录足够了解，没有用的完全可以删除掉，或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。</p><p>​既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。</p><p><strong>步骤①</strong>：打开设置，【Files】→【Settings】</p><img src="image-20211122173835517.png" alt="image-20211122173835517" style="zoom:80%;"><p><strong>步骤②</strong>：打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示</p><img src="image-20211122174020028.png" alt="image-20211122174020028" style="zoom: 67%;"><p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可</p><p>​到这里就做完了，其实就是Idea的一个小功能</p><p><strong>总结</strong></p><ol><li>Idea中隐藏指定文件或指定类型文件<ol><li>【Files】→【Settings】</li><li>【Editor】→【File Types】→【Ignored Files and Folders】</li><li>输入要隐藏的名称，支持*号通配符</li><li>回车确认添加</li></ol></li></ol><h3 id="1-5-SpringBoot简介"><a href="#1-5-SpringBoot简介" class="headerlink" title="1.5 SpringBoot简介"></a>1.5 SpringBoot简介</h3><p>​入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。</p><p>​SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来<font color="#ff0000"><b>简化Spring应用的初始搭建以及开发过程</b></font>。</p><p>​都简化了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：</p><ul><li>Spring程序缺点<ul><li>依赖设置繁琐<ul><li>以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标时必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定面</li></ul></li><li>配置繁琐<ul><li>以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用</li></ul></li></ul></li></ul><blockquote><p>回顾</p><p>​通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li></ol></blockquote><p>​再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：</p><ul><li>起步依赖（简化依赖配置）<ul><li>依赖配置的书写简化就是靠这个起步依赖达成的</li></ul></li><li>自动配置（简化常用工程相关配置）<ul><li>配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说</li></ul></li><li>辅助功能（内置服务器，……）<ul><li>除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot程序的一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了</li></ul></li></ul><p>​==下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面：==</p><ul><li>parent</li><li>starter</li><li>引导类</li><li>内嵌tomcat</li></ul><h4 id="1-5-1-parent"><a href="#1-5-1-parent" class="headerlink" title="1.5.1 parent"></a>1.5.1 parent</h4><p>​SpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版与B技术的3.5版可以合作在一起，但是和B技术的3.7版<strong>合并使用时就有冲突</strong>。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p><p>​SpringBoot一看这种情况so easy啊，于是<strong>将所有的技术版本的常见使用方案都给开发者整理了出来</strong>，<strong>以后开发者使用时直接用它提供的版本方案</strong>，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做<font color="#ff0000"><b>parent</b></font>。</p><p>​<font color="#ff0000"><b>parent</b></font>自身具有很多个版本，每个<font color="#ff0000"><b>parent</b></font>版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的<font color="#ff0000"><b>parent</b></font>就行了，由<font color="#ff0000"><b>parent</b></font>帮助开发者统一的进行各种技术的版本管理。</p><p><img src="image-20230907152428415.png" alt="image-20230907152428415"></p><p>​比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由<font color="#ff0000"><b>parent</b></font>负责处理。</p><p>​有人可能会提出来，万一<font color="#ff0000"><b>parent</b></font>给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，<font color="#ff0000"><b>parent</b></font>仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，<font color="#ff0000"><b>使用parent可以帮助开发者进行版本的统一管理</b></font></p><p>​<font color="#ff0000"><b>关注</b></font>：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚</p><p>​那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义</p><ul><li>项目中的pom.xml中继承了一个坐标</li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/parent&gt;</code></pre><ul><li>打开后可以查阅到其中又继承了一个坐标</li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/parent&gt;</code></pre><ul><li>这个坐标中定义了两组信息，<strong>第一组是各式各样的依赖版本号属性</strong>，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号</li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;properties&gt;    &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt;    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;    &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt;    &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt;    &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt;    &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt;    &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;    &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt;    &lt;h2.version&gt;1.4.200&lt;/h2.version&gt;    &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt;    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt;    &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt;    &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt;    &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt;    &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt;    &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt;    &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt;    &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;&lt;/properties&gt;</code></pre><p>​第二组是<strong>各式各样的的依赖坐标信息</strong>，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;            &lt;version&gt;${hibernate.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;${junit.version}&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><p><font color="#ff0000"><b>关注</b></font>：上面的依赖坐标定义是出现在<dependencymanagement>标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的</dependencymanagement></p><p><font color="#ff0000"><b>关注</b></font>：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;            &lt;version&gt;${spring-boot.version}&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><p><strong>总结</strong></p><ol><li>开发SpringBoot程序要继承spring-boot-starter-parent</li><li>spring-boot-starter-parent中定义了若干个依赖管理</li><li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>不用继承parent的形式，也可以采用引入依赖的形式实现效果</li></ol><p><strong>思考</strong></p><p>​parent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p><h4 id="1-5-2-starter"><a href="#1-5-2-starter" class="headerlink" title="1.5.2 starter"></a>1.5.2 starter</h4><p>​SpringBoot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p><p>​SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p><p>​starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<font color="#ff0000"><b>使用starter可以帮助开发者减少依赖配置</b></font></p><p>​这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义</p><ul><li>项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖</li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>在spring-boot-starter-web中又定义了若干个具体依赖的坐标</li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.3.9&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.9&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。</p><p>​但是我们发现除了这两个还有其他的，比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.3.9&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;version&gt;2.12.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;        &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;        &lt;version&gt;2.12.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;        &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;        &lt;version&gt;2.12.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;        &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;        &lt;version&gt;2.12.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。</p><p>​到这里基本上得到了一个信息，<strong>使用starter可以帮开发者快速配置依赖关系。以前依赖3个坐标的，现在导入一个就搞定了</strong>，就是加速依赖配置的。</p><p><strong>starter与parent的区别</strong></p><p>​朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p><p>​<font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font></p><p>​<font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号（<strong>依赖管理。而非依赖</strong>），以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font></p><p><strong>实际开发应用方式</strong></p><ul><li><p>实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter</p><ul><li>如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供</li><li>如果没有对应的starter，手写坐标即可</li></ul></li><li><p>实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理</p><ul><li>方式一：直接写坐标</li><li>方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了</properties></li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;properties&gt;    &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt;    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;    &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt;    &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt;    &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt;    &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt;    &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;    &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt;    &lt;h2.version&gt;1.4.200&lt;/h2.version&gt;    &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt;    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt;    &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt;    &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt;    &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt;    &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt;    &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt;    &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt;    &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;&lt;/properties&gt;</code></pre></li></ul><p><font color="#f0f"><b>温馨提示</b></font></p><p>​SpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">命名规则：spring-boot-starter-技术名称</code></pre><p>​所以以后见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合章节再说</p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h4 id="1-5-3-引导类"><a href="#1-5-3-引导类" class="headerlink" title="1.5.3 引导类"></a>1.5.3 引导类</h4><p>​配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类了，带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class Springboot0101QuickstartApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot0101QuickstartApplication.class, args);    }}</code></pre><p>​SpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。那SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class Springboot0101QuickstartApplication {    public static void main(String[] args) {        ConfigurableApplicationContext ctx = SpringApplication.run(Springboot0101QuickstartApplication.class, args);        BookController bean = ctx.getBean(BookController.class);        System.out.println("bean======&gt;" + bean);    }}</code></pre><p>​通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。这个类在SpringBoot程序中是所有功能的入口，称这个类为<font color="#ff0000"><b>引导类</b></font>。</p><p>​作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font></p><p><strong>总结</strong></p><ol><li>SpringBoot工程提供引导类用来作为启动程序的入口</li><li>SpringBoot工程启动后<strong>创建并初始化Spring容器</strong>，扫描引导类所在包加载bean</li></ol><p><strong>思考</strong></p><p>​程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？</p><h4 id="1-5-4-内嵌tomcat"><a href="#1-5-4-内嵌tomcat" class="headerlink" title="1.5.4 内嵌tomcat"></a>1.5.4 内嵌tomcat</h4><p>​当前我们做的SpringBoot入门案例勾选了Spirng-web的功能，并且导入了对应的starter。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​SpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西。我帮你搞一个web服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。</p><p>​由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。</p><p>​下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题</p><ol><li>这个服务器在什么位置定义的</li><li>这个服务器是怎么运行的</li><li>这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾</li></ol><p><strong>内嵌Tomcat定义位置</strong></p><p>​说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​打开查看web的starter导入了哪些东西</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.3.9&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.9&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;        &lt;version&gt;1.3.5&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;        &lt;version&gt;9.0.52&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt;                &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;        &lt;version&gt;9.0.52&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;        &lt;version&gt;9.0.52&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt;                &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的</p><p><strong>内嵌Tomcat运行原理</strong></p><p>​Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉的小伙伴可能有印象，tomcat安装目录中保存有jar，好多个jar。</p><p>​下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。</p><p>​如果是对象，那Spring容器是用来管理对象的，这个对象能不能交给Spring容器管理呢？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了。tomcat服务器运行其实是以对象的形式在Spring容器中运行的，怪不得我们没有安装这个tomcat，而且还能用。闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;        &lt;version&gt;9.0.52&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。</p><p><strong>更换内嵌Tomcat</strong></p><p>​那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器</p><ul><li><p>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</p></li><li><p>jetty：更轻量级，负载性能远不及tomcat</p></li><li><p>undertow：负载性能勉强跑赢tomcat</p><p>想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。</p></li></ul><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。</p><p><strong>总结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是==将Tomcat服务器作为对象运行==，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><p>​到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识</p><ol><li>使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的</li><li>学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等</li></ol><p>​第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。</p><h2 id="2-SpringBoot基础配置"><a href="#2-SpringBoot基础配置" class="headerlink" title="2. SpringBoot基础配置"></a>2. SpringBoot基础配置</h2><p>​入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它在辅助加快Spring程序的开发效率。我们发现现在几乎不用做任何的配置，功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。</p><p>​如果我们想修改默认的配置i，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖的，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么干预SpringBoot的默认配置，修改成自己的配置。</p><p>​</p><h3 id="2-1-属性配置"><a href="#2-1-属性配置" class="headerlink" title="2.1 属性配置"></a>2.1 属性配置</h3><p>​SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的</p><p><img src="image-20211123165428245.png" alt="image-20211123165428245"></p><p>​那该如何写呢？properties格式的文件书写规范是key=value</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">name=itheima</code></pre><p>​这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了</p><img src="image-20211123165719091.png" alt="image-20211123165719091" style="zoom:80%;"><p>​根据提示敲回车，输入80端口，搞定</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=80</code></pre><p>​下面就可以直接运行程序，测试效果了。</p><p>​我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。</p><p>​其实到这里我们应该得到如下三个信息</p><ol><li>SpringBoot程序可以在application.properties文件中进行属性配置</li><li>application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置</li><li>SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面</li></ol><p><strong>总结</strong></p><ol><li>==<strong>SpringBoot默认配置文件是application.properties</strong>==</li></ol><p>​做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。</p><p><strong>关闭运行日志图表（banner)</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.main.banner-mode=off</code></pre><p><strong>设置运行日志的显示级别</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">logging.level.root=debug</code></pre><p>​你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。</p><p>​我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。</p><p>​打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>​能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p><strong>总结</strong></p><ol><li>SpringBoot中<strong>导入对应starter后，提供对应配置属性</strong></li><li>书写SpringBoot配置采用关键字+提示形式书写</li></ol><h3 id="2-2-配置文件分类"><a href="#2-2-配置文件分类" class="headerlink" title="2.2 配置文件分类"></a>2.2 配置文件分类</h3><p>​现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下:</p><ul><li><p>properties格式</p></li><li><p>yml格式</p></li><li><p>yaml格式</p><p>一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下</p></li><li><p>application.properties（properties格式）</p></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=80</code></pre><ul><li>application.yml（yml格式）</li></ul><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">server:  port: 81</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 82</code></pre><p>​仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。</p><p><strong>总结</strong></p><ol><li>SpringBoot提供了3种配置文件的格式<ul><li>properties（传统格式/默认格式）</li><li><strong>yml</strong>（主流格式）</li><li>yaml</li></ul></li></ol><p><strong>思考</strong></p><p>​现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？</p><h4 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h4><p>​其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。</p><ul><li>application.properties（properties格式）</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=80</code></pre><ul><li>application.yml（yml格式）</li></ul><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">server:  port: 81</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 82</code></pre><p>​启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">application.properties  &gt;  application.yml  &gt;  application.yaml</code></pre><p>​虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。</p><p>​最后我们把配置文件内容给修改一下</p><ul><li>application.properties（properties格式）</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=80spring.main.banner-mode=off</code></pre><ul><li>application.yml（yml格式）</li></ul><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">server:  port: 81logging:   level:     root: debug</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 82</code></pre><p>​我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，那所有的配置项都会生效。</p><p><strong>总结</strong></p><ol><li>配置文件间的加载优先级properties（最高）&gt;  yml  &gt;  yaml（最低）</li><li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li></ol><h4 id="教你一招：自动提示功能消失解决方案"><a href="#教你一招：自动提示功能消失解决方案" class="headerlink" title="教你一招：自动提示功能消失解决方案"></a>教你一招：<strong>自动提示功能消失解决方案</strong></h4><p>​可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。</p><p>​先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下3种：</p><ol><li><p>Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能</p></li><li><p>Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息</p><p>这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：</p></li></ol><p><strong>步骤①</strong>：打开设置，【Files】→【Project Structure…】</p><p><img src="image-20211126160548690.png" alt="image-20211126160548690"></p><p><strong>步骤②</strong>：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块</p><p><img src="image-20211126160726589.png" alt="image-20211126160726589"><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/SpringBoot2%2525E5%252585%2525A8%2525E5%2525A5%252597/1.%2525E5%25259F%2525BA%2525E7%2525A1%252580%2525E7%2525AF%252587/%2525E8%2525AE%2525B2%2525E4%2525B9%252589/img/image-20211126160844372.png" alt="image-20211126160844372"></p><p><strong>步骤③</strong>：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示</p><p><img src="image-20211126160946448.png" alt="image-20211126160946448"><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/SpringBoot2%2525E5%252585%2525A8%2525E5%2525A5%252597/1.%2525E5%25259F%2525BA%2525E7%2525A1%252580%2525E7%2525AF%252587/%2525E8%2525AE%2525B2%2525E4%2525B9%252589/img/image-20211126160954338.png" alt="image-20211126160954338"></p><p><strong>步骤④</strong>：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了</p><p><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/SpringBoot2%2525E5%252585%2525A8%2525E5%2525A5%252597/1.%2525E5%25259F%2525BA%2525E7%2525A1%252580%2525E7%2525AF%252587/%2525E8%2525AE%2525B2%2525E4%2525B9%252589/img/image-20211126161145082.png" alt="image-20211126161145082"><img src="image-20211126161156324.png" alt="image-20211126161156324" style="zoom:80%;"></p><p>​到这里就做完了，其实就是Idea的一个小功能</p><p><img src="image-20211126161301699.png" alt="image-20211126161301699"></p><p><strong>总结</strong></p><ol><li><p>指定SpringBoot配置文件</p><ul><li>Setting → Project Structure → Facets</li><li>选中对应项目/工程</li><li>Customize Spring Boot</li><li>选择配置文件</li></ul></li></ol><h3 id="2-3-yaml文件"><a href="#2-3-yaml文件" class="headerlink" title="2.3 yaml文件"></a>2.3 yaml文件</h3><p>​SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。</p><p>​YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：</p><ul><li><p>.yml格式（主流）</p></li><li><p>.yaml格式</p><p>对于文件自身在书写时，具有严格的语法格式要求，具体如下：</p></li></ul><ol><li>大小写敏感</li><li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ol><p>  上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，<font color="#ff0000"><b>数据前面要加空格与冒号隔开</b></font></p><p>​下面列出常见的数据书写格式，熟悉一下</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">boolean: TRUE  #TRUE,true,True,FALSE,false，False均可float: 3.14    #6.8523015e+5  #支持科学计数法int: 123       #0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制null: ~        #使用~表示nullstring: HelloWorld      #字符串可以直接书写string2: "Hello World"  #可以使用双引号包裹特殊字符date: 2018-02-17        #日期必须使用yyyy-MM-dd格式datetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区</code></pre><p>​此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">subject:- Java- 前端- 大数据enterprise:name: itcast    age: 16    subject:    - Java        - 前端        - 大数据likes: [王者荣耀,刺激战场]#数组书写缩略格式users: #对象数组格式一  - name: Tom   age: 4  - name: Jerry    age: 5users: #对象数组格式二  -      name: Tom    age: 4  -       name: Jerry    age: 5    users2: [ { name: Tom , age: 4 } , { name: Jerry , age: 5 } ]#对象数组缩略格式</code></pre><p><strong>总结</strong></p><ol><li>yaml语法规则<ul><li>大小写敏感</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ul></li><li>注意属性名冒号后面与数据之间有一个<strong>空格</strong></li><li>字面值、对象数据格式、数组数据格式</li></ol><p><strong>思考</strong></p><p>​现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据时给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。</p><h3 id="2-4-yaml数据读取"><a href="#2-4-yaml数据读取" class="headerlink" title="2.4 yaml数据读取"></a>2.4 yaml数据读取</h3><p>​对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式</p><h4 id="读取单一数据"><a href="#读取单一数据" class="headerlink" title="读取单一数据"></a>读取单一数据</h4><p>​yaml中保存的单个数据，可以使用Spring中的注解直接读取，使用@Value可以读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名.二级属性名……}</b></font></p><img src="image-20211126180433356.png" alt="image-20211126180433356" style="zoom:80%;"><p>​记得使用@Value注解时，要将该注入写在某一个指定的Spring管控的bean的属性名上方。现在就可以读取到对应的单一数据行了</p><p><strong>总结</strong></p><ol><li>使用@Value配合SpEL读取单个数据</li><li>如果数据存在多层级，依次书写层级名称即可</li></ol><h4 id="读取全部数据"><a href="#读取全部数据" class="headerlink" title="读取全部数据"></a>读取全部数据</h4><p>​读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中</p><img src="image-20211126180738569.png" alt="image-20211126180738569" style="zoom:80%;"><p>​数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法时getProperties（String），参数填写属性名即可</p><p><strong>总结</strong></p><ol><li>使用Environment对象封装全部配置信息</li><li>使用@Autowired自动装配数据到Environment对象中</li></ol><h4 id="读取对象数据"><a href="#读取对象数据" class="headerlink" title="读取对象数据"></a>读取对象数据</h4><p>​单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的 getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作。</p><p>​首先<strong>定义一个对象</strong>，并将该对象纳入Spring管控的范围@Component，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。</p><img src="image-20211126181126382.png" alt="image-20211126181126382" style="zoom:80%;"><p>​这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得<strong>数据属性名要与对象的变量名一一对应</strong>啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。</p><p>​<img src="image-20211126181423432.png" alt="image-20211126181423432" style="zoom:80%;"></p><p>​<font color="#f0f"><b>温馨提示</b></font></p><p>​细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，是这样的，咱们到原理篇再揭秘如何弹出提示。</p><p><strong>总结</strong></p><ol><li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li><li>封装类需要定义为Spring管理的bean，否则无法进行属性注入</li></ol><h4 id="yaml文件中的数据引用"><a href="#yaml文件中的数据引用" class="headerlink" title="yaml文件中的数据引用"></a>yaml文件中的数据引用</h4><p>​如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">center:dataDir: /usr/local/fire/data    tmpDir: /usr/local/fire/tmp    logDir: /usr/local/fire/log    msgDir: /usr/local/fire/msgDir</code></pre><p>或者</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">center:dataDir: D:/usr/local/fire/data    tmpDir: D:/usr/local/fire/tmp    logDir: D:/usr/local/fire/log    msgDir: D:/usr/local/fire/msgDir</code></pre><p>​这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">baseDir: /usr/local/firecenter:    dataDir: ${baseDir}/data    tmpDir: ${baseDir}/tmp    logDir: ${baseDir}/log    msgDir: ${baseDir}/msgDir</code></pre><p>​还有一个注意事项，在书写字符串时，如果需要使用<strong>转义字符</strong>，需要将数据字符串<strong>使用双引号包裹起来</strong></p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">lesson: "Spring\tboot\nlesson"# Springboot# lesson</code></pre><p><strong>总结</strong></p><ol><li>在配置文件中可以使用${属性名}方式引用属性值</li><li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li></ol><p>​到这里有关yaml文件的基础使用就先告一段落，在实用篇中再继续研究更深入的内容。</p><h2 id="3-基于SpringBoot实现SSMP整合"><a href="#3-基于SpringBoot实现SSMP整合" class="headerlink" title="3. 基于SpringBoot实现SSMP整合"></a>3. 基于SpringBoot实现SSMP整合</h2><p>​重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式</p><ul><li><p>整合JUnit</p></li><li><p>整合MyBatis</p></li><li><p>整合MyBatis-Plus</p></li><li><p>整合Druid</p><p>上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。</p></li></ul><h3 id="3-1-整合JUnit"><a href="#3-1-整合JUnit" class="headerlink" title="3.1 整合JUnit"></a>3.1 整合JUnit</h3><p>​SpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。</p><p>​我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//加载spring整合junit专用的类运行器@RunWith(SpringJUnit4ClassRunner.class)//指定对应的配置信息@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTestCase {    //注入你要测试的对象    @Autowired    private AccountService accountService;    @Test    public void testGetById(){        //执行要测试的对象对应的方法        System.out.println(accountService.findById(2));    }}</code></pre><p>​其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用于测试的类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，<font color="#ff0000"><b>每次都指定一样的东西，这个东西写起来没有技术含量啊</b></font>，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。似然<font color="#ff0000"><b>有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写</b></font></p><p>​SpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot04JunitApplicationTests {    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() {        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    }}</code></pre><p>​看看这次简化成什么样了，<strong>一个注解就搞定</strong>了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——<font color="#ff0000"><b>简化</b></font>。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。</p><h4 id="classes-属性"><a href="#classes-属性" class="headerlink" title="classes 属性"></a>classes 属性</h4><p>这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想<strong>手动指定启动类</strong>有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTest(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests {    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() {        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    }}</code></pre><p>​第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTest@ContextConfiguration(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests {    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() {        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    }}</code></pre><blockquote><p>如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置。</p></blockquote><p><font color="#f0f"><b>温馨提示</b></font></p><p>​使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。</p><p><strong>总结</strong></p><ol><li>导入测试对应的starter</li><li>测试类使用@SpringBootTest修饰</li><li>使用自动装配的形式添加要测试的对象</li><li>测试类如果存在于引导类所在包或子包中无需指定引导类</li><li>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</li></ol><h3 id="3-2-整合MyBatis"><a href="#3-2-整合MyBatis" class="headerlink" title="3.2 整合MyBatis"></a>3.2 整合MyBatis</h3><h4 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h4><p>​整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行</p><ul><li><p>导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--1.导入mybatis与spring整合的jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;1.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--导入spring操作数据库必选的包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>Spring核心配置</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configuration@ComponentScan("com.itheima")@PropertySource("jdbc.properties")public class SpringConfig {}</code></pre></li><li><p>MyBatis要交给Spring接管的bean</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//定义mybatis专用的配置类@Configurationpublic class MyBatisConfig {//    定义创建SqlSessionFactory对应的bean    @Bean    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){        //SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象        SqlSessionFactoryBean sfb = new SqlSessionFactoryBean();        //设置数据源替代原始配置中的environments的配置        sfb.setDataSource(dataSource);        //设置类型别名替代原始配置中的typeAliases的配置        sfb.setTypeAliasesPackage("com.itheima.domain");        return sfb;    }//    定义加载所有的映射配置    @Bean    public MapperScannerConfigurer mapperScannerConfigurer(){        MapperScannerConfigurer msc = new MapperScannerConfigurer();        msc.setBasePackage("com.itheima.dao");        return msc;    }}</code></pre></li><li><p>数据源对应的bean，此处使用Druid数据源</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class JdbcConfig {    @Value("${jdbc.driver}")    private String driver;    @Value("${jdbc.url}")    private String url;    @Value("${jdbc.username}")    private String userName;    @Value("${jdbc.password}")    private String password;    @Bean("dataSource")    public DataSource dataSource(){        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(userName);        ds.setPassword(password);        return ds;    }}</code></pre></li><li><p>数据库连接信息（properties格式）</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=falsejdbc.username=rootjdbc.password=root</code></pre></li></ul><h4 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h4><p>上述格式基本上是简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式</p><p><strong>步骤①</strong>：创建模块时勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库</p><p><img src="image-20211129092156020.png" alt="image-20211129092156020"></p><p><img src="image-20211129092210993.png" alt="image-20211129092210993"></p><p>​或者手工导入对应技术的starter，和对应数据库的坐标</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;!--1.导入对应的starter--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>步骤②</strong>：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8    username: root    password: root</code></pre><p>​完了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面就可以写一下MyBatis程序运行需要的Dao（或者Mapper）就可以运行了</p><p><strong>实体类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Book {    private Integer id;    private String type;    private String name;    private String description;    // get set函数    // toString}</code></pre><p><strong>映射接口（Dao）</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao {    @Select("select * from tbl_book where id = #{id}")    public Book getById(Integer id);}</code></pre><p><strong>测试类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot05MybatisApplicationTests {    @Autowired    private BookDao bookDao;    @Test    void contextLoads() {        System.out.println(bookDao.getById(1));    }}</code></pre><p>​完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解</p><p>​<font color="#ff0000"><b>注意</b></font>：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。当SpringBoot2.4.3（不含）版本之前会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root</code></pre><p>​这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置不写UTC，写Asia/Shanghai也可以解决这个问题。</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai    username: root    password: root</code></pre><p>​如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。</p><p>​此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用<strong>com.mysql.jdbc.Driver</strong>，换用<font color="#ff0000"><b>com.mysql.cj.jdbc.Driver</b></font>。前面的例子中已经更换了驱动了，在此说明一下。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</code></pre><p><strong>总结</strong></p><ol><li><p>整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库SQL映射需要添加@Mapper被容器识别到</p></li><li><p>MySQL 8.X驱动强制要求设置时区</p><ul><li>修改url，添加serverTimezone设定</li><li>修改MySQL数据库配置</li></ul></li><li><p>驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p></li></ol><h3 id="3-3-整合MyBatis-Plus"><a href="#3-3-整合MyBatis-Plus" class="headerlink" title="3.3 整合MyBatis-Plus"></a>3.3 整合MyBatis-Plus</h3><p>​做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话</p><ul><li>导入对应技术的starter坐标</li><li>根据对应技术的要求做配置</li></ul><p>​    虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。</p><p>​接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合</p><p><strong>步骤①</strong>：导入对应的starter</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>​关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">Spring-boot-start-***</code></pre><p>​而这个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解</p><table><thead><tr><th>starter所属</th><th>命名规则</th><th>示例</th></tr></thead><tbody><tr><td>官方提供</td><td>spring-boot-starter-技术名称</td><td>spring-boot-starter-web <br>spring-boot-starter-test</td></tr><tr><td>第三方提供</td><td>第三方技术名称-spring-boot-starter</td><td>druid-spring-boot-starter</td></tr><tr><td>第三方提供</td><td>第三方技术名称-boot-starter（第三方技术名称过长，简化命名）</td><td>mybatis-plus-boot-starter</td></tr></tbody></table><p><font color="#f0f"><b>温馨提示</b></font></p><p>​有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标</p><p><strong>步骤②</strong>：配置数据源相关信息</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db    username: root    password: root</code></pre><p>​没了，就这么多，剩下的就是写MyBaitsPlus的程序了</p><p><strong>映射接口（Dao）</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; {}</code></pre><p>​核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。</p><img src="image-20211129100313919.png" alt="image-20211129100313919" style="zoom:80%;"><p>​下面就可以写一个测试类进行测试了，此处省略。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mybatis-plus:  global-config:    db-config:      table-prefix: tbl_#设置所有表的通用前缀名称为tbl_</code></pre><p><strong>总结</strong></p><ol><li>手工添加MyBatis-Plus对应的starter</li><li>数据层接口使用BaseMapper简化开发</li><li>需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</li></ol><h3 id="3-4-整合Druid"><a href="#3-4-整合Druid" class="headerlink" title="3.4 整合Druid"></a>3.4 整合Druid</h3><p>​使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。</p><p>​前面整合MyBatis和MP的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。</p><p>​在没有指定数据源时，我们的配置如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai    username: root    password: root</code></pre><p>​此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</code></pre><p>​上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。</p><ol><li><p>导入对应的技术坐标</p></li><li><p>配置使用指定的数据源类型</p></li></ol><p> 下面就切换一下数据源对象</p><p><strong>步骤①</strong>：导入对应的坐标（注意，是坐标，此处不是starter）</p><p><img src="image-20230913110440256.png" alt="image-20230913110440256"></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.16&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>步骤②</strong>：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource</code></pre><p>​</p><p>这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，<strong>导入对应的starter</strong>，进行相应的配置即可。</p><p><strong>步骤①</strong>：导入对应的starter</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.6&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>步骤②</strong>：修改配置</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root</code></pre><p>​注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性时druid下面的属性，那你能想到吗？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅</p><img src="image-20211129112610729.png" alt="image-20211129112610729" style="zoom:80%;"><p>​与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。</p><p>​这是我们做的第4个技术的整合方案，还是那两句话：<font color="#ff0000"><b>导入对应starter，使用对应配置</b></font>。没了，SpringBoot整合其他技术就这么简单粗暴。</p><p><strong>总结</strong></p><ol><li>整合Druid需要导入Druid对应的starter</li><li>根据Druid提供的配置方式进行配置</li><li>整合第三方技术通用方式<ul><li>导入对应的starter</li><li>根据提供的配置格式，配置非默认值对应的配置项</li></ul></li></ol><h3 id="3-5-SSMP整合综合案例"><a href="#3-5-SSMP整合综合案例" class="headerlink" title="3.5 SSMP整合综合案例"></a>3.5 SSMP整合综合案例</h3><p>​SpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。</p><p>​先看一下这个案例的最终效果</p><p><strong>主页面</strong></p><p><img src="image-20211129113447844.png" alt="image-20211129113447844"></p><p><strong>添加</strong></p><p><img src="image-20211129113522459.png" alt="image-20211129113522459"></p><p><strong>删除</strong></p><p><img src="image-20211129113550829.png" alt="image-20211129113550829"></p><p><strong>修改</strong></p><p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211129113610966.png" alt="image-20211129113610966"></p><p><strong>分页</strong></p><p><img src="image-20211129113628969.png" alt="image-20211129113628969"></p><p><strong>条件查询</strong></p><p><img src="image-20211129113650369.png" alt="image-20211129113650369"></p><p>​整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个</p><ol><li>实体类开发————使用Lombok快速制作实体类</li><li>Dao开发————整合MyBatisPlus，制作数据层测试</li><li>Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类</li><li>Controller开发————基于Restful开发，使用PostMan测试接口功能</li><li>Controller开发————前后端开发协议制作</li><li>页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理<ul><li>列表</li><li>新增</li><li>修改</li><li>删除</li><li>分页</li><li>查询</li></ul></li><li>项目异常处理</li><li>按条件查询————页面功能调整、Controller修正功能、Service修正功能</li></ol><p>​    可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟进进度，完成这个小案例的制作。</p><h4 id="0-模块创建"><a href="#0-模块创建" class="headerlink" title="0.模块创建"></a>0.模块创建</h4><p>​对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。</p><img src="image-20211129114306062.png" alt="image-20211129114306062" style="zoom:80%;"><p>我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。</p><img src="image-20211129114328967.png" alt="image-20211129114328967" style="zoom:80%;"><p>一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。</p><p>下面我们就可以创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。</p><p><strong>pom.xml</strong></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>application.yml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 80</code></pre><h4 id="1-实体类开发"><a href="#1-实体类开发" class="headerlink" title="1.实体类开发"></a>1.实体类开发</h4><p>​本案例对应的模块表结构如下：</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">-- ------------------------------ Table structure for tbl_book-- ----------------------------DROP TABLE IF EXISTS `tbl_book`;CREATE TABLE `tbl_book`  (  `id` int(11) NOT NULL AUTO_INCREMENT,  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of tbl_book-- ----------------------------INSERT INTO `tbl_book` VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');INSERT INTO `tbl_book` VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');INSERT INTO `tbl_book` VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');INSERT INTO `tbl_book` VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');INSERT INTO `tbl_book` VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');INSERT INTO `tbl_book` VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');INSERT INTO `tbl_book` VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');INSERT INTO `tbl_book` VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');INSERT INTO `tbl_book` VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');INSERT INTO `tbl_book` VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');INSERT INTO `tbl_book` VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');INSERT INTO `tbl_book` VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+');</code></pre><p>​根据上述表结构，制作对应的实体类</p><p><strong>实体类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Book {    private Integer id;    private String type;    private String name;    private String description;}</code></pre><p>​实体类的开发可以自动通过工具手工生成get/set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。</p><p>​Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;!--lombok--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>​使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">import lombok.Data;@Datapublic class Book {    private Integer id;    private String type;    private String name;    private String description;}</code></pre><p>​到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面课程中遇到了能用的东西时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些</p><p><strong>总结</strong></p><ol><li>实体类制作</li><li>使用lombok简化开发<ul><li>导入lombok无需指定版本，由SpringBoot提供版本</li><li>@Data注解</li></ul></li></ol><h4 id="2-数据层开发——基础CRUD"><a href="#2-数据层开发——基础CRUD" class="headerlink" title="2.数据层开发——基础CRUD"></a>2.数据层开发——基础CRUD</h4><p>​数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上</p><p><strong>步骤①</strong>：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.4.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>步骤②</strong>：配置数据库连接相关的数据源配置</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">server:  port: 80spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root</code></pre><p><strong>步骤③</strong>：使用MP的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; {}</code></pre><p><strong>步骤④</strong>：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">package com.itheima.dao;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.itheima.domain.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class BookDaoTestCase {    @Autowired    private BookDao bookDao;    @Test    void testGetById(){        System.out.println(bookDao.selectById(1));    }    @Test    void testSave(){        Book book = new Book();        book.setType("测试数据123");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookDao.insert(book);    }    @Test    void testUpdate(){        Book book = new Book();        book.setId(17);        book.setType("测试数据abcdefg");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookDao.updateById(book);    }    @Test    void testDelete(){        bookDao.deleteById(16);    }    @Test    void testGetAll(){        bookDao.selectList(null);    }}</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​MP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MP使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 80spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: rootmybatis-plus:  global-config:    db-config:      table-prefix: tbl_#设置表名通用前缀      id-type: auto#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</code></pre><h5 id="查看MP运行日志"><a href="#查看MP运行日志" class="headerlink" title="查看MP运行日志"></a>查看MP运行日志</h5><p>​在进行数据层测试的时候，因为基础的CRUD操作均由MP给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你干预开发出来的，所以查看执行期运行的SQL语句就成为当务之急。</p><p>​SpringBoot整合MP的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">mybatis-plus:  global-config:    db-config:      table-prefix: tbl_      id-type: auto  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>​再来看运行结果，此时就显示了运行期执行SQL的情况。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring==&gt;  Preparing: SELECT id,type,name,description FROM tbl_book==&gt; Parameters: &lt;==    Columns: id, type, name, description&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&lt;==        Row: 13, 测试类型, 测试数据, 测试描述数据&lt;==        Row: 14, 测试数据update, 测试数据update, 测试数据update&lt;==        Row: 15, -----------------, 测试数据123, 测试数据123&lt;==      Total: 15</code></pre><p>​其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。</p><p>​此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p><img src="image-20211129143207295.png" alt="image-20211129143207295" style="zoom:80%;"><p><strong>总结</strong></p><ol><li><p>手工导入starter坐标（2个），mysql驱动（1个）</p></li><li><p>配置数据源与MyBatisPlus对应的配置</p></li><li><p>开发Dao接口（继承BaseMapper）</p></li><li><p>制作测试类测试Dao功能是否有效</p></li><li><p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志</p></li></ol><h4 id="3-数据层开发——分页功能制作"><a href="#3-数据层开发——分页功能制作" class="headerlink" title="3.数据层开发——分页功能制作"></a>3.数据层开发——分页功能制作</h4><p>​前面仅仅是使用了MP提供的基础CRUD功能，实际上MP给我们提供了几乎所有的基础操作，这一节说一下如果实现数据库端的分页操作</p><p>​MP提供的分页操作API如下</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetPage(){    IPage page = new Page(2,5);    bookDao.selectPage(page, null);    System.out.println(page.getCurrent());    System.out.println(page.getSize());    System.out.println(page.getTotal());    System.out.println(page.getPages());    System.out.println(page.getRecords());}</code></pre><p>​其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MP提供的，别选错包了。创建此对象时就需要指定分页的两个基本数据</p><ul><li>当前显示第几页</li><li>每页显示几条数据</li></ul><p>​    可以通过创建Page对象时利用构造方法初始化这两个数据</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">IPage page = new Page(2,5);</code></pre><p>​将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">IPage page = bookDao.selectPage(page, null);</code></pre><p>​原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetPage(){    IPage page = new Page(2,5);    bookDao.selectPage(page, null);    System.out.println(page.getCurrent());//当前页码值    System.out.println(page.getSize());//每页显示数    System.out.println(page.getTotal());//数据总量    System.out.println(page.getPages());//总页数    System.out.println(page.getRecords());//详细数据}</code></pre><p>​到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页当前是无效的。为什么这样呢？这个要源于MP的内部机制。</p><p>​对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MP为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。</p><p>​基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MP将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MP的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下</p><p><strong>定义MP拦截器并将其设置为Spring管控的bean</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class MPConfig {    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return interceptor;    }}</code></pre><p>​上述代码第一行是创建MP的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p><p><strong>总结</strong></p><ol><li>使用IPage封装分页数据</li><li>分页操作依赖MyBatisPlus分页拦截器实现功能</li><li>借助MyBatisPlus日志查阅执行SQL语句</li></ol><h4 id="4-数据层开发——条件查询功能制作"><a href="#4-数据层开发——条件查询功能制作" class="headerlink" title="4.数据层开发——条件查询功能制作"></a>4.数据层开发——条件查询功能制作</h4><p>​除了分页功能，MP还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MP将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种套件的拼装。这里给大家普及一下基本格式，详细的操作还是到MP的课程中查阅吧</p><p>​下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetBy(){    QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;();    qw.like("name","Spring");    bookDao.selectList(qw);}</code></pre><p>​其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。</p><p>​这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。</p><p>​MP针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就变了上述问题的出现</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetBy2(){    String name = "1";    LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;();    lqw.like(Book::getName,name);    bookDao.selectList(lqw);}</code></pre><p>​为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MP还提供了动态拼装SQL的快捷书写方式</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetBy2(){    String name = "1";    LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;();    //if(name != null) lqw.like(Book::getName,name);//方式一：JAVA代码控制    lqw.like(name != null,Book::getName,name);//方式二：API接口提供控制开关    bookDao.selectList(lqw);}</code></pre><p>​其实就是个格式，没有区别。关于MP的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴还是去完整的学习一下MP的知识吧，这里只是蜻蜓点水的用了几个操作而已。</p><p><strong>总结</strong></p><ol><li><p>使用QueryWrapper对象封装查询条件</p></li><li><p>推荐使用LambdaQueryWrapper对象</p></li><li><p>所有查询操作封装成方法调用</p></li><li><p>查询条件支持动态条件拼装</p></li></ol><h4 id="5-业务层开发"><a href="#5-业务层开发" class="headerlink" title="5.业务层开发"></a>5.业务层开发</h4><p>​数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是<font color="#ff0000"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。</p><p>​一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">login(String username,String password);</code></pre><p>​而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">selectByUserNameAndPassword(String username,String password);</code></pre><p>​我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据接口：传入ID字段，查询出对应结果，结果是单条数据接口：传入离职字段，查询出对应结果，结果是多条数据</code></pre><p>​但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR</code></pre><p>​你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。</p><p>​多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface BookService {    Boolean save(Book book);    Boolean update(Book book);    Boolean delete(Integer id);    Book getById(Integer id);    List&lt;Book&gt; getAll();    IPage&lt;Book&gt; getPage(int currentPage,int pageSize);}</code></pre><p>​业务层实现类如下，转调数据层即可</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl implements BookService {    @Autowired    private BookDao bookDao;    @Override    public Boolean save(Book book) {        return bookDao.insert(book) &gt; 0;    }    @Override    public Boolean update(Book book) {        return bookDao.updateById(book) &gt; 0;    }    @Override    public Boolean delete(Integer id) {        return bookDao.deleteById(id) &gt; 0;    }    @Override    public Book getById(Integer id) {        return bookDao.selectById(id);    }    @Override    public List&lt;Book&gt; getAll() {        return bookDao.selectList(null);    }    @Override    public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) {        IPage page = new Page(currentPage,pageSize);        bookDao.selectPage(page,null);        return page;    }}</code></pre><p>​别忘了对业务层接口进行测试，测试类如下</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTestpublic class BookServiceTest {    @Autowired    private IBookService bookService;    @Test    void testGetById(){        System.out.println(bookService.getById(4));    }    @Test    void testSave(){        Book book = new Book();        book.setType("测试数据123");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookService.save(book);    }    @Test    void testUpdate(){        Book book = new Book();        book.setId(17);        book.setType("-----------------");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookService.updateById(book);    }    @Test    void testDelete(){        bookService.removeById(18);    }    @Test    void testGetAll(){        bookService.list();    }    @Test    void testGetPage(){        IPage&lt;Book&gt; page = new Page&lt;Book&gt;(2,5);        bookService.page(page);        System.out.println(page.getCurrent());        System.out.println(page.getSize());        System.out.println(page.getTotal());        System.out.println(page.getPages());        System.out.println(page.getRecords());    }}</code></pre><p><strong>总结</strong></p><ol><li>Service接口名称定义成业务名称，并与Dao接口名称进行区分</li><li>制作测试类测试Service功能是否有效</li></ol><h5 id="业务层快速开发"><a href="#业务层快速开发" class="headerlink" title="业务层快速开发"></a>业务层快速开发</h5><p>​其实MP技术不仅提供了数据层快速开发方案，业务层MP也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用</p><p>​业务层接口快速开发</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface IBookService extends IService&lt;Book&gt; {    //添加非通用操作API接口}</code></pre><p>​业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService {    @Autowired    private BookDao bookDao;//添加非通用操作API}</code></pre><p>​如果感觉MP提供的功能不足以支撑你的使用需要，其实是一定不能支撑的，因为需求不可能是通用的，在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。</p><p><strong>总结</strong></p><ol><li>使用通用接口（ISerivce<t>）快速开发Service</t></li><li>使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl</li><li>可以在通用接口基础上做功能重载或功能追加</li><li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li></ol><h4 id="6-表现层开发"><a href="#6-表现层开发" class="headerlink" title="6.表现层开发"></a>6.表现层开发</h4><p>​终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行</p><p>​表现层接口如下:</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController2 {    @Autowired    private IBookService bookService;    @GetMapping    public List&lt;Book&gt; getAll(){        return bookService.list();    }    // save 和 update都使用json来传参    @PostMapping    public Boolean save(@RequestBody Book book){        return bookService.save(book);    }    @PutMapping    public Boolean update(@RequestBody Book book){        return bookService.modify(book);    }    // delete 和 getById都使用路径方式来传参    @DeleteMapping("{id}")    public Boolean delete(@PathVariable Integer id){        return bookService.delete(id);    }    @GetMapping("{id}")    public Book getById(@PathVariable Integer id){        return bookService.getById(id);    }    @GetMapping("{currentPage}/{pageSize}")    public IPage&lt;Book&gt; getPage(@PathVariable int currentPage,@PathVariable int pageSize){        return bookService.getPage(currentPage,pageSize, null);    }}</code></pre><p>​在实用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了</p><p><strong>普通GET请求</strong></p><p><img src="image-20211129152237371.png" alt="image-20211129152237371"></p><p><strong>PUT请求传递json数据，后台实用@RequestBody接收数据</strong></p><p><img src="image-20211129152300177.png" alt="image-20211129152300177"></p><p><strong>GET请求传递路径变量，后台实用@PathVariable接收数据</strong></p><p><img src="Users\itcast\AppData\Roaming\Typora\typora-user-images\image-20211129152320073.png" alt="image-20211129152320073"></p><p><strong>总结</strong></p><ol><li>基于Restful制作表现层接口<ul><li>新增：POST</li><li>删除：DELETE</li><li>修改：PUT</li><li>查询：GET</li></ul></li><li>接收参数<ul><li>实体数据：@RequestBody</li><li>路径变量：@PathVariable</li></ul></li></ol><h4 id="7-表现层消息一致性处理"><a href="#7-表现层消息一致性处理" class="headerlink" title="7.表现层消息一致性处理"></a>7.表现层消息一致性处理</h4><p>​目前我们通过Postman测试后业务层接口功能时通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重</p><p>​<strong>增删改操作结果</strong></p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">true</code></pre><p>​<strong>查询单个数据操作结果</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"计算机理论",&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Spring实战&nbsp;第5版",&nbsp;&nbsp;&nbsp;&nbsp;"description":&nbsp;"Spring入门经典教程"}</code></pre><p>​<strong>查询全部数据操作结果</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">[&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"计算机理论",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Spring实战&nbsp;第5版",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description":&nbsp;"Spring入门经典教程"&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"计算机理论",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Spring&nbsp;5核心原理与30个类手写实战",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description":&nbsp;"十年沉淀之作"&nbsp;&nbsp;&nbsp;&nbsp;}]</code></pre><p>​每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Datapublic class R {    private Boolean flag;    private Object data;}</code></pre><p>​其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{&nbsp;&nbsp;&nbsp;&nbsp;"flag":&nbsp;true,&nbsp;&nbsp;&nbsp;&nbsp;"data":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"计算机理论",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Spring实战&nbsp;第5版",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description":&nbsp;"Spring入门经典教程"&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>​表现层开发格式也需要转换一下</p><img src="image-20211129153301262.png" alt="image-20211129153301262" style="zoom:80%;"><img src="image-20211129153319052.png" alt="image-20211129153319052" style="zoom:80%;"><img src="image-20211129153332499.png" alt="image-20211129153332499" style="zoom:80%;"><p>​结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的麻烦。</p><p><strong>总结</strong></p><ol><li><p>设计统一的返回值结果类型便于前端开发读取数据</p></li><li><p>返回值结果类型可以根据需求自行设定，没有固定格式</p></li><li><p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p></li></ol><h4 id="8-前后端联通性测试"><a href="#8-前后端联通性测试" class="headerlink" title="8.前后端联通性测试"></a>8.前后端联通性测试</h4><p>​后端的表现层接口开发完毕，就可以进行前端的开发了。</p><p>​将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。</p><p>​<img src="image-20211129153831990.png" alt="image-20211129153831990"></p><p>​在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//列表getAll() {axios.get("/books").then((res)=&gt;{console.log(res.data);});},</code></pre><p>​只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了</p><p><strong>总结</strong></p><ol><li>单体项目中页面放置在resources/static目录下</li><li>created钩子函数用于初始化页面时发起调用</li><li>页面使用axios发送异步请求获取数据后确认前后端是否联通</li></ol><h4 id="9-页面基础功能开发"><a href="#9-页面基础功能开发" class="headerlink" title="9.页面基础功能开发"></a>9.页面基础功能开发</h4><h5 id="F-1-列表功能（非分页版）"><a href="#F-1-列表功能（非分页版）" class="headerlink" title="F-1.列表功能（非分页版）"></a>F-1.列表功能（非分页版）</h5><p>​列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可</p><p>​<strong>页面数据模型定义</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">data:{dataList: [],//当前页要展示的列表数据...},</code></pre><p>​异步请求获取数据</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//列表getAll() {    axios.get("/books").then((res)=&gt;{        this.dataList = res.data.data;    });},</code></pre><p>​这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了</p><p>总结：</p><ol><li>将查询数据返回到页面，利用前端数据绑定进行数据展示</li></ol><h5 id="F-2-添加功能"><a href="#F-2-添加功能" class="headerlink" title="F-2.添加功能"></a>F-2.添加功能</h5><p>​添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可</p><p>​<strong>默认状态</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">data:{dialogFormVisible: false,//添加表单是否可见...},</code></pre><p>​<strong>切换为显示状态</strong></p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//弹出添加窗口handleCreate() {this.dialogFormVisible = true;},</code></pre><p>​由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹</p><p>​<strong>定义清理数据操作</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//重置表单resetForm() {    this.formData = {};},</code></pre><p>​<strong>切换弹窗状态时清理数据</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//弹出添加窗口handleCreate() {    this.dialogFormVisible = true;    this.resetForm();},</code></pre><p>​至此准备工作完成，下面就要调用后台完成添加操作了</p><p>​<strong>添加操作</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//添加handleAdd () {    //发送异步请求    axios.post("/books",this.formData).then((res)=&gt;{        //如果操作成功，关闭弹层，显示数据        if(res.data.flag){            this.dialogFormVisible = false;            this.$message.success("添加成功");        }else {            this.$message.error("添加失败");        }    }).finally(()=&gt;{        this.getAll();    });},</code></pre><ol><li>将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台</li><li>根据返回的操作结果决定下一步操作<ul><li>如何是true就关闭添加窗口，显示添加成功的消息</li><li>如果是false保留添加窗口，显示添加失败的消息</li></ul></li><li>无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）</li></ol><p>​<strong>取消添加操作</strong></p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//取消cancel(){    this.dialogFormVisible = false;    this.$message.info("操作取消");},</code></pre><p><strong>总结</strong></p><ol><li>请求方式使用POST调用后台对应操作</li><li>添加操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>弹出添加Div时清除表单数据</li></ol><h5 id="F-3-删除功能"><a href="#F-3-删除功能" class="headerlink" title="F-3.删除功能"></a>F-3.删除功能</h5><p>​模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可</p><p>​<strong>删除操作</strong></p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">// 删除handleDelete(row) {    axios.delete("/books/"+row.id).then((res)=&gt;{        if(res.data.flag){            this.$message.success("删除成功");        }else{            this.$message.error("删除失败");        }    }).finally(()=&gt;{        this.getAll();    });},</code></pre><p>​<strong>删除操作提示信息</strong></p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">// 删除handleDelete(row) {    //1.弹出提示框    this.$confirm("此操作永久删除当前数据，是否继续？","提示",{        type:'info'    }).then(()=&gt;{        //2.做删除业务        axios.delete("/books/"+row.id).then((res)=&gt;{       if(res.data.flag){            this.$message.success("删除成功");        }else{            this.$message.error("删除失败");        }        }).finally(()=&gt;{            this.getAll();        });    }).catch(()=&gt;{        //3.取消删除        this.$message.info("取消删除操作");    });}，</code></pre><p><strong>总结</strong></p><ol><li>请求方式使用Delete调用后台对应操作</li><li>删除操作需要传递当前行数据对应的id值到后台</li><li>删除操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>删除操作前弹出提示框避免误操作</li></ol><h5 id="F-4-修改功能"><a href="#F-4-修改功能" class="headerlink" title="F-4.修改功能"></a>F-4.修改功能</h5><p>​修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p><ol><li><p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p></li><li><p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p></li><li><p>查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台</p></li><li><p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p></li><li><p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p><p>所以整体上来看，修改功能就是前面几个功能的大合体</p><p><strong>查询并展示数据</strong></p></li></ol><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//弹出编辑窗口handleUpdate(row) {    axios.get("/books/"+row.id).then((res)=&gt;{        if(res.data.flag){            //展示弹层，加载数据            this.formData = res.data.data;            this.dialogFormVisible4Edit = true;        }else{            this.$message.error("数据同步失败，自动刷新");        }    });},</code></pre><p>​<strong>修改操作</strong></p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//修改handleEdit() {    axios.put("/books",this.formData).then((res)=&gt;{        //如果操作成功，关闭弹层并刷新页面        if(res.data.flag){            this.dialogFormVisible4Edit = false;            this.$message.success("修改成功");        }else {            this.$message.error("修改失败，请重试");        }    }).finally(()=&gt;{        this.getAll();    });},</code></pre><p><strong>总结</strong></p><ol><li>加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）</li><li>利用前端双向数据绑定将查询到的数据进行回显（同查询全部）</li><li>请求方式使用PUT调用后台对应操作（同新增传递数据）</li><li>修改操作结束后动态刷新页面加载数据（同新增）</li><li>根据操作结果不同，显示对应的提示信息（同新增）</li></ol><p>​</p><h4 id="10-业务消息一致性处理"><a href="#10-业务消息一致性处理" class="headerlink" title="10.业务消息一致性处理"></a>10.业务消息一致性处理</h4><p>​目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{&nbsp;&nbsp;&nbsp;&nbsp;"timestamp":&nbsp;"2021-09-15T03:27:31.038+00:00",&nbsp;&nbsp;&nbsp;&nbsp;"status":&nbsp;500,&nbsp;&nbsp;&nbsp;&nbsp;"error":&nbsp;"Internal&nbsp;Server&nbsp;Error",&nbsp;&nbsp;&nbsp;&nbsp;"path":&nbsp;"/books"}</code></pre><p>​面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{&nbsp;&nbsp;&nbsp;&nbsp;"flag":&nbsp;true,&nbsp;&nbsp;&nbsp;&nbsp;"data":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"计算机理论",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":&nbsp;"Spring实战&nbsp;第5版",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description":&nbsp;"Spring入门经典教程"&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>​看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理</p><p>​首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Datapublic class R{    private Boolean flag;    private Object data;    private String msg;//用于封装消息}</code></pre><p>​后台代码也要根据情况做处理，当前是模拟的错误</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@PostMappingpublic R save(@RequestBody Book book) throws IOException {    Boolean flag = bookService.insert(book);    return new R(flag , flag ? "添加成功^_^" : "添加失败-_-!");}</code></pre><p>​然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的后台服务器异常处理</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestControllerAdvicepublic class ProjectExceptionAdvice {    @ExceptionHandler(Exception.class)    public R doOtherException(Exception ex){        //记录日志        //发送消息给运维        //发送邮件给开发人员,ex对象发送给开发人员        ex.printStackTrace();        return new R(false,null,"服务器故障，请稍后再试！");    }}</code></pre><p>​页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//添加handleAdd () {//发送ajax请求    axios.post("/books",this.formData).then((res)=&gt;{        //如果操作成功，关闭弹层，显示数据        if(res.data.flag){            this.dialogFormVisible = false;            this.$message.success(res.data.msg);        }else {            this.$message.error(res.data.msg);//消息来自于后台传递过来，而非固定内容        }    }).finally(()=&gt;{        this.getAll();    });},</code></pre><p><strong>总结</strong></p><ol><li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li><li>异常处理器必须被扫描加载，否则无法生效</li><li>表现层返回结果的模型类中添加消息属性用来传递消息到页面</li></ol><p>​</p><h4 id="11-页面功能开发"><a href="#11-页面功能开发" class="headerlink" title="11.页面功能开发"></a>11.页面功能开发</h4><h5 id="F-5-分页功能"><a href="#F-5-分页功能" class="headerlink" title="F-5.分页功能"></a>F-5.分页功能</h5><p>​分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!--分页组件--&gt;&lt;div class="pagination-container"&gt;    &lt;el-paginationclass="pagiantion"@current-change="handleCurrentChange":current-page="pagination.currentPage":page-size="pagination.pageSize"layout="total, prev, pager, next, jumper":total="pagination.total"&gt;    &lt;/el-pagination&gt;&lt;/div&gt;</code></pre><p>​为了配合分页组件，封装分页对应的数据模型</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">data:{pagination: {//分页相关模型数据currentPage: 1,//当前页码pageSize:10,//每页显示的记录数total:0,//总记录数}},</code></pre><p>​修改查询全部功能为分页查询，通过路径变量传递页码信息参数</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">getAll() {    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) =&gt; {    });},</code></pre><p>​后台提供对应的分页功能</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@GetMapping("/{currentPage}/{pageSize}")public R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize){    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage, pageSize);    return new R(null != pageBook ,pageBook);}</code></pre><p>​页面根据分页操作结果读取对应数据，并进行数据模型绑定</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">getAll() {    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) =&gt; {        this.pagination.total = res.data.data.total;        this.pagination.currentPage = res.data.data.current;        this.pagination.pagesize = res.data.data.size;        this.dataList = res.data.data.records;    });},</code></pre><p>​对切换页码操作设置调用当前分页操作</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">//切换页码handleCurrentChange(currentPage) {    this.pagination.currentPage = currentPage;    this.getAll();},</code></pre><p><strong>总结</strong></p><ol><li>使用el分页组件</li><li>定义分页组件绑定的数据模型</li><li>异步调用获取分页数据</li><li>分页数据页面回显</li></ol><h5 id="F-6-删除功能维护"><a href="#F-6-删除功能维护" class="headerlink" title="F-6.删除功能维护"></a>F-6.删除功能维护</h5><p>​由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@GetMapping("{currentPage}/{pageSize}")public R getPage(@PathVariable int currentPage,@PathVariable int pageSize){    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值    if( currentPage &gt; page.getPages()){        page = bookService.getPage((int)page.getPages(), pageSize);    }    return new R(true, page);}</code></pre><h5 id="F-7-条件查询功能"><a href="#F-7-条件查询功能" class="headerlink" title="F-7.条件查询功能"></a>F-7.条件查询功能</h5><p>​最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p><ul><li><p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件</p></li><li><p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大</p></li><li><p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p><p>经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别</p><p>页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递</p><p><strong>页面封装查询条件字段</strong></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">pagination: {//分页相关模型数据currentPage: 1,//当前页码pageSize:10,//每页显示的记录数total:0,//总记录数name: "",type: "",description: ""},</code></pre><p>页面添加查询条件字段对应的数据模型绑定名称</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div class="filter-container"&gt;    &lt;el-input placeholder="图书类别" v-model="pagination.type" class="filter-item"/&gt;    &lt;el-input placeholder="图书名称" v-model="pagination.name" class="filter-item"/&gt;    &lt;el-input placeholder="图书描述" v-model="pagination.description" class="filter-item"/&gt;    &lt;el-button @click="getAll()" class="dalfBut"&gt;查询&lt;/el-button&gt;    &lt;el-button type="primary" class="butT" @click="handleCreate()"&gt;新建&lt;/el-button&gt;&lt;/div&gt;</code></pre><p>将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">getAll() {    //1.获取查询条件,拼接查询条件    param = "?name="+this.pagination.name;    param += "&amp;type="+this.pagination.type;    param += "&amp;description="+this.pagination.description;    console.log("-----------------"+ param);    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize+param).then((res) =&gt; {        this.dataList = res.data.data.records;    });},</code></pre><p>后台代码中定义实体类封查询条件</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@GetMapping("{currentPage}/{pageSize}")public R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) {    System.out.println("参数=====&gt;"+book);    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize);    return new R(null != pageBook ,pageBook);}</code></pre><p>对应业务层接口与实现类进行修正</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface IBookService extends IService&lt;Book&gt; {    IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook);}</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl2 extends ServiceImpl&lt;BookDao,Book&gt; implements IBookService {    public IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook){        IPage page = new Page(currentPage,pageSize);        LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;();        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());        return bookDao.selectPage(page,lqw);    }}</code></pre><p>页面回显数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">getAll() {    //1.获取查询条件,拼接查询条件    param = "?name="+this.pagination.name;    param += "&amp;type="+this.pagination.type;    param += "&amp;description="+this.pagination.description;    console.log("-----------------"+ param);    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize+param).then((res) =&gt; {        this.pagination.total = res.data.data.total;        this.pagination.currentPage = res.data.data.current;        this.pagination.pagesize = res.data.data.size;        this.dataList = res.data.data.records;    });},</code></pre></li></ul><p><strong>总结</strong></p><ol><li>定义查询条件数据模型（当前封装到分页数据模型中）</li><li>异步调用分页功能并通过请求参数传递数据到后台</li></ol><h2 id="基础篇完结"><a href="#基础篇完结" class="headerlink" title="基础篇完结"></a>基础篇完结</h2><p>​基础篇到这里就全部结束了，在基础篇中带着大家学习了如果创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。</p><h1 id="二、SpringBoot运维实用篇"><a href="#二、SpringBoot运维实用篇" class="headerlink" title="二、SpringBoot运维实用篇"></a>二、SpringBoot运维实用篇</h1><p>​基础篇发布以后，看到了很多小伙伴在网上的留言，也帮助超过100位小伙伴解决了一些遇到的问题，并且已经发现了部分问题具有典型性，预计将有些问题在后面篇章的合适位置添加到本套课程中，作为解决方案提供给大家。</p><p>​从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全SpringBoot的知识图谱。比如在基础篇中只给大家讲了yaml的语法格式，但是具体写yaml文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。</p><p>​实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。</p><p>​下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：</p><ul><li>SpringBoot程序的打包与运行</li><li>配置高级</li><li>多环境开发</li><li>日志</li></ul><p>​下面开启第一部分SpringBoot程序打包与运行的学习</p><h2 id="1-SpringBoot程序的打包与运行"><a href="#1-SpringBoot程序的打包与运行" class="headerlink" title="1. SpringBoot程序的打包与运行"></a>1. SpringBoot程序的打包与运行</h2><p>​刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。</p><img src="image-20211201091317258.png" alt="image-20211201091317258" style="zoom:67%;"><p>​但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。</p><img src="image-20211201091341645.png" alt="image-20211201091341645" style="zoom:67%;"><p>​我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。</p><img src="image-20211201091502040.png" alt="image-20211201091502040" style="zoom:67%;"><p>​那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p><ol><li>开发部门使用Git、SVN等版本控制工具上传工程到版本服务器</li><li>服务器使用版本控制工具下载工程</li><li>服务器上使用Maven工具在当前真机环境下重新构建项目</li><li>启动服务</li></ol><p>​继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。</p><h3 id="程序打包与运行"><a href="#程序打包与运行" class="headerlink" title="程序打包与运行"></a>程序打包与运行</h3><p>​SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">mvn package</code></pre><p>​打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。</p><p>​程序包打好以后，就可以直接执行了。在程序包所在路径下，cmd执行指令。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">java -jar 工程包名.jar</code></pre><p>​执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p><p>​<font color="#ff0000"><b>特别关注</b></font>：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。</p><p>​<font color="#ff0000"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p><strong>总结</strong></p><ol><li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li><li>SpringBoot工程执行mvn命令package进行打包</li><li>执行jar命令：java –jar 工程名.jar</li></ol><h3 id="SpringBoot程序打包失败处理"><a href="#SpringBoot程序打包失败处理" class="headerlink" title="SpringBoot程序打包失败处理"></a>SpringBoot程序打包失败处理</h3><p>​有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象</p><img src="image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;"><p>​要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。</p><p>​搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。</p><p>​在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>​我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征</p><ul><li>打包后文件的大小不同</li><li>打包后所包含的内容不同</li><li>打包程序中个别文件内容不同</li></ul><p>​先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：</p><img src="image-20211201095610270.png" alt="image-20211201095610270" style="zoom:150%;"><p>​不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。</p><p>​<img src="image-20211201101541267.png" alt="image-20211201101541267" style="zoom:50%;"><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;"></p><p>​我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。</p><p>​<img src="image-20211201101805569.png" alt="image-20211201101805569" style="zoom:50%;"><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;"></p><p>​原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。</p><p>​<img src="image-20211201102025791.png" alt="image-20211201102025791" style="zoom:50%;"></p><p>​仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。</p><p>​再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\springframework\boot\loader，在里面可以找到一个<font color="#ff0000"><b>JarLauncher.class</b></font>的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。</p><p>​回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别</p><ul><li><p>小容量文件的MANIFEST.MF</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">Manifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0</code></pre></li><li><p>大容量文件的MANIFEST.MF</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.itheima.SSMPApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher</code></pre></li></ul><p>​大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。</p><p>​现在这组设定的作用就搞清楚了</p><ol><li>SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包</li><li>首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类</li><li>JarLauncher类执行时会找到Start-Class属性，也就是启动类类名</li><li>运行启动类时会运行当前工程的内容</li><li>运行当前工程时会使用依赖的jar包，从lib目录中查找</li></ol><p>​看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。</p><p>​再来看之前的报错信息：</p><img src="image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;"><p>​由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。</p><p>​上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。</p><p><strong>总结</strong></p><ol><li>spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包</li></ol><h3 id="命令行启动常见问题及解决方案"><a href="#命令行启动常见问题及解决方案" class="headerlink" title="命令行启动常见问题及解决方案"></a>命令行启动常见问题及解决方案</h3><p>​各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA"># 查询端口netstat -ano# 查询指定端口netstat -ano |findstr "端口号"# 根据进程PID查询进程名称tasklist |findstr "进程PID号"# 根据PID杀死任务taskkill /F /PID "进程PID号"# 根据进程名称杀死任务taskkill -f -t -im "进程名称"</code></pre><p>​关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。</p><h3 id="SpringBoot项目快速启动（Linux版）"><a href="#SpringBoot项目快速启动（Linux版）" class="headerlink" title="SpringBoot项目快速启动（Linux版）"></a>SpringBoot项目快速启动（Linux版）</h3><p>​其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。</p><ul><li>基于Linux（CenterOS7）</li><li>安装JDK，且版本不低于打包时使用的JDK版本</li><li>安装包保存在/usr/local/自定义目录中或$HOME下</li><li>其他操作参照Windows版进行</li></ul><h2 id="2-配置高级"><a href="#2-配置高级" class="headerlink" title="2. 配置高级"></a>2. 配置高级</h2><p>​关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。</p><h3 id="2-1-临时属性设置"><a href="#2-1-临时属性设置" class="headerlink" title="2.1 临时属性设置"></a>2.1 临时属性设置</h3><p>​目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。</p><p><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20211206095113771.png" alt="image-20211206095113771">             <img src="image-20211206095524343.png" alt="image-20211206095524343">             <img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20211206095101581.png" alt="image-20211206095101581"></p><p>​SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">java –jar springboot.jar –-server.port=80</code></pre><p>​上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。</p><p>​如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">java –jar springboot.jar –-server.port=80 --logging.level.root=debug</code></pre><h4 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a>属性加载优先级</h4><p>​现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><img src="image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;"><p>​我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p><p>​比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。</p><p>​我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。</p><p><strong>总结</strong></p><ol><li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式：java –jar 工程名.jar –-属性名=值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性，否则设置无效</li></ol><h4 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h4><p>​临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。</p><p>​打开SpringBoot启动类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。</p><img src="image-20211206101947622.png" alt="image-20211206101947622" style="zoom:80%;"><p>​做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public static void main(String[] args) {}</code></pre><p>​原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public static void main(String[] args) {    SpringApplication.run(SSMPApplication.class,args);}</code></pre><p>​这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样<strong>外部临时属性就无法进入到SpringBoot程序中</strong>了。确保了安全性</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public static void main(String[] args) {    SpringApplication.run(SSMPApplication.class);}</code></pre><p>​或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public static void main(String[] args) {    String[] arg = new String[1];    arg[0] = "--server.port=8082";    SpringApplication.run(SSMPApplication.class, arg);}</code></pre><p><strong>总结</strong></p><ol><li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li></ol><p><strong>思考</strong></p><p>​现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。</p><h3 id="2-2-配置文件分类-1"><a href="#2-2-配置文件分类-1" class="headerlink" title="2.2 配置文件分类"></a>2.2 配置文件分类</h3><p>​SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。</p><p><strong>4个级别分别是</strong>：</p><ul><li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li><li>类路径下config目录下配置文件</li><li>程序包所在目录中配置文件</li><li>程序包所在目录中config目录下配置文件</li></ul><p>​好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为</p><ol><li>file ：config/application.yml <strong>【最高】</strong></li><li>file ：application.yml</li><li>classpath：config/application.yml</li><li>classpath：application.yml  <strong>【最低】</strong></li></ol><p>​那为什么设计这种多种呢？说一个最典型的应用吧。</p><ul><li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li><li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li><li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li></ul><p>​解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p><p>​级别1和2什么时候使用呢？程序==打包以后==就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p><p><strong>总结</strong></p><ol><li><p>配置文件分为4种</p><ul><li>项目类路径配置文件：服务于开发人员本机开发与测试</li><li>项目类路径config目录中配置文件：服务于项目经理整体调控</li><li>工程路径配置文件：服务于运维人员配置涉密线上环境</li><li>工程路径config目录中配置文件：服务于运维经理整体调控</li></ul></li><li><p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p></li></ol><h3 id="2-3-自定义配置文件"><a href="#2-3-自定义配置文件" class="headerlink" title="2.3 自定义配置文件"></a>2.3 自定义配置文件</h3><p>​之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。</p><p>​自定义配置文件方式有如下两种：</p><p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong></p><img src="image-20211206105548238.png" alt="image-20211206105548238" style="zoom:67%;"><p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong></p><img src="image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;"><p>​也可以设置加载多个配置文件</p><img src="image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;"><p>​使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。</p><p><strong>总结</strong></p><ol><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol><h2 id="3-多环境开发"><a href="#3-多环境开发" class="headerlink" title="3. 多环境开发"></a>3. 多环境开发</h2><p>​讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。</p><p>​什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。</p><img src="image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;"><h3 id="3-1-多环境开发（yaml单一文件版）"><a href="#3-1-多环境开发（yaml单一文件版）" class="headerlink" title="3.1 多环境开发（yaml单一文件版）"></a>3.1 多环境开发（yaml单一文件版）</h3><p>​那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 80</code></pre><p>​如何想设计两组环境呢？中间使用三个减号分隔开</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 80---server:  port: 81</code></pre><p>​如何区分两种环境呢？起名字呗</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles: proserver:port: 80---spring:profiles: devserver:port: 81</code></pre><p>​那用哪一个呢？设置默认启动哪个就可以了</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:active: pro# 启动pro---spring:profiles: proserver:port: 80---spring:profiles: devserver:port: 81</code></pre><p>​就这么简单，再多来一组环境也OK</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:active: pro# 启动pro---spring:profiles: proserver:port: 80---spring:profiles: devserver:port: 81---spring:profiles: testserver:port: 82</code></pre><p>​其中关于环境名称定义上述格式是过时格式，标准格式如下</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:config:    activate:        on-profile: pro</code></pre><p><strong>总结</strong></p><ol><li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li><li>yaml格式中设置多环境使用—区分环境设置边界</li><li>每种环境的区别在于加载的配置属性不同</li><li>启用某种环境时需要指定启动时使用该环境</li></ol><h3 id="3-2-多环境开发（yaml多文件版）"><a href="#3-2-多环境开发（yaml多文件版）" class="headerlink" title="3.2 多环境开发（yaml多文件版）"></a>3.2 多环境开发（yaml多文件版）</h3><p>​将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p><p><strong>主配置文件</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:active: pro# 启动pro</code></pre><p><strong>环境配置文件</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:port: 80</code></pre><p>​环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p><p><strong>application-pro.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:port: 80</code></pre><p><strong>application-dev.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:port: 81</code></pre><p>​文件的命名规则为：application-环境名.yml。</p><p>​在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul><p><strong>总结</strong></p><ol><li><p>可以使用独立配置文件定义环境属性</p></li><li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p></li></ol><h3 id="3-3-多环境开发（properties多文件版）"><a href="#3-3-多环境开发（properties多文件版）" class="headerlink" title="3.3 多环境开发（properties多文件版）"></a>3.3 多环境开发（properties多文件版）</h3><p>​SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。</p><p><strong>主配置文件</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.profiles.active=pro</code></pre><p><strong>环境配置文件</strong></p><p><strong>application-pro.properties</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=80</code></pre><p><strong>application-dev.properties</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port=81</code></pre><p>​文件的命名规则为：application-环境名.properties。</p><p><strong>总结</strong></p><ol><li>properties文件多环境配置仅支持多文件格式</li></ol><h3 id="3-4-多环境开发独立配置文件书写技巧"><a href="#3-4-多环境开发独立配置文件书写技巧" class="headerlink" title="3.4 多环境开发独立配置文件书写技巧"></a>3.4 多环境开发独立配置文件书写技巧</h3><p>​作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。</p><p><strong>准备工作</strong></p><p>​将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p><ul><li>application-devDB.yml</li><li>application-devRedis.yml</li><li>application-devMVC.yml</li></ul><p><strong>使用</strong></p><p>​使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:    active: dev        include: devDB,devRedis,devMVC</code></pre><p>​比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p><p><strong>注意</strong></p><p>​当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p><p><strong>改良</strong></p><p>​但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:    active: dev        group:        "dev": devDB,devRedis,devMVC      "pro": proDB,proRedis,proMVC      "test": testDB,testRedis,testMVC</code></pre><p>​现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！</p><p><strong>总结</strong></p><ol><li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li></ol><h3 id="3-5-多环境开发控制"><a href="#3-5-多环境开发控制" class="headerlink" title="3.5 多环境开发控制"></a>3.5 多环境开发控制</h3><p>​多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。</p><p>​要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p><p>​maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：</p><ul><li>先在maven环境中设置用什么具体的环境</li><li>在SpringBoot中读取maven设置的环境即可</li></ul><p><strong>maven中设置多环境（使用属性方式区分环境）</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;profiles&gt;    &lt;profile&gt;        &lt;id&gt;env_dev&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;dev&lt;/profile.active&gt;        &lt;/properties&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;!--默认启动环境--&gt;        &lt;/activation&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;env_pro&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;pro&lt;/profile.active&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><p><strong>SpringBoot中读取maven设置值</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:profiles:    active: @profile.active@</code></pre><p>​上面的@属性名@就是读取maven中配置的属性值的语法格式。</p><p><strong>总结</strong></p><ol><li>当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</li><li>基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</li></ol><h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4. 日志"></a>4. 日志</h2><p>​运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：</p><ul><li>编程期调试代码</li><li>运营期记录信息</li><li>记录日常运营重要信息（峰值流量、平均响应时长……）</li><li>记录应用报错信息（错误堆栈）</li><li>记录运维过程数据（扩容、宕机、报警……）</li></ul><p>​或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。</p><h4 id="4-1-代码中使用日志工具记录日志"><a href="#4-1-代码中使用日志工具记录日志" class="headerlink" title="4.1 代码中使用日志工具记录日志"></a>4.1 代码中使用日志工具记录日志</h4><p>​日志的使用格式非常固定，直接上操作步骤：</p><p><strong>步骤①</strong>：添加日志记录操作</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController extends BaseClass{    // 声明日志对象    private static final Logger log = LoggerFactory.getLogger(BookController.class);    @GetMapping    public String getById(){        log.debug("debug...");        log.info("info...");        log.warn("warn...");        log.error("error...");        return "springboot is running...2";    }}</code></pre><p>​上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。</p><p><strong>步骤②</strong>：在配置文件中设置日志输出级别</p><p>​日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：</p><ul><li>TRACE：运行堆栈信息，使用率低</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul><p>​一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true</code></pre><p>​这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true# 设置日志级别，root表示根节点，即整体应用日志级别logging:level:    root: debug</code></pre><p>​还可以再设置更细粒度的控制</p><p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">logging:# 设置日志组    group:    # 自定义组名，设置当前组中所包含的包        ebank: com.itheima.controller    level:    root: warn        # 为对应组设置日志级别        ebank: debug    # 为对包设置日志级别        com.itheima.controller: debug</code></pre><p>​说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p><p><strong>总结</strong></p><ol><li>日志用于记录开发调试与运维过程消息</li><li>日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR</li><li>可以通过日志组或代码包的形式进行日志显示级别的控制</li></ol><h4 id="教你一招：优化日志对象创建代码"><a href="#教你一招：优化日志对象创建代码" class="headerlink" title="教你一招：优化日志对象创建代码"></a>教你一招：优化日志对象创建代码</h4><p>​写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController extends BaseClass{    private static final Logger log = LoggerFactory.getLogger(BookController.class);//这一句可以不写了}</code></pre><p>​导入lombok后使用注解搞定，日志对象名为log</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Slf4j//这个注解替代了下面那一行@RestController@RequestMapping("/books")public class BookController extends BaseClass{    private static final Logger log = LoggerFactory.getLogger(BookController.class);//这一句可以不写了}</code></pre><p><strong>总结</strong></p><ol><li>基于lombok提供的@Slf4j注解为类快速添加日志对象</li></ol><h4 id="4-2-日志输出格式控制"><a href="#4-2-日志输出格式控制" class="headerlink" title="4.2 日志输出格式控制"></a>4.2 日志输出格式控制</h4><p>​日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p><p><img src="image-20211206123431222.png" alt="image-20211206123431222"></p><p>​对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">logging:pattern:    console: "%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n"</code></pre><p><strong>总结</strong></p><ol><li>日志输出格式设置规则</li></ol><h4 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h4><p>​日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p><p>​对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。</p><p>​记录日志到文件中格式非常简单，设置日志文件名即可。</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">logging:file:    name: server.log</code></pre><p>​虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">logging:logback:    rollingpolicy:        max-file-size: 3KB            file-name-pattern: server.%d{yyyy-MM-dd}.%i.log</code></pre><p>​以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。</p><p><strong>总结</strong></p><ol><li>日志记录到文件</li><li>日志文件格式设置</li></ol><h2 id="运维实用篇完结"><a href="#运维实用篇完结" class="headerlink" title="运维实用篇完结"></a>运维实用篇完结</h2><p>​运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。</p><p>​在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。</p><p>​看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。</p><h1 id="三、SpringBoot开发实用篇"><a href="#三、SpringBoot开发实用篇" class="headerlink" title="三、SpringBoot开发实用篇"></a>三、SpringBoot开发实用篇</h1><p>​怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。</p><p>​运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。</p><p>​开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：</p><ul><li>热部署</li><li>配置高级</li><li>测试</li><li>数据层解决方案</li><li>整合第三方技术</li><li>监控</li></ul><p>​看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习</p><h2 id="1-热部署"><a href="#1-热部署" class="headerlink" title="1. 热部署"></a>1. 热部署</h2><p>​什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。</p><p>​热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。</p><p><strong>非springboot项目热部署实现原理</strong></p><p>​开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。</p><p>​上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串”abc”改成”cba”，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。</p><p>​看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。</p><p><strong>springboot项目热部署实现原理</strong></p><p>​基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。</p><p>​下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。</p><h3 id="1-1-手动启动热部署"><a href="#1-1-手动启动热部署" class="headerlink" title="1.1 手动启动热部署"></a>1.1 手动启动热部署</h3><p><strong>步骤①</strong>：导入开发者工具对应的坐标</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：构建项目，可以使用快捷键激活此功能</p><p><img src="image-20220222121257218.png" alt="image-20220222121257218"></p><p>​对应的快捷键一定要记得</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">&lt;CTR&gt;L+&lt;F9&gt;</code></pre><p>​以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。</p><p><strong>重启与重载</strong></p><p>​一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。</p><ul><li>base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化</li><li>restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响</li></ul><p>​当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。</p><p><strong>总结</strong></p><ol><li>使用开发者工具可以为当前项目开启热部署功能</li><li>使用构建项目操作对工程进行热部署</li></ol><p><strong>思考</strong></p><p>​上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。</p><p>​</p><h3 id="1-2-自动启动热部署"><a href="#1-2-自动启动热部署" class="headerlink" title="1.2 自动启动热部署"></a>1.2 自动启动热部署</h3><p>​自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署</p><p><strong>步骤①</strong>：设置自动构建项目</p><p>​打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目</p><p><img src="image-20220222123543551.png" alt="image-20220222123543551"></p><p>​自动构建项目选项勾选后</p><p><strong>步骤②</strong>：开启IDEA的自动编译（动态）<br>具体步骤：打开顶部工具栏 File -&gt; Settings -&gt; Advanced Settings -&gt; Compiler -&gt; 然后勾选 Allow auto-make to start even if developed application is currently running。</p><p><img src="dac3b70d1006450e9732df275b4994bb.png" alt="在这里插入图片描述"></p><p><strong>步骤③</strong>：开启IDEA的<a href="https://so.csdn.net/so/search?q=%E7%83%AD%E9%83%A8%E7%BD%B2&amp;spm=1001.2101.3001.7020">热部署</a>策略（非常重要）<br>具体步骤：点击Edit COnfigurations…进入</p><p><img src="8d21bf16df2a4417b7cca5c81674be85.png" alt="在这里插入图片描述"></p><p>选择Modif options -&gt; On ‘Updata’ actrion -&gt; Update classes and resources</p><p><img src="7e5757cad94a4d5792e9e81abbe9ef47.png" alt="在这里插入图片描述"></p><p><font color="#ff0000"><b>关注</b></font>：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置==当idea工具失去焦点5秒后进行热部署==。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。</p><p><strong>总结</strong></p><ol><li>自动热部署要开启自动构建项目</li><li>自动热部署要开启在程序运行时自动构建项目</li></ol><p><strong>思考</strong></p><p>​现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。</p><h3 id="1-3-参与热部署监控的文件范围配置"><a href="#1-3-参与热部署监控的文件范围配置" class="headerlink" title="1.3 参与热部署监控的文件范围配置"></a>1.3 参与热部署监控的文件范围配置</h3><p>​通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下</p><ul><li>/META-INF/maven</li><li>/META-INF/resources</li><li>/resources</li><li>/static</li><li>/public</li><li>/templates</li></ul><p>​以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  devtools:    restart:      # 设置不参与热部署的文件或文件夹      exclude: static/**,public/**,config/application.yml</code></pre><p><strong>总结</strong></p><ol><li>通过配置可以修改不参与热部署的文件或目录</li></ol><p><strong>思考</strong></p><p>​热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。</p><h3 id="1-4-关闭热部署"><a href="#1-4-关闭热部署" class="headerlink" title="1.4 关闭热部署"></a>1.4 关闭热部署</h3><p>​线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  devtools:    restart:      enabled: false</code></pre><p>​如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class SSMPApplication {    public static void main(String[] args) {        System.setProperty("spring.devtools.restart.enabled","false");        SpringApplication.run(SSMPApplication.class);    }}</code></pre><p>​其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。</p><p><strong>总结</strong></p><ol><li>通过配置可以关闭热部署功能降低线上程序的资源消耗</li></ol><h2 id="2-配置高级-1"><a href="#2-配置高级-1" class="headerlink" title="2. 配置高级"></a>2. 配置高级</h2><p>​进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。</p><h3 id="2-1-ConfigurationProperties"><a href="#2-1-ConfigurationProperties" class="headerlink" title="2.1 @ConfigurationProperties"></a>2.1 @ConfigurationProperties</h3><h4 id="自定义的bean"><a href="#自定义的bean" class="headerlink" title="自定义的bean"></a>自定义的bean</h4><p>​在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性</p><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">servers:  ip-address: 192.168.0.1   port: 2345  timeout: -1</code></pre><p>​然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Datapublic class ServerConfig {    private String ipAddress;    private int port;    private long timeout;}</code></pre><p>​使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig {    private String ipAddress;    private int port;    private long timeout;}</code></pre><p>​</p><p>这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给<strong>自定义的bean</strong>使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而<strong>第三方开发的bean</strong>源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。</p><h4 id="第三方的bean"><a href="#第三方的bean" class="headerlink" title="第三方的bean"></a>第三方的bean</h4><p>​使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。</p><p><strong>步骤①</strong>：使用@Bean注解定义第三方bean</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Beanpublic DruidDataSource datasource(){    DruidDataSource ds = new DruidDataSource();    return ds;}</code></pre><p><strong>步骤②</strong>：在yml中定义要绑定的属性，注意datasource此时全小写</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">datasource:  driverClassName: com.mysql.jdbc.Driver</code></pre><p><strong>步骤③</strong>：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Bean@ConfigurationProperties(prefix = "datasource")public DruidDataSource datasource(){    DruidDataSource ds = new DruidDataSource();    return ds;}</code></pre><p>​操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。</p><p>​做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？</p><p><strong>步骤①</strong>：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootApplication@EnableConfigurationProperties(ServerConfig.class)public class Springboot13ConfigurationApplication {}</code></pre><p><strong>步骤②</strong>：在对应的类上直接使用@ConfigurationProperties进行属性绑定</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig {    private String ipAddress;    private int port;    private long timeout;}</code></pre><p>​有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。</p><p>​</p><blockquote><p>最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息</p><p><img src="image-20220222145535749.png" alt="image-20220222145535749"></p><p>出现这个提示后只需要添加一个坐标此提醒就消失了:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></blockquote><p><strong>总结</strong></p><ol><li>使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性</li><li>当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明</li></ol><h3 id="2-2-宽松绑定-松散绑定"><a href="#2-2-宽松绑定-松散绑定" class="headerlink" title="2.2 宽松绑定/松散绑定"></a>2.2 宽松绑定/松散绑定</h3><p>​在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">dataSource:  driverClassName: com.mysql.jdbc.Driver</code></pre><p>​此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Bean@ConfigurationProperties(prefix = "dataSource")public DruidDataSource datasource(){    DruidDataSource ds = new DruidDataSource();    return ds;}</code></pre><p>​此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">Configuration property name 'dataSource' is not valid:    Invalid characters: 'S'    Bean: datasource    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letterAction:Modify 'dataSource' so that it conforms to the canonical names requirements.</code></pre><p>​为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。</p><p>​什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：</p><p>​在ServerConfig中的ipAddress属性名</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig {    private String ipAddress;}</code></pre><p>​可以与下面的配置属性名规则全兼容</p><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">servers:  ipAddress: 192.168.0.2       # 驼峰模式  ip_address: 192.168.0.2      # 下划线模式  ip-address: 192.168.0.2      # 烤肉串模式  IP_ADDRESS: 192.168.0.2      # 常量模式</code></pre><p>​也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。</p><p>​到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">Configuration property name 'dataSource' is not valid:    Invalid characters: 'S'    Bean: datasource    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letterAction:Modify 'dataSource' so that it conforms to the canonical names requirements.</code></pre><p>​其中Reason描述了报错的原因，<strong>前缀名规范</strong>的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。</p><p>​最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。</p><p><strong>总结</strong></p><ol><li>@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li><li>@Value注解不支持松散绑定规则</li><li><strong>绑定前缀名</strong>推荐采用烤肉串命名规则，即使用中划线做分隔符</li></ol><h3 id="2-3-常用计量单位绑定"><a href="#2-3-常用计量单位绑定" class="headerlink" title="2.3 常用计量单位绑定"></a>2.3 常用计量单位绑定</h3><p>​在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。</p><pre class="line-numbers language-YML" data-language="YML"><code class="language-YML">servers:  ip-address: 192.168.0.1   port: 2345  timeout: -1</code></pre><p>​但是每个人都这个timeout值的理解会产生不同，比如线上服务器完成一次主从备份，如果配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？</p><p>​除了加强约定之外，springboot充分利用了<strong>JDK8中提供的全新的用来表示计量单位的新数据类型</strong>，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig {    @DurationUnit(ChronoUnit.HOURS)    private Duration serverTimeOut;    @DataSizeUnit(DataUnit.MEGABYTES)    private DataSize dataSize;}</code></pre><p><strong>Duration</strong>：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</p><p><strong>DataSize</strong>：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）</p><p>​使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。</p><p>Druation常用单位如下：</p><img src="image-20220222173911102.png" alt="image-20220222173911102" style="zoom:50%;"><p>DataSize常用单位如下：</p><img src="image-20220222174130102.png" alt="image-20220222174130102" style="zoom:67%;"><h3 id="2-4-校验"><a href="#2-4-校验" class="headerlink" title="2.4 校验"></a>2.4 校验</h3><p>​目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误。SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤</p><p><strong>步骤①</strong>：开启校验框架</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--1.导入JSR303规范--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.validation&lt;/groupId&gt;    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--使用hibernate框架提供的校验器做实现--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：在需要开启校验功能的类上使用注解@Validated开启校验功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Data@ConfigurationProperties(prefix = "servers")//开启对当前bean的属性注入校验@Validatedpublic class ServerConfig {}</code></pre><p><strong>步骤③</strong>：对具体的字段设置校验规则</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")//开启对当前bean的属性注入校验@Validatedpublic class ServerConfig {    //设置具体的规则    @Max(value = 8888,message = "最大值不能超过8888")    @Min(value = 202,message = "最小值不能低于202")    private int port;}</code></pre><p>​通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。</p><p><strong>总结</strong></p><ol><li>开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式</li></ol><h3 id="2-5-数据类型转换"><a href="#2-5-数据类型转换" class="headerlink" title="2.5 数据类型转换"></a>2.5 数据类型转换</h3><p>​有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。</p><p>​先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">java.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)</code></pre><p>​其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: 0127</code></pre><p>​这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。</p><p>​之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong></p><img src="image-20220222225748370.png" alt="image-20220222225748370" style="zoom:80%;"><p>​这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。</p><p>​这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。</p><p><strong>总结</strong></p><ol><li>yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</li></ol><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>​说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。</p><h3 id="3-1-加载测试专用属性"><a href="#3-1-加载测试专用属性" class="headerlink" title="3.1 加载测试专用属性"></a>3.1 加载测试专用属性</h3><p>​测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">env:  maxMemory: 32GB  minMemory: 16GB</code></pre><p>​但是你现在想测试对应的兼容性，需要测试如下配置</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">env:  maxMemory: 16GB  minMemory: 8GB</code></pre><p>​这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要<strong>在测试环境中创建一组临时属性</strong>，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。</p><p><strong>临时属性</strong></p><p>​springboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//properties属性可以为当前测试用例添加临时的属性配置@SpringBootTest(properties = {"test.prop=testValue1"})public class PropertiesAndArgsTest {    @Value("${test.prop}")    private String msg;        @Test    void testProperties(){        System.out.println(msg);    }}</code></pre><p>​使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。</p><p><strong>临时参数</strong></p><p>​除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//args属性可以为当前测试用例添加临时的命令行参数@SpringBootTest(args={"--test.prop=testValue2"})public class PropertiesAndArgsTest {        @Value("${test.prop}")    private String msg;        @Test    void testProperties(){        System.out.println(msg);    }}</code></pre><p>​使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。</p><p>​说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？</p><img src="image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;"><p>​在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。</p><p>​到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。</p><p><strong>总结</strong></p><ol><li>加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例</li></ol><p><strong>思考</strong></p><p>​应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。</p><h3 id="3-2-加载测试专用配置"><a href="#3-2-加载测试专用配置" class="headerlink" title="3.2 加载测试专用配置"></a>3.2 加载测试专用配置</h3><p>​上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。</p><p>​学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：</p><p><strong>步骤①</strong>：在测试包test中创建专用的测试环境配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MsgConfig {    @Bean    public String msg(){        return "bean msg";    }}</code></pre><p>​上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据</p><p><strong>步骤②</strong>：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTest@Import({MsgConfig.class})public class ConfigurationTest {    @Autowired    private String msg;    @Test    void testConfiguration(){        System.out.println(msg);    }}</code></pre><p>​到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。</p><p><strong>总结</strong></p><ol><li>定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境</li></ol><p><strong>思考</strong></p><p>​当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。</p><h3 id="3-3-Web环境模拟测试"><a href="#3-3-Web环境模拟测试" class="headerlink" title="3.3 Web环境模拟测试"></a>3.3 Web环境模拟测试</h3><p>​在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个</p><h4 id="3-3-1-测试类中启动web环境"><a href="#3-3-1-测试类中启动web环境" class="headerlink" title="3.3.1 测试类中启动web环境"></a>3.3.1 测试类中启动web环境</h4><p>​每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class WebTest {}</code></pre><p>​测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：</p><img src="image-20220223125453317.png" alt="image-20220223125453317" style="zoom:80%;"><ul><li>MOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置</li><li>DEFINED_PORT：使用自定义的端口作为web服务器端口</li><li>RANDOM_PORT：使用随机端口作为web服务器端口</li><li>NONE：不启动web环境</li></ul><p>​通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。</p><p>​测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。</p><h4 id="3-3-2-测试类中发送请求"><a href="#3-3-2-测试类中发送请求" class="headerlink" title="3.3.2 测试类中发送请求"></a>3.3.2 测试类中发送请求</h4><p>​对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：</p><p><strong>步骤①</strong>：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest {}</code></pre><p><strong>步骤②</strong>：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest {    @Test    void testWeb(@Autowired MockMvc mvc) {    }}</code></pre><p><strong>步骤③</strong>：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest {    @Test    void testWeb(@Autowired MockMvc mvc) throws Exception {        //http://localhost:8080/books        //创建虚拟请求，当前访问/books        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");        //执行对应的请求        mvc.perform(builder);    }}</code></pre><p>​执行测试程序，现在就可以正常的发送/books对应的请求了，注意访问路径不要写<a href="http://localhost:8080/books%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%89%8D%E9%9D%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E8%99%9A%E6%8B%9F%E7%9A%84web%E7%8E%AF%E5%A2%83%EF%BC%8C%E6%97%A0%E9%9C%80%E6%8C%87%E5%AE%9A%EF%BC%8C%E4%BB%85%E6%8C%87%E5%AE%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。</a></p><p><strong>总结</strong></p><ol><li>在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试</li><li>为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程</li></ol><p><strong>思考</strong></p><p>​目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。</p><h4 id="3-3-3-web环境请求结果比对"><a href="#3-3-3-web环境请求结果比对" class="headerlink" title="3.3.3 web环境请求结果比对"></a>3.3.3 web环境请求结果比对</h4><p>​上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：</p><ul><li><p>响应状态匹配</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testStatus(@Autowired MockMvc mvc) throws Exception {    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    StatusResultMatchers status = MockMvcResultMatchers.status();    //预计本次调用时成功的：状态200    ResultMatcher ok = status.isOk();    //添加预计值到本次调用过程中进行匹配    action.andExpect(ok);}</code></pre></li><li><p>响应体匹配（非json数据格式）</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testBody(@Autowired MockMvc mvc) throws Exception {    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.string("springboot2");    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);}</code></pre></li><li><p>响应体匹配（json数据格式，开发中的主流使用方式）</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testJson(@Autowired MockMvc mvc) throws Exception {    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json("{\"id\":1,\"name\":\"springboot2\",\"type\":\"springboot\"}");    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);}</code></pre></li><li><p>响应头信息匹配</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testContentType(@Autowired MockMvc mvc) throws Exception {    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string("Content-Type", "application/json");    //添加预计值到本次调用过程中进行匹配    action.andExpect(contentType);}</code></pre></li></ul><p>​基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Testvoid testGetById(@Autowired MockMvc mvc) throws Exception {    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    StatusResultMatchers status = MockMvcResultMatchers.status();    ResultMatcher ok = status.isOk();    action.andExpect(ok);    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string("Content-Type", "application/json");    action.andExpect(contentType);    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json("{\"id\":1,\"name\":\"springboot\",\"type\":\"springboot\"}");    action.andExpect(result);}</code></pre><p><strong>总结</strong></p><ol><li>web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对</li></ol><h3 id="3-4-数据层测试回滚"><a href="#3-4-数据层测试回滚" class="headerlink" title="3.4 数据层测试回滚"></a>3.4 数据层测试回滚</h3><p>​当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？</p><p>​springboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以<strong>避免事务的提交</strong>。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTest@Transactional@Rollback(true)public class DaoTest {    @Autowired    private BookService bookService;    @Test    void testSave(){        Book book = new Book();        book.setName("springboot3");        book.setType("springboot3");        book.setDescription("springboot3");        bookService.save(book);    }}</code></pre><p>​如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务，是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。</p><p><strong>总结</strong></p><ol><li>在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务</li><li>通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用</li></ol><p><strong>思考</strong></p><p>​当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。</p><h3 id="3-5-测试用例数据设定"><a href="#3-5-测试用例数据设定" class="headerlink" title="3.5 测试用例数据设定"></a>3.5 测试用例数据设定</h3><p>​对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">testcase:  book:    id: ${random.int}    id2: ${random.int(10)}    type: ${random.int!5,10!}    name: ${random.value}    uuid: ${random.uuid}    publishTime: ${random.long}</code></pre><p>​当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "testcase.book")public class BookCase {    private int id;    private int id2;    private int type;    private String name;    private String uuid;    private long publishTime;}</code></pre><p>​对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：</p><img src="image-20220223135454862.png" alt="image-20220223135454862" style="zoom:80%;"><ul><li>${random.int}表示随机整数</li><li>${random.int(10)}表示10以内的随机数</li><li>${random.int(10,20)}表示10到20的随机数</li><li>其中()可以是任意字符，例如[]，!!均可</li></ul><p><strong>总结</strong></p><ol><li>使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性</li></ol><h2 id="4-数据层解决方案"><a href="#4-数据层解决方案" class="headerlink" title="4. 数据层解决方案"></a>4. 数据层解决方案</h2><p>​开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是SQL解决方案相关的内容，除此之外，数据的来源还可以是非SQL技术相关的数据操作，因此第二部分围绕着NOSQL解决方案讲解。至于什么是NOSQL解决方案，讲到了再说吧。下面就从SQL解决方案说起。</p><h3 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h3><p>​回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：</p><ul><li>数据源技术：Druid</li><li>持久化技术：MyBatisPlus</li><li>数据库技术：MySQL</li></ul><p>​下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。</p><h4 id="数据源技术"><a href="#数据源技术" class="headerlink" title="数据源技术"></a>数据源技术</h4><p>​目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">INFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSourceINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited</code></pre><p>​如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">INFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...INFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</code></pre><p>​虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。</p><p>​数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。</p><p>​springboot提供了3款内嵌数据源技术，分别如下：</p><ul><li>HikariCP</li><li>Tomcat提供DataSource</li><li>Commons DBCP</li></ul><p>​第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。</p><p>​第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。</p><p>​第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。</p><p>​springboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    druid:     url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root</code></pre><p>​换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: root</code></pre><p>​ 当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root</code></pre><p>​这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root      maximum-pool-size: 50</code></pre><p>​如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。</p><p><strong>总结</strong></p><ol><li>springboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP</li></ol><h4 id="持久化技术"><a href="#持久化技术" class="headerlink" title="持久化技术"></a>持久化技术</h4><p>​说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。</p><p>​这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：</p><p><strong>步骤①</strong>：导入jdbc对应的坐标，记得是starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency</code></pre><p><strong>步骤②</strong>：自动装配JdbcTemplate对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot15SqlApplicationTests {    @Test    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){    }}</code></pre><p><strong>步骤③</strong>：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){    String sql = "select * from tbl_book";    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);    System.out.println(maps);}</code></pre><p><strong>步骤④</strong>：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){    String sql = "select * from tbl_book";    RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() {        @Override        public Book mapRow(ResultSet rs, int rowNum) throws SQLException {            Book temp = new Book();            temp.setId(rs.getInt("id"));            temp.setName(rs.getString("name"));            temp.setType(rs.getString("type"));            temp.setDescription(rs.getString("description"));            return temp;        }    };    List&lt;Book&gt; list = jdbcTemplate.query(sql, rm);    System.out.println(list);}</code></pre><p><strong>步骤⑤</strong>：使用JdbcTemplate实现增删改操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate){    String sql = "insert into tbl_book values(3,'springboot1','springboot2','springboot3')";    jdbcTemplate.update(sql);}</code></pre><p>​如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  jdbc:    template:      query-timeout: -1   # 查询超时时间      max-rows: 500       # 最大行数      fetch-size: -1      # 缓存行数</code></pre><p><strong>总结</strong></p><ol><li>SpringBoot内置JdbcTemplate持久化解决方案</li><li>使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标</li></ol><h4 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术"></a>数据库技术</h4><p>​截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。</p><p>​springboot提供了3款内置的数据库，分别是</p><ul><li>H2</li><li>HSQL</li><li>Derby</li></ul><p>​以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。</p><p>​我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。</p><p>​下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛</p><p><strong>步骤①</strong>：导入H2数据库对应的坐标，一共2个</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：将工程设置为web工程，启动工程时启动H2数据库</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤③</strong>：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  h2:    console:      enabled: true      path: /h2</code></pre><p>​web端访问路径/h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问/h2路径就可以正常访问了</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">datasource:  url: jdbc:h2:~/test  hikari:    driver-class-name: org.h2.Driver    username: sa    password: 123456</code></pre><p><strong>步骤④</strong>：使用JdbcTemplate或MyBatisPlus技术操作数据库</p><p>（略）</p><p>​其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。</p><p><strong>总结</strong></p><ol><li>H2内嵌式数据库启动方式，添加坐标，添加配置</li><li>H2数据库线上运行时请务必关闭</li></ol><p>​到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。</p><ul><li>数据源技术：Druid、Hikari、tomcat DataSource、DBCP</li><li>持久化技术：MyBatisPlus、MyBatis、JdbcTemplate</li><li>数据库技术：MySQL、H2、HSQL、Derby</li></ul><p>​现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。</p><h3 id="4-2-NoSQL"><a href="#4-2-NoSQL" class="headerlink" title="4.2 NoSQL"></a>4.2 NoSQL</h3><p>​SQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。</p><p>​因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。</p><h4 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h4><p>​Redis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。</p><p>​Redis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>​下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。</p><p>​啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。</p><p>​安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。</p><img src="image-20220224091709173.png" alt="image-20220224091709173" style="zoom: 80%;"><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">redis-server.exe redis.windows.conf</code></pre><p>​初学者无需调整服务器对外服务端口，默认6379。</p><p><strong>启动客户端</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">redis-cli.exe</code></pre><p>​如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。</p><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>​服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。</p><p>​放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">set name itheimaset age 12</code></pre><p>​从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">get nameget age</code></pre><p>​以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：</p><pre class="line-numbers language-none"><code class="language-none">hset a a1 aa1#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1hset a a2 aa2</code></pre><p>​获取hash结构中的数据命令如下</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">hget a a1#得到aa1hget a a2#得到aa2</code></pre><p>​有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。</p><h5 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h5><p>​在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。</p><p>​第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化</p><p>​第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题</p><p>​第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同</p><p>​按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。</p><p>​下面就开始springboot整合redis，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合redis的starter坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中</p><img src="image-20220224101142220.png" alt="image-20220224101142220" style="zoom:50%;"><p><strong>步骤②</strong>：进行基础配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379</code></pre><p>​操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。</p><p><strong>步骤③</strong>：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot16RedisApplicationTests {    @Autowired    private RedisTemplate redisTemplate;    @Test    void set() {        ValueOperations ops = redisTemplate.opsForValue();        ops.set("age",41);    }    @Test    void get() {        ValueOperations ops = redisTemplate.opsForValue();        Object age = ops.get("name");        System.out.println(age);    }    @Test    void hset() {        HashOperations ops = redisTemplate.opsForHash();        ops.put("info","b","bb");    }    @Test    void hget() {        HashOperations ops = redisTemplate.opsForHash();        Object val = ops.get("info", "b");        System.out.println(val);    }}</code></pre><p>​在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：</p><img src="image-20220224103104908.png" alt="image-20220224103104908" style="zoom:80%;"><p><strong>总结</strong></p><ol><li>springboot整合redis步骤<ol><li>导入springboot整合redis的starter坐标</li><li>进行基础配置</li><li>使用springboot整合redis的专用客户端接口RedisTemplate操作</li></ol></li></ol><p><strong>StringRedisTemplate</strong></p><p>​由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTestpublic class StringRedisTemplateTest {    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void get(){        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();        String name = ops.get("name");        System.out.println(name);    }}</code></pre><p><strong>redis客户端选择</strong></p><pre><code>     springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：</code></pre><p><strong>步骤①</strong>：导入jedis坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​jedis坐标受springboot管理，无需提供版本号</p><p><strong>步骤②</strong>：配置客户端技术类型，设置为jedis</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379    client-type: jedis</code></pre><p><strong>步骤③</strong>：根据需要设置对应的配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379    client-type: jedis    lettuce:      pool:        max-active: 16    jedis:      pool:        max-active: 16</code></pre><p><strong>lettcus与jedis区别</strong></p><ul><li>jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响</li><li>lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作</li></ul><p><strong>总结</strong></p><ol><li>springboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis</li><li>如果需要切换redis客户端实现技术，可以通过配置的形式进行</li></ol><h4 id="SpringBoot整合MongoDB"><a href="#SpringBoot整合MongoDB" class="headerlink" title="SpringBoot整合MongoDB"></a>SpringBoot整合MongoDB</h4><p>​使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。</p><p>​MongoDB是一个开源、高性能、无模式的文档型数据库，它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。</p><p>​上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：</p><ul><li>淘宝用户数据<ul><li>存储位置：数据库</li><li>特征：永久性存储，修改频度极低</li></ul></li><li>游戏装备数据、游戏道具数据<ul><li>存储位置：数据库、Mongodb</li><li>特征：永久性存储与临时存储相结合、修改频度较高</li></ul></li><li>直播数据、打赏数据、粉丝数据<ul><li>存储位置：数据库、Mongodb</li><li>特征：永久性存储与临时存储相结合，修改频度极高</li></ul></li><li>物联网数据<ul><li>存储位置：Mongodb</li><li>特征：临时存储，修改频度飞速</li></ul></li></ul><p>​快速了解一下MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://www.mongodb.com/try/download">https://www.mongodb.com/try/download</a></p><p>​下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。</p><p>​解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令</p><p><img src="image-20220224111306933.png" alt="image-20220224111306933"></p><p>​mongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下</p><p><img src="image-20220224111053408.png" alt="image-20220224111053408"></p><p>​如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。</p><img src="image-20220224113956882.png" alt="image-20220224113956882" style="zoom:50%;"><p>​根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">regsvr32 vcruntime140_1.dll</code></pre><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">mongod --dbpath=..\data\db</code></pre><p>​启动服务器时需要指定数据存储位置，通过参数–dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。</p><p><strong>启动客户端</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">mongo --host=127.0.0.1 --port=27017</code></pre><h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p>​MongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。</p><p>​同类型的软件较多，本次安装的软件时Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用。</p><img src="image-20220224114911573.png" alt="image-20220224114911573" style="zoom: 33%;"><p>​打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect…】</p><p><img src="image-20220224115202422.png" alt="image-20220224115202422"></p><p>​进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置</p><img src="image-20220224115254200.png" alt="image-20220224115254200" style="zoom:80%;"><p>​如果输入设置值即可连接（默认不修改即可连接本机27017端口）</p><p><img src="image-20220224115300266.png" alt="image-20220224115300266"></p><p>​连接成功后在命令输入区域输入命令即可操作MongoDB。</p><p>​创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可</p><p>​创建集合：在Collections上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用</p><p>​新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">db.集合名称.insert/save/insertOne(文档)</code></pre><p>​删除文档：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">db.集合名称.remove(条件)</code></pre><p>​修改文档：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">db.集合名称.update(条件，{操作种类:{文档}})</code></pre><p>​查询文档：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">基础查询查询全部：   db.集合.find();查第一条：   db.集合.findOne()查询指定数量文档：db.集合.find().limit(10)//查10条文档跳过指定数量文档：db.集合.find().skip(20)//跳过20条文档统计：  db.集合.count()排序：db.集合.sort({age:1})//按age升序排序投影：db.集合名称.find(条件,{name:1,age:1}) //仅保留name与age域条件查询基本格式：db.集合.find({条件})模糊查询：db.集合.find({域名:/正则表达式/})  //等同SQL中的like，比like强大，可以执行正则所有规则条件比较运算：   db.集合.find({域名:{$gt:值}})//等同SQL中的数值比较操作，例如：name&gt;18包含查询：db.集合.find({域名:{$in:[值1，值2]}})//等同于SQL中的in条件连接查询：   db.集合.find({$and:[{条件1},{条件2}]})   //等同于SQL中的and、or</code></pre><p>​有关MongoDB的基础操作就普及到这里，需要全面掌握MongoDB技术，请参看相关教程学习。</p><h5 id="整合-1"><a href="#整合-1" class="headerlink" title="整合"></a>整合</h5><p>​使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。</p><p>​第一，先导入对应技术的整合starter坐标</p><p>​第二，配置必要信息</p><p>​第三，使用提供的API操作即可</p><p>​下面就开始springboot整合MongoDB，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合MongoDB的starter坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中</p><img src="image-20220224120721626.png" alt="image-20220224120721626" style="zoom: 67%;"><p><strong>步骤②</strong>：进行基础配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  data:    mongodb:      uri: mongodb://localhost/itheima</code></pre><p>​操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。</p><p><strong>步骤③</strong>：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot17MongodbApplicationTests {    @Autowired    private MongoTemplate mongoTemplate;    @Test    void contextLoads() {        Book book = new Book();        book.setId(2);        book.setName("springboot2");        book.setType("springboot2");        book.setDescription("springboot2");        mongoTemplate.save(book);    }    @Test    void find(){        List&lt;Book&gt; all = mongoTemplate.findAll(Book.class);        System.out.println(all);    }}</code></pre><p>​整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉，有关springboot整合MongoDB我们就讲到这里。有兴趣可以继续学习MongoDB的操作，然后再来这里通过编程的形式操作MongoDB。</p><p><strong>总结</strong></p><ol><li>springboot整合MongoDB步骤<ol><li>导入springboot整合MongoDB的starter坐标</li><li>进行基础配置</li><li>使用springboot整合MongoDB的专用客户端接口MongoTemplate操作</li></ol></li></ol><h4 id="SpringBoot整合ES"><a href="#SpringBoot整合ES" class="headerlink" title="SpringBoot整合ES"></a>SpringBoot整合ES</h4><p>​NoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。</p><p>​ES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。</p><p>​那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。</p><p>​要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：</p><ol><li><p>将被查询的字段的数据全部文本信息进行查分，分成若干个词</p><ul><li>例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。</li></ul></li><li><p>将分词得到的结果存储起来，对应每条数据的id</p><ul><li><p>例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1</p></li><li><p>例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2</p></li><li><p>此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中</p><table><thead><tr><th>分词结果关键字</th><th>对应id</th></tr></thead><tbody><tr><td>中华</td><td>1</td></tr><tr><td>人民</td><td>1,2</td></tr><tr><td>共和国</td><td>1</td></tr><tr><td>代表</td><td>2</td></tr><tr><td>大会</td><td>2</td></tr></tbody></table></li></ul></li><li><p>当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。</p></li></ol><p>​上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做<strong>倒排索引</strong>。</p><p>​通过上述内容的学习，发现使用ES其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下ES的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://</a><a href="https://www.elastic.co/cn/downloads/elasticsearch">www.elastic.co/cn/downloads/elasticsearch</a></p><p>​下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="image-20220225132756400.png" alt="image-20220225132756400"></p><ul><li>bin目录：包含所有的可执行命令</li><li>config目录：包含ES服务器使用的配置文件</li><li>jdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题</li><li>lib目录：包含ES运行的依赖jar文件</li><li>logs目录：包含ES运行后产生的所有日志文件</li><li>modules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包</li><li>plugins目录：包含ES软件安装的插件，默认为空</li></ul><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">elasticsearch.bat</code></pre><p>​双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问<a href="http://localhost:9200看到如下信息视为ES服务器正常启动">http://localhost:9200看到如下信息视为ES服务器正常启动</a></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">{  "name" : "CZBK-**********",  "cluster_name" : "elasticsearch",  "cluster_uuid" : "j137DSswTPG8U4Yb-0T1Mg",  "version" : {    "number" : "7.16.2",    "build_flavor" : "default",    "build_type" : "zip",    "build_hash" : "2b937c44140b6559905130a8650c64dbd0879cfb",    "build_date" : "2021-12-18T19:42:46.604893745Z",    "build_snapshot" : false,    "lucene_version" : "8.10.1",    "minimum_wire_compatibility_version" : "6.8.0",    "minimum_index_compatibility_version" : "6.0.0-beta1"  },  "tagline" : "You Know, for Search"}</code></pre><h5 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h5><p>​ES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。</p><p>​要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。</p><ul><li><p>创建索引，books是索引名称，下同</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">PUT请求http://localhost:9200/books</code></pre><p>发送请求后，看到如下信息即索引创建成功</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "acknowledged": true,    "shards_acknowledged": true,    "index": "books"}</code></pre><p>重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "error": {        "root_cause": [            {                "type": "resource_already_exists_exception",                "reason": "index [books/VgC_XMVAQmedaiBNSgO2-w] already exists",                "index_uuid": "VgC_XMVAQmedaiBNSgO2-w",                "index": "books"            }        ],        "type": "resource_already_exists_exception",        "reason": "index [books/VgC_XMVAQmedaiBNSgO2-w] already exists",# books索引已经存在        "index_uuid": "VgC_XMVAQmedaiBNSgO2-w",        "index": "book"    },    "status": 400}</code></pre></li><li><p>查询索引</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">GET请求http://localhost:9200/books</code></pre><p>查询索引得到索引相关信息，如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "book": {        "aliases": {},        "mappings": {},        "settings": {            "index": {                "routing": {                    "allocation": {                        "include": {                            "_tier_preference": "data_content"                        }                    }                },                "number_of_shards": "1",                "provided_name": "books",                "creation_date": "1645768584849",                "number_of_replicas": "1",                "uuid": "VgC_XMVAQmedaiBNSgO2-w",                "version": {                    "created": "7160299"                }            }        }    }}</code></pre><p>如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "error": {        "root_cause": [            {                "type": "index_not_found_exception",                "reason": "no such index [book]",                "resource.type": "index_or_alias",                "resource.id": "book",                "index_uuid": "_na_",                "index": "book"            }        ],        "type": "index_not_found_exception",        "reason": "no such index [book]",# 没有book索引        "resource.type": "index_or_alias",        "resource.id": "book",        "index_uuid": "_na_",        "index": "book"    },    "status": 404}</code></pre></li><li><p>删除索引</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">DELETE请求http://localhost:9200/books</code></pre><p>删除所有后，给出删除结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "acknowledged": true}</code></pre><p>如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{    "error": {        "root_cause": [            {                "type": "index_not_found_exception",                "reason": "no such index [books]",                "resource.type": "index_or_alias",                "resource.id": "book",                "index_uuid": "_na_",                "index": "book"            }        ],        "type": "index_not_found_exception",        "reason": "no such index [books]",# 没有books索引        "resource.type": "index_or_alias",        "resource.id": "book",        "index_uuid": "_na_",        "index": "book"    },    "status": 404}</code></pre></li><li><p>创建索引并指定分词器</p><p>​前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>​分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT请求http://localhost:9200/books请求参数如下（注意是json格式的参数）{&nbsp;&nbsp;&nbsp;&nbsp;"mappings":{#定义mappings属性，替换创建索引时对应的mappings属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"properties":{#定义索引中包含的属性设置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":{#设置索引中包含id属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":"keyword"#当前属性可以被直接搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name":{#设置索引中包含name属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":"text",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#当前属性是文本信息，参与分词&nbsp;&nbsp;                "analyzer":"ik_max_word",&nbsp;&nbsp;&nbsp;#使用IK分词器进行分词&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "copy_to":"all"#分词结果拷贝到all属性中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":"keyword"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":"text",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "analyzer":"ik_max_word",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "copy_to":"all"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"all":{#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":"text",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                "analyzer":"ik_max_word"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>​创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "books": {        "aliases": {},        "mappings": {#mappings属性已经被替换            "properties": {                "all": {                    "type": "text",                    "analyzer": "ik_max_word"                },                "description": {                    "type": "text",                    "copy_to": [                        "all"                    ],                    "analyzer": "ik_max_word"                },                "id": {                    "type": "keyword"                },                "name": {                    "type": "text",                    "copy_to": [                        "all"                    ],                    "analyzer": "ik_max_word"                },                "type": {                    "type": "keyword"                }            }        },        "settings": {            "index": {                "routing": {                    "allocation": {                        "include": {                            "_tier_preference": "data_content"                        }                    }                },                "number_of_shards": "1",                "provided_name": "books",                "creation_date": "1645769809521",                "number_of_replicas": "1",                "uuid": "DohYKvr_SZO4KRGmbZYmTQ",                "version": {                    "created": "7160299"                }            }        }    }}</code></pre></li></ul><p>目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。</p><ul><li><p>添加文档，有三种方式</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST请求http://localhost:9200/books/_doc#使用系统生成idPOST请求http://localhost:9200/books/_create/1#使用指定idPOST请求http://localhost:9200/books/_doc/1#使用指定id，不存在创建，存在更新（版本递增）文档通过请求参数传递，数据格式json{&nbsp;&nbsp;&nbsp;&nbsp;"name":"springboot",&nbsp;&nbsp;&nbsp;&nbsp;"type":"springboot",&nbsp;&nbsp;&nbsp;&nbsp;"description":"springboot"}  </code></pre></li><li><p>查询文档</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET请求http://localhost:9200/books/_doc/1 #查询单个文档 GET请求http://localhost:9200/books/_search #查询全部文档</code></pre></li><li><p>条件查询</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET请求http://localhost:9200/books/_search?q=name:springboot# q=查询属性名:查询属性值</code></pre></li><li><p>删除文档</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE请求http://localhost:9200/books/_doc/1</code></pre></li><li><p>修改文档（全量更新）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT请求http://localhost:9200/books/_doc/1文档通过请求参数传递，数据格式json{&nbsp;&nbsp;&nbsp;&nbsp;"name":"springboot",&nbsp;&nbsp;&nbsp;&nbsp;"type":"springboot",&nbsp;&nbsp;&nbsp;&nbsp;"description":"springboot"}</code></pre></li><li><p>修改文档（部分更新）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST请求http://localhost:9200/books/_update/1文档通过请求参数传递，数据格式json{    "doc":{#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新&nbsp;&nbsp;&nbsp;&nbsp;    "name":"springboot"#仅更新提供的属性值，未提供的属性值不参与更新操作    }}</code></pre></li></ul><h5 id="整合-2"><a href="#整合-2" class="headerlink" title="整合"></a>整合</h5><p>​使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。</p><p>​下面就开始springboot整合ES，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合ES的starter坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：进行基础配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  elasticsearch:    rest:      uris: http://localhost:9200</code></pre><p>​配置ES服务器地址，端口9200</p><p><strong>步骤③</strong>：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot18EsApplicationTests {    @Autowired    private ElasticsearchRestTemplate template;}</code></pre><p>​上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。</p><p>​下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：使用编程的形式设置连接的ES服务器，并获取客户端对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot18EsApplicationTests {    private RestHighLevelClient client;      @Test      void testCreateClient() throws IOException {          HttpHost host = HttpHost.create("http://localhost:9200");          RestClientBuilder builder = RestClient.builder(host);          client = new RestHighLevelClient(builder);            client.close();      }}</code></pre><p>​配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。</p><p><strong>步骤③</strong>：使用客户端对象操作ES，例如创建索引</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Springboot18EsApplicationTests {    private RestHighLevelClient client;      @Test      void testCreateIndex() throws IOException {          HttpHost host = HttpHost.create("http://localhost:9200");          RestClientBuilder builder = RestClient.builder(host);          client = new RestHighLevelClient(builder);                    CreateIndexRequest request = new CreateIndexRequest("books");          client.indices().create(request, RequestOptions.DEFAULT);                     client.close();      }}</code></pre><p>​高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。</p><p>​当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot18EsApplicationTests {    @BeforeEach//在测试类中每个操作运行前运行的方法    void setUp() {        HttpHost host = HttpHost.create("http://localhost:9200");        RestClientBuilder builder = RestClient.builder(host);        client = new RestHighLevelClient(builder);    }    @AfterEach//在测试类中每个操作运行后运行的方法    void tearDown() throws IOException {        client.close();    }    private RestHighLevelClient client;    @Test    void testCreateIndex() throws IOException {        CreateIndexRequest request = new CreateIndexRequest("books");        client.indices().create(request, RequestOptions.DEFAULT);    }}</code></pre><p>​现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果</p><p><strong>创建索引（IK分词器）</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid testCreateIndexByIK() throws IOException {    CreateIndexRequest request = new CreateIndexRequest("books");    String json = "{\n" +            "    \"mappings\":{\n" +            "        \"properties\":{\n" +            "            \"id\":{\n" +            "                \"type\":\"keyword\"\n" +            "            },\n" +            "            \"name\":{\n" +            "                \"type\":\"text\",\n" +            "                \"analyzer\":\"ik_max_word\",\n" +            "                \"copy_to\":\"all\"\n" +            "            },\n" +            "            \"type\":{\n" +            "                \"type\":\"keyword\"\n" +            "            },\n" +            "            \"description\":{\n" +            "                \"type\":\"text\",\n" +            "                \"analyzer\":\"ik_max_word\",\n" +            "                \"copy_to\":\"all\"\n" +            "            },\n" +            "            \"all\":{\n" +            "                \"type\":\"text\",\n" +            "                \"analyzer\":\"ik_max_word\"\n" +            "            }\n" +            "        }\n" +            "    }\n" +            "}";    //设置请求中的参数    request.source(json, XContentType.JSON);    client.indices().create(request, RequestOptions.DEFAULT);}</code></pre><p>​IK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。</p><p><strong>添加文档</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//添加文档void testCreateDoc() throws IOException {    Book book = bookDao.selectById(1);    IndexRequest request = new IndexRequest("books").id(book.getId().toString());    String json = JSON.toJSONString(book);    request.source(json,XContentType.JSON);    client.index(request,RequestOptions.DEFAULT);}</code></pre><p>​添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。</p><p><strong>批量添加文档</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//批量添加文档void testCreateDocAll() throws IOException {    List&lt;Book&gt; bookList = bookDao.selectList(null);    BulkRequest bulk = new BulkRequest();    for (Book book : bookList) {        IndexRequest request = new IndexRequest("books").id(book.getId().toString());        String json = JSON.toJSONString(book);        request.source(json,XContentType.JSON);        bulk.add(request);    }    client.bulk(bulk,RequestOptions.DEFAULT);}</code></pre><p>​批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。</p><p><strong>按id查询文档</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//按id查询void testGet() throws IOException {    GetRequest request = new GetRequest("books","1");    GetResponse response = client.get(request, RequestOptions.DEFAULT);    String json = response.getSourceAsString();    System.out.println(json);}</code></pre><p>​根据id查询文档使用的请求对象是GetRequest。</p><p><strong>按条件查询文档</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//按条件查询void testSearch() throws IOException {    SearchRequest request = new SearchRequest("books");    SearchSourceBuilder builder = new SearchSourceBuilder();    builder.query(QueryBuilders.termQuery("all","spring"));    request.source(builder);    SearchResponse response = client.search(request, RequestOptions.DEFAULT);    SearchHits hits = response.getHits();    for (SearchHit hit : hits) {        String source = hit.getSourceAsString();        //System.out.println(source);        Book book = JSON.parseObject(source, Book.class);        System.out.println(book);    }}</code></pre><p>​按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。</p><p>​springboot整合ES的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合ES的客户端对象。至于操作，由于ES操作种类过多，所以显得操作略微有点复杂。有关springboot整合ES就先学习到这里吧。</p><p><strong>总结</strong></p><ol><li>springboot整合ES步骤<ol><li>导入springboot整合ES的High Level Client坐标</li><li>手工管理客户端对象，包括初始化和关闭操作</li><li>使用High Level Client根据操作的种类不同，选择不同的Request对象完成对应操作</li></ol></li></ol><h2 id="5-整合第三方技术"><a href="#5-整合第三方技术" class="headerlink" title="5. 整合第三方技术"></a>5. 整合第三方技术</h2><p>​通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调API。</p><p>​springboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。</p><h3 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h3><p>​企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。</p><img src="image-20220226154148303.png" alt="image-20220226154148303" style="zoom:67%;"><p>​          应用程序直接与数据库打交道，访问效率低</p><p>​为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。</p><img src="image-20220226154233010.png" alt="image-20220226154233010" style="zoom:67%;"><pre><code>                                         使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高</code></pre><p>​缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。</p><h4 id="SpringBoot内置缓存解决方案"><a href="#SpringBoot内置缓存解决方案" class="headerlink" title="SpringBoot内置缓存解决方案"></a>SpringBoot内置缓存解决方案</h4><p>​springboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。</p><p><strong>步骤①</strong>：导入springboot提供的缓存技术对应的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//开启缓存功能@EnableCachingpublic class Springboot19CacheApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot19CacheApplication.class, args);    }}</code></pre><p><strong>步骤③</strong>：设置操作的数据是否使用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class BookServiceImpl implements BookService {    @Autowired    private BookDao bookDao;    @Cacheable(value="cacheSpace",key="#id")    public Book getById(Integer id) {        return bookDao.selectById(id);    }}</code></pre><p>​在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。</p><p>​使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。</p><h4 id="手机验证码案例"><a href="#手机验证码案例" class="headerlink" title="手机验证码案例"></a>手机验证码案例</h4><p>​为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。</p><p>​手机验证码案例需求如下：</p><ul><li>输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）</li><li>输入手机号和验证码验证结果</li></ul><p>​为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。</p><p><strong>步骤①</strong>：导入springboot提供的缓存技术对应的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//开启缓存功能@EnableCachingpublic class Springboot19CacheApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot19CacheApplication.class, args);    }}</code></pre><p><strong>步骤③</strong>：定义验证码对应的实体类，封装手机号与验证码两个属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class SMSCode {    private String tele;    private String code;}</code></pre><p><strong>步骤④</strong>：定义验证码功能的业务层接口与实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface SMSCodeService {    public String sendCodeToSMS(String tele);    public boolean checkCode(SMSCode smsCode);}@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @Autowired    private CodeUtils codeUtils;    @CachePut(value = "smsCode", key = "#tele")    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        return code;// 可以将code放入缓存    }    public boolean checkCode(SMSCode smsCode) {        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true        String code = smsCode.getCode();        String cacheCode = codeUtils.get(smsCode.getTele());        return code.equals(cacheCode);    }}</code></pre><p>​获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。</p><p>​对于校验验证码的功能建议放入工具类中进行。</p><p><strong>步骤⑤</strong>：定义验证码的生成策略与根据手机号读取验证码的功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class CodeUtils {    private String [] patch = {"000000","00000","0000","000","00","0",""};    public String generator(String tele){        int hash = tele.hashCode();        int encryption = 20206666;        long result = hash ^ encryption;        long nowTime = System.currentTimeMillis();        result = result ^ nowTime;        long code = result % 1000000;        code = code &lt; 0 ? -code : code;        String codeStr = code + "";        int len = codeStr.length();        return patch[len] + codeStr;    }    @Cacheable(value = "smsCode",key="#tele")    public String get(String tele){        return null;    }}</code></pre><p><strong>步骤⑥</strong>：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/sms")public class SMSCodeController {    @Autowired    private SMSCodeService smsCodeService;        @GetMapping    public String getCode(String tele){        String code = smsCodeService.sendCodeToSMS(tele);        return code;    }        @PostMapping    public boolean checkCode(SMSCode smsCode){        return smsCodeService.checkCode(smsCode);    }}</code></pre><h4 id="SpringBoot整合Ehcache缓存"><a href="#SpringBoot整合Ehcache缓存" class="headerlink" title="SpringBoot整合Ehcache缓存"></a>SpringBoot整合Ehcache缓存</h4><p>​手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合Ehcache技术。Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整</p><p><strong>步骤①</strong>：导入Ehcache的坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。</p><p><strong>步骤②</strong>：配置缓存技术实现使用Ehcache</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cache:    type: ehcache    ehcache:      config: ehcache.xml</code></pre><p>​配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。</p><p>​由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"         updateCheck="false"&gt;    &lt;diskStore path="D:\ehcache" /&gt;    &lt;!--默认缓存策略 --&gt;    &lt;!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--&gt;    &lt;!-- diskPersistent：是否启用磁盘持久化--&gt;    &lt;!-- maxElementsInMemory：最大缓存数量--&gt;    &lt;!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘--&gt;    &lt;!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--&gt;    &lt;!-- timeToLiveSeconds：最大存活时间--&gt;    &lt;!-- memoryStoreEvictionPolicy：缓存清除策略--&gt;    &lt;defaultCache        eternal="false"        diskPersistent="false"        maxElementsInMemory="1000"        overflowToDisk="false"        timeToIdleSeconds="60"        timeToLiveSeconds="60"        memoryStoreEvictionPolicy="LRU" /&gt;    &lt;cache        name="smsCode"        eternal="false"        diskPersistent="false"        maxElementsInMemory="1000"        overflowToDisk="false"        timeToIdleSeconds="10"        timeToLiveSeconds="10"        memoryStoreEvictionPolicy="LRU" /&gt;&lt;/ehcache&gt;</code></pre><p>​注意前面的案例中，设置了数据保存的位置是smsCode</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@CachePut(value = "smsCode", key = "#tele")public String sendCodeToSMS(String tele) {    String code = codeUtils.generator(tele);    return code;}</code></pre><p>​这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。</p><p>​到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。</p><p><strong>总结</strong></p><ol><li>springboot使用Ehcache作为缓存实现需要导入Ehcache的坐标</li><li>修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件</li></ol><p>​</p><h4 id="SpringBoot整合Redis缓存"><a href="#SpringBoot整合Redis缓存" class="headerlink" title="SpringBoot整合Redis缓存"></a>SpringBoot整合Redis缓存</h4><p>​上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。</p><p>​比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。</p><p><strong>步骤①</strong>：导入redis的坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置缓存技术实现使用redis</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379  cache:    type: redis</code></pre><p>​如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    host: localhost    port: 6379  cache:    type: redis    redis:      use-key-prefix: false      key-prefix: sms_      cache-null-values: false      time-to-live: 10s</code></pre><p><strong>总结</strong></p><ol><li>springboot使用redis作为缓存实现需要导入redis的坐标</li><li>修改设置，配置缓存供应商为redis，并提供对应的缓存配置</li></ol><h4 id="SpringBoot整合Memcached缓存"><a href="#SpringBoot整合Memcached缓存" class="headerlink" title="SpringBoot整合Memcached缓存"></a>SpringBoot整合Memcached缓存</h4><p>​目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。</p><p>​按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。</p><p><strong>安装</strong></p><p>​windows版安装包下载地址：<a href="https://www.runoob.com/memcached/window-install-memcached.html">https://www.runoob.com/memcached/window-install-memcached.html</a></p><p>​下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="image-20220226174957040.png" alt="image-20220226174957040"></p><p>​可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：</p><img src="image-20220226175141986.png" alt="image-20220226175141986" style="zoom:80%;"><p>​此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行</p><img src="image-20220226175302903.png" alt="image-20220226175302903" style="zoom:80%;"><p>​然后再次执行安装服务的命令即可，如下：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">memcached.exe -d install</code></pre><p>​服务安装完毕后可以使用命令启动和停止服务，如下：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">memcached.exe -d start# 启动服务memcached.exe -d stop# 停止服务</code></pre><p>​也可以在任务管理器中进行服务状态的切换</p><img src="image-20220226175441675.png" alt="image-20220226175441675" style="zoom:67%;"><p><strong>变更缓存为Memcached</strong></p><p>​由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。</p><p>​memcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached</p><p><strong>步骤①</strong>：导入xmemcached的坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt;    &lt;artifactId&gt;xmemcached&lt;/artifactId&gt;    &lt;version&gt;2.4.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置memcached，制作memcached的配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class XMemcachedConfig {    @Bean    public MemcachedClient getMemcachedClient() throws IOException {        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder("localhost:11211");        MemcachedClient memcachedClient = memcachedClientBuilder.build();        return memcachedClient;    }}</code></pre><p>​memcached默认对外服务端口11211。</p><p><strong>步骤③</strong>：使用xmemcached客户端操作缓存，注入MemcachedClient对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @Autowired    private CodeUtils codeUtils;    @Autowired    private MemcachedClient memcachedClient;    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        try {            memcachedClient.set(tele,10,code);        } catch (Exception e) {            e.printStackTrace();        }        return code;    }    public boolean checkCode(SMSCode smsCode) {        String code = null;        try {            code = memcachedClient.get(smsCode.getTele()).toString();        } catch (Exception e) {            e.printStackTrace();        }        return smsCode.getCode().equals(code);    }}</code></pre><p>​设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。</p><p>​上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。</p><p><strong>定义配置属性</strong></p><p>​以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。</p><ul><li><p>定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@ConfigurationProperties(prefix = "memcached")@Datapublic class XMemcachedProperties {    private String servers;    private int poolSize;    private long opTimeout;}</code></pre></li><li><p>定义memcached节点信息</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">memcached:  servers: localhost:11211  poolSize: 10  opTimeout: 3000</code></pre></li><li><p>在memcached配置类中加载信息</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class XMemcachedConfig {    @Autowired    private XMemcachedProperties props;    @Bean    public MemcachedClient getMemcachedClient() throws IOException {        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(props.getServers());        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());        MemcachedClient memcachedClient = memcachedClientBuilder.build();        return memcachedClient;    }}</code></pre><p><strong>总结</strong></p><ol><li>memcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限</li><li>由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存</li><li>导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存</li><li>初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载</li></ol><p><strong>思考</strong></p><p>​到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。</p><h4 id="SpringBoot整合jetcache缓存"><a href="#SpringBoot整合jetcache缓存" class="headerlink" title="SpringBoot整合jetcache缓存"></a>SpringBoot整合jetcache缓存</h4><p>​目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。</p><p>​jetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。</p><p>​做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：</p><ul><li>本地缓存（Local）<ul><li>LinkedHashMap</li><li>Caffeine</li></ul></li><li>远程缓存（Remote）<ul><li>Redis</li><li>Tair</li></ul></li></ul><p>​其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。</p><h5 id="纯远程方案"><a href="#纯远程方案" class="headerlink" title="纯远程方案"></a>纯远程方案</h5><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：远程方案基本配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jetcache:  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50</code></pre><p>​其中poolConfig是必配项，否则会报错</p><p><strong>步骤③</strong>：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotationpublic class Springboot20JetCacheApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot20JetCacheApplication.class, args);    }}</code></pre><p><strong>步骤④</strong>：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @Autowired    private CodeUtils codeUtils;        @CreateCache(name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    }    public boolean checkCode(SMSCode smsCode) {        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    }}</code></pre><p>​通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。</p><p>​上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jetcache:  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50</code></pre><p>​如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @Autowired    private CodeUtils codeUtils;        @CreateCache(area="sms",name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    }    public boolean checkCode(SMSCode smsCode) {        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    }}</code></pre><h5 id="纯本地方案"><a href="#纯本地方案" class="headerlink" title="纯本地方案"></a>纯本地方案</h5><p>​远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。</p><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：本地缓存基本配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson</code></pre><p>​为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。</p><p><strong>步骤③</strong>：启用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotationpublic class Springboot20JetCacheApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot20JetCacheApplication.class, args);    }}</code></pre><p><strong>步骤④</strong>：创建缓存对象Cache时，标注当前使用本地缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @CreateCache(name="jetCache_",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    }    public boolean checkCode(SMSCode smsCode) {        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    }}</code></pre><p>​cacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType=CacheType.LOCAL即使用本地缓存。</p><h5 id="本地-远程方案"><a href="#本地-远程方案" class="headerlink" title="本地+远程方案"></a>本地+远程方案</h5><p>​本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">jetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50</code></pre><p>​在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @CreateCache(name="jetCache_",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)    private Cache&lt;String ,String&gt; jetCache;}</code></pre><p>​cacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息</p><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>jetcache.statIntervalMinutes</td><td>0</td><td>统计间隔，0表示不统计</td></tr><tr><td>jetcache.hiddenPackages</td><td>无</td><td>自动生成name时，隐藏指定的包名前缀</td></tr><tr><td>jetcache.[local|remote].${area}.type</td><td>无</td><td>缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair</td></tr><tr><td>jetcache.[local|remote].${area}.keyConvertor</td><td>无</td><td>key转换器，当前仅支持fastjson</td></tr><tr><td>jetcache.[local|remote].${area}.valueEncoder</td><td>java</td><td>仅remote类型的缓存需要指定，可选java和kryo</td></tr><tr><td>jetcache.[local|remote].${area}.valueDecoder</td><td>java</td><td>仅remote类型的缓存需要指定，可选java和kryo</td></tr><tr><td>jetcache.[local|remote].${area}.limit</td><td>100</td><td>仅local类型的缓存需要指定，缓存实例最大元素数</td></tr><tr><td>jetcache.[local|remote].${area}.expireAfterWriteInMillis</td><td>无穷大</td><td>默认过期时间，毫秒单位</td></tr><tr><td>jetcache.local.${area}.expireAfterAccessInMillis</td><td>0</td><td>仅local类型的缓存有效，毫秒单位，最大不活动间隔</td></tr></tbody></table><p>​以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。</p><p><strong>方法缓存</strong></p><p>​jetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可</p><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置缓存</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson  remote:    default:      type: redis      host: localhost      port: 6379      keyConvertor: fastjson      valueEncode: java      valueDecode: java      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50</code></pre><p>​由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。</p><p>​注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Datapublic class Book implements Serializable {    private Integer id;    private String type;    private String name;    private String description;}</code></pre><p><strong>步骤③</strong>：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotation//开启方法注解缓存@EnableMethodCache(basePackages = "com.itheima")public class Springboot20JetCacheApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot20JetCacheApplication.class, args);    }}</code></pre><p><strong>步骤④</strong>：使用注解@Cached标注当前方法使用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class BookServiceImpl implements BookService {    @Autowired    private BookDao bookDao;        @Override    @Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)    public Book getById(Integer id) {        return bookDao.selectById(id);    }}</code></pre><h5 id="远程方案的数据同步"><a href="#远程方案的数据同步" class="headerlink" title="远程方案的数据同步"></a>远程方案的数据同步</h5><p>​由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据</p><p><strong>更新缓存</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@CacheUpdate(name="book_",key="#book.id",value="#book")public boolean update(Book book) {    return bookDao.updateById(book) &gt; 0;}</code></pre><p><strong>删除缓存</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@CacheInvalidate(name="book_",key = "#id")public boolean delete(Integer id) {    return bookDao.deleteById(id) &gt; 0;}</code></pre><p><strong>定时刷新缓存</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)@CacheRefresh(refresh = 5)public Book getById(Integer id) {    return bookDao.selectById(id);}</code></pre><h5 id="数据报表"><a href="#数据报表" class="headerlink" title="数据报表"></a>数据报表</h5><p>​jetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jetcache:  statIntervalMinutes: 1</code></pre><p>​设置后，每1分钟在控制台输出缓存数据命中信息</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003cache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime---------+-------+-------+------+-------+-------+---------+--------------+--------------book_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188---------+-------+-------+------+-------+-------+---------+--------------+--------------</code></pre><p><strong>总结</strong></p><ol><li>jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案</li><li>jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种</li><li>注意数据进入远程缓存时的类型转换问题</li><li>jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能</li><li>jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况</li></ol><p><strong>思考</strong></p><p>​jetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。</p><h4 id="SpringBoot整合j2cache缓存"><a href="#SpringBoot整合j2cache缓存" class="headerlink" title="SpringBoot整合j2cache缓存"></a>SpringBoot整合j2cache缓存</h4><p>​jetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：</p><p><strong>步骤①</strong>：导入j2cache、redis、ehcache坐标</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;    &lt;artifactId&gt;j2cache-core&lt;/artifactId&gt;    &lt;version&gt;2.8.4-release&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;    &lt;artifactId&gt;j2cache-spring-boot2-starter&lt;/artifactId&gt;    &lt;version&gt;2.8.0-release&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​j2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标</p><p><strong>步骤②</strong>：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 1级缓存j2cache.L1.provider_class = ehcacheehcache.configXml = ehcache.xml# 2级缓存j2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProviderj2cache.L2.config_section = redisredis.hosts = localhost:6379# 1级缓存中的数据如何到达二级缓存j2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</code></pre><p>​此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。</p><p>​一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。</p><p><strong>步骤③</strong>：使用缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService {    @Autowired    private CodeUtils codeUtils;    @Autowired    private CacheChannel cacheChannel;    public String sendCodeToSMS(String tele) {        String code = codeUtils.generator(tele);        cacheChannel.set("sms",tele,code);        return code;    }    public boolean checkCode(SMSCode smsCode) {        String code = cacheChannel.get("sms",smsCode.getTele()).asString();        return smsCode.getCode().equals(code);    }}</code></pre><p>​j2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。</p><p>​j2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#J2Cache configuration########################################## Cache Broadcast Method# values:# jgroups -&gt; use jgroups's multicast# redis -&gt; use redis publish/subscribe mechanism (using jedis)# lettuce -&gt; use redis publish/subscribe mechanism (using lettuce, Recommend)# rabbitmq -&gt; use RabbitMQ publisher/consumer mechanism# rocketmq -&gt; use RocketMQ publisher/consumer mechanism# none -&gt; don't notify the other nodes in cluster# xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy#########################################j2cache.broadcast = redis# jgroups propertiesjgroups.channel.name = j2cachejgroups.configXml = /network.xml# RabbitMQ propertiesrabbitmq.exchange = j2cacherabbitmq.host = localhostrabbitmq.port = 5672rabbitmq.username = guestrabbitmq.password = guest# RocketMQ propertiesrocketmq.name = j2cacherocketmq.topic = j2cache# use ; to split multi hostsrocketmq.hosts = 127.0.0.1:9876########################################## Level 1&amp;2 provider# values:# none -&gt; disable this level cache# ehcache -&gt; use ehcache2 as level 1 cache# ehcache3 -&gt; use ehcache3 as level 1 cache# caffeine -&gt; use caffeine as level 1 cache(only in memory)# redis -&gt; use redis as level 2 cache (using jedis)# lettuce -&gt; use redis as level 2 cache (using lettuce)# readonly-redis -&gt; use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.# memcached -&gt; use memcached as level 2 cache (xmemcached),# [classname] -&gt; use custom provider#########################################j2cache.L1.provider_class = caffeinej2cache.L2.provider_class = redis# When L2 provider isn't `redis`, using `L2.config_section = redis` to read redis configurations# j2cache.L2.config_section = redis# Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)# NOTICE: redis hash mode (redis.storage = hash) do not support this feature)j2cache.sync_ttl_to_redis = true# Whether to cache null objects by default (default false)j2cache.default_cache_null_object = true########################################## Cache Serialization Provider# values:# fst -&gt; using fast-serialization (recommend)# kryo -&gt; using kryo serialization# json -&gt; using fst's json serialization (testing)# fastjson -&gt; using fastjson serialization (embed non-static class not support)# java -&gt; java standard# fse -&gt; using fse serialization# [classname implements Serializer]#########################################j2cache.serialization = json#json.map.person = net.oschina.j2cache.demo.Person########################################## Ehcache configuration########################################## ehcache.configXml = /ehcache.xml# ehcache3.configXml = /ehcache3.xml# ehcache3.defaultHeapSize = 1000########################################## Caffeine configuration# caffeine.region.[name] = size, xxxx[s|m|h|d]##########################################caffeine.properties = /caffeine.properties########################################## Redis connection configuration################################################################################### Redis Cluster Mode## single -&gt; single redis server# sentinel -&gt; master-slaves servers# cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）# sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）##########################################redis.mode = single#redis storage mode (generic|hash)redis.storage = generic## redis pub/sub channel nameredis.channel = j2cache## redis pub/sub server (using redis.hosts when empty)redis.channel.host =#cluster name just for shardedredis.cluster_name = j2cache## redis cache namespace optional, default[empty]redis.namespace =## redis command scan parameter count, default[1000]#redis.scanCount = 1000## connection# Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379redis.hosts = 127.0.0.1:6379redis.timeout = 2000redis.password =redis.database = 0redis.ssl = false## redis pool propertiesredis.maxTotal = 100redis.maxIdle = 10redis.maxWaitMillis = 5000redis.minEvictableIdleTimeMillis = 60000redis.minIdle = 1redis.numTestsPerEvictionRun = 10redis.lifo = falseredis.softMinEvictableIdleTimeMillis = 10redis.testOnBorrow = trueredis.testOnReturn = falseredis.testWhileIdle = trueredis.timeBetweenEvictionRunsMillis = 300000redis.blockWhenExhausted = falseredis.jmxEnabled = false########################################## Lettuce scheme## redis -&gt; single redis server# rediss -&gt; single redis server with ssl# redis-sentinel -&gt; redis sentinel# redis-cluster -&gt; cluster servers#################################################################################### Lettuce Mode## single -&gt; single redis server# sentinel -&gt; master-slaves servers# cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）# sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）############################################ redis command scan parameter count, default[1000]#lettuce.scanCount = 1000lettuce.mode = singlelettuce.namespace =lettuce.storage = hashlettuce.channel = j2cachelettuce.scheme = redislettuce.hosts = 127.0.0.1:6379lettuce.password =lettuce.database = 0lettuce.sentinelMasterId =lettuce.maxTotal = 100lettuce.maxIdle = 10lettuce.minIdle = 10# timeout in millisecondslettuce.timeout = 10000# redis cluster topology refresh interval in millisecondslettuce.clusterTopologyRefresh = 3000########################################## memcached server configurations# refer to https://gitee.com/mirrors/XMemcached#########################################memcached.servers = 127.0.0.1:11211memcached.username =memcached.password =memcached.connectionPoolSize = 10memcached.connectTimeout = 1000memcached.failureMode = falsememcached.healSessionInterval = 1000memcached.maxQueuedNoReplyOperations = 100memcached.opTimeout = 100memcached.sanitizeKeys = false</code></pre><p><strong>总结</strong></p><ol><li>j2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案</li><li>j2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式</li><li>j2cache操作接口通过CacheChannel实现</li></ol><h3 id="5-2-任务"><a href="#5-2-任务" class="headerlink" title="5.2 任务"></a>5.2 任务</h3><p>​springboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。</p><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>​Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。</p><ul><li>工作（Job）：用于定义具体执行的工作</li><li>工作明细（JobDetail）：用于描述定时工作相关的信息</li><li>触发器（Trigger）：描述了工作明细与调度器的对应关系</li><li>调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则</li></ul><p>​简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。</p><p><strong>步骤①</strong>：导入springboot整合Quartz的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyQuartz extends QuartzJobBean {    @Override    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {        System.out.println("quartz task run...");    }}</code></pre><p><strong>步骤③</strong>：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class QuartzConfig {    @Bean    public JobDetail printJobDetail(){        //绑定具体的工作        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();    }    @Bean    public Trigger printJobTrigger(){        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule("0/5 * * * * ?");        //绑定对应的工作明细        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();    }}</code></pre><p>​工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。</p><p>​触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。</p><p><strong>总结</strong></p><ol><li>springboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象</li><li>JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象</li><li>Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器</li></ol><p><strong>思考</strong></p><p>​上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，如何用呢？咱们下节再说。</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>​spring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做</p><p><strong>步骤①</strong>：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//开启定时任务功能@EnableSchedulingpublic class Springboot22TaskApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot22TaskApplication.class, args);    }}</code></pre><p><strong>步骤②</strong>：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class MyBean {    @Scheduled(cron = "0/1 * * * * ?")    public void print(){        System.out.println(Thread.currentThread().getName()+" :spring task run...");    }}</code></pre><p>​完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。</p><p>​如何想对定时任务进行相关配置，可以通过配置文件进行</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  task:   scheduling:      pool:       size: 1# 任务调度线程池大小 默认 1      thread-name-prefix: ssm_      # 调度线程名称前缀 默认 scheduling-              shutdown:          await-termination: false# 线程池关闭时等待所有任务完成          await-termination-period: 10s# 调度线程关闭前最大等待时间，确保最后一定关闭</code></pre><p><strong>总结</strong></p><ol><li><p>spring task需要使用注解@EnableScheduling开启定时任务功能</p></li><li><p>为定时执行的的任务设置执行周期，描述方式cron表达式</p></li></ol><h3 id="5-3-邮件"><a href="#5-3-邮件" class="headerlink" title="5.3 邮件"></a>5.3 邮件</h3><p>​springboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。</p><p>​学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。</p><ul><li>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议</li><li>POP3（Post Office Protocol - Version 3）：用于<strong>接收</strong>电子邮件的标准协议</li><li>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</li></ul><p>​简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。</p><h4 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h4><p><strong>步骤①</strong>：导入springboot整合javamail的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置邮箱的登录信息</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  mail:    host: smtp.126.com    username: test@126.com    password: test</code></pre><p>​java程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。</p><p>​host配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。</p><p>​password并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：</p><p><img src="image-20220228111251036.png" alt="image-20220228111251036"></p><p><strong>步骤③</strong>：使用JavaMailSender接口发送邮件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class SendMailServiceImpl implements SendMailService {    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = "test@qq.com";    //接收人    private String to = "test@126.com";    //标题    private String subject = "测试邮件";    //正文    private String context = "测试邮件正文内容";    @Override    public void sendMail() {        SimpleMailMessage message = new SimpleMailMessage();        message.setFrom(from+"(小甜甜)");        message.setTo(to);        message.setSubject(subject);        message.setText(context);        javaMailSender.send(message);    }}</code></pre><p>​将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。</p><h4 id="发送多组件邮件（附件、复杂正文）"><a href="#发送多组件邮件（附件、复杂正文）" class="headerlink" title="发送多组件邮件（附件、复杂正文）"></a>发送多组件邮件（附件、复杂正文）</h4><p>​发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。</p><p><strong>发送网页正文邮件</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class SendMailServiceImpl2 implements SendMailService {    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = "test@qq.com";    //接收人    private String to = "test@126.com";    //标题    private String subject = "测试邮件";    //正文    private String context = "&lt;img src='ABC.JPG'/&gt;&lt;a href='https://www.itcast.cn'&gt;点开有惊喜&lt;/a&gt;";    public void sendMail() {        try {            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message);            helper.setFrom(to+"(小甜甜)");            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context,true);//此处设置正文支持html解析            javaMailSender.send(message);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p><strong>发送带有附件的邮件</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class SendMailServiceImpl2 implements SendMailService {    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = "test@qq.com";    //接收人    private String to = "test@126.com";    //标题    private String subject = "测试邮件";    //正文    private String context = "测试邮件正文";    public void sendMail() {        try {            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message,true);//此处设置支持附件            helper.setFrom(to+"(小甜甜)");            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context);            //添加附件            File f1 = new File("springboot_23_mail-0.0.1-SNAPSHOT.jar");            File f2 = new File("resources\\logo.png");            helper.addAttachment(f1.getName(),f1);            helper.addAttachment("最靠谱的培训结构.png",f2);            javaMailSender.send(message);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p><strong>总结</strong></p><ol><li>springboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程</li></ol><h3 id="5-4-消息"><a href="#5-4-消息" class="headerlink" title="5.4 消息"></a>5.4 消息</h3><p>​springboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。</p><h4 id="消息的概念"><a href="#消息的概念" class="headerlink" title="消息的概念"></a>消息的概念</h4><p>​从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。</p><p>​为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。</p><p>​对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。</p><p>​对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。</p><p>​所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。</p><p>​所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。</p><p>​以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。</p><h4 id="Java处理消息的标准规范"><a href="#Java处理消息的标准规范" class="headerlink" title="Java处理消息的标准规范"></a>Java处理消息的标准规范</h4><p>​目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：</p><ul><li>JMS</li><li>AMQP</li><li>MQTT</li></ul><p>​为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及</p><h5 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h5><p>​JMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。</p><p><strong>JMS消息模型</strong></p><p>​JMS规范中规范了消息有两种模型。分别是<strong>点对点模型</strong>和<strong>发布订阅模型</strong>。</p><p>​<strong>点对点模型</strong>：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。</p><p>​<strong>发布订阅模型</strong>：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。</p><p>​以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。</p><p><strong>JMS消息种类</strong></p><p>​根据消息中包含的数据种类划分，可以将消息划分成6种消息。</p><ul><li>TextMessage</li><li>MapMessage</li><li>BytesMessage</li><li>StreamMessage</li><li>ObjectMessage</li><li>Message （只有消息头和属性）</li></ul><p>​JMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。</p><h5 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h5><p>​JMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。</p><p>​这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。</p><p>​单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。</p><p>​AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS操作。<br><strong>优点</strong></p><p>​具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现</p><p><strong>JMS消息种类</strong></p><p>​AMQP消息种类：byte[]</p><p>​AMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。</p><p><strong>AMQP消息模型</strong></p><ul><li>direct exchange</li><li>fanout exchange</li><li>topic exchange</li><li>headers exchange</li><li>system exchange</li></ul><p>​目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ</p><h5 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h5><p>​MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。</p><p>​除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。</p><h5 id="KafKa"><a href="#KafKa" class="headerlink" title="KafKa"></a>KafKa</h5><p>​Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。</p><p>​本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。</p><h4 id="购物订单发送手机短信案例"><a href="#购物订单发送手机短信案例" class="headerlink" title="购物订单发送手机短信案例"></a>购物订单发送手机短信案例</h4><p>​为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。</p><p>​手机验证码案例需求如下：</p><ul><li><p>执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件</p></li><li><p>消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）</p><p>由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：</p></li></ul><p><strong>订单业务</strong></p><p>​<strong>业务层接口</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface OrderService {    void order(String id);}</code></pre><p>​模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类</p><p>​<strong>业务层实现</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class OrderServiceImpl implements OrderService {    @Autowired    private MessageService messageService;        @Override    public void order(String id) {        //一系列操作，包含各种服务调用，处理各种业务        System.out.println("订单处理开始");        //短信消息处理        messageService.sendMessage(id);        System.out.println("订单处理结束");        System.out.println();    }}</code></pre><p>​业务层转调短信处理的服务MessageService</p><p>​<strong>表现层服务</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/orders")public class OrderController {    @Autowired    private OrderService orderService;    @PostMapping("{id}")    public void order(@PathVariable String id){        orderService.order(id);    }}</code></pre><p>​表现层对外开发接口，传入订单id即可（模拟）</p><p><strong>短信处理业务</strong></p><p>​<strong>业务层接口</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface MessageService {    void sendMessage(String id);    String doMessage();}</code></pre><p>​短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计</p><p>​<strong>业务层实现</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class MessageServiceImpl implements MessageService {    private ArrayList&lt;String&gt; msgList = new ArrayList&lt;String&gt;();    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列，id："+id);        msgList.add(id);    }    @Override    public String doMessage() {        String id = msgList.remove(0);        System.out.println("已完成短信发送业务，id："+id);        return id;    }}</code></pre><p>​短信处理业务层实现中使用集合先模拟消息队列，观察效果</p><p>​<strong>表现层服务</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/msgs")public class MessageController {    @Autowired    private MessageService messageService;    @GetMapping    public String doMessage(){        String id = messageService.doMessage();        return id;    }}</code></pre><p>​短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。</p><p>​下面开启springboot整合各种各样的消息中间件，从严格满足JMS规范的ActiveMQ开始</p><h4 id="SpringBoot整合ActiveMQ"><a href="#SpringBoot整合ActiveMQ" class="headerlink" title="SpringBoot整合ActiveMQ"></a>SpringBoot整合ActiveMQ</h4><p>​ActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。</p><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://activemq.apache.org/components/classic/download/">https://activemq.apache.org/components/classic/download</a><a href="https://activemq.apache.org/components/classic/download/">/</a></p><p>​下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="image-20220228160001620.png" alt="image-20220228160001620"></p><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">activemq.bat</code></pre><p>​运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。</p><p><strong>访问web管理服务</strong></p><p>​ActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">http://127.0.0.1:8161/</code></pre><p>​web管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：</p><img src="image-20220228160844972.png" alt="image-20220228160844972" style="zoom:67%;"><p>​首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：</p><p><img src="image-20220228161010401.png" alt="image-20220228161010401"></p><p>​看到上述界面视为启动ActiveMQ服务成功。</p><p><strong>启动失败</strong></p><p>​在ActiveMQ启动时要占用多个端口，以下为正常启动信息：</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">wrapper  | --&gt; Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\soft\jdk1.8.0_172\jrejvm 1    |   Heap sizes: current=249344k  free=235037k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=7ySrCD75XhLCpLjd -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=9364 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]jvm 1    | ACTIVEMQ_HOME: ..\..jvm 1    | ACTIVEMQ_BASE: ..\..jvm 1    | ACTIVEMQ_CONF: ..\..\confjvm 1    | ACTIVEMQ_DATA: ..\..\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    |  INFO | Listening for connections at: amqp://CZBK-20210302VL:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector amqp startedjvm 1    |  INFO | Listening for connections at: stomp://CZBK-20210302VL:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector stomp startedjvm 1    |  INFO | Listening for connections at: mqtt://CZBK-20210302VL:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector mqtt startedjvm 1    |  INFO | Starting Jetty serverjvm 1    |  INFO | Creating Jetty connectorjvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f{/,null,STARTING} has uncovered http methods for path: /jvm 1    |  INFO | Listening for connections at ws://CZBK-20210302VL:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector ws startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) startedjvm 1    |  INFO | For help or more information please see: http://activemq.apache.orgjvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\soft\activemq\bin\win64\..\..\data\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mbjvm 1    |  INFO | ActiveMQ WebConsole available at http://127.0.0.1:8161/jvm 1    |  INFO | ActiveMQ Jolokia REST API available at http://127.0.0.1:8161/api/jolokia/</code></pre><p>​其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看<a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">【命令行启动常见问题及解决方案】</a></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">wrapper  | --&gt; Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\soft\jdk1.8.0_172\jrejvm 1    |   Heap sizes: current=249344k  free=235038k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=14836 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]jvm 1    | ACTIVEMQ_HOME: ..\..jvm 1    | ACTIVEMQ_BASE: ..\..jvm 1    | ACTIVEMQ_CONF: ..\..\confjvm 1    | ACTIVEMQ_DATA: ..\..\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)jvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)jvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)jvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)jvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)jvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)jvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)jvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)jvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)jvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)jvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)jvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)jvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)jvm 1    |      ... 46 morejvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)jvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)jvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)jvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)jvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)jvm 1    |      at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:237)jvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)jvm 1    |      ... 52 morejvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting downjvm 1    |  INFO | socketQueue interrupted - stoppingjvm 1    |  INFO | Connector openwire stoppedjvm 1    |  INFO | Could not accept connection during shutdown  : null (null)jvm 1    |  INFO | Connector amqp stoppedjvm 1    |  INFO | Connector stomp stoppedjvm 1    |  INFO | Connector mqtt stoppedjvm 1    |  INFO | Connector ws stoppedjvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] stoppedjvm 1    |  INFO | Stopping async queue tasksjvm 1    |  INFO | Stopping async topic tasksjvm 1    |  INFO | Stopped KahaDBjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 secondsjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdownjvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.apache.activemq.xbean.XBeanBrokerService#0' defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      ... 16 morejvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)wrapper  | &lt;-- Wrapper Stopped请按任意键继续. . .</code></pre><h5 id="整合-3"><a href="#整合-3" class="headerlink" title="整合"></a>整合</h5><p>​做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工</p><p><strong>步骤①</strong>：导入springboot整合ActiveMQ的starter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置ActiveMQ的服务器地址</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  activemq:    broker-url: tcp://localhost:61616</code></pre><p><strong>步骤③</strong>：使用JmsMessagingTemplate操作ActiveMQ</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MessageServiceActivemqImpl implements MessageService {    @Autowired    private JmsMessagingTemplate messagingTemplate;    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列，id："+id);        messagingTemplate.convertAndSend("order.queue.id",id);    }    @Override    public String doMessage() {        String id = messagingTemplate.receiveAndConvert("order.queue.id",String.class);        System.out.println("已完成短信发送业务，id："+id);        return id;    }}</code></pre><p>​发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。</p><p>​接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class MessageListener {    @JmsListener(destination = "order.queue.id")    @SendTo("order.other.queue.id")    public String receive(String id){        System.out.println("已完成短信发送业务，id："+id);        return "new:"+id;    }}</code></pre><p>​使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。</p><p>​如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。</p><p><strong>步骤⑤</strong>：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  activemq:    broker-url: tcp://localhost:61616  jms:    pub-sub-domain: true</code></pre><p>​pub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。</p><p><strong>总结</strong></p><ol><li>springboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列</li><li>操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener</li><li>配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型</li></ol><h4 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h4><p>​RabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。</p><p><strong>Erlang安装</strong></p><p>​windows版安装包下载地址：<a href="https://www.erlang.org/downloads">https</a><a href="https://www.erlang.org/downloads">://www.erlang.org/downloads</a></p><p>​下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。</p><p>​安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：</p><p><img src="image-20220228164851551.png" alt="image-20220228164851551"></p><p>​Erlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。</p><ul><li>ERLANG_HOME</li><li>PATH</li></ul><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://rabbitmq.com/install-windows.html">https://</a><a href="https://rabbitmq.com/install-windows.html">rabbitmq.com/install-windows.html</a></p><p>​下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件</p><img src="image-20220228165151524.png" alt="image-20220228165151524" style="zoom:67%;"><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">rabbitmq-service.bat start# 启动服务rabbitmq-service.bat stop# 停止服务rabbitmqctl status# 查看服务状态</code></pre><p>​运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。</p><p>​注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。</p><p>​说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。</p><p>​说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。</p><img src="image-20220228170147193.png" alt="image-20220228170147193" style="zoom:67%;"><p><strong>访问web管理服务</strong></p><p>​RabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">rabbitmq-plugins.bat list# 查看当前所有插件的运行状态rabbitmq-plugins.bat enable rabbitmq_management# 启动rabbitmq_management插件</code></pre><p>​启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">http://localhost:15672</code></pre><p>​web管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：</p><p><img src="image-20220228170504793.png" alt="image-20220228170504793"></p><p>​首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：</p><p><img src="image-20220228170535261.png" alt="image-20220228170535261"></p><h5 id="整合-direct模型"><a href="#整合-direct模型" class="headerlink" title="整合(direct模型)"></a>整合(direct模型)</h5><p>​RabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。</p><p><strong>步骤①</strong>：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置RabbitMQ的服务器地址</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  rabbitmq:    host: localhost    port: 5672</code></pre><p><strong>步骤③</strong>：初始化直连模式系统设置</p><p>​由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class RabbitConfigDirect {    @Bean    public Queue directQueue(){        return new Queue("direct_queue");    }    @Bean    public Queue directQueue2(){        return new Queue("direct_queue2");    }    @Bean    public DirectExchange directExchange(){        return new DirectExchange("directExchange");    }    @Bean    public Binding bindingDirect(){        return BindingBuilder.bind(directQueue()).to(directExchange()).with("direct");    }    @Bean    public Binding bindingDirect2(){        return BindingBuilder.bind(directQueue2()).to(directExchange()).with("direct2");    }}</code></pre><p>​队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。</p><p><strong>步骤④</strong>：使用AmqpTemplate操作RabbitMQ</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MessageServiceRabbitmqDirectImpl implements MessageService {    @Autowired    private AmqpTemplate amqpTemplate;    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列（rabbitmq direct），id："+id);        amqpTemplate.convertAndSend("directExchange","direct",id);    }}</code></pre><p>​amqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。</p><p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class MessageListener {    @RabbitListener(queues = "direct_queue")    public void receive(String id){        System.out.println("已完成短信发送业务(rabbitmq direct)，id："+id);    }}</code></pre><p>​使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。</p><h5 id="整合-topic模型"><a href="#整合-topic模型" class="headerlink" title="整合(topic模型)"></a>整合(topic模型)</h5><p><strong>步骤①</strong>：同上</p><p><strong>步骤②</strong>：同上</p><p><strong>步骤③</strong>：初始化主题模式系统设置</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class RabbitConfigTopic {    @Bean    public Queue topicQueue(){        return new Queue("topic_queue");    }    @Bean    public Queue topicQueue2(){        return new Queue("topic_queue2");    }    @Bean    public TopicExchange topicExchange(){        return new TopicExchange("topicExchange");    }    @Bean    public Binding bindingTopic(){        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with("topic.*.id");    }    @Bean    public Binding bindingTopic2(){        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.orders.*");    }}</code></pre><p>​主题模式支持routingKey匹配模式，*表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。</p><table><thead><tr><th><strong>匹配键</strong></th><th><strong>topic.*.*</strong></th><th><strong>topic.#</strong></th></tr></thead><tbody><tr><td>topic.order.id</td><td>true</td><td>true</td></tr><tr><td>order.topic.id</td><td>false</td><td>false</td></tr><tr><td>topic.sm.order.id</td><td>false</td><td>true</td></tr><tr><td>topic.sm.id</td><td>false</td><td>true</td></tr><tr><td>topic.id.order</td><td>true</td><td>true</td></tr><tr><td>topic.id</td><td>false</td><td>true</td></tr><tr><td>topic.order</td><td>false</td><td>true</td></tr></tbody></table><p><strong>步骤④</strong>：使用AmqpTemplate操作RabbitMQ</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MessageServiceRabbitmqTopicImpl implements MessageService {    @Autowired    private AmqpTemplate amqpTemplate;    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列（rabbitmq topic），id："+id);        amqpTemplate.convertAndSend("topicExchange","topic.orders.id",id);    }}</code></pre><p>​发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。</p><p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定队列</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class MessageListener {    @RabbitListener(queues = "topic_queue")    public void receive(String id){        System.out.println("已完成短信发送业务(rabbitmq topic 1)，id："+id);    }    @RabbitListener(queues = "topic_queue2")    public void receive2(String id){        System.out.println("已完成短信发送业务(rabbitmq topic 22222222)，id："+id);    }}</code></pre><p>​使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。</p><p><strong>总结</strong></p><ol><li>springboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列</li><li>操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener</li><li>RabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同</li></ol><h4 id="SpringBoot整合RocketMQ"><a href="#SpringBoot整合RocketMQ" class="headerlink" title="SpringBoot整合RocketMQ"></a>SpringBoot整合RocketMQ</h4><p>​RocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。</p><h5 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org</a><a href="https://rocketmq.apache.org/">/</a></p><p>​下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件</p><p><img src="image-20220228174453471.png" alt="image-20220228174453471"></p><p>​RocketMQ安装后需要配置环境变量，具体如下：</p><ul><li>ROCKETMQ_HOME</li><li>PATH</li><li>NAMESRV_ADDR （建议）： 127.0.0.1:9876</li></ul><p>​关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。</p><p><strong>RocketMQ工作模式</strong></p><p>​在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。</p><img src="image-20220228175123790.png" alt="image-20220228175123790" style="zoom:80%;"><p><strong>启动服务器</strong></p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">mqnamesrv# 启动命名服务器mqbroker# 启动broker</code></pre><p>​运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。</p><p>​运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。</p><p><strong>测试服务器启动状态</strong></p><p>​RocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">tools org.apache.rocketmq.example.quickstart.Producer# 生产消息tools org.apache.rocketmq.example.quickstart.Consumer# 消费消息</code></pre><h5 id="整合（异步消息）"><a href="#整合（异步消息）" class="headerlink" title="整合（异步消息）"></a>整合（异步消息）</h5><p><strong>步骤①</strong>：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置RocketMQ的服务器地址</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rocketmq:  name-server: localhost:9876  producer:    group: group_rocketmq</code></pre><p>​设置默认的生产者消费者所属组group。</p><p><strong>步骤③</strong>：使用RocketMQTemplate操作RocketMQ</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MessageServiceRocketmqImpl implements MessageService {    @Autowired    private RocketMQTemplate rocketMQTemplate;    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列（rocketmq），id："+id);        SendCallback callback = new SendCallback() {            @Override            public void onSuccess(SendResult sendResult) {                System.out.println("消息发送成功");            }            @Override            public void onException(Throwable e) {                System.out.println("消息发送失败！！！！！");            }        };        rocketMQTemplate.asyncSend("order_id",id,callback);    }}</code></pre><p>​使用asyncSend方法发送异步消息。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@RocketMQMessageListener(topic = "order_id",consumerGroup = "group_rocketmq")public class MessageListener implements RocketMQListener&lt;String&gt; {    @Override    public void onMessage(String id) {        System.out.println("已完成短信发送业务(rocketmq)，id："+id);    }}</code></pre><p>​RocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。</p><p>​使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定组、指定名称的消息队列。</p><p><strong>总结</strong></p><ol><li>springboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列</li><li>操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener</li></ol><h4 id="SpringBoot整合Kafka"><a href="#SpringBoot整合Kafka" class="headerlink" title="SpringBoot整合Kafka"></a>SpringBoot整合Kafka</h4><h5 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h5><p>​windows版安装包下载地址：<a href="https://kafka.apache.org/downloads">https://</a><a href="https://kafka.apache.org/downloads">kafka.apache.org/downloads</a></p><p>​下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件</p><p><img src="image-20220228181442155.png" alt="image-20220228181442155"></p><p>​建议使用windows版2.8.1版本。</p><p><strong>启动服务器</strong></p><p>​kafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">zookeeper-server-start.bat ..\..\config\zookeeper.properties# 启动zookeeperkafka-server-start.bat ..\..\config\server.properties# 启动kafka</code></pre><p>​运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。</p><p>​运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。</p><p><strong>创建主题</strong></p><p>​和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD"># 创建topickafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima# 查询topickafka-topics.bat --zookeeper 127.0.0.1:2181 --list# 删除topickafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima</code></pre><p><strong>测试服务器启动状态</strong></p><p>​Kafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">kafka-console-producer.bat --broker-list localhost:9092 --topic itheima# 测试生产消息kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning# 测试消息消费</code></pre><h5 id="整合-4"><a href="#整合-4" class="headerlink" title="整合"></a>整合</h5><p><strong>步骤①</strong>：导入springboot整合Kafka的starter，此坐标由springboot维护版本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>步骤②</strong>：配置Kafka的服务器地址</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  kafka:    bootstrap-servers: localhost:9092    consumer:      group-id: order</code></pre><p>​设置默认的生产者消费者所属组id。</p><p><strong>步骤③</strong>：使用KafkaTemplate操作Kafka</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MessageServiceKafkaImpl implements MessageService {    @Autowired    private KafkaTemplate&lt;String,String&gt; kafkaTemplate;    @Override    public void sendMessage(String id) {        System.out.println("待发送短信的订单已纳入处理队列（kafka），id："+id);        kafkaTemplate.send("itheima2022",id);    }}</code></pre><p>​使用send方法发送消息，需要传入topic名称。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class MessageListener {    @KafkaListener(topics = "itheima2022")    public void onMessage(ConsumerRecord&lt;String,String&gt; record){        System.out.println("已完成短信发送业务(kafka)，id："+record.value());    }}</code></pre><p>​使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。</p><p><strong>总结</strong></p><ol><li><p>springboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列</p></li><li><p>操作Kafka需要配置Kafka服务器地址，默认端口9092</p></li><li><p>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中</p></li></ol><h2 id="6-监控"><a href="#6-监控" class="headerlink" title="6. 监控"></a>6. 监控</h2><p>​在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。</p><p>​什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。</p><p>​本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。</p><h3 id="6-1-监控的意义"><a href="#6-1-监控的意义" class="headerlink" title="6.1 监控的意义"></a>6.1 监控的意义</h3><p>​对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是<strong>监控服务状态是否处理宕机状态</strong>。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，<strong>监控服务运行指标</strong>。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，<strong>监控程序运行日志</strong>。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，<strong>管理服务状态</strong>。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。</p><p>​通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。</p><img src="image-20220301093704396.png" alt="image-20220301093704396" style="zoom:50%;"><p>​此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。</p><img src="image-20220301094001896.png" alt="image-20220301094001896" style="zoom:50%;"><p>​新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。</p><img src="image-20220301094259844.png" alt="image-20220301094259844" style="zoom:50%;"><p>​如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。</p><img src="image-20220301094547748.png" alt="image-20220301094547748" style="zoom:50%;"><p>​被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。</p><p>​以上描述的整个过程就是一个监控系统的基本流程。</p><p><strong>总结</strong></p><ol><li>监控是一个非常重要的工作，是保障程序正常运行的基础手段</li><li>监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示</li><li>被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控</li></ol><p><strong>思考</strong></p><p>​下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。</p><h3 id="6-2-可视化监控平台"><a href="#6-2-可视化监控平台" class="headerlink" title="6.2 可视化监控平台"></a>6.2 可视化监控平台</h3><p>​springboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为<strong>Spring Boot Admin</strong>。</p><p>​Spring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。</p><p>​下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。</p><p><strong>服务端开发</strong></p><p><strong>步骤①</strong>：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​上述过程可以通过创建项目时使用勾选的形式完成。</p><img src="image-20220301102432817.png" alt="image-20220301102432817" style="zoom:50%;"><p><strong>步骤②</strong>：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@EnableAdminServerpublic class Springboot25AdminServerApplication {    public static void main(String[] args) {        SpringApplication.run(Springboot25AdminServerApplication.class, args);    }}</code></pre><p>​做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。</p><img src="image-20220301103028468.png" alt="image-20220301103028468" style="zoom: 50%;"><p>​由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。</p><p><strong>客户端开发</strong></p><p>​客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。</p><p><strong>步骤①</strong>：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>​上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。</p><p><strong>步骤②</strong>：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  boot:    admin:      client:        url: http://localhost:8080</code></pre><p>​做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。</p><img src="image-20220301103838079.png" alt="image-20220301103838079" style="zoom: 50%;"><p>​可以看到，当前监控了1个程序，点击进去查看详细信息。</p><img src="image-20220301103936386.png" alt="image-20220301103936386" style="zoom: 50%;"><p>​由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。</p><ol><li><p>开放指定信息给服务器看</p></li><li><p>允许服务器以HTTP请求的方式获取对应的信息</p><p>配置如下：</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 80spring:  boot:    admin:      client:        url: http://localhost:8080management:  endpoint:    health:      show-details: always  endpoints:    web:      exposure:        include: "*"</code></pre><p>​上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。</p><img src="image-20220301104742563.png" alt="image-20220301104742563" style="zoom: 50%;"><p>​但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:  endpoint:    health:      show-details: always</code></pre><p>​健康明细信息如下：</p><img src="image-20220301105116554.png" alt="image-20220301105116554" style="zoom: 50%;"><p>​目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">endpoints:  web:    exposure:      include: "*"</code></pre><p>​配置后再刷新服务器页面，就可以看到所有的信息了。</p><img src="image-20220301105554494.png" alt="image-20220301105554494" style="zoom: 50%;"><p>​以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。</p><p><strong>配置多个客户端</strong></p><p>​可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。</p><img src="image-20220301110352170.png" alt="image-20220301110352170" style="zoom: 50%;"><p>​进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。</p><ul><li>类加载面板中可以查阅到开发者自定义的类，如左图</li></ul><p>​                        <img src="image-20220301161246835.png" alt="image-20220301161246835" style="zoom:33%;"><img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20220301161949431.png" alt="image-20220301161949431" style="zoom:33%;"></p><ul><li>映射中可以查阅到当前应用配置的所有请求</li></ul><p>​                        <img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20220301161418791.png" alt="image-20220301161418791" style="zoom: 33%;"><img src="image-20220301162008737.png" alt="image-20220301162008737" style="zoom:33%;"></p><ul><li>性能指标中可以查阅当前应用独有的请求路径统计数据</li></ul><p>​                        <img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/SpringBoot2%25E5%2585%25A8%25E5%25A5%2597/%25E8%25AE%25B2%25E4%25B9%2589/img/image-20220301161906949.png" alt="image-20220301161906949" style="zoom: 33%;"><img src="image-20220301162040670.png" alt="image-20220301162040670" style="zoom: 33%;"></p><p><strong>总结</strong></p><ol><li>开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可</li><li>开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可</li><li>在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标</li></ol><p><strong>思考</strong></p><p>​之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。</p><h3 id="6-3-监控原理"><a href="#6-3-监控原理" class="headerlink" title="6.3 监控原理"></a>6.3 监控原理</h3><p>​通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头</p><img src="image-20220301170214076.png" alt="image-20220301170214076" style="zoom: 50%;"><p>​首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。</p><p><img src="image-20220301170723057.png" alt="image-20220301170723057"></p><p>​通过发送请求，可以得到一组json信息，如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "_links": {        "self": {            "href": "http://localhost:81/actuator",            "templated": false        },        "beans": {            "href": "http://localhost:81/actuator/beans",            "templated": false        },        "caches-cache": {            "href": "http://localhost:81/actuator/caches/{cache}",            "templated": true        },        "caches": {            "href": "http://localhost:81/actuator/caches",            "templated": false        },        "health": {            "href": "http://localhost:81/actuator/health",            "templated": false        },        "health-path": {            "href": "http://localhost:81/actuator/health/{*path}",            "templated": true        },        "info": {            "href": "http://localhost:81/actuator/info",            "templated": false        },        "conditions": {            "href": "http://localhost:81/actuator/conditions",            "templated": false        },        "shutdown": {            "href": "http://localhost:81/actuator/shutdown",            "templated": false        },        "configprops": {            "href": "http://localhost:81/actuator/configprops",            "templated": false        },        "configprops-prefix": {            "href": "http://localhost:81/actuator/configprops/{prefix}",            "templated": true        },        "env": {            "href": "http://localhost:81/actuator/env",            "templated": false        },        "env-toMatch": {            "href": "http://localhost:81/actuator/env/{toMatch}",            "templated": true        },        "loggers": {            "href": "http://localhost:81/actuator/loggers",            "templated": false        },        "loggers-name": {            "href": "http://localhost:81/actuator/loggers/{name}",            "templated": true        },        "heapdump": {            "href": "http://localhost:81/actuator/heapdump",            "templated": false        },        "threaddump": {            "href": "http://localhost:81/actuator/threaddump",            "templated": false        },        "metrics-requiredMetricName": {            "href": "http://localhost:81/actuator/metrics/{requiredMetricName}",            "templated": true        },        "metrics": {            "href": "http://localhost:81/actuator/metrics",            "templated": false        },        "scheduledtasks": {            "href": "http://localhost:81/actuator/scheduledtasks",            "templated": false        },        "mappings": {            "href": "http://localhost:81/actuator/mappings",            "templated": false        }    }}</code></pre><p>​其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">{    "status": "UP",    "components": {        "diskSpace": {            "status": "UP",            "details": {                "total": 297042808832,                "free": 72284409856,                "threshold": 10485760,                "exists": true            }        },        "ping": {            "status": "UP"        }    }}</code></pre><p>​当前信息与监控面板中的数据存在着对应关系</p><img src="image-20220301171025615.png" alt="image-20220301171025615" style="zoom:50%;"><p>​原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。</p><p>​到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。</p><p><img src="image-20220301171437817.png" alt="image-20220301171437817"></p><p>​这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。</p><p>​Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator<strong>可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求</strong>/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：</p><table><thead><tr><th>ID</th><th>描述</th><th>默认启用</th></tr></thead><tbody><tr><td>auditevents</td><td>暴露当前应用程序的审计事件信息。</td><td>是</td></tr><tr><td>beans</td><td>显示应用程序中所有 Spring bean 的完整列表。</td><td>是</td></tr><tr><td>caches</td><td>暴露可用的缓存。</td><td>是</td></tr><tr><td>conditions</td><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td><td>是</td></tr><tr><td>configprops</td><td>显示所有 @ConfigurationProperties 的校对清单。</td><td>是</td></tr><tr><td>env</td><td>暴露 Spring ConfigurableEnvironment 中的属性。</td><td>是</td></tr><tr><td>flyway</td><td>显示已应用的 Flyway 数据库迁移。</td><td>是</td></tr><tr><td>health</td><td>显示应用程序健康信息</td><td>是</td></tr><tr><td>httptrace</td><td>显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求/响应交换）。</td><td>是</td></tr><tr><td>info</td><td>显示应用程序信息。</td><td>是</td></tr><tr><td>integrationgraph</td><td>显示 Spring Integration 图。</td><td>是</td></tr><tr><td>loggers</td><td>显示和修改应用程序中日志记录器的配置。</td><td>是</td></tr><tr><td>liquibase</td><td>显示已应用的 Liquibase 数据库迁移。</td><td>是</td></tr><tr><td>metrics</td><td>显示当前应用程序的指标度量信息。</td><td>是</td></tr><tr><td>mappings</td><td>显示所有 @RequestMapping 路径的整理清单。</td><td>是</td></tr><tr><td>scheduledtasks</td><td>显示应用程序中的调度任务。</td><td>是</td></tr><tr><td>sessions</td><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。</td><td>是</td></tr><tr><td>shutdown</td><td>正常关闭应用程序。</td><td>否</td></tr><tr><td>threaddump</td><td>执行线程 dump。</td><td>是</td></tr><tr><td>heapdump</td><td>返回一个 hprof 堆 dump 文件。</td><td>是</td></tr><tr><td>jolokia</td><td>通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。</td><td>是</td></tr><tr><td>logfile</td><td>返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。</td><td>是</td></tr><tr><td>prometheus</td><td>以可以由 Prometheus 服务器抓取的格式暴露指标。</td><td>是</td></tr></tbody></table><p>​上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:  endpoint:    health:# 端点名称      show-details: always    info:# 端点名称      enabled: true# 是否开放</code></pre><p>​为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">management:  endpoints:    enabled-by-default: true# 是否开启默认端点，默认值true</code></pre><p>​上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">management:  endpoints:    web:      exposure:        include: "*"</code></pre><p>​整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">management:  endpoint:# 具体端点的配置    health:      show-details: always    info:      enabled: true  endpoints:# 全部端点的配置    web:      exposure:        include: "*"    enabled-by-default: true</code></pre><p><strong>总结</strong></p><ol><li><p>被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能</p></li><li><p>端点功能的开放与关闭可以通过配置进行控制</p></li><li><p>web端默认无法获取所有端点信息，通过配置开放端点功能</p></li></ol><h3 id="6-4-自定义监控指标"><a href="#6-4-自定义监控指标" class="headerlink" title="6.4 自定义监控指标"></a>6.4 自定义监控指标</h3><p>​端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。</p><p><strong>INFO端点</strong></p><p>​info端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息</p><ul><li><p>配置形式</p><p>在yml文件中通过设置info节点的信息就可以快速配置端点信息</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">info:  appName: @project.artifactId@  version: @project.version@  company: 传智教育  author: itheima</code></pre><p>配置完毕后，对应信息显示在监控平台上</p><img src="image-20220301174133248.png" alt="image-20220301174133248" style="zoom:50%;"><p>也可以通过请求端点信息路径获取对应json信息</p><img src="image-20220301174241310.png" alt="image-20220301174241310" style="zoom:50%;"></li><li><p>编程形式</p><p>通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class InfoConfig implements InfoContributor {    @Override    public void contribute(Info.Builder builder) {        builder.withDetail("runTime",System.currentTimeMillis());//添加单个信息        Map infoMap = new HashMap();        infoMap.put("buildTime","2006");        builder.withDetails(infoMap);//添加一组信息    }}</code></pre></li></ul><p><strong>Health端点</strong></p><p>​health端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class HealthConfig extends AbstractHealthIndicator {    @Override    protected void doHealthCheck(Health.Builder builder) throws Exception {        boolean condition = true;        if(condition) {            builder.status(Status.UP);//设置运行状态为启动状态            builder.withDetail("runTime", System.currentTimeMillis());            Map infoMap = new HashMap();            infoMap.put("buildTime", "2006");            builder.withDetails(infoMap);        }else{            builder.status(Status.OUT_OF_SERVICE);//设置运行状态为不在服务状态            builder.withDetail("上线了吗？","你做梦");        }    }}</code></pre><p>​当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。</p><img src="image-20220301174751845.png" alt="image-20220301174751845" style="zoom:50%;"><p><strong>Metrics端点</strong></p><p>​metrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService {    @Autowired    private BookDao bookDao;    private Counter counter;    public BookServiceImpl(MeterRegistry meterRegistry){        counter = meterRegistry.counter("用户付费操作次数：");    }    @Override    public boolean delete(Integer id) {        //每次执行删除业务等同于执行了付费业务        counter.increment();        return bookDao.deleteById(id) &gt; 0;    }}</code></pre><p>​在性能指标中就出现了自定义的性能指标监控项</p><img src="image-20220301175101812.png" alt="image-20220301175101812" style="zoom:50%;"><p><strong>自定义端点</strong></p><p>​可以根据业务需要自定义端点，方便业务监控</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component@Endpoint(id="pay",enableByDefault = true)public class PayEndpoint {    @ReadOperation    public Object getPay(){        Map payMap = new HashMap();        payMap.put("level 1","300");        payMap.put("level 2","291");        payMap.put("level 3","666");        return payMap;    }}</code></pre><p>​由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。</p><img src="image-20220301175355482.png" alt="image-20220301175355482" style="zoom:50%;"><p><strong>总结</strong></p><ol><li>端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同</li><li>info端点通过配置和编程的方式都可以添加端点指标</li><li>health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定</li><li>metrics指标通过在业务中添加监控操作设置指标</li><li>可以自定义端点添加更多的指标</li></ol><h2 id="开发实用篇完结"><a href="#开发实用篇完结" class="headerlink" title="开发实用篇完结"></a>开发实用篇完结</h2><p>​开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。</p><p>​整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。</p><p>​实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。</p><p>​开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。</p><h1 id="四、SpringBoot原理篇"><a href="#四、SpringBoot原理篇" class="headerlink" title="四、SpringBoot原理篇"></a>四、SpringBoot原理篇</h1><p>​在学习前面三篇的时候，好多小伙伴一直在B站评论区嚷嚷着期待原理篇，今天可以正式的宣布了，他来了他来了他脚踏祥云进来了（此处请自行脑补BGM）。</p><p>​其实从本人的角度出发，看了这么多学习java的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，<strong>先应用熟练</strong>，<strong>培养技术应用的条件反射</strong>，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， <strong>原理真不是看源码</strong>，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如spirng程序，写起来很费劲，springboot出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。</p><p>​springboot技术本身就是为了加速spring程序的开发的，可以大胆的说，springboot技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将springboot定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是spirngboot的原理。没有的事，springboot作为一款工具，压根就没有原理。我们下面要学习的其实就是spirngboot程序的工作流程。</p><p>​下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：</p><ul><li>自动配置工作流程</li><li>自定义starter开发</li><li>springboot程序启动流程</li></ul><p>​下面开启第一部分自动配置工作流程的学习</p><h2 id="1-自动配置工作流程"><a href="#1-自动配置工作流程" class="headerlink" title="1. 自动配置工作流程"></a>1. 自动配置工作流程</h2><p>​自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。</p><h3 id="1-1-bean的加载方式"><a href="#1-1-bean的加载方式" class="headerlink" title="1.1 bean的加载方式"></a>1.1 bean的加载方式</h3><p>​关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD">https://www.bilibili.com/video/BV1P44y1N7QG</code></pre><h4 id="方式一：配置文件-标签"><a href="#方式一：配置文件-标签" class="headerlink" title="方式一：配置文件+<bean/>标签"></a>方式一：配置文件+<code>&lt;bean/&gt;</code>标签</h4><p>​最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;    &lt;!--xml方式声明自己开发的bean--&gt;    &lt;bean id="cat" class="Cat"/&gt;    &lt;bean class="Dog"/&gt;    &lt;!--xml方式声明第三方开发的bean--&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/&gt;    &lt;bean class="com.alibaba.druid.pool.DruidDataSource"/&gt;    &lt;bean class="com.alibaba.druid.pool.DruidDataSource"/&gt;&lt;/beans&gt;</code></pre><h4 id="方式二：配置文件扫描-注解定义bean"><a href="#方式二：配置文件扫描-注解定义bean" class="headerlink" title="方式二：配置文件扫描+注解定义bean"></a>方式二：配置文件扫描+注解定义bean</h4><p>​由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component("tom")public class Cat {}</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Servicepublic class Mouse {}</code></pre><p>​当然，由于我们无法在<strong>第三方提供的技术</strong>源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Componentpublic class DbConfig {    @Bean    public DruidDataSource dataSource(){        DruidDataSource ds = new DruidDataSource();        return ds;    }}</code></pre><p>​上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd    "&gt;    &lt;!--指定扫描加载bean的位置--&gt;    &lt;context:component-scan base-package="com.itheima.bean,com.itheima.config"/&gt;&lt;/beans&gt;</code></pre><p>​方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。</p><h4 id="方式三：注解方式声明配置类"><a href="#方式三：注解方式声明配置类" class="headerlink" title="方式三：注解方式声明配置类"></a>方式三：注解方式声明配置类</h4><p>​方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，<strong>使用java类替换掉这种固定格式的配置</strong>，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。</p><p>​定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan({"com.itheima.bean","com.itheima.config"})public class SpringConfig3 {    @Bean    public DogFactoryBean dog(){        return new DogFactoryBean();    }}</code></pre><h5 id="使用FactroyBean接口"><a href="#使用FactroyBean接口" class="headerlink" title="使用FactroyBean接口"></a>使用FactroyBean接口</h5><p>​补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class DogFactoryBean implements FactoryBean&lt;Dog&gt; {    @Override    public Dog getObject() throws Exception {        Dog d = new Dog();        //.........        return d;    }    @Override    public Class&lt;?&gt; getObjectType() {        return Dog.class;    }    @Override    public boolean isSingleton() {        return true;    }}</code></pre><p>​有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。</p><p>​通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan({"com.itheima.bean","com.itheima.config"})public class SpringConfig3 {    @Bean    public DogFactoryBean dog(){        return new DogFactoryBean();    }}</code></pre><h5 id="注解格式导入XML格式配置的bean"><a href="#注解格式导入XML格式配置的bean" class="headerlink" title="注解格式导入XML格式配置的bean"></a>注解格式导入XML格式配置的bean</h5><p>​再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configuration@ImportResource("applicationContext1.xml")public class SpringConfig32 {}</code></pre><h5 id="proxyBeanMethods属性"><a href="#proxyBeanMethods属性" class="headerlink" title="proxyBeanMethods属性"></a>proxyBeanMethods属性</h5><p>​前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以<strong>保障配置类中使用方法创建的bean的唯一性</strong>。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configuration(proxyBeanMethods = true)public class SpringConfig33 {    @Bean    public Cat cat(){        return new Cat();    }}</code></pre><p>​下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class App33 {    public static void main(String[] args) {        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig33.class);        String[] names = ctx.getBeanDefinitionNames();        for (String name : names) {            System.out.println(name);        }        System.out.println("-------------------------");        SpringConfig33 springConfig33 = ctx.getBean("springConfig33", SpringConfig33.class);        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());// 同一个对象    }}</code></pre><h4 id="方式四：使用-Import注解注入bean"><a href="#方式四：使用-Import注解注入bean" class="headerlink" title="方式四：使用@Import注解注入bean"></a>方式四：使用@Import注解注入bean</h4><p>​使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。</p><p>​有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。</p><p>​所以我们需要一种<strong>精准制导的加载方式</strong>，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的<strong>bean没有使用@Component修饰</strong>呢？这下就无解了，而@Import就无需考虑这个问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import({Dog.class,DbConfig.class})public class SpringConfig4 {}</code></pre><h5 id="使用-Import注解注入配置类"><a href="#使用-Import注解注入配置类" class="headerlink" title="使用@Import注解注入配置类"></a>使用@Import注解注入配置类</h5><p>​除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(DogFactoryBean.class)public class SpringConfig4 {}</code></pre><h4 id="方式五：编程形式注册bean"><a href="#方式五：编程形式注册bean" class="headerlink" title="方式五：编程形式注册bean"></a>方式五：编程形式注册bean</h4><p>​前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class App5 {    public static void main(String[] args) {        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.register(Mouse.class);    }}</code></pre><p>​其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class App5 {    public static void main(String[] args) {        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.registerBean("tom", Cat.class,0);        ctx.registerBean("tom", Cat.class,1);        ctx.registerBean("tom", Cat.class,2);// 最后输出这个        System.out.println(ctx.getBean(Cat.class));    }}</code></pre><h4 id="方式六：导入实现了ImportSelector接口的类（重要）"><a href="#方式六：导入实现了ImportSelector接口的类（重要）" class="headerlink" title="方式六：导入实现了ImportSelector接口的类（重要）"></a>方式六：导入实现了ImportSelector接口的类（重要）</h4><p>​在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。</p><p>​      实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p><p>​现在又多了一种控制bean加载的方式，或者说是<strong>选择bean的方式</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// ImportSelector实现控制动态加载beanpublic class MyImportSelector implements ImportSelector {    @Override    public String[] selectImports(AnnotationMetadata metadata) { //metadata就是spring直接装载的bean，如SpringConfig6        //各种条件的判定，判定完毕后，决定是否装载指定的bean        //判断导入MyImportSelector的源SpringConfig6是否使用了Configuration注解        boolean flag = metadata.hasAnnotation("org.springframework.context.annotation.Configuration");//此时为true        if(flag){            return new String[]{"com.itheima.bean.Dog"};        }        return new String[]{"com.itheima.bean.Cat"};    }}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration//@ComponentScan(basePackages = "com.itheima")@Import(MyImportSelector.class)public class SpringConfig6 {}</code></pre><h4 id="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"><a href="#方式七：导入实现了ImportBeanDefinitionRegistrar接口的类" class="headerlink" title="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"></a>方式七：导入实现了ImportBeanDefinitionRegistrar接口的类</h4><p>​方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。    </p><p>​      BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你<strong>对bean的初始化进行更加细粒度的控制</strong>，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyRegistrar implements ImportBeanDefinitionRegistrar {    @Override    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {        BeanDefinition beanDefinition =             BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();        registry.registerBeanDefinition("bookService",beanDefinition);    }}</code></pre><h4 id="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"><a href="#方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类" class="headerlink" title="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"></a>方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类</h4><p>​上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果<strong>有冲突怎么办？谁能有最终裁定权？</strong>这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。</p><p>​spring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是<strong>最后一个运行</strong>的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 实现对容器中bean的最终裁定public class MyPostProcessor implements BeanDefinitionRegistryPostProcessor {    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {        BeanDefinition beanDefinition =             BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();        registry.registerBeanDefinition("bookService",beanDefinition);    }}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import({BookServiceImpl1.class, MyPostProcessor.class, MyRegistrar2.class, MyRegistrar.class}) //最终加载MyPostProcessor.class定义的bean：BookServiceImpl4.classpublic class SpringConfig8 {}</code></pre><p>​       总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。</p><p><strong>总结</strong></p><ol><li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean</li><li>@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载</li><li>spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li></ol><h3 id="1-2-bean的加载控制"><a href="#1-2-bean的加载控制" class="headerlink" title="1.2 bean的加载控制"></a>1.2 bean的加载控制</h3><p>​前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。</p><p>​企业级开发中<strong>不可能在spring容器中进行bean的饱和式加载</strong>的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，常常通过判定是否加载了某个类来<strong>控制某些bean的加载</strong>。</p><h4 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h4><p>下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class MyImportSelector implements ImportSelector {    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) {        try {            Class&lt;?&gt; clazz = Class.forName("com.itheima.bean.Mouse");            if(clazz != null) {                return new String[]{"com.itheima.bean.Cat"};            }        } catch (ClassNotFoundException e) {//            e.printStackTrace();            return new String[0];        }        return null;    }}</code></pre><p>​通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。</p><h4 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h4><p>​下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnClass(name = "com.itheima.bean.Wolf")public Cat tom(){    return new Cat();}</code></pre><p>​@ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnMissingClass("com.itheima.bean.Dog")public Cat tom(){    return new Cat();}</code></pre><p>​这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnClass(name = "com.itheima.bean.Wolf")@ConditionalOnMissingClass("com.itheima.bean.Mouse")public Cat tom(){    return new Cat();}</code></pre><p>​除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnWebApplicationpublic Cat tom(){    return new Cat();}</code></pre><p>​下面是判定容器环境是否是非web环境。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnNotWebApplicationpublic Cat tom(){    return new Cat();}</code></pre><p>​当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@ConditionalOnBean(name="jerry")public Cat tom(){    return new Cat();}</code></pre><p>​</p><p>以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class SpringConfig {    @Bean    @ConditionalOnClass(name="com.mysql.jdbc.Driver")    public DruidDataSource dataSource(){        return new DruidDataSource();    }}</code></pre><p>​其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。</p><p><strong>总结</strong></p><ol><li>springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean</li></ol><h3 id="1-3-bean的依赖属性配置管理"><a href="#1-3-bean的依赖属性配置管理" class="headerlink" title="1.3 bean的依赖属性配置管理"></a>1.3 bean的依赖属性配置管理</h3><p>​bean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">cartoon:  cat:    name: "图多盖洛"    age: 5  mouse:    name: "泰菲"    age: 1</code></pre><p>​然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@ConfigurationProperties(prefix = "cartoon")@Datapublic class CartoonProperties {    private Cat cat;    private Mouse mouse;}</code></pre><p>​最后在使用的位置注入对应的配置即可。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse{    @Autowired    private CartoonProperties cartoonProperties;}</code></pre><p>​建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。</p><p><strong>总结</strong></p><ol><li>bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties</li><li>设置属性类加载指定前缀的配置信息</li><li>在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。</li></ol><h3 id="1-4-自动配置原理（工作流程）"><a href="#1-4-自动配置原理（工作流程）" class="headerlink" title="1.4 自动配置原理（工作流程）"></a>1.4 自动配置原理（工作流程）</h3><p>​经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。</p><p>​啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。</p><p>​自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。</p><p><img src="image-20230929181504112.png" alt="image-20230929181504112"></p><p>​而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：</p><p><strong>阶段一：准备阶段</strong></p><ol><li><p>springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成<strong>技术集A</strong></p></li><li><p>收集常用技术(<strong>技术集A</strong>)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集B</strong></p></li></ol><p><strong>阶段二：加载阶段</strong></p><ol><li><p>springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成<strong>初始化环境</strong></p></li><li><p>springboot将<strong>技术集A</strong>包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</p></li><li><p>springboot会对<strong>技术集A</strong>中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与springboot的<strong>技术集A</strong>进行比对了，哪个匹配上加载哪个</p></li><li><p>因为有些技术不做配置就无法工作，所以springboot开始对<strong>设置集B</strong>下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</p></li><li><p>但是默认配置不一定能解决问题，于是springboot开放修改<strong>设置集B</strong>的接口，可以由开发者根据需要决定是否覆盖默认配置</p></li></ol><p>​</p><p>以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想==自己实现自动配置==的功能，都要做哪些工作呢？</p><ul><li>首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的<strong>技术集A</strong></li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class CartoonCatAndMouse{}</code></pre><ul><li>然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的<strong>设置集B</strong></li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">cartoon:  cat:    name: "图多盖洛"    age: 5  mouse:    name: "泰菲"    age: 1</code></pre><ul><li>将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@ConfigurationProperties(prefix = "cartoon")@Datapublic class CartoonProperties {    private Cat cat;    private Mouse mouse;}</code></pre><ul><li>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware {    private CartoonProperties cartoonProperties;}</code></pre><ul><li>当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件</li></ul><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@ConditionalOnClass(name="org.springframework.data.redis.core.RedisOperations")@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware {    private CartoonProperties cartoonProperties;}</code></pre><p>​做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。</p><pre class="line-numbers language-CMD" data-language="CMD"><code class="language-CMD"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.itheima.bean.CartoonCatAndMouse</code></pre><p>​其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：</p><ol><li>自动配置从根本上来说就是一个bean的加载</li><li>通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱</li><li>使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱</li><li>springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱</li></ol><p>​你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。</p><p>​以上内容是自动配置的工作流程。</p><blockquote><p>==<strong>总结</strong>==</p><ol><li>springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中<strong>配置的所有的类</strong>都加载成bean</li><li>在加载bean的时候，bean对应的类定义上都设置有<strong>加载条件</strong>，因此有可能加载成功，也可能条件检测失败不加载bean</li><li>对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的<strong>配置属性类</strong>并加载对应的配置</li><li>配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须yml配置后使用了</li></ol><p>讲解【自动配置原理（3）】<a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=159&amp;spm_id_from=pageDriver&amp;vd_source=b50a10126b84c902a8bd17e6539f5171">https://www.bilibili.com/video/BV15b4y1a7yG?p=159&amp;spm_id_from=pageDriver&amp;vd_source=b50a10126b84c902a8bd17e6539f5171</a></p></blockquote><h3 id="1-5-变更自动配置"><a href="#1-5-变更自动配置" class="headerlink" title="1.5 变更自动配置"></a>1.5 变更自动配置</h3><p>​知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：</p><p><strong>方式一：通过yaml配置设置排除指定的自动配置类</strong></p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">spring:  autoconfigure:    exclude:      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</code></pre><p><strong>方式二：通过注解参数排除自动配置类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableAutoConfiguration(excludeName = "",exclude = {})</code></pre><p><strong>方式三：排除坐标（应用面较窄）</strong></p><p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>总结</strong></p><ol><li>springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li></ol><h2 id="2-自定义starter开发"><a href="#2-自定义starter开发" class="headerlink" title="2. 自定义starter开发"></a>2. 自定义starter开发</h2><p>​自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。</p><h3 id="2-1-案例：记录系统访客独立IP访问次数"><a href="#2-1-案例：记录系统访客独立IP访问次数" class="headerlink" title="2.1 案例：记录系统访客独立IP访问次数"></a>2.1 案例：记录系统访客独立IP访问次数</h3><p>​本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。</p><p>​例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">         IP访问监控+-----ip-address-----+--num--+|     192.168.0.135  |   15  ||     61.129.65.248  |   20  |+--------------------+-------+</code></pre><p>​在进行具体制作之前，先对功能做具体的分析</p><ol><li><p>数据记录在什么位置</p><p>最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。</p></li><li><p>统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。</p></li><li><p>为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。</p><ul><li>输出频度，默认10秒</li><li>数据特征：累计数据 / 阶段数据，默认累计数据</li><li>输出格式：详细模式 / 极简模式</li></ul></li></ol><p>​在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。</p><h3 id="2-2-IP计数业务功能开发（自定义starter）"><a href="#2-2-IP计数业务功能开发（自定义starter）" class="headerlink" title="2.2 IP计数业务功能开发（自定义starter）"></a>2.2 IP计数业务功能开发（自定义starter）</h3><p>​本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。</p><p><strong>步骤一：创建全新的模块，定义业务功能类</strong></p><p>​功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountService {    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();}</code></pre><p>​有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。</p><p><strong>步骤二：制作统计功能</strong></p><p>​制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountService {    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    public void count(){        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数        //1.获取当前操作的IP地址        String ip = null;        //2.根据IP地址从Map取值，并递增        Integer count = ipCountMap.get(ip);        if(count == null){            ipCountMap.put(ip,1);        }else{            ipCountMap.put(ip,count + 1);        }    }}</code></pre><p>​因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountService {    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Autowired    //当前的request对象的注入工作由使用当前starter的工程提供自动装配    private HttpServletRequest httpServletRequest;    public void count(){        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数        //1.获取当前操作的IP地址        String ip = httpServletRequest.getRemoteAddr();        //2.根据IP地址从Map取值，并递增        Integer count = ipCountMap.get(ip);        if(count == null){            ipCountMap.put(ip,1);        }else{            ipCountMap.put(ip,count + 1);        }    }}</code></pre><p><strong>步骤三：定义自动配置类</strong></p><p>​我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpAutoConfiguration {    @Bean    public IpCountService ipCountService(){        return new IpCountService();    }}</code></pre><p>​自动配置类需要在spring.factories文件中做配置方可自动运行。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.itcast.autoconfig.IpAutoConfiguration</code></pre><p><strong>步骤四：在原始项目中模拟调用，测试功能</strong></p><p>​原始调用项目中导入当前开发的starter</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;dependency&gt;    &lt;groupId&gt;cn.itcast&lt;/groupId&gt;    &lt;artifactId&gt;ip_spring_boot_starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>​推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController {    @Autowired    private IpCountService ipCountService;    @GetMapping("{currentPage}/{pageSize}")    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book){        ipCountService.count();        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);        if( currentPage &gt; page.getPages()){            page = bookService.getPage((int)page.getPages(), pageSize,book);        }        return new R(true, page);    }}</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！</p><p><strong>当前效果</strong></p><p>​每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。</p><h3 id="2-3-定时任务报表开发"><a href="#2-3-定时任务报表开发" class="headerlink" title="2.3 定时任务报表开发"></a>2.3 定时任务报表开发</h3><p>​当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。</p><p><strong>步骤一：开启定时任务功能</strong></p><p>​定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableSchedulingpublic class IpAutoConfiguration {    @Bean    public IpCountService ipCountService(){        return new IpCountService();    }}</code></pre><p><strong>步骤二：制作显示统计数据功能</strong></p><p>​定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountService {    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Scheduled(cron = "0/5 * * * * ?")    public void print(){        System.out.println("         IP访问监控");        System.out.println("+-----ip-address-----+--num--+");        for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) {            String key = entry.getKey();            Integer value = entry.getValue();            System.out.println(String.format("|%18s  |%5d  |",key,value));        }        System.out.println("+--------------------+-------+");      }}</code></pre><p>​其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​每次运行效果之前先clean然后install，切记切记！！</p><p><strong>当前效果</strong></p><p>​每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。</p><h3 id="2-4-使用属性配置设置功能参数"><a href="#2-4-使用属性配置设置功能参数" class="headerlink" title="2.4 使用属性配置设置功能参数"></a>2.4 使用属性配置设置功能参数</h3><p>​由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。</p><p><strong>步骤一：定义参数格式</strong></p><p>​设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">tools:  ip:    cycle: 10    cycleReset: false    model: "detail"</code></pre><p><strong>步骤二：定义封装参数的属性类，读取配置参数</strong></p><p>​为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。</p><p>​日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@ConfigurationProperties(prefix = "tools.ip")public class IpProperties {    /**     * 日志显示周期     */    private Long cycle = 5L;    /**     * 是否周期内重置数据     */    private Boolean cycleReset = false;    /**     * 日志输出模式  detail：详细模式  simple：极简模式     */    private String model = LogModel.DETAIL.value;    public enum LogModel{        DETAIL("detail"),        SIMPLE("simple");        private String value;        LogModel(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }}</code></pre><p><strong>步骤三：加载属性类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableScheduling@EnableConfigurationProperties(IpProperties.class)public class IpAutoConfiguration {    @Bean    public IpCountService ipCountService(){        return new IpCountService();    }}</code></pre><p><strong>步骤四：应用配置属性</strong></p><p>​在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。</p><p>​注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountService {    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Autowired    private IpProperties ipProperties;    @Scheduled(cron = "0/5 * * * * ?")    public void print(){        if(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue())){            System.out.println("         IP访问监控");            System.out.println("+-----ip-address-----+--num--+");            for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) {                String key = entry.getKey();                Integer value = entry.getValue();                System.out.println(String.format("|%18s  |%5d  |",key,value));            }            System.out.println("+--------------------+-------+");        }else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue())){            System.out.println("     IP访问监控");            System.out.println("+-----ip-address-----+");            for (String key: ipCountMap.keySet()) {                System.out.println(String.format("|%18s  |",key));            }            System.out.println("+--------------------+");        }        //阶段内统计数据归零        if(ipProperties.getCycleReset()){            ipCountMap.clear();        }    }}</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​每次运行效果之前先clean然后install，切记切记！！</p><p><strong>当前效果</strong></p><p>​在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。</p><h3 id="2-5-使用属性配置设置定时器参数"><a href="#2-5-使用属性配置设置定时器参数" class="headerlink" title="2.5 使用属性配置设置定时器参数"></a>2.5 使用属性配置设置定时器参数</h3><p>​在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。</p><p><strong>步骤一：@Scheduled注解使用#{}读取bean属性值</strong></p><p>​此处读取bean名称为ipProperties的bean的cycle属性值</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Scheduled(cron = "0/#{ipProperties.cycle} * * * * ?")public void print(){}</code></pre><p><strong>步骤二：属性类定义bean并指定bean的访问名称</strong></p><p>​如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Component("ipProperties")@ConfigurationProperties(prefix = "tools.ip")public class IpProperties {}</code></pre><p><strong>步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@EnableScheduling//@EnableConfigurationProperties(IpProperties.class)@Import(IpProperties.class)public class IpAutoConfiguration {    @Bean    public IpCountService ipCountService(){        return new IpCountService();    }}</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​每次运行效果之前先clean然后install，切记切记！！</p><p><strong>当前效果</strong></p><p>​在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制</p><h3 id="2-6-拦截器开发"><a href="#2-6-拦截器开发" class="headerlink" title="2.6 拦截器开发"></a>2.6 拦截器开发</h3><p>​基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中</p><p><strong>步骤一：开发拦截器</strong></p><p>​使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class IpCountInterceptor implements HandlerInterceptor {    @Autowired    private IpCountService ipCountService;    @Override    public boolean preHandle(HttpServletRequest request,                              HttpServletResponse response, Object handler) throws Exception {        ipCountService.count();        return true;    }}</code></pre><p><strong>步骤二：配置拦截器</strong></p><p>​配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Configurationpublic class SpringMvcConfig implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(ipCountInterceptor()).addPathPatterns("/**");    }    @Bean    public IpCountInterceptor ipCountInterceptor(){        return new IpCountInterceptor();    }}</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​每次运行效果之前先clean然后install，切记切记！！</p><p><strong>当前效果</strong></p><p>​在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。</p><p>​到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。</p><h3 id="2-7-功能性完善——开启yml提示功能"><a href="#2-7-功能性完善——开启yml提示功能" class="headerlink" title="2.7 功能性完善——开启yml提示功能"></a>2.7 功能性完善——开启yml提示功能</h3><p>​我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。</p><p>​springboot提供有专用的工具实现此功能，仅需要导入下列坐标。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>​程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">{  "groups": [    {      "name": "tools.ip",      "type": "cn.itcast.properties.IpProperties",      "sourceType": "cn.itcast.properties.IpProperties"    }  ],  "properties": [    {      "name": "tools.ip.cycle",      "type": "java.lang.Long",      "description": "日志显示周期",      "sourceType": "cn.itcast.properties.IpProperties",      "defaultValue": 5    },    {      "name": "tools.ip.cycle-reset",      "type": "java.lang.Boolean",      "description": "是否周期内重置数据",      "sourceType": "cn.itcast.properties.IpProperties",      "defaultValue": false    },    {      "name": "tools.ip.model",      "type": "java.lang.String",      "description": "日志输出模式  detail：详细模式  simple：极简模式",      "sourceType": "cn.itcast.properties.IpProperties"    }  ],  "hints": [    {      "name": "tools.ip.model",      "values": [        {          "value": "detail",          "description": "详细模式."        },        {          "value": "simple",          "description": "极简模式."        }      ]    }  ]}</code></pre><p><strong>总结</strong></p><ol><li>自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能</li><li>通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果</li><li>本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter</li><li>对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写</li></ol><h2 id="3-SpringBoot程序启动流程解析"><a href="#3-SpringBoot程序启动流程解析" class="headerlink" title="3. SpringBoot程序启动流程解析"></a>3. SpringBoot程序启动流程解析</h2><p>​原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。</p><p>​其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。</p><p>​springboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：</p><ul><li>环境属性（Environment）</li><li>系统配置（spring.factories）</li><li>参数（Arguments、application.properties）</li></ul><p>​以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">Springboot30StartupApplication【10】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);    SpringApplication【1332】-&gt;return run(new Class&lt;?&gt;[] { primarySource }, args);        SpringApplication【1343】-&gt;return new SpringApplication(primarySources).run(args);            SpringApplication【1343】-&gt;SpringApplication(primarySources)            # 加载各种配置信息，初始化各种配置对象                SpringApplication【266】-&gt;this(null, primarySources);                    SpringApplication【280】-&gt;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)                        SpringApplication【281】-&gt;this.resourceLoader = resourceLoader;                        # 初始化资源加载器                        SpringApplication【283】-&gt;this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));                        # 初始化配置类的类名信息（格式转换）                        SpringApplication【284】-&gt;this.webApplicationType = WebApplicationType.deduceFromClasspath();                        # 确认当前容器加载的类型                        SpringApplication【285】-&gt;this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();                        # 获取系统配置引导信息                        SpringApplication【286】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));                        # 获取ApplicationContextInitializer.class对应的实例                        SpringApplication【287】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));                        # 初始化监听器，对初始化过程及运行过程进行干预                        SpringApplication【288】-&gt;this.mainApplicationClass = deduceMainApplicationClass();                        # 初始化了引导类类名信息，备用            SpringApplication【1343】-&gt;new SpringApplication(primarySources).run(args)            # 初始化容器，得到ApplicationContext对象                SpringApplication【323】-&gt;StopWatch stopWatch = new StopWatch();                # 设置计时器                SpringApplication【324】-&gt;stopWatch.start();                # 计时开始                SpringApplication【325】-&gt;DefaultBootstrapContext bootstrapContext = createBootstrapContext();                # 系统引导信息对应的上下文对象                SpringApplication【327】-&gt;configureHeadlessProperty();                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）                    java.awt.headless=true                SpringApplication【328】-&gt;SpringApplicationRunListeners listeners = getRunListeners(args);                # 获取当前注册的所有监听器                SpringApplication【329】-&gt;listeners.starting(bootstrapContext, this.mainApplicationClass);                # 监听器执行了对应的操作步骤                SpringApplication【331】-&gt;ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);                # 获取参数                SpringApplication【333】-&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);                # 将前期读取的数据加载成了一个环境对象，用来描述信息                SpringApplication【333】-&gt;configureIgnoreBeanInfo(environment);                # 做了一个配置，备用                SpringApplication【334】-&gt;Banner printedBanner = printBanner(environment);                # 初始化logo                SpringApplication【335】-&gt;context = createApplicationContext();                # 创建容器对象，根据前期配置的容器类型进行判定并创建                SpringApplication【363】-&gt;context.setApplicationStartup(this.applicationStartup);                # 设置启动模式                SpringApplication【337】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);                # 对容器进行设置，参数来源于前期的设定                SpringApplication【338】-&gt;refreshContext(context);                # 刷新容器环境                SpringApplication【339】-&gt;afterRefresh(context, applicationArguments);                # 刷新完毕后做后处理                SpringApplication【340】-&gt;stopWatch.stop();                # 计时结束                SpringApplication【341】-&gt;if (this.logStartupInfo) {                # 判定是否记录启动时间的日志                SpringApplication【342】-&gt;    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);                # 创建日志对应的对象，输出日志信息，包含启动时间                SpringApplication【344】-&gt;listeners.started(context);                # 监听器执行了对应的操作步骤                SpringApplication【345】-&gt;callRunners(context, applicationArguments);                # 调用运行器                SpringApplication【353】-&gt;listeners.running(context);                # 监听器执行了对应的操作步骤</code></pre><p>​上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？</p><p>​遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Abc implements InitializingBean, DisposableBean {    public void destroy() throws Exception {        //销毁操作    }    public void afterPropertiesSet() throws Exception {        //初始化操作    }}</code></pre><p>​springboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。</p><p>​springboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：</p><ul><li>org.springframework.boot.context.event.ApplicationStartingEvent<ul><li>应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent</li></ul></li><li>org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent<ul><li>环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent</li></ul></li><li>org.springframework.boot.context.event.ApplicationContextInitializedEvent<ul><li>上下文初始化事件</li></ul></li><li>org.springframework.boot.context.event.ApplicationPreparedEvent<ul><li>应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent</li></ul></li><li>org.springframework.context.event.ContextRefreshedEvent<ul><li>上下文刷新事件</li></ul></li><li>org.springframework.boot.context.event.ApplicationStartedEvent<ul><li>应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent</li></ul></li><li>org.springframework.boot.context.event.ApplicationReadyEvent<ul><li>应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求</li></ul></li><li>org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）</li></ul><p>​上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">//设定监听器，在应用启动开始事件时进行功能追加public class MyListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; {    public void onApplicationEvent(ApplicationStartingEvent event) {//自定义事件处理逻辑    }}</code></pre><p>​按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。</p><p><strong>总结</strong></p><ol><li>springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器</li><li>整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码</li></ol><h2 id="原理篇完结"><a href="#原理篇完结" class="headerlink" title="原理篇完结"></a>原理篇完结</h2><p>​原理篇到这里就要结束了，springboot2整套课程的基础篇、实用篇和原理篇就全部讲完了。至于后面的番外篇由于受B站视频上传总量不得超过200个视频的约束，番外篇的内容不会在当前课程中发布了，会重新定义一个课程继续发布，至于具体时间，暂时还无法给到各位小伙伴。</p><p>​原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到reflush方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将spring的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，( ´•︵•` )</p><p>​课程做到这里就要和各位小伙伴先say顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于IT研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。</p><p>​番外篇，さようなら！ 안녕히 계십시오！แล้วเจอกัน！До свидания ！خداحافظ ！</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="/2023/07/25/MyBatisPlus/"/>
      <url>/2023/07/25/MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<h2 id="1，MyBatisPlus入门案例与简介"><a href="#1，MyBatisPlus入门案例与简介" class="headerlink" title="1，MyBatisPlus入门案例与简介"></a>1，MyBatisPlus入门案例与简介</h2><p>这一节我们来学习下MyBatisPlus的入门案例与简介，这个和其他课程都不太一样，其他的课程都是先介绍概念，然后再写入门案例。而对于MyBatisPlus的学习，我们将顺序做了调整，主要的原因MyBatisPlus主要是对MyBatis的简化，所有我们先体会下它简化在哪，然后再学习它是什么，以及它帮我们都做哪些事。</p><h3 id="1-1-入门案例"><a href="#1-1-入门案例" class="headerlink" title="1.1 入门案例"></a>1.1 入门案例</h3><ul><li><p>MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。</p></li><li><p>开发方式</p><ul><li>基于MyBatis使用MyBatisPlus</li><li>基于Spring使用MyBatisPlus</li><li>==基于SpringBoot使用MyBatisPlus==</li></ul></li></ul><p>SpringBoot刚刚我们学习完成，它能快速构建Spring开发环境用以整合其他技术，使用起来是非常简单，对于MP的学习，我们也基于SpringBoot来构建学习。</p><p>学习之前，我们先来回顾下，SpringBoot整合Mybatis的开发过程:</p><ul><li><p>创建SpringBoot工程</p><p><img src="1630997819698.png" alt="1630997819698"></p></li><li><p>勾选配置使用的技术，能够实现自动添加起步依赖包</p><p><img src="1630997860020.png" alt="1630997860020"></p></li><li><p>设置dataSource相关属性(JDBC参数)</p><p><img src="1630997901479.png" alt="1630997901479"></p></li><li><p>定义数据层接口映射配置</p><p><img src="1630997929891.png" alt="1630997929891"></p></li></ul><p>我们可以参考着上面的这个实现步骤把SpringBoot整合MyBatisPlus来快速实现下，具体的实现步骤为:</p><h4 id="步骤1-创建数据库及表"><a href="#步骤1-创建数据库及表" class="headerlink" title="步骤1:创建数据库及表"></a>步骤1:创建数据库及表</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create database if not exists mybatisplus_db character set utf8;use mybatisplus_db;CREATE TABLE user (    id bigint(20) primary key auto_increment,    name varchar(32) not null,    password  varchar(32) not null,    age int(3) not null ,    tel varchar(32) not null);insert into user values(1,'Tom','tom',3,'18866668888');insert into user values(2,'Jerry','jerry',4,'16688886666');insert into user values(3,'Jock','123456',41,'18812345678');insert into user values(4,'传智播客','itcast',15,'4006184000');</code></pre><h4 id="步骤2-创建SpringBoot工程"><a href="#步骤2-创建SpringBoot工程" class="headerlink" title="步骤2:创建SpringBoot工程"></a>步骤2:创建SpringBoot工程</h4><p><img src="1630998241426.png" alt="1630998241426"></p><h4 id="步骤3-勾选配置使用技术"><a href="#步骤3-勾选配置使用技术" class="headerlink" title="步骤3:勾选配置使用技术"></a>步骤3:勾选配置使用技术</h4><p><img src="1630998321660.png" alt="1630998321660"></p><p><strong>说明:</strong></p><ul><li>由于MP并未被收录到idea的系统内置配置，无法直接选择加入，需要手动在pom.xml中配置添加</li></ul><h4 id="步骤4-pom-xml补全依赖"><a href="#步骤4-pom-xml补全依赖" class="headerlink" title="步骤4:pom.xml补全依赖"></a>步骤4:pom.xml补全依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>说明:</strong></p><ul><li><p>druid数据源可以加也可以不加，SpringBoot有内置的数据源，可以配置成使用Druid数据源</p></li><li><p>从MP的依赖关系可以看出，通过依赖传递已经将MyBatis与MyBatis整合Spring的jar包导入，我们不需要额外在添加MyBatis的相关jar包</p><p><img src="1631206757758.png" alt="1631206757758"></p></li></ul><h4 id="步骤5-添加MP的相关配置信息"><a href="#步骤5-添加MP的相关配置信息" class="headerlink" title="步骤5:添加MP的相关配置信息"></a>步骤5:添加MP的相关配置信息</h4><p>resources默认生成的是properties配置文件，可以将其替换成yml文件，并在文件中配置数据库连接的相关信息:<code>application.yml</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC     username: root    password: root</code></pre><p><strong>说明:</strong>==serverTimezone是用来设置时区，UTC是标准时区，和咱们的时间差8小时，所以可以将其修改为<code>Asia/Shanghai</code>==</p><h4 id="步骤6-根据数据库表创建实体类"><a href="#步骤6-根据数据库表创建实体类" class="headerlink" title="步骤6:根据数据库表创建实体类"></a>步骤6:根据数据库表创建实体类</h4><p><strong>类名和表名需要对应，属性名和字段名对应</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {       private Long id;    private String name;    private String password;    private Integer age;    private String tel;    //setter...getter...toString方法略}</code></pre><h4 id="步骤7-创建Dao接口"><a href="#步骤7-创建Dao接口" class="headerlink" title="步骤7:创建Dao接口"></a>步骤7:创建Dao接口</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface UserDao extends BaseMapper&lt;User&gt;{}</code></pre><h4 id="步骤8-编写引导类"><a href="#步骤8-编写引导类" class="headerlink" title="步骤8:编写引导类"></a>步骤8:编写引导类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication//@MapperScan("com.itheima.dao")public class Mybatisplus01QuickstartApplication {    public static void main(String[] args) {        SpringApplication.run(Mybatisplus01QuickstartApplication.class, args);    }}</code></pre><p>**说明:**Dao接口要想被容器扫描到，有两种解决方案:</p><ul><li>方案一:在Dao接口上添加<code>@Mapper</code>注解，并且确保Dao处在引导类所在包或其子包中<ul><li>该方案的缺点是需要在每一Dao接口中添加注解</li></ul></li><li>方案二:在引导类上添加<code>@MapperScan</code>注解，其属性为所要扫描的Dao所在包<ul><li>该方案的好处是只需要写一次，则指定包下的所有Dao接口都能被扫描到，<code>@Mapper</code>就可以不写。</li></ul></li></ul><h4 id="步骤9-编写测试类"><a href="#步骤9-编写测试类" class="headerlink" title="步骤9:编写测试类"></a>步骤9:编写测试类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass MpDemoApplicationTests {@Autowiredprivate UserDao userDao;@Testpublic void testGetAll() {List&lt;User&gt; userList = userDao.selectList(null);System.out.println(userList);}}</code></pre><p><strong>说明:</strong></p><p>userDao注入的时候下面有红线提示的原因是什么?</p><ul><li><p>UserDao是一个接口，不能实例化对象</p></li><li><p>只有在服务器启动IOC容器初始化后，由框架创建DAO接口的代理对象来注入</p></li><li><p>现在服务器并未启动，所以代理对象也未创建，IDEA查找不到对应的对象注入，所以提示报红</p></li><li><p>一旦服务启动，就能注入其代理对象，所以该错误提示不影响正常运行。</p></li></ul><p>查看运行结果:</p><p><img src="1630999646096.png" alt="1630999646096"></p><p>跟之前整合MyBatis相比，你会发现我们不需要在DAO接口中编写方法和SQL语句了，只需要继承<code>BaseMapper</code>接口即可。整体来说简化很多。</p><h3 id="1-2-MybatisPlus简介"><a href="#1-2-MybatisPlus简介" class="headerlink" title="1.2 MybatisPlus简介"></a>1.2 MybatisPlus简介</h3><p>MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在==简化开发、提高效率==</p><p>通过刚才的案例，相信大家能够体会简化开发和提高效率这两个方面的优点。</p><p>MyBatisPlus的官网为:<code>https://mp.baomidou.com/</code></p><p><strong>说明:</strong></p><p><img src="1631011942323.png" alt="1631011942323"></p><p>现在的页面中，这一行已经被删除，现在再去访问<code>https://mybatis.plus</code>会发现访问不到，这个就有很多可能性供我们猜想了，所以大家使用baomidou的网址进行访问即可。</p><p>官方文档中有一张很多小伙伴比较熟悉的图片:</p><p><img src="1631012174092.png" alt="1631012174092"></p><p>从这张图中我们可以看出MP旨在成为MyBatis的最好搭档，而不是替换MyBatis,所以可以理解为MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。</p><p>对于MP的学习，大家可以参考着官方文档来进行学习，里面都有详细的代码案例。</p><p>MP的特性:</p><ul><li>无侵入：只做增强不做改变，不会对现有工程产生影响</li><li>强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作</li><li>支持 Lambda：编写查询条件无需担心字段写错</li><li>支持主键自动生成</li><li>内置分页插件</li><li>……</li></ul><h2 id="2，标准数据层开发"><a href="#2，标准数据层开发" class="headerlink" title="2，标准数据层开发"></a>2，标准数据层开发</h2><p>在这一节中我们重点学习的是数据层标准的CRUD(增删改查)的实现与分页功能。代码比较多，我们一个个来学习。</p><h3 id="2-1-标准CRUD使用"><a href="#2-1-标准CRUD使用" class="headerlink" title="2.1 标准CRUD使用"></a>2.1 标准CRUD使用</h3><p>对于标准的CRUD功能都有哪些以及MP都提供了哪些方法可以使用呢?</p><p>我们先来看张图:</p><p><img src="1631018877517.png" alt="1631018877517"></p><p>对于这张图的方法，我们挨个来演示下:</p><p>首先说下，案例中的环境就是咱们入门案例的内容，第一个先来完成<code>新增</code>功能</p><h3 id="2-2-新增"><a href="#2-2-新增" class="headerlink" title="2.2 新增"></a>2.2 新增</h3><p>在进行新增之前，我们可以分析下新增的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int insert (T t)</code></pre><ul><li><p>T:泛型，新增用来保存新增数据</p></li><li><p>int:返回值，新增成功后返回1，没有新增成功返回的是0</p></li></ul><p>在测试类中进行新增操作:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testSave() {        User user = new User();        user.setName("黑马程序员");        user.setPassword("itheima");        user.setAge(12);        user.setTel("4006184000");        userDao.insert(user);    }}</code></pre><p>执行测试后，数据库表中就会添加一条数据。</p><p><img src="1631013124310.png" alt="1631013124310"></p><p>但是数据中的主键ID，有点长，那这个主键ID是如何来的?我们更想要的是主键自增，应该是5才对，这个是我们后面要学习的主键ID生成策略，这块的这个问题，我们暂时先放放。</p><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><p>在进行删除之前，我们可以分析下删除的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int deleteById (Serializable id)</code></pre><ul><li><p>Serializable：参数类型</p><ul><li><p>思考:参数类型为什么是一个序列化类?</p><p><img src="1631013655771.png" alt="1631013655771"></p><p>从这张图可以看出，</p><ul><li>String和Number是Serializable的子类，</li><li>Number又是Float,Double,Integer等类的父类，</li><li>能作为主键的数据类型都已经是Serializable的子类，</li><li>MP使用Serializable作为参数类型，就好比我们可以用Object接收任何数据类型一样。</li></ul></li></ul></li><li><p>int:返回值类型，数据删除成功返回1，未删除数据返回0。</p></li></ul><p>在测试类中进行新增操作:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> @SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testDelete() {        userDao.deleteById(1401856123725713409L);    }}</code></pre><h3 id="2-4-修改"><a href="#2-4-修改" class="headerlink" title="2.4 修改"></a>2.4 修改</h3><p>在进行修改之前，我们可以分析下修改的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int updateById(T t);</code></pre><ul><li><p>T:泛型，需要修改的数据内容，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值</p></li><li><p>int:返回值，修改成功后返回1，未修改数据返回0</p></li></ul><p>在测试类中进行新增操作:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testUpdate() {        User user = new User();        user.setId(1L);        user.setName("Tom888");        user.setPassword("tom888");        userDao.updateById(user);    }}</code></pre><p>**说明:**修改的时候，只修改实体对象中有值的字段。</p><h3 id="2-5-根据ID查询"><a href="#2-5-根据ID查询" class="headerlink" title="2.5 根据ID查询"></a>2.5 根据ID查询</h3><p>在进行根据ID查询之前，我们可以分析下根据ID查询的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">T selectById (Serializable id)</code></pre><ul><li>Serializable：参数类型,主键ID的值</li><li>T:根据ID查询只会返回一条数据</li></ul><p>在测试类中进行新增操作:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetById() {        User user = userDao.selectById(2L);        System.out.println(user);    }}</code></pre><h3 id="2-6-查询所有"><a href="#2-6-查询所有" class="headerlink" title="2.6 查询所有"></a>2.6 查询所有</h3><p>在进行查询所有之前，我们可以分析下查询所有的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code></pre><ul><li>Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null</li><li>List<t>:因为查询的是所有，所以返回的数据是一个集合</t></li></ul><p>在测试类中进行新增操作:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll() {        List&lt;User&gt; userList = userDao.selectList(null);        System.out.println(userList);    }}</code></pre><p>我们所调用的方法都是来自于DAO接口继承的BaseMapper类中。里面的方法有很多，我们后面会慢慢去学习里面的内容。</p><h3 id="2-7-Lombok"><a href="#2-7-Lombok" class="headerlink" title="2.7 Lombok"></a>2.7 Lombok</h3><p>代码写到这，我们会发现DAO接口类的编写现在变成最简单的了，里面什么都不用写。反过来看看模型类的编写都需要哪些内容:</p><ul><li>私有属性</li><li>setter…getter…方法</li><li>toString方法</li><li>构造函数</li></ul><p>虽然这些内容不难，同时也都是通过IDEA工具生成的，但是过程还是必须得走一遍，那么对于模型类的编写有没有什么优化方法?就是我们接下来要学习的Lombok。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发。</li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><h5 id="步骤1-添加lombok依赖"><a href="#步骤1-添加lombok依赖" class="headerlink" title="步骤1:添加lombok依赖"></a>步骤1:添加lombok依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;!--&lt;version&gt;1.18.12&lt;/version&gt;--&gt;&lt;/dependency&gt;</code></pre><p><strong>注意：</strong>版本可以不用写，因为SpringBoot中已经管理了lombok的版本。</p><h5 id="步骤2-安装Lombok的插件"><a href="#步骤2-安装Lombok的插件" class="headerlink" title="步骤2:安装Lombok的插件"></a>步骤2:安装Lombok的插件</h5><p>==新版本IDEA已经内置了该插件，如果删除setter和getter方法程序有报红，则需要安装插件==</p><p><img src="1631016543648.png" alt="1631016543648"></p><p>如果在IDEA中找不到lombok插件，可以访问如下网站</p><p><code>https://plugins.jetbrains.com/plugin/6317-lombok/versions</code></p><p>根据自己IDEA的版本下载对应的lombok插件，下载成功后，在IDEA中采用离线安装的方式进行安装。</p><p><img src="1631016876641.png" alt="1631016876641"></p><h5 id="步骤3-模型类上添加注解"><a href="#步骤3-模型类上添加注解" class="headerlink" title="步骤3:模型类上添加注解"></a>步骤3:模型类上添加注解</h5><p>Lombok常见的注解有:</p><ul><li>@Setter:为模型类的属性提供setter方法</li><li>@Getter:为模型类的属性提供getter方法</li><li>@ToString:为模型类的属性提供toString方法</li><li>@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法</li><li>==@Data:是个组合注解，包含上面的注解的功能==</li><li>==@NoArgsConstructor:提供一个无参构造函数==</li><li>==@AllArgsConstructor:提供一个包含所有参数的构造函数==</li></ul><p>Lombok的注解还有很多，上面标红的三个是比较常用的，其他的大家后期用到了，再去补充学习。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor @NoArgsConstructorpublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;}</code></pre><p><strong>说明:</strong></p><p>Lombok只是简化模型类的编写，我们之前的方法也能用，比如有人会问:我如果只想要有name和password的构造函数，该如何编写?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;    public User(String name, String password) {        this.name = name;        this.password = password;    }}</code></pre><p>这种方式是被允许的。</p><h3 id="2-8-分页功能"><a href="#2-8-分页功能" class="headerlink" title="2.8 分页功能"></a>2.8 分页功能</h3><p>基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。</p><p>分页查询使用的方法是:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></pre><ul><li>IPage:用来构建分页查询条件</li><li>Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null</li><li>IPage:返回值，你会发现构建分页条件和方法的返回值都是IPage</li></ul><p>IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为<code>Page</code>。</p><h4 id="步骤1-调用方法传入参数获取返回值"><a href="#步骤1-调用方法传入参数获取返回值" class="headerlink" title="步骤1:调用方法传入参数获取返回值"></a>步骤1:调用方法传入参数获取返回值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus01QuickstartApplicationTests {    @Autowired    private UserDao userDao;        //分页查询    @Test    void testSelectPage(){        //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数        IPage&lt;User&gt; page=new Page&lt;&gt;(1,3);        //2 执行分页查询        userDao.selectPage(page,null);        //3 获取分页结果        System.out.println("当前页码值："+page.getCurrent());        System.out.println("每页显示数："+page.getSize());        System.out.println("一共多少页："+page.getPages());        System.out.println("一共多少条数据："+page.getTotal());        System.out.println("数据："+page.getRecords());    }}</code></pre><h4 id="步骤2-设置分页拦截器"><a href="#步骤2-设置分页拦截器" class="headerlink" title="步骤2:设置分页拦截器"></a>步骤2:设置分页拦截器</h4><p>这个拦截器MP已经为我们提供好了，我们只需要将其配置成Spring管理的bean对象即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig {        @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        //1 创建MybatisPlusInterceptor拦截器对象        MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor();        //2 添加分页拦截器        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mpInterceptor;    }}</code></pre><p>**说明:**上面的代码记不住咋办呢?</p><p>这些内容在MP的官方文档中有详细的说明，我们可以查看官方文档类配置</p><p><img src="1631208030131.png" alt="1631208030131"></p><h4 id="步骤3-运行测试程序"><a href="#步骤3-运行测试程序" class="headerlink" title="步骤3:运行测试程序"></a>步骤3:运行测试程序</h4><p><img src="1631019660480.png" alt="1631019660480"></p><h3 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h3><p>如果想查看MP执行的SQL语句，可以修改application.yml配置文件，</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #打印SQL日志到控制台</code></pre><p>打开日志后，就可以在控制台打印出对应的SQL语句，开启日志功能性能就会受到影响，调试完后记得关闭。</p><p><img src="1631019896688.png" alt="1631019896688"></p><h2 id="3，DQL编程控制"><a href="#3，DQL编程控制" class="headerlink" title="3，DQL编程控制"></a>3，DQL编程控制</h2><p>增删改查四个操作中，查询是非常重要的也是非常复杂的操作，这块需要我们重点学习下，这节我们主要学习的内容有:</p><ul><li>条件查询方式</li><li>查询投影</li><li>查询条件设定</li><li>字段映射与表名映射</li></ul><h3 id="3-1-条件查询"><a href="#3-1-条件查询" class="headerlink" title="3.1 条件查询"></a>3.1 条件查询</h3><h4 id="3-1-1-条件查询的类"><a href="#3-1-1-条件查询的类" class="headerlink" title="3.1.1 条件查询的类"></a>3.1.1 条件查询的类</h4><ul><li>MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合。</li></ul><p>这个我们在前面都有见过，比如查询所有和分页查询的时候，都有看到过一个<code>Wrapper</code>类，这个类就是用来构建查询条件的，如下图所示:</p><p><img src="1631020283701.png" alt="1631020283701"></p><p>那么条件查询如何使用Wrapper来构建呢?</p><h4 id="3-1-2-环境构建"><a href="#3-1-2-环境构建" class="headerlink" title="3.1.2 环境构建"></a>3.1.2 环境构建</h4><p>在构建条件查询之前，我们先来准备下环境</p><ul><li><p>创建一个SpringBoot项目</p></li><li><p>pom.xml中添加对应的依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.0&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;mybatisplus_02_dql&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>编写UserDao接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface UserDao extends BaseMapper&lt;User&gt; {}</code></pre></li><li><p>编写模型类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;}</code></pre></li><li><p>编写引导类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class Mybatisplus02DqlApplication {    public static void main(String[] args) {        SpringApplication.run(Mybatisplus02DqlApplication.class, args);    }}</code></pre></li><li><p>编写配置文件</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># dataSourcespring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC    username: root    password: root# mp日志mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></li><li><p>编写测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        List&lt;User&gt; userList = userDao.selectList(null);        System.out.println(userList);    }}</code></pre><p>最终创建的项目结构为:</p><p><img src="1631033477792.png" alt="1631033477792"></p></li><li><p>测试的时候，控制台打印的日志比较多，速度有点慢而且不利于查看运行结果，所以接下来我们把这个日志处理下:</p><ul><li><p>取消初始化spring日志打印，resources目录下添加logback.xml，名称固定，内容如下:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt;&lt;/configuration&gt;</code></pre><p>**说明:**logback.xml的配置内容，不是我们学习的重点，如果有兴趣可以自行百度查询。</p></li><li><p>取消MybatisPlus启动banner图标</p><p><img src="1631021315906.png" alt="1631021315906"></p><p>application.yml添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># mybatis-plus日志控制台输出mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    banner: off # 关闭mybatisplus启动图标</code></pre></li><li><p>取消SpringBoot的log打印</p><p><img src="1631021269422.png" alt="1631021269422"></p><p>application.yml添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  main:    banner-mode: off # 关闭SpringBoot启动图标(banner)</code></pre></li></ul></li></ul><p>解决控制台打印日志过多的相关操作可以不用去做，一般会被用来方便我们查看程序运行的结果。</p><h4 id="3-1-3-构建条件查询"><a href="#3-1-3-构建条件查询" class="headerlink" title="3.1.3 构建条件查询"></a>3.1.3 构建条件查询</h4><p>在进行查询的时候，我们的入口是在Wrapper这个类上，因为它是一个接口，所以我们需要去找它对应的实现类，关于实现类也有很多，说明我们有多种构建查询条件对象的方式，</p><p><img src="1631021942869.png" alt="1631021942869"></p><ol><li>先来看第一种:==QueryWrapper==</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        QueryWrapper qw = new QueryWrapper();        qw.lt("age",18);        List&lt;User&gt; userList = userDao.selectList(qw);        System.out.println(userList);    }}</code></pre><ul><li><p>lt: 小于(&lt;) ,最终的sql语句为</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,password,age,tel FROM user WHERE (age &lt; ?)</code></pre></li></ul><p>第一种方式介绍完后，有个小问题就是在写条件的时候，容易出错，比如age写错，就会导致查询不成功</p><ol start="2"><li>接着来看第二种:==QueryWrapper的基础上使用lambda==</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        QueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;User&gt;();        qw.lambda().lt(User::getAge, 10);//添加条件        List&lt;User&gt; userList = userDao.selectList(qw);        System.out.println(userList);    }}</code></pre><ul><li>User::getAget,为lambda表达式中的，类名::方法名，最终的sql语句为:</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,password,age,tel FROM user WHERE (age &lt; ?)</code></pre><p>**注意:**构建LambdaQueryWrapper的时候泛型不能省。</p><p>此时我们再次编写条件的时候，就不会存在写错名称的情况，但是qw后面多了一层lambda()调用</p><ol start="3"><li>接着来看第三种:==LambdaQueryWrapper==</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.lt(User::getAge, 10);        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><p>这种方式就解决了上一种方式所存在的问题。</p><h4 id="3-1-4-多条件构建"><a href="#3-1-4-多条件构建" class="headerlink" title="3.1.4 多条件构建"></a>3.1.4 多条件构建</h4><p>学完了三种构建查询对象的方式，每一种都有自己的特点，所以用哪一种都行，刚才都是一个条件，那如果有多个条件该如何构建呢?</p><blockquote><p>需求:查询数据库表中，年龄在10岁到30岁之间的用户信息</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.lt(User::getAge, 30);        lqw.gt(User::getAge, 10);        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li><p>gt：大于(&gt;),最终的SQL语句为</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,password,age,tel FROM user WHERE (age &lt; ? AND age &gt; ?)</code></pre></li><li><p>构建多条件的时候，可以支持<strong>链式编程</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();lqw.lt(User::getAge, 30).gt(User::getAge, 10);List&lt;User&gt; userList = userDao.selectList(lqw);System.out.println(userList);</code></pre></li></ul><blockquote><p>需求:查询数据库表中，年龄小于10或年龄大于30的数据</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.lt(User::getAge, 10).or().gt(User::getAge, 30);        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li><p>or()就相当于我们sql语句中的<code>or</code>关键字,不加默认是<code>and</code>，最终的sql语句为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,password,age,tel FROM user WHERE (age &lt; ? OR age &gt; ?)</code></pre></li></ul><h4 id="3-1-5-null判定"><a href="#3-1-5-null判定" class="headerlink" title="3.1.5 null判定"></a>3.1.5 null判定</h4><p>先来看一张图，</p><p><img src="1631023641992.png" alt="1631023641992"></p><ul><li>我们在做条件查询的时候，一般会有很多条件可以供用户进行选择查询。</li><li>这些条件用户可以选择使用也可以选择不使用，比如我要查询价格在8000以上的手机</li><li>在输入条件的时候，价格有一个区间范围，按照需求只需要在第一个价格输入框中输入8000</li><li>后台在做价格查询的时候，一般会让 price&gt;值1 and price &lt;值2</li><li>因为前端没有输入值2，所以如果不处理的话，就会出现 price&gt;8000 and price &lt; null问题</li><li>这个时候查询的结果就会出问题，具体该如何解决?</li></ul><p><img src="1631024145264.png" alt="1631024145264"></p><blockquote><p>需求:查询数据库表中，根据输入年龄范围来查询符合条件的记录</p><p>用户在输入值的时候，</p><p>​如果只输入第一个框，说明要查询大于该年龄的用户</p><p>​如果只输入第二个框，说明要查询小于该年龄的用户</p><p>​    如果两个框都输入了，说明要查询年龄在两个范围之间的用户</p></blockquote><p>思考第一个问题：后台如果想接收前端的两个数据，该如何接收?</p><p>我们可以使用两个简单数据类型，也可以使用一个模型类，但是User类中目前只有一个age属性,如:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;}</code></pre><p>使用一个age属性，如何去接收页面上的两个值呢?这个时候我们有两个解决方案</p><p>方案一:添加属性age2,这种做法可以但是会影响到原模型类的属性内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;    private Integer age2;}</code></pre><p>方案二:新建一个模型类,让其继承User类，并在其中添加age2属性，UserQuery在拥有User属性后同时添加了age2属性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;}@Datapublic class UserQuery extends User {    private Integer age2;}</code></pre><p>环境准备好后，我们来实现下刚才的需求：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        //模拟页面传递过来的查询数据        UserQuery uq = new UserQuery();        uq.setAge(10);        uq.setAge2(30);        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        if(null != uq.getAge2()){            lqw.lt(User::getAge, uq.getAge2());        }        if( null != uq.getAge()) {            lqw.gt(User::getAge, uq.getAge());        }        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><p>上面的写法可以完成条件为非空的判断，但是问题很明显，如果条件多的话，每个条件都需要判断，代码量就比较大，来看MP给我们提供的简化方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        //模拟页面传递过来的查询数据        UserQuery uq = new UserQuery();        uq.setAge(10);        uq.setAge2(30);        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.lt(null!=uq.getAge2(),User::getAge, uq.getAge2());        lqw.gt(null!=uq.getAge(),User::getAge, uq.getAge());        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li><p>lt()方法</p><p><img src="1631025068317.png" alt="1631025068317"></p><p>condition为boolean类型，返回true，则添加条件，返回false则不添加条件</p></li></ul><h3 id="3-2-查询投影"><a href="#3-2-查询投影" class="headerlink" title="3.2 查询投影"></a>3.2 查询投影</h3><h4 id="3-2-1-查询指定字段"><a href="#3-2-1-查询指定字段" class="headerlink" title="3.2.1 查询指定字段"></a>3.2.1 查询指定字段</h4><p>目前我们在查询数据的时候，什么都没有做默认就是查询表中所有字段的内容，我们所说的查询投影即不查询所有字段，只查询出指定内容的数据。</p><p>具体如何来实现?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.select(User::getId,User::getName,User::getAge);        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li><p>select(…)方法用来设置查询的字段列，可以设置多个，最终的sql语句为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,age FROM user</code></pre></li><li><p>如果使用的不是lambda，就需要手动指定字段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();        lqw.select("id","name","age","tel");        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li>最终的sql语句为:SELECT id,name,age,tel FROM user</li></ul></li></ul><h4 id="3-2-2-聚合查询"><a href="#3-2-2-聚合查询" class="headerlink" title="3.2.2 聚合查询"></a>3.2.2 聚合查询</h4><blockquote><p>需求:聚合函数查询，完成count、max、min、avg、sum的使用</p><p>count:总记录数</p><p>max:最大值</p><p>min:最小值</p><p>avg:平均值</p><p>sum:求和</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();        //lqw.select("count(*) as count");        //SELECT count(*) as count FROM user        //lqw.select("max(age) as maxAge");        //SELECT max(age) as maxAge FROM user        //lqw.select("min(age) as minAge");        //SELECT min(age) as minAge FROM user        //lqw.select("sum(age) as sumAge");        //SELECT sum(age) as sumAge FROM user        lqw.select("avg(age) as avgAge");        //SELECT avg(age) as avgAge FROM user        List&lt;Map&lt;String, Object&gt;&gt; userList = userDao.selectMaps(lqw);        System.out.println(userList);    }}</code></pre><p>为了在做结果封装的时候能够更简单，我们将上面的聚合函数都起了个名称，方面后期来获取这些数据</p><h4 id="3-2-3-分组查询"><a href="#3-2-3-分组查询" class="headerlink" title="3.2.3 分组查询"></a>3.2.3 分组查询</h4><blockquote><p>需求:分组查询，完成 group by的查询使用</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();        lqw.select("count(*) as count,tel");        lqw.groupBy("tel");        List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(lqw);        System.out.println(list);    }}</code></pre><ul><li><p>groupBy为分组，最终的sql语句为</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT count(*) as count,tel FROM user GROUP BY tel</code></pre></li></ul><p><strong>注意:</strong></p><ul><li>聚合与分组查询，无法使用lambda表达式来完成</li><li>MP只是对MyBatis的增强，如果MP实现不了，我们可以直接在DAO接口中使用MyBatis的方式实现</li></ul><h3 id="3-3-查询条件"><a href="#3-3-查询条件" class="headerlink" title="3.3 查询条件"></a>3.3 查询条件</h3><p>前面我们只使用了lt()和gt(),除了这两个方法外，MP还封装了很多条件对应的方法，这一节我们重点把MP提供的查询条件方法进行学习下。</p><p>MP的查询条件有很多:</p><ul><li>范围匹配（&gt; 、 = 、between）</li><li>模糊匹配（like）</li><li>空判定（null）</li><li>包含性匹配（in）</li><li>分组（group）</li><li>排序（order）</li><li>……</li></ul><h4 id="3-3-1-等值查询"><a href="#3-3-1-等值查询" class="headerlink" title="3.3.1 等值查询"></a>3.3.1 等值查询</h4><blockquote><p>需求:根据用户名和密码查询用户信息</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.eq(User::getName, "Jerry").eq(User::getPassword, "jerry");        User loginUser = userDao.selectOne(lqw);        System.out.println(loginUser);    }}</code></pre><ul><li><p>eq()： 相当于 <code>=</code>,对应的sql语句为</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?)</code></pre></li><li><p>selectList：查询结果为多个或者单个</p></li><li><p>selectOne:查询结果为单个</p></li></ul><h4 id="3-3-2-范围查询"><a href="#3-3-2-范围查询" class="headerlink" title="3.3.2 范围查询"></a>3.3.2 范围查询</h4><blockquote><p>需求:对年龄进行范围查询，使用lt()、le()、gt()、ge()、between()进行范围查询</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.between(User::getAge, 10, 30);        //SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li>gt():大于(&gt;)</li><li>ge():大于等于(&gt;=)</li><li>lt():小于(&lt;)</li><li>lte():小于等于(&lt;=)</li><li>between():between ? and ?</li></ul><h4 id="3-3-3-模糊查询"><a href="#3-3-3-模糊查询" class="headerlink" title="3.3.3 模糊查询"></a>3.3.3 模糊查询</h4><blockquote><p>需求:查询表中name属性的值以<code>J</code>开头的用户信息,使用like进行模糊查询</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();        lqw.likeLeft(User::getName, "J");        //SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?)        List&lt;User&gt; userList = userDao.selectList(lqw);        System.out.println(userList);    }}</code></pre><ul><li>like():前后加百分号,如 %J%</li><li>likeLeft():前面加百分号,如 %J</li><li>likeRight():后面加百分号,如 J%</li></ul><h4 id="3-3-4-排序查询"><a href="#3-3-4-排序查询" class="headerlink" title="3.3.4 排序查询"></a>3.3.4 排序查询</h4><blockquote><p>需求:查询所有数据，然后按照id降序</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        LambdaQueryWrapper&lt;User&gt; lwq = new LambdaQueryWrapper&lt;&gt;();        /**         * condition ：条件，返回boolean，         当condition为true，进行排序，如果为false，则不排序         * isAsc:是否为升序，true为升序，false为降序         * columns：需要操作的列         */        lwq.orderBy(true,false, User::getId);        userDao.selectList(lw    }}</code></pre><p>除了上面演示的这种实现方式，还有很多其他的排序方法可以被调用，如图:</p><p><img src="1631209838333.png" alt="1631209838333"></p><ul><li>orderBy排序<ul><li>condition:条件，true则添加排序，false则不添加排序</li><li>isAsc:是否为升序，true升序，false降序</li><li>columns:排序字段，可以有多个</li></ul></li><li>orderByAsc/Desc(单个column):按照指定字段进行升序/降序</li><li>orderByAsc/Desc(多个column):按照多个字段进行升序/降序</li><li>orderByAsc/Desc<ul><li>condition:条件，true添加排序，false不添加排序</li><li>多个columns：按照多个字段进行排序</li></ul></li></ul><p>除了上面介绍的这几种查询条件构建方法以外还会有很多其他的方法，比如isNull,isNotNull,in,notIn等等方法可供选择，具体参考官方文档的条件构造器来学习使用，具体的网址为:</p><p><code>https://mp.baomidou.com/guide/wrapper.html#abstractwrapper</code></p><h3 id="3-4-映射匹配兼容性"><a href="#3-4-映射匹配兼容性" class="headerlink" title="3.4 映射匹配兼容性"></a>3.4 映射匹配兼容性</h3><p>前面我们已经能从表中查询出数据，并将数据封装到模型类中，这整个过程涉及到一张表和一个模型类:</p><p><img src="1631030296965.png" alt="1631030296965"></p><p>之所以数据能够成功的从表中获取并封装到模型对象中，原因是表的字段列名和模型类的属性名一样。</p><p>那么问题就来了:</p><h4 id="问题1-表字段与编码属性设计不同步"><a href="#问题1-表字段与编码属性设计不同步" class="headerlink" title="问题1:表字段与编码属性设计不同步"></a>问题1:表字段与编码属性设计不同步</h4><p>当表的列名和模型类的属性名发生不一致，就会导致数据封装不到模型对象，这个时候就需要其中一方做出修改，那如果前提是两边都不能改又该如何解决?</p><p>MP给我们提供了一个注解<code>@TableField</code>,使用该注解可以实现模型类属性名和表的列名之间的映射关系</p><p><img src="1631030550100.png" alt="1631030550100"></p><h4 id="问题2-编码中添加了数据库中未定义的属性"><a href="#问题2-编码中添加了数据库中未定义的属性" class="headerlink" title="问题2:编码中添加了数据库中未定义的属性"></a>问题2:编码中添加了数据库中未定义的属性</h4><p>当模型类中多了一个数据库表不存在的字段，就会导致生成的sql语句中在select的时候查询了数据库不存在的字段，程序运行就会报错，错误信息为:</p><p>==Unknown column ‘多出来的字段名称’ in ‘field list’==</p><p>具体的解决方案用到的还是<code>@TableField</code>注解，它有一个属性叫<code>exist</code>，设置该字段是否在数据库表中存在，如果设置为false则不存在，生成sql语句查询的时候，就不会再查询该字段了。</p><p><img src="1631031054206.png" alt="1631031054206"></p><h4 id="问题3：采用默认查询开放了更多的字段查看权限"><a href="#问题3：采用默认查询开放了更多的字段查看权限" class="headerlink" title="问题3：采用默认查询开放了更多的字段查看权限"></a>问题3：采用默认查询开放了更多的字段查看权限</h4><p>查询表中所有的列的数据，就可能把一些敏感数据查询到返回给前端，这个时候我们就需要限制哪些字段默认不要进行查询。解决方案是<code>@TableField</code>注解的一个属性叫<code>select</code>，该属性设置默认是否需要查询该字段的值，true(默认值)表示默认查询该字段，false表示默认不查询该字段。</p><p><img src="1631031270558.png" alt="1631031270558"></p><h4 id="知识点1：-TableField"><a href="#知识点1：-TableField" class="headerlink" title="知识点1：@TableField"></a>知识点1：@TableField</h4><table><thead><tr><th>名称</th><th>@TableField</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类属性定义上方</td></tr><tr><td>作用</td><td>设置当前属性对应的数据库表中的字段关系</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表字段名称<br>exist:设置属性在数据库表字段中是否存在，默认为true，此属性不能与value合并使用<br>select:设置属性是否参与查询，此属性与select()映射配置不冲突</td></tr></tbody></table><h4 id="问题4-表名与编码开发设计不同步"><a href="#问题4-表名与编码开发设计不同步" class="headerlink" title="问题4:表名与编码开发设计不同步"></a>问题4:表名与编码开发设计不同步</h4><p>该问题主要是表的名称和模型类的名称不一致，导致查询失败，这个时候通常会报如下错误信息:</p><p>==Table ‘databaseName.tableNaem’ doesn’t exist==,翻译过来就是数据库中的表不存在。</p><p><img src="1631031828378.png" alt="1631031828378"></p><p>解决方案是使用MP提供的另外一个注解<code>@TableName</code>来设置表与模型类之间的对应关系。</p><p><img src="1631031915632.png" alt="1631031915632"></p><h4 id="知识点2：-TableName"><a href="#知识点2：-TableName" class="headerlink" title="知识点2：@TableName"></a>知识点2：@TableName</h4><table><thead><tr><th>名称</th><th>@TableName</th></tr></thead><tbody><tr><td>类型</td><td>==类注解==</td></tr><tr><td>位置</td><td>模型类定义上方</td></tr><tr><td>作用</td><td>设置当前类对应于数据库表关系</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表名称</td></tr></tbody></table><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>接下来我们使用案例的方式把刚才的知识演示下:</p><h5 id="步骤1-修改数据库表user为tbl-user"><a href="#步骤1-修改数据库表user为tbl-user" class="headerlink" title="步骤1:修改数据库表user为tbl_user"></a>步骤1:修改数据库表user为tbl_user</h5><p>直接查询会报错，原因是MP默认情况下会使用模型类的类名首字母小写当表名使用。</p><p><img src="1631032123894.png" alt="1631032123894"></p><h5 id="步骤2-模型类添加-TableName注解"><a href="#步骤2-模型类添加-TableName注解" class="headerlink" title="步骤2:模型类添加@TableName注解"></a>步骤2:模型类添加@TableName注解</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    private String password;    private Integer age;    private String tel;}</code></pre><h5 id="步骤3-将字段password修改成pwd"><a href="#步骤3-将字段password修改成pwd" class="headerlink" title="步骤3:将字段password修改成pwd"></a>步骤3:将字段password修改成pwd</h5><p>直接查询会报错，原因是MP默认情况下会使用模型类的属性名当做表的列名使用</p><p><img src="1631032283147.png" alt="1631032283147"></p><h5 id="步骤4：使用-TableField映射关系"><a href="#步骤4：使用-TableField映射关系" class="headerlink" title="步骤4：使用@TableField映射关系"></a>步骤4：使用@TableField映射关系</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    @TableField(value="pwd")    private String password;    private Integer age;    private String tel;}</code></pre><h5 id="步骤5-添加一个数据库表不存在的字段"><a href="#步骤5-添加一个数据库表不存在的字段" class="headerlink" title="步骤5:添加一个数据库表不存在的字段"></a>步骤5:添加一个数据库表不存在的字段</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    @TableField(value="pwd")    private String password;    private Integer age;    private String tel;    private Integer online;}</code></pre><p>直接查询会报错，原因是MP默认情况下会查询模型类的所有属性对应的数据库表的列，而online不存在</p><p><img src="1631032450558.png" alt="1631032450558"></p><h5 id="步骤6：使用-TableField排除字段"><a href="#步骤6：使用-TableField排除字段" class="headerlink" title="步骤6：使用@TableField排除字段"></a>步骤6：使用@TableField排除字段</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    @TableField(value="pwd")    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><h5 id="步骤7-查询时将pwd隐藏"><a href="#步骤7-查询时将pwd隐藏" class="headerlink" title="步骤7:查询时将pwd隐藏"></a>步骤7:查询时将pwd隐藏</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><h2 id="4，DML编程控制"><a href="#4，DML编程控制" class="headerlink" title="4，DML编程控制"></a>4，DML编程控制</h2><p>查询相关的操作我们已经介绍完了，紧接着我们需要对另外三个，增删改进行内容的讲解。挨个来说明下，首先是新增(insert)中的内容。</p><h3 id="4-1-id生成策略控制"><a href="#4-1-id生成策略控制" class="headerlink" title="4.1 id生成策略控制"></a>4.1 id生成策略控制</h3><p>前面我们在新增的时候留了一个问题，就是新增成功后，主键ID是一个很长串的内容，我们更想要的是按照数据库表字段进行自增长，在解决这个问题之前，我们先来分析下ID该如何选择:</p><ul><li>不同的表应用不同的id生成策略<ul><li>日志：自增（1,2,3,4，……）</li><li>购物订单：特殊规则（FQ23948AK3843）</li><li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li><li>关系表：可省略id</li><li>……</li></ul></li></ul><p>不同的业务采用的ID生成方式应该是不一样的，那么在MP中都提供了哪些主键生成策略，以及我们该如何进行选择?</p><p>在这里我们又需要用到MP的一个注解叫<code>@TableId</code></p><h4 id="知识点1：-TableId"><a href="#知识点1：-TableId" class="headerlink" title="知识点1：@TableId"></a>知识点1：@TableId</h4><table><thead><tr><th>名称</th><th>@TableId</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示主键的属性定义上方</td></tr><tr><td>作用</td><td>设置当前类中主键属性的生成策略</td></tr><tr><td>相关属性</td><td>value(默认)：设置数据库表主键名称<br>type:设置主键属性的生成策略，值查照IdType的枚举值</td></tr></tbody></table><h4 id="4-1-1-环境构建"><a href="#4-1-1-环境构建" class="headerlink" title="4.1.1 环境构建"></a>4.1.1 环境构建</h4><p>在构建条件查询之前，我们先来准备下环境</p><ul><li><p>创建一个SpringBoot项目</p></li><li><p>pom.xml中添加对应的依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.0&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;mybatisplus_03_dml&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>编写UserDao接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface UserDao extends BaseMapper&lt;User&gt; {}</code></pre></li><li><p>编写模型类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    private Long id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre></li><li><p>编写引导类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class Mybatisplus03DqlApplication {    public static void main(String[] args) {        SpringApplication.run(Mybatisplus03DqlApplication.class, args);    }}</code></pre></li><li><p>编写配置文件</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># dataSourcespring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC    username: root    password: root# mp日志mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></li><li><p>编写测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus02DqlApplicationTests {    @Autowired    private UserDao userDao;        @Test    void testGetAll(){        List&lt;User&gt; userList = userDao.selectList(null);        System.out.println(userList);    }}</code></pre></li><li><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testSave(){        User user = new User();        user.setName("黑马程序员");        user.setPassword("itheima");        user.setAge(12);        user.setTel("4006184000");        userDao.insert(user);    }    @Test    void testDelete(){        userDao.deleteById(1401856123925713409L)    }    @Test    void testUpdate(){        User user = new User();        user.setId(3L);        user.setName("Jock666");        user.setVersion(1);        userDao.updateById(user);    }}</code></pre></li><li><p>最终创建的项目结构为:</p><p><img src="1631033634879.png" alt="1631033634879"></p></li></ul><h4 id="4-1-2-代码演示"><a href="#4-1-2-代码演示" class="headerlink" title="4.1.2 代码演示"></a>4.1.2 代码演示</h4><h5 id="AUTO策略"><a href="#AUTO策略" class="headerlink" title="AUTO策略"></a>AUTO策略</h5><h6 id="步骤1-设置生成策略为AUTO"><a href="#步骤1-设置生成策略为AUTO" class="headerlink" title="步骤1:设置生成策略为AUTO"></a>步骤1:设置生成策略为AUTO</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    @TableId(type = IdType.AUTO)    private Long id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><h6 id="步骤2-删除测试数据并修改自增值"><a href="#步骤2-删除测试数据并修改自增值" class="headerlink" title="步骤2:删除测试数据并修改自增值"></a>步骤2:删除测试数据并修改自增值</h6><ul><li><p>删除测试数据</p><p><img src="1631211291677.png" alt="1631211291677"></p></li><li><p>因为之前生成主键ID的值比较长，会把MySQL的自动增长的值变的很大，所以需要将其调整为目前最新的id值。</p></li></ul><p><img src="1631211080703.png" alt="1631211080703"></p><h6 id="步骤3-运行新增方法"><a href="#步骤3-运行新增方法" class="headerlink" title="步骤3:运行新增方法"></a>步骤3:运行新增方法</h6><p>会发现，新增成功，并且主键id也是从5开始</p><p><img src="1631211383421.png" alt="1631211383421"></p><p>经过这三步的演示，会发现<code>AUTO</code>的作用是==使用数据库ID自增==，在使用该策略的时候一定要确保对应的数据库表设置了ID主键自增，否则无效。</p><p>接下来，我们可以进入源码查看下ID的生成策略有哪些?</p><p>打开源码后，你会发现并没有看到中文注释，这就需要我们点击右上角的<code>Download Sources</code>,会自动帮你把这个类的java文件下载下来，我们就能看到具体的注释内容。因为这个技术是国人制作的，所以他代码中的注释还是比较容易看懂的。</p><p><img src="1631211697712.png" alt="1631211697712"></p><p>当把源码下载完后，就可以看到如下内容:</p><p><img src="1631211902833.png" alt="1631211902833"></p><p>从源码中可以看到，除了AUTO这个策略以外，还有如下几种生成策略:</p><ul><li>NONE: 不设置id生成策略</li><li>INPUT:用户手工输入id</li><li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)</li><li>ASSIGN_UUID:以UUID生成算法作为id生成策略</li><li>其他的几个策略均已过时，都将被ASSIGN_ID和ASSIGN_UUID代替掉。</li></ul><p><strong>拓展:</strong></p><p>分布式ID是什么?</p><ul><li>当数据量足够大的时候，一台数据库服务器存储不下，这个时候就需要多台数据库服务器进行存储</li><li>比如订单表就有可能被存储在不同的服务器上</li><li>如果用数据库表的自增主键，因为在两台服务器上所以会出现冲突</li><li>这个时候就需要一个全局唯一ID,这个ID就是分布式ID。</li></ul><h5 id="INPUT策略"><a href="#INPUT策略" class="headerlink" title="INPUT策略"></a>INPUT策略</h5><h6 id="步骤1-设置生成策略为INPUT"><a href="#步骤1-设置生成策略为INPUT" class="headerlink" title="步骤1:设置生成策略为INPUT"></a>步骤1:设置生成策略为INPUT</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    @TableId(type = IdType.INPUT)    private Long id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><p>**注意:**这种ID生成策略，需要将表的自增策略删除掉</p><p><img src="1631212246124.png" alt="1631212246124"></p><h6 id="步骤2-添加数据手动设置ID"><a href="#步骤2-添加数据手动设置ID" class="headerlink" title="步骤2:添加数据手动设置ID"></a>步骤2:添加数据手动设置ID</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testSave(){        User user = new User();        //设置主键ID的值        user.setId(666L);        user.setName("黑马程序员");        user.setPassword("itheima");        user.setAge(12);        user.setTel("4006184000");        userDao.insert(user);    }}</code></pre><h6 id="步骤3-运行新增方法-1"><a href="#步骤3-运行新增方法-1" class="headerlink" title="步骤3:运行新增方法"></a>步骤3:运行新增方法</h6><p>如果没有设置主键ID的值，则会报错，错误提示就是主键ID没有给值:</p><p><img src="1631212469974.png" alt="1631212469974"></p><p>如果设置了主键ID,则数据添加成功，如下:</p><p><img src="1631212421137.png" alt="1631212421137"></p><h5 id="ASSIGN-ID策略"><a href="#ASSIGN-ID策略" class="headerlink" title="ASSIGN_ID策略"></a>ASSIGN_ID策略</h5><h6 id="步骤1-设置生成策略为ASSIGN-ID"><a href="#步骤1-设置生成策略为ASSIGN-ID" class="headerlink" title="步骤1:设置生成策略为ASSIGN_ID"></a>步骤1:设置生成策略为ASSIGN_ID</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    @TableId(type = IdType.ASSIGN_ID)    private Long id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><h6 id="步骤2-添加数据不设置ID"><a href="#步骤2-添加数据不设置ID" class="headerlink" title="步骤2:添加数据不设置ID"></a>步骤2:添加数据不设置ID</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testSave(){        User user = new User();        user.setName("黑马程序员");        user.setPassword("itheima");        user.setAge(12);        user.setTel("4006184000");        userDao.insert(user);    }}</code></pre><p>**注意:**这种生成策略，不需要手动设置ID，如果手动设置ID，则会使用自己设置的值。</p><h6 id="步骤3-运行新增方法-2"><a href="#步骤3-运行新增方法-2" class="headerlink" title="步骤3:运行新增方法"></a>步骤3:运行新增方法</h6><p><img src="1631242753467.png" alt="1631242753467"></p><p>生成的ID就是一个Long类型的数据。</p><h5 id="ASSIGN-UUID策略"><a href="#ASSIGN-UUID策略" class="headerlink" title="ASSIGN_UUID策略"></a>ASSIGN_UUID策略</h5><h6 id="步骤1-设置生成策略为ASSIGN-UUID"><a href="#步骤1-设置生成策略为ASSIGN-UUID" class="headerlink" title="步骤1:设置生成策略为ASSIGN_UUID"></a>步骤1:设置生成策略为ASSIGN_UUID</h6><p>使用uuid需要注意的是，主键的类型不能是Long，而应该改成String类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@TableName("tbl_user")public class User {    @TableId(type = IdType.ASSIGN_UUID)    private String id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;}</code></pre><h6 id="步骤2-修改表的主键类型"><a href="#步骤2-修改表的主键类型" class="headerlink" title="步骤2:修改表的主键类型"></a>步骤2:修改表的主键类型</h6><p><img src="1631243694870.png" alt="1631243694870"></p><p>主键类型设置为varchar，长度要大于32，因为UUID生成的主键为32位，如果长度小的话就会导致插入失败。</p><h6 id="步骤3-添加数据不设置ID"><a href="#步骤3-添加数据不设置ID" class="headerlink" title="步骤3:添加数据不设置ID"></a>步骤3:添加数据不设置ID</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testSave(){        User user = new User();        user.setName("黑马程序员");        user.setPassword("itheima");        user.setAge(12);        user.setTel("4006184000");        userDao.insert(user);    }}</code></pre><h6 id="步骤4-运行新增方法"><a href="#步骤4-运行新增方法" class="headerlink" title="步骤4:运行新增方法"></a>步骤4:运行新增方法</h6><p><img src="1631243810974.png" alt="1631243810974"></p><p>接下来我们来聊一聊雪花算法:</p><p>雪花算法(SnowFlake),是Twitter官方给出的算法实现 是用Scala写的。其生成的结果是一个64bit大小整数，它的结构如下图:</p><p><img src="1631243987800.png" alt="1631243987800"></p><ol><li>1bit,不用,因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。</li><li>41bit-时间戳，用来记录时间戳，毫秒级</li><li>10bit-工作机器id，用来记录工作机器id,其中高位5bit是数据中心ID其取值范围0-31，低位5bit是工作节点ID其取值范围0-31，两个组合起来最多可以容纳1024个节点</li><li>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID</li></ol><h4 id="4-1-3-ID生成策略对比"><a href="#4-1-3-ID生成策略对比" class="headerlink" title="4.1.3 ID生成策略对比"></a>4.1.3 ID生成策略对比</h4><p>介绍了这些主键ID的生成策略，我们以后该用哪个呢?</p><ul><li>NONE: 不设置id生成策略，MP不自动生成，约等于INPUT,所以这两种方式都需要用户手动设置，但是手动设置第一个问题是容易出现相同的ID造成主键冲突，为了保证主键不冲突就需要做很多判定，实现起来比较复杂</li><li>AUTO:数据库ID自增,这种策略适合在数据库服务器只有1台的情况下使用,不可作为分布式ID使用</li><li>ASSIGN_UUID:可以在分布式的情况下使用，而且能够保证唯一，但是生成的主键是32位的字符串，长度过长占用空间而且还不能排序，查询性能也慢</li><li>ASSIGN_ID:可以在分布式的情况下使用，生成的是Long类型的数字，可以排序性能也高，但是生成的策略和服务器时间有关，如果修改了系统时间就有可能导致出现重复主键</li><li>综上所述，每一种主键策略都有自己的优缺点，根据自己项目业务的实际情况来选择使用才是最明智的选择。</li></ul><h4 id="4-1-4-简化配置"><a href="#4-1-4-简化配置" class="headerlink" title="4.1.4 简化配置"></a>4.1.4 简化配置</h4><p>前面我们已经完成了表关系映射、数据库主键策略的设置，接下来对于这两个内容的使用，我们再讲下他们的简化配置:</p><h5 id="模型类主键策略设置"><a href="#模型类主键策略设置" class="headerlink" title="模型类主键策略设置"></a>模型类主键策略设置</h5><p>对于主键ID的策略已经介绍完，但是如果要在项目中的每一个模型类上都需要使用相同的生成策略，如:<img src="1631245676125.png" alt="1631245676125"></p><p>确实是稍微有点繁琐，我们能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?</p><p>答案是肯定有，我们只需要在配置文件中添加如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mybatis-plus:  global-config:    db-config:    id-type: assign_id</code></pre><p>配置完成后，每个模型类的主键ID策略都将成为assign_id.</p><h5 id="数据库表与模型类的映射关系"><a href="#数据库表与模型类的映射关系" class="headerlink" title="数据库表与模型类的映射关系"></a>数据库表与模型类的映射关系</h5><p>MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以<code>tbl_</code>开头，那么我们就需要将所有的模型类上添加<code>@TableName</code>，如:</p><p><img src="1631245757169.png" alt="1631245757169"></p><p>配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mybatis-plus:  global-config:    db-config:    table-prefix: tbl_</code></pre><p>设置表的前缀内容，这样MP就会拿 <code>tbl_</code>加上模型类的首字母小写，就刚好组装成数据库的表名。</p><h3 id="4-2-多数据操作"><a href="#4-2-多数据操作" class="headerlink" title="4.2 多数据操作"></a>4.2 多数据操作</h3><p>先来看下问题:</p><p><img src="1631246166514.png" alt="1631246166514"></p><p>之前添加了很多商品到购物车，过了几天发现这些东西又不想要了，该怎么办呢?</p><p>很简单删除掉，但是一个个删除的话还是比较慢和费事的，所以一般会给用户一个批量操作，也就是前面有一个复选框，用户一次可以勾选多个也可以进行全选，然后删一次就可以将购物车清空，这个就需要用到<code>批量删除</code>的操作了。</p><h4 id="4-2-1-多数据删除"><a href="#4-2-1-多数据删除" class="headerlink" title="4.2.1 多数据删除"></a>4.2.1 多数据删除</h4><p>具体该如何实现多条删除，我们找找对应的API方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></pre><p>翻译方法的字面意思为:删除（根据ID 批量删除）,参数是一个集合，可以存放多个id值。</p><blockquote><p>需求:根据传入的id集合将数据库表中的数据删除掉。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testDelete(){        //删除指定多条数据        List&lt;Long&gt; list = new ArrayList&lt;&gt;();        list.add(1402551342481838081L);        list.add(1402553134049501186L);        list.add(1402553619611430913L);        userDao.deleteBatchIds(list);    }}</code></pre><p>执行成功后，数据库表中的数据就会按照指定的id进行删除。</p><h4 id="4-2-2-多数据查询"><a href="#4-2-2-多数据查询" class="headerlink" title="4.2.2 多数据查询"></a>4.2.2 多数据查询</h4><p>除了按照id集合进行批量删除，也可以按照id集合进行批量查询，还是先来看下API</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></pre><p>方法名称翻译为:查询（根据ID 批量查询），参数是一个集合，可以存放多个id值。</p><blockquote><p>需求：根据传入的ID集合查询用户信息</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testGetByIds(){        //查询指定多条数据        List&lt;Long&gt; list = new ArrayList&lt;&gt;();        list.add(1L);        list.add(3L);        list.add(4L);        userDao.selectBatchIds(list);    }}</code></pre><p>查询结果就会按照指定传入的id值进行查询</p><p><img src="1631246688218.png" alt="1631246688218"></p><h3 id="4-3-逻辑删除"><a href="#4-3-逻辑删除" class="headerlink" title="4.3 逻辑删除"></a>4.3 逻辑删除</h3><p>接下来要讲解是删除中比较重要的一个操作，逻辑删除，先来分析下问题:</p><p><img src="1631246806130.png" alt="1631246806130"></p><ul><li><p>这是一个员工和其所签的合同表，关系是一个员工可以签多个合同，是一个一(员工)对多(合同)的表</p></li><li><p>员工ID为1的张业绩，总共签了三个合同，如果此时他离职了，我们需要将员工表中的数据进行删除，会执行delete操作</p></li><li><p>如果表在设计的时候有主外键关系，那么同时也得将合同表中的前三条数据也删除掉</p><p><img src="1631246997190.png" alt="1631246997190"></p></li><li><p>后期要统计所签合同的总金额，就会发现对不上，原因是已经将员工1签的合同信息删除掉了</p></li><li><p>如果只删除员工不删除合同表数据，那么合同的员工编号对应的员工信息不存在，那么就会出现垃圾数据，就会出现无主合同，根本不知道有张业绩这个人的存在</p></li><li><p>所以经过分析，我们不应该将表中的数据删除掉，而是需要进行保留，但是又得把离职的人和在职的人进行区分，这样就解决了上述问题，如:</p><p><img src="1631247188218.png" alt="1631247188218"></p></li><li><p>区分的方式，就是在员工表中添加一列数据<code>deleted</code>，如果为0说明在职员工，如果离职则将其改完1，（0和1所代表的含义是可以自定义的）</p></li></ul><p>所以对于删除操作业务问题来说有:</p><ul><li>物理删除:业务数据从数据库中丢弃，执行的是delete操作</li><li>逻辑删除:为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中，执行的是update操作</li></ul><p>MP中逻辑删除具体该如何实现?</p><h4 id="步骤1-修改数据库表添加deleted列"><a href="#步骤1-修改数据库表添加deleted列" class="headerlink" title="步骤1:修改数据库表添加deleted列"></a>步骤1:修改数据库表添加<code>deleted</code>列</h4><p>字段名可以任意，内容也可以自定义，比如<code>0</code>代表正常，<code>1</code>代表删除，可以在添加列的同时设置其默认值为<code>0</code>正常。</p><p><img src="1631247439168.png" alt="1631247439168"></p><h4 id="步骤2-实体类添加属性"><a href="#步骤2-实体类添加属性" class="headerlink" title="步骤2:实体类添加属性"></a>步骤2:实体类添加属性</h4><p>(1)添加与数据库表的列对应的一个属性名，名称可以任意，如果和数据表列名对不上，可以使用@TableField进行关系映射，如果一致，则会自动对应。</p><p>(2)标识新增的字段为逻辑删除字段，使用<code>@TableLogic</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data//@TableName("tbl_user") 可以不写是因为配置了全局配置public class User {    @TableId(type = IdType.ASSIGN_UUID)    private String id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;    @TableLogic(value="0",delval="1")    //value为正常数据的值，delval为删除数据的值    private Integer deleted;}</code></pre><p>也可直接在全局配置中添加，见下面 思考</p><h4 id="步骤3-运行删除方法"><a href="#步骤3-运行删除方法" class="headerlink" title="步骤3:运行删除方法"></a>步骤3:运行删除方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testDelete(){       userDao.deleteById(1L);    }}</code></pre><p><img src="1631247818327.png" alt="1631247818327"></p><p>从测试结果来看，逻辑删除最后走的是update操作，会将指定的字段修改成删除状态对应的值。</p><p><strong>思考</strong></p><p>逻辑删除，对查询有没有影响呢?</p><ul><li><p>执行查询操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testFind(){       System.out.println(userDao.selectList(null));    }}</code></pre><p>运行测试，会发现打印出来的sql语句中会多一个查询条件，如:</p><p><img src="1631248019999.png" alt="1631248019999"></p><p>可想而知，MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。</p></li><li><p>如果还是想把已经删除的数据都查询出来该如何实现呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapperpublic interface UserDao extends BaseMapper&lt;User&gt; {    //查询所有数据包含已经被删除的数据    @Select("select * from tbl_user")    public List&lt;User&gt; selectAll();}</code></pre></li><li><p>如果每个表都要有逻辑删除，那么就需要在每个模型类的属性上添加<code>@TableLogic</code>注解，如何优化?</p><p>在配置文件中添加全局配置，如下:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">mybatis-plus:  global-config:    db-config:      # 逻辑删除字段名      logic-delete-field: deleted      # 逻辑删除字面值：未删除为0      logic-not-delete-value: 0      # 逻辑删除字面值：删除为1      logic-delete-value: 1</code></pre></li></ul><p>介绍完逻辑删除，逻辑删除的本质为:</p><p><strong>逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。</strong></p><p>执行的SQL语句为:</p><p>UPDATE tbl_user SET ==deleted===1 where id = ? AND ==deleted===0</p><p>执行数据结果为:</p><p><img src="1631248494929.png" alt="1631248494929"></p><h4 id="知识点1：-TableLogic"><a href="#知识点1：-TableLogic" class="headerlink" title="知识点1：@TableLogic"></a>知识点1：@TableLogic</h4><table><thead><tr><th>名称</th><th>@TableLogic</th></tr></thead><tbody><tr><td>类型</td><td>==属性注解==</td></tr><tr><td>位置</td><td>模型类中用于表示删除字段的属性定义上方</td></tr><tr><td>作用</td><td>标识该字段为进行逻辑删除的字段</td></tr><tr><td>相关属性</td><td>value：逻辑未删除值<br>delval:逻辑删除值</td></tr></tbody></table><h3 id="4-4-乐观锁"><a href="#4-4-乐观锁" class="headerlink" title="4.4 乐观锁"></a>4.4 乐观锁</h3><h4 id="4-4-1-概念"><a href="#4-4-1-概念" class="headerlink" title="4.4.1 概念"></a>4.4.1 概念</h4><p>在讲解乐观锁之前，我们还是先来分析下问题:</p><p>业务并发现象带来的问题:==秒杀==</p><ul><li>假如有100个商品或者票在出售，为了能保证每个商品或者票只能被一个人购买，如何保证不会出现超买或者重复卖</li><li>对于这一类问题，其实有很多的解决方案可以使用</li><li>第一个最先想到的就是锁，锁在一台服务器中是可以解决的，但是如果在多台服务器下锁就没有办法控制，比如12306有两台服务器在进行卖票，在两台服务器上都添加锁的话，那也有可能会导致在同一时刻有两个线程在进行卖票，还是会出现并发问题</li><li>我们接下来介绍的这种方式是针对于小型企业的解决方案，因为数据库本身的性能就是个瓶颈，如果对其并发量超过2000以上的就需要考虑其他的解决方案了。</li></ul><p>简单来说，乐观锁主要解决的问题是当要更新一条记录的时候，希望这条记录没有被别人更新。</p><h4 id="4-4-2-实现思路"><a href="#4-4-2-实现思路" class="headerlink" title="4.4.2 实现思路"></a>4.4.2 实现思路</h4><p>乐观锁的实现方式:</p><blockquote><ul><li>数据库表中添加version列，比如默认值给1</li><li>第一个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第二个线程要修改数据之前，取出记录时，获取当前数据库中的version=1</li><li>第一个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1  [2]</li><li>oldVersion = version  [1]</li></ul></li><li>第二个线程执行更新时，set version = newVersion where version = oldVersion<ul><li>newVersion = version+1  [2]</li><li>oldVersion = version  [1]</li></ul></li><li>假如这两个线程都来更新数据，第一个和第二个线程都可能先执行<ul><li>假如第一个线程先执行更新，会把version改为2，</li><li>第二个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第二个线程会修改失败</li><li>假如第二个线程先执行更新，会把version改为2，</li><li>第一个线程再更新的时候，set version = 2 where version = 1,此时数据库表的数据version已经为2，所以第一个线程会修改失败</li><li>不管谁先执行都会确保只能有一个线程更新数据，这就是MP提供的乐观锁的实现原理分析。</li></ul></li></ul></blockquote><p>上面所说的步骤具体该如何实现呢?</p><h4 id="4-4-3-实现步骤"><a href="#4-4-3-实现步骤" class="headerlink" title="4.4.3 实现步骤"></a>4.4.3 实现步骤</h4><p>分析完步骤后，具体的实现步骤如下:</p><h5 id="步骤1-数据库表添加列"><a href="#步骤1-数据库表添加列" class="headerlink" title="步骤1:数据库表添加列"></a>步骤1:数据库表添加列</h5><p>列名可以任意，比如使用<code>version</code>,给列设置默认值为<code>1</code></p><p><img src="1631249913103.png" alt="1631249913103"></p><h5 id="步骤2-在模型类中添加对应的属性"><a href="#步骤2-在模型类中添加对应的属性" class="headerlink" title="步骤2:在模型类中添加对应的属性"></a>步骤2:在模型类中添加对应的属性</h5><p>根据添加的字段列名，在模型类中添加对应的属性值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data//@TableName("tbl_user") 可以不写是因为配置了全局配置public class User {    @TableId(type = IdType.ASSIGN_UUID)    private String id;    private String name;    @TableField(value="pwd",select=false)    private String password;    private Integer age;    private String tel;    @TableField(exist=false)    private Integer online;    private Integer deleted;    @Version    private Integer version;}</code></pre><h5 id="步骤3-添加乐观锁的拦截器"><a href="#步骤3-添加乐观锁的拦截器" class="headerlink" title="步骤3:添加乐观锁的拦截器"></a>步骤3:添加乐观锁的拦截器</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MpConfig {    @Bean    public MybatisPlusInterceptor mpInterceptor() {        //1.定义Mp拦截器        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();        //2.添加乐观锁拦截器        mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());        return mpInterceptor;    }}</code></pre><h5 id="步骤4-执行更新操作"><a href="#步骤4-执行更新操作" class="headerlink" title="步骤4:执行更新操作"></a>步骤4:执行更新操作</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testUpdate(){       User user = new User();        user.setId(3L);        user.setName("Jock666");        userDao.updateById(user);    }}</code></pre><p><img src="1631252305080.png" alt="1631252305080"></p><p>你会发现，这次修改并没有更新version字段，原因是没有携带version数据。</p><p>添加version数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testUpdate(){        User user = new User();        user.setId(3L);        user.setName("Jock666");        user.setVersion(1);        userDao.updateById(user);    }}</code></pre><p><img src="1631252393659.png" alt="1631252393659"></p><p>你会发现，我们传递的是1，MP会将1进行加1，然后，更新回到数据库表中。</p><p>所以要想实现乐观锁，首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中，所以我们在查询的时候，需要对其进行查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testUpdate(){        //1.先通过要修改的数据id将当前数据查询出来        User user = userDao.selectById(3L);        //2.将要修改的属性逐一设置进去        user.setName("Jock888");        userDao.updateById(user);    }}</code></pre><p><img src="1631252667865.png" alt="1631252667865"></p><p>大概分析完乐观锁的实现步骤以后，我们来模拟一种加锁的情况，看看能不能实现多个人修改同一个数据的时候，只能有一个人修改成功。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus03DqlApplicationTests {    @Autowired    private UserDao userDao;    @Test    void testUpdate(){       //1.先通过要修改的数据id将当前数据查询出来        User user = userDao.selectById(3L);     //version=3        User user2 = userDao.selectById(3L);    //version=3        user2.setName("Jock aaa");        userDao.updateById(user2);              //version=&gt;4        user.setName("Jock bbb");        userDao.updateById(user);               //verion=3?条件还成立吗？    }}</code></pre><p>运行程序，分析结果：</p><p><img src="1631253302587.png" alt="1631253302587"></p><p>乐观锁就已经实现完成了，如果对于上面的这些步骤记不住咋办呢?</p><p>参考官方文档来实现:</p><p><code>https://mp.baomidou.com/guide/interceptor-optimistic-locker.html#optimisticlockerinnerinterceptor</code></p><p><img src="1631253387845.png" alt="1631253387845"></p><h2 id="5，快速开发"><a href="#5，快速开发" class="headerlink" title="5，快速开发"></a>5，快速开发</h2><h3 id="5-1-代码生成器原理分析"><a href="#5-1-代码生成器原理分析" class="headerlink" title="5.1 代码生成器原理分析"></a>5.1 代码生成器原理分析</h3><p>造句:<img src="1631253928893.png" alt="1631253928893"></p><p>我们可以往空白内容进行填词造句，比如:<img src="1631253971409.png" alt="1631253971409"></p><p>在比如:<img src="1631253994782.png" alt="1631253994782"></p><p>观察我们之前写的代码，会发现其中也会有很多重复内容，比如:</p><p><img src="1631254075651.png" alt="1631254075651"></p><p>那我们就想，如果我想做一个Book模块的开发，是不是只需要将红色部分的内容全部更换成<code>Book</code>即可，如：</p><p><img src="1631254119948.png" alt="1631254119948"></p><p>所以我们会发现，做任何模块的开发，对于这段代码，基本上都是对红色部分的调整，所以我们把去掉红色内容的东西称之为==模板==，红色部分称之为==参数==，以后只需要传入不同的参数，就可以根据模板创建出不同模块的dao代码。</p><p>除了Dao可以抽取模块，其实我们常见的类都可以进行抽取，只要他们有公共部分即可。再来看下模型类的模板：</p><p><img src="1631254344180.png" alt="1631254344180"></p><ul><li>① 可以根据数据库表的表名来填充</li><li>② 可以根据用户的配置来生成ID生成策略</li><li>③到⑨可以根据数据库表字段名称来填充</li></ul><p>所以只要我们知道是对哪张表进行代码生成，这些内容我们都可以进行填充。</p><p>分析完后，我们会发现，要想完成代码自动生成，我们需要有以下内容:</p><ul><li>模板: MyBatisPlus提供，可以自己提供，但是麻烦，不建议</li><li>数据库相关配置:读取数据库获取表和字段信息</li><li>开发者自定义配置:手工配置，比如ID生成策略</li></ul><h3 id="5-2-代码生成器实现"><a href="#5-2-代码生成器实现" class="headerlink" title="5.2 代码生成器实现"></a>5.2 代码生成器实现</h3><h4 id="步骤1-创建一个Maven项目"><a href="#步骤1-创建一个Maven项目" class="headerlink" title="步骤1:创建一个Maven项目"></a>步骤1:创建一个Maven项目</h4><h4 id="代码2-导入对应的jar包"><a href="#代码2-导入对应的jar包" class="headerlink" title="代码2:导入对应的jar包"></a>代码2:导入对应的jar包</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.1&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;mybatisplus_04_generator&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--spring webmvc--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mybatisplus--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--druid--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--test--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--lombok--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--代码生成器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--velocity模板引擎--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;            &lt;version&gt;2.3&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="步骤3-编写引导类"><a href="#步骤3-编写引导类" class="headerlink" title="步骤3:编写引导类"></a>步骤3:编写引导类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class Mybatisplus04GeneratorApplication {    public static void main(String[] args) {        SpringApplication.run(Mybatisplus04GeneratorApplication.class, args);    }}</code></pre><h4 id="步骤4-创建代码生成类"><a href="#步骤4-创建代码生成类" class="headerlink" title="步骤4:创建代码生成类"></a>步骤4:创建代码生成类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CodeGenerator {    public static void main(String[] args) {        //1.获取代码生成器的对象        AutoGenerator autoGenerator = new AutoGenerator();        //设置数据库相关配置        DataSourceConfig dataSource = new DataSourceConfig();        dataSource.setDriverName("com.mysql.cj.jdbc.Driver");        dataSource.setUrl("jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC");        dataSource.setUsername("root");        dataSource.setPassword("root");        autoGenerator.setDataSource(dataSource);        //设置全局配置        GlobalConfig globalConfig = new GlobalConfig();        globalConfig.setOutputDir(System.getProperty("user.dir")+"/mybatisplus_04_generator/src/main/java");    //设置代码生成位置        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录        globalConfig.setAuthor("黑马程序员");    //设置作者        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件        globalConfig.setMapperName("%sDao");    //设置数据层接口名，%s为占位符，指代模块名称        globalConfig.setIdType(IdType.ASSIGN_ID);   //设置Id生成策略        autoGenerator.setGlobalConfig(globalConfig);        //设置包名相关配置        PackageConfig packageInfo = new PackageConfig();        packageInfo.setParent("com.aaa");   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径        packageInfo.setEntity("domain");    //设置实体类包名        packageInfo.setMapper("dao");   //设置数据层包名        autoGenerator.setPackageInfo(packageInfo);        //策略设置        StrategyConfig strategyConfig = new StrategyConfig();        strategyConfig.setInclude("tbl_user");  //设置当前参与生成的表名，参数为可变参数        strategyConfig.setTablePrefix("tbl_");  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格        strategyConfig.setVersionFieldName("version");  //设置乐观锁字段名        strategyConfig.setLogicDeleteFieldName("deleted");  //设置逻辑删除字段名        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok        autoGenerator.setStrategy(strategyConfig);        //2.执行生成操作        autoGenerator.execute();    }}</code></pre><p>对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改，</p><p><code>https://mp.baomidou.com/guide/generator.html</code></p><h4 id="步骤5-运行程序"><a href="#步骤5-运行程序" class="headerlink" title="步骤5:运行程序"></a>步骤5:运行程序</h4><p>运行成功后，会在当前项目中生成很多代码，代码包含<code>controller</code>,<code>service</code>，<code>mapper</code>和<code>entity</code></p><p><img src="1631255110375.png" alt="1631255110375"></p><p>至此代码生成器就已经完成工作，我们能快速根据数据库表来创建对应的类，简化我们的代码开发。</p><h3 id="5-3-MP中Service的CRUD"><a href="#5-3-MP中Service的CRUD" class="headerlink" title="5.3 MP中Service的CRUD"></a>5.3 MP中Service的CRUD</h3><p>回顾我们之前业务层代码的编写，编写接口和对应的实现类:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService{}@Servicepublic class UserServiceImpl implements UserService{}</code></pre><p>接口和实现类有了以后，需要在接口和实现类中声明方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService{public List&lt;User&gt; findAll();}@Servicepublic class UserServiceImpl implements UserService{    @Autowired    private UserDao userDao;    public List&lt;User&gt; findAll(){        return userDao.selectList(null);    }}</code></pre><p>MP看到上面的代码以后就说这些方法也是比较固定和通用的，那我来帮你抽取下，所以MP提供了一个Service接口和实现类，分别是:<code>IService</code>和<code>ServiceImpl</code>,后者是对前者的一个具体实现。</p><p>以后我们自己写的Service就可以进行如下修改:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService extends IService&lt;User&gt;{}@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserDao, User&gt; implements UserService{}</code></pre><p>修改以后的好处是，MP已经帮我们把业务层的一些基础的增删改查都已经实现了，可以直接进行使用。</p><p>编写测试类进行测试:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass Mybatisplus04GeneratorApplicationTests {    private IUserService userService;    @Test    void testFindAll() {        List&lt;User&gt; list = userService.list();        System.out.println(list);    }}</code></pre><p>**注意:**mybatisplus_04_generator项目中对于MyBatis的环境是没有进行配置，如果想要运行，需要提取将配置文件中的内容进行完善后在运行。</p><p>思考:在MP封装的Service层都有哪些方法可以用?</p><p>查看官方文档:<code>https://mp.baomidou.com/guide/crud-interface.html</code>,这些提供的方法大家可以参考官方文档进行学习使用，方法的名称可能有些变化，但是方法对应的参数和返回值基本类似。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/07/20/SpringMVC/"/>
      <url>/2023/07/20/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="三、SpringMVC"><a href="#三、SpringMVC" class="headerlink" title="三、SpringMVC"></a>三、SpringMVC</h1><h1 id="1、SpringMVC简介"><a href="#1、SpringMVC简介" class="headerlink" title="1、SpringMVC简介"></a>1、SpringMVC简介</h1><h3 id="1-1、什么是MVC"><a href="#1-1、什么是MVC" class="headerlink" title="1.1、什么是MVC"></a>1.1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><h2 id="1-2、什么是SpringMVC"><a href="#1-2、什么是SpringMVC" class="headerlink" title="1.2、什么是SpringMVC"></a>1.2、什么是SpringMVC</h2><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet</p></blockquote><h2 id="1-3、SpringMVC的特点"><a href="#1-3、SpringMVC的特点" class="headerlink" title="1.3、SpringMVC的特点"></a>1.3、SpringMVC的特点</h2><ul><li><p><strong>Spring</strong> <strong>家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</p></li><li><p><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</p></li><li><p>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></p></li><li><p><strong>代码清新简洁</strong>，大幅度提升开发效率</p></li><li><p>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</p></li><li><p><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</p></li></ul><h1 id="2、入门案例"><a href="#2、入门案例" class="headerlink" title="2、入门案例"></a>2、入门案例</h1><h2 id="2-1、开发环境"><a href="#2-1、开发环境" class="headerlink" title="2.1、开发环境"></a>2.1、开发环境</h2><p>IDE：idea 2019.2</p><p>构建工具：maven3.5.4</p><p>服务器：tomcat8.5</p><p>Spring版本：5.3.1</p><h2 id="2-2、创建maven工程"><a href="#2-2、创建maven工程" class="headerlink" title="2.2、创建maven工程"></a>2.2、创建maven工程</h2><h3 id="①添加web模块"><a href="#①添加web模块" class="headerlink" title="①添加web模块"></a>①添加web模块</h3><h3 id="②打包方式：war"><a href="#②打包方式：war" class="headerlink" title="②打包方式：war"></a>②打包方式：war</h3><h3 id="③引入依赖"><a href="#③引入依赖" class="headerlink" title="③引入依赖"></a>③引入依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- SpringMVC --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- ServletAPI --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- Spring5和Thymeleaf整合包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠</p><p>传递性导入。</p><p><img src="29.png" alt="29"></p><h2 id="2-3、配置web-xml"><a href="#2-3、配置web-xml" class="headerlink" title="2.3、配置web.xml"></a>2.3、配置web.xml</h2><p>注册SpringMVC的<strong>前端控制器DispatcherServlet</strong></p><h3 id="①默认配置方式"><a href="#①默认配置方式" class="headerlink" title="①默认配置方式"></a>①默认配置方式</h3><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为<servlet-name>-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</servlet-name></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;!--        设置springMVC的核心控制器所能处理的请求的请求路径        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径        但是/不能匹配.jsp请求路径的请求--&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h3 id="②扩展配置方式"><a href="#②扩展配置方式" class="headerlink" title="②扩展配置方式"></a>②扩展配置方式</h3><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt;    &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;    &lt;init-param&gt;        &lt;!-- contextConfigLocation为固定值 --&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;        &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--        作为框架的核心组件，在启动过程中有大量的初始化操作要做        而这些操作放在第一次请求时才执行会严重影响访问速度        因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;!--        设置springMVC的核心控制器所能处理的请求的请求路径        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径        但是/不能匹配.jsp请求路径的请求    --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><blockquote><p>注：</p><p><url-pattern>标签中使用/和/*的区别：</url-pattern></p><ul><li><p>/：匹配的请求可以是 /login 或 .html 或 .js 或 .css 方式的请求路径，但是<strong>不能匹配.jsp请求路径</strong>的请求。因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理（DispatcherServlet无法处理jsp，需要专门的JspServlet），从而找不到相应的页面</p></li><li><p>/*：匹配所有请求（包括.jsp），例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用<code>/*</code>的写法</p></li></ul></blockquote><h2 id="2-4、创建请求控制器"><a href="#2-4、创建请求控制器" class="headerlink" title="2.4、创建请求控制器"></a>2.4、创建请求控制器</h2><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class HelloController {}</code></pre><h2 id="2-5、创建SpringMVC的配置文件"><a href="#2-5、创建SpringMVC的配置文件" class="headerlink" title="2.5、创建SpringMVC的配置文件"></a>2.5、创建SpringMVC的配置文件</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package="com.atguigu.mvc.controller"/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;    &lt;property name="order" value="1"/&gt;    &lt;property name="characterEncoding" value="UTF-8"/&gt;    &lt;property name="templateEngine"&gt;        &lt;bean class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;            &lt;property name="templateResolver"&gt;                &lt;bean                      class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;                    &lt;!-- 视图前缀 --&gt;                    &lt;property name="prefix" value="/WEB-INF/templates/"/&gt;                    &lt;!-- 视图后缀 --&gt;                    &lt;property name="suffix" value=".html"/&gt;                    &lt;property name="templateMode" value="HTML5"/&gt;                    &lt;property name="characterEncoding" value="UTF-8" /&gt;                &lt;/bean&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!--    处理静态资源，例如html、js、css、jpg    若只设置该标签，则只能访问静态资源，其他请求则无法访问    此时必须设置&lt;mvc:annotation-driven/&gt;解决问题--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;!-- 处理响应中文内容乱码 --&gt;        &lt;bean              class="org.springframework.http.converter.StringHttpMessageConverter"&gt;            &lt;property name="defaultCharset" value="UTF-8" /&gt;            &lt;property name="supportedMediaTypes"&gt;                &lt;list&gt;                    &lt;value&gt;text/html&lt;/value&gt;                    &lt;value&gt;application/json&lt;/value&gt;                &lt;/list&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><h2 id="2-6、测试HelloWorld"><a href="#2-6、测试HelloWorld" class="headerlink" title="2.6、测试HelloWorld"></a>2.6、测试HelloWorld</h2><h3 id="①实现对首页的访问"><a href="#①实现对首页的访问" class="headerlink" title="①实现对首页的访问"></a>①实现对首页的访问</h3><p>在请求控制器中创建处理请求的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping("/")public String index() {    //设置视图名称    return "index";}</code></pre><h3 id="②通过超链接跳转到指定页面"><a href="#②通过超链接跳转到指定页面" class="headerlink" title="②通过超链接跳转到指定页面"></a>②通过超链接跳转到指定页面</h3><p>在主页index.html中设置超链接</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;首页&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;首页&lt;/h1&gt;        &lt;a th:href="@{/hello}"&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>在请求控制器中创建处理请求的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/hello")public String HelloWorld() {return "target";}</code></pre><h2 id="2-7、总结"><a href="#2-7、总结" class="headerlink" title="2.7、总结"></a>2.7、总结</h2><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。</p><p>前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。</p><p>处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p><h1 id="3、-RequestMapping注解"><a href="#3、-RequestMapping注解" class="headerlink" title="3、@RequestMapping注解"></a>3、@RequestMapping注解</h1><h2 id="3-1、-RequestMapping注解的功能"><a href="#3-1、-RequestMapping注解的功能" class="headerlink" title="3.1、@RequestMapping注解的功能"></a>3.1、@RequestMapping注解的功能</h2><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是<strong>将请求和处理请求的控制器方法关联起来</strong>，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h2 id="3-2、-RequestMapping注解的位置"><a href="#3-2、-RequestMapping注解的位置" class="headerlink" title="3.2、@RequestMapping注解的位置"></a>3.2、@RequestMapping注解的位置</h2><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller@RequestMapping("/test")public class RequestMappingController {    //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping    @RequestMapping("/testRequestMapping")    public String testRequestMapping(){        return "success";    }}</code></pre><h2 id="3-3、-RequestMapping注解的value属性"><a href="#3-3、-RequestMapping注解的value属性" class="headerlink" title="3.3、@RequestMapping注解的value属性"></a>3.3、@RequestMapping注解的value属性</h2><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的value属性是一个<strong>字符串类型的数组</strong>，即当前浏览器所发送请求的请求路径匹配value属性中的<strong>任何一个</strong>值，则当前请求就会被注解所标识的方法进行处理</p><p>@RequestMapping注解的==value属性<strong>必须设置</strong>==，至少通过请求地址匹配请求映射</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{/testRequestMapping}"&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href="@{/test}"&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(    value = {"/testRequestMapping", "/test"})public String testRequestMapping(){    return "success";}</code></pre><h2 id="3-4、-RequestMapping注解的method属性"><a href="#3-4、-RequestMapping注解的method属性" class="headerlink" title="3.4、@RequestMapping注解的method属性"></a>3.4、@RequestMapping注解的method属性</h2><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>@RequestMapping注解的method属性是一个<strong>RequestMethod类型的数组</strong>，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{/test}"&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action="@{/test}" method="post"&gt;&lt;input type="submit"&gt;&lt;/form&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(    value = {"/testRequestMapping", "/test"},    method = {RequestMethod.GET, RequestMethod.POST})public String testRequestMapping(){    return "success";}</code></pre><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h2 id="3-5、-RequestMapping注解的params属性（了解）"><a href="#3-5、-RequestMapping注解的params属性（了解）" class="headerlink" title="3.5、@RequestMapping注解的params属性（了解）"></a>3.5、@RequestMapping注解的params属性（了解）</h2><p>@RequestMapping注解的params属性通过请求的<strong>请求参数匹配请求映射</strong></p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{/test(username='admin',password=123456)"&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(    value = {"/testRequestMapping", "/test"}    ,method = {RequestMethod.GET, RequestMethod.POST}    ,params = {"username","password!=123456"})public String testRequestMapping(){    return "success";}</code></pre><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p></blockquote><h2 id="3-6、-RequestMapping注解的headers属性（了解）"><a href="#3-6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="3.6、@RequestMapping注解的headers属性（了解）"></a>3.6、@RequestMapping注解的headers属性（了解）</h2><p>@RequestMapping注解的headers属性通过请求的<strong>请求头信息匹配请求映射</strong></p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p><blockquote><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p></blockquote><h2 id="3-7、SpringMVC支持ant风格的路径"><a href="#3-7、SpringMVC支持ant风格的路径" class="headerlink" title="3.7、SpringMVC支持ant风格的路径"></a>3.7、SpringMVC支持ant风格的路径</h2><p>在@RequestMapping注解的value属性值中设置一些特殊字符：</p><p>？：表示任意的单个字符（不包括?）</p><p>*：表示任意的0个或多个字符（不包括?和/）</p><p>**：表示任意层数的任意目录</p><p>注意：在使用<code>**</code>时，只能使用/**/xxx的方式，<code>**</code>前后不能有任何的其他字符</p><h2 id="3-8、SpringMVC支持路径中的占位符（重点）"><a href="#3-8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="3.8、SpringMVC支持路径中的占位符（重点）"></a>3.8、SpringMVC支持路径中的占位符（重点）</h2><p>原始方式：/deleteUser?id=1</p><p>rest方式：/user/delete/1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据<strong>通过REST风格路径的方式传输</strong>到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{/testRest/1/admin}"&gt;测试路径中的占位符&lt;/a&gt;&lt;br&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testRest/{id}/{username}")public String testRest(@PathVariable("id") String id, @PathVariable("username")String username){    System.out.println("id:"+id+",username:"+username);    return "success";}//最终输出的内容为--&gt;id:1,username:admin</code></pre><h1 id="4、SpringMVC获取请求参数"><a href="#4、SpringMVC获取请求参数" class="headerlink" title="4、SpringMVC获取请求参数"></a>4、SpringMVC获取请求参数</h1><p>用来接收url地址传参或表单传参（实际开发中不常用）</p><p>/testParam?username=’admin’&amp;password=123456</p><h2 id="4-1、通过ServletAPI获取（不常用）"><a href="#4-1、通过ServletAPI获取（不常用）" class="headerlink" title="4.1、通过ServletAPI获取（不常用）"></a>4.1、通过ServletAPI获取（不常用）</h2><p>将<strong>HttpServletRequest作为控制器方法的形参</strong>，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testParam")public String testParam(HttpServletRequest request){    String username = request.getParameter("username");    String password = request.getParameter("password");    System.out.println("username:"+username+",password:"+password);    return "success";}</code></pre><h2 id="4-2、通过控制器方法的形参获取请求参数"><a href="#4-2、通过控制器方法的形参获取请求参数" class="headerlink" title="4.2、通过控制器方法的形参获取请求参数"></a>4.2、通过控制器方法的形参获取请求参数</h2><p>在控制器方法的<strong>形参位置，设置和请求参数同名的形参</strong>，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{/testParam(username='admin',password=123456)}"&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testParam")public String testParam(String username, String password){    System.out.println("username:"+username+",password:"+password);    return "success";}</code></pre><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h2 id="4-3、-RequestParam"><a href="#4-3、-RequestParam" class="headerlink" title="4.3、@RequestParam"></a>4.3、@RequestParam</h2><p>@RequestParam是将<strong>请求参数</strong>和控制器方法的形参创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><ul><li><p><strong>value</strong>：指定为形参赋值的请求参数的参数名</p></li><li><p><strong>required</strong>：设置是否必须传输此请求参数，默认值为true</p><ul><li>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；</li><li>若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</li></ul></li><li><p><strong>defaultValue</strong>：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/param")public String getParam(    @RequestParam(value = "userName", required = true, defaultValue = "hello") String username, String password){    System.out.println("username:"+username+",password:"+password);    return "success";}</code></pre><h2 id="4-4、-RequestHeader"><a href="#4-4、-RequestHeader" class="headerlink" title="4.4、@RequestHeader"></a>4.4、@RequestHeader</h2><p>@RequestHeader是将<strong>请求头信息</strong>和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h2 id="4-5、-CookieValue"><a href="#4-5、-CookieValue" class="headerlink" title="4.5、@CookieValue"></a>4.5、@CookieValue</h2><p>@CookieValue是将<strong>cookie数据</strong>和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/param")public String getParam(    @RequestHeader("referer") String referer,    @CookieValue("JSESSIONID") String jsessionId // 获取浏览器中存储的cookie){    System.out.println("jsessionId:"+jsessionId);    System.out.println("referer:"+referer);    return "success";}</code></pre><h2 id="4-6、通过POJO获取请求参数"><a href="#4-6、通过POJO获取请求参数" class="headerlink" title="4.6、通过POJO获取请求参数"></a>4.6、通过POJO获取请求参数</h2><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的<strong>请求参数的参数名和实体类中的属性名一致</strong>，那么请求参数就会为此属性赋值</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form th:action="@{/testpojo}" method="post"&gt;    用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;    性别：&lt;input type="radio" name="sex" value="男"&gt;男&lt;input type="radio"name="sex" value="女"&gt;女&lt;br&gt;    年龄：&lt;input type="text" name="age"&gt;&lt;br&gt;    邮箱：&lt;input type="text" name="email"&gt;&lt;br&gt;    &lt;input type="submit"&gt;&lt;/form&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testpojo")public String testPOJO(User user){    System.out.println(user);    return "success";}//最终结果--&gt;User{id=null, username='张三', password='123', sex='男', age=23, email='123@qq.com'}</code></pre><h2 id="4-7、解决获取请求参数的乱码问题"><a href="#4-7、解决获取请求参数的乱码问题" class="headerlink" title="4.7、解决获取请求参数的乱码问题"></a>4.7、解决获取请求参数的乱码问题</h2><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><blockquote><p>注：</p><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote><h1 id="5、域对象共享数据"><a href="#5、域对象共享数据" class="headerlink" title="5、域对象共享数据"></a>5、域对象共享数据</h1><h2 id="5-1、使用ServletAPI向request域对象共享数据（不常用）"><a href="#5-1、使用ServletAPI向request域对象共享数据（不常用）" class="headerlink" title="5.1、使用ServletAPI向request域对象共享数据（不常用）"></a>5.1、使用ServletAPI向request域对象共享数据（不常用）</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testServletAPI")public String testServletAPI(HttpServletRequest request){    request.setAttribute("testScope", "hello,servletAPI");    return "success";}</code></pre><h2 id="5-2、使用ModelAndView向request域对象共享数据"><a href="#5-2、使用ModelAndView向request域对象共享数据" class="headerlink" title="5.2、使用ModelAndView向request域对象共享数据"></a>5.2、使用ModelAndView向request域对象共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testModelAndView")public ModelAndView testModelAndView(){    /**     * ModelAndView有Model和View的功能     * Model主要用于向请求域共享数据     * View主要用于设置视图，实现页面跳转     */    ModelAndView mav = new ModelAndView();    //向请求域共享数据    mav.addObject("testScope", "hello,ModelAndView");    //设置视图，实现页面跳转    mav.setViewName("success");    return mav;}</code></pre><h2 id="5-3、使用Model向request域对象共享数据"><a href="#5-3、使用Model向request域对象共享数据" class="headerlink" title="5.3、使用Model向request域对象共享数据"></a>5.3、使用Model向request域对象共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testModel")public String testModel(Model model){    model.addAttribute("testScope", "hello,Model");    return "success";}</code></pre><h2 id="5-4、使用map向request域对象共享数据"><a href="#5-4、使用map向request域对象共享数据" class="headerlink" title="5.4、使用map向request域对象共享数据"></a>5.4、使用map向request域对象共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testMap")public String testMap(Map&lt;String, Object&gt; map){    map.put("testScope", "hello,Map");    return "success";}</code></pre><h2 id="5-5、使用ModelMap向request域对象共享数据"><a href="#5-5、使用ModelMap向request域对象共享数据" class="headerlink" title="5.5、使用ModelMap向request域对象共享数据"></a>5.5、使用ModelMap向request域对象共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testModelMap")public String testModelMap(ModelMap modelMap){    modelMap.addAttribute("testScope", "hello,ModelMap");    return "success";}</code></pre><h2 id="5-6、Model、ModelMap、Map的关系"><a href="#5-6、Model、ModelMap、Map的关系" class="headerlink" title="5.6、Model、ModelMap、Map的关系"></a>5.6、Model、ModelMap、Map的关系</h2><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Model{}public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {}public class ExtendedModelMap extends ModelMap implements Model {}public class BindingAwareModelMap extends ExtendedModelMap {}</code></pre><h2 id="5-7、向session域共享数据"><a href="#5-7、向session域共享数据" class="headerlink" title="5.7、向session域共享数据"></a>5.7、向session域共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testSession")public String testSession(HttpSession session){    session.setAttribute("testSessionScope", "hello,session");    return "success";}</code></pre><h2 id="5-8、向application域共享数据"><a href="#5-8、向application域共享数据" class="headerlink" title="5.8、向application域共享数据"></a>5.8、向application域共享数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testApplication")public String testApplication(HttpSession session){    ServletContext application = session.getServletContext();    application.setAttribute("testApplicationScope", "hello,application");    return "success";}</code></pre><h1 id="6、SpringMVC的视图"><a href="#6、SpringMVC的视图" class="headerlink" title="6、SpringMVC的视图"></a>6、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户。</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图。</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView。</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView。</p><h2 id="6-1、ThymeleafView"><a href="#6-1、ThymeleafView" class="headerlink" title="6.1、ThymeleafView"></a>6.1、ThymeleafView</h2><p>当控制器方法中所设置的视图名称<strong>没有任何前缀</strong>时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图。</p><p>后缀所得到的最终路径，会通过转发的方式实现跳转</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testHello")public String testHello(){return "hello";}</code></pre><p><img src="30.png" alt="30"></p><h2 id="6-2、转发视图"><a href="#6-2、转发视图" class="headerlink" title="6.2、转发视图"></a>6.2、转发视图</h2><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称<strong>以<code>"forward:"</code>为前缀</strong>时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:/“，”forward:/employee”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testForward")public String testForward(){return "forward:/testHello";}</code></pre><p><img src="31.png" alt="31"></p><blockquote><p>注：</p><p>此方法很少使用。因为ThymeleafView也是使用转发方式，且直接通过ThymeleafView解析器渲染，因此多使用ThymeleafView的方式</p></blockquote><h2 id="6-3、重定向视图"><a href="#6-3、重定向视图" class="headerlink" title="6.3、重定向视图"></a>6.3、重定向视图</h2><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称<strong>以<code>"redirect:"</code>为前缀</strong>时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:/“，”redirect:/employee”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testRedirect")public String testRedirect(){return "redirect:/testHello";}</code></pre><p><img src="32.png" alt="32"></p><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p></blockquote><h2 id="6-4、视图控制器view-controller"><a href="#6-4、视图控制器view-controller" class="headerlink" title="6.4、视图控制器view-controller"></a>6.4、视图控制器view-controller</h2><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    path：设置处理的请求地址    view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path="/testView" view-name="success"&gt;&lt;/mvc:view-controller&gt;</code></pre><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置<strong>开启mvc注解驱动的标签</strong>：<code>&lt;mvc:annotation-driven /&gt;</code></p></blockquote><h1 id="7、RESTful"><a href="#7、RESTful" class="headerlink" title="7、RESTful"></a>7、RESTful</h1><h2 id="7-1、RESTful简介"><a href="#7-1、RESTful简介" class="headerlink" title="7.1、RESTful简介"></a>7.1、RESTful简介</h2><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><h3 id="①资源"><a href="#①资源" class="headerlink" title="①资源"></a>①资源</h3><p>资源是一种看待服务器的方式，即<strong>将服务器看作是由很多离散的资源组成</strong>。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。<strong>一个资源可以由一个或多个URI来标识</strong>。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h3 id="②资源的表述"><a href="#②资源的表述" class="headerlink" title="②资源的表述"></a>②资源的表述</h3><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h3 id="③状态转移"><a href="#③状态转移" class="headerlink" title="③状态转移"></a>③状态转移</h3><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h2 id="7-2、RESTful的实现"><a href="#7-2、RESTful的实现" class="headerlink" title="7.2、RESTful的实现"></a>7.2、RESTful的实现</h2><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE用来删除资源。</p><p>REST 风格提倡 <strong>URL 地址使用统一的风格设计</strong>，从前到后各个单词使用斜杠分开，<strong>不使用问号键值对方式携带请求参数</strong>，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th><strong>操作</strong></th><th><strong>传统方式</strong></th><th><strong>REST风格</strong></th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><h2 id="7-3、HiddenHttpMethodFilter"><a href="#7-3、HiddenHttpMethodFilter" class="headerlink" title="7.3、HiddenHttpMethodFilter"></a>7.3、HiddenHttpMethodFilter</h2><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p><p>SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们<strong>将</strong> <strong>POST</strong> <strong>请求转换为</strong> <strong>DELETE</strong> <strong>或</strong> <strong>PUT</strong> <strong>请求</strong></p><p>==HiddenHttpMethodFilter 处理put和delete请求的条件：==</p><ul><li><p>当前请求的请求方式必须为post</p></li><li><p>当前请求必须传输请求参数_method</p></li></ul><p>在web.xml中注册HiddenHttpMethodFilter</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;filter&gt;    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数 <code>_method</code>的值，因此请求参数<code>_method</code>的值才是最终的请求方式</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form th:action="@{/user}" method="post"&gt;    // type为hidden name为_method    &lt;input type="hidden" name="_method" value="put"&gt;    &lt;input type="submit" value="修改用户信息"&gt;&lt;/form&gt;</code></pre><blockquote><p>注：</p><p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter。在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String paramValue = request.getParameter(this.methodParam);</code></pre></li></ul></blockquote><h1 id="8、RESTful案例"><a href="#8、RESTful案例" class="headerlink" title="8、RESTful案例"></a>8、RESTful案例</h1><h2 id="8-1、准备工作"><a href="#8-1、准备工作" class="headerlink" title="8.1、准备工作"></a>8.1、准备工作</h2><p>和传统 CRUD 一样，实现对员工信息的增删改查。</p><ul><li>搭建环境</li><li>准备实体类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.mvc.bean;public class Employee {    private Integer id;    private String lastName;    private String email;    //1 male, 0 female    private Integer gender;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getLastName() {        return lastName;    }    public void setLastName(String lastName) {        this.lastName = lastName;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    public Integer getGender() {        return gender;    }    public void setGender(Integer gender) {        this.gender = gender;    }    public Employee(Integer id, String lastName, String email, Integer gender) {        super();        this.id = id;        this.lastName = lastName;        this.email = email;        this.gender = gender;    }    public Employee() {    }}</code></pre><ul><li>准备dao模拟数据</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao {    private static Map&lt;Integer, Employee&gt; employees = null;    static{        employees = new HashMap&lt;Integer, Employee&gt;();        employees.put(1001, new Employee(1001, "E-AA", "aa@163.com", 1));        employees.put(1002, new Employee(1002, "E-BB", "bb@163.com", 1));        employees.put(1003, new Employee(1003, "E-CC", "cc@163.com", 0));        employees.put(1004, new Employee(1004, "E-DD", "dd@163.com", 0));        employees.put(1005, new Employee(1005, "E-EE", "ee@163.com", 1));    }    private static Integer initId = 1006;    public void save(Employee employee){        if(employee.getId() == null){            employee.setId(initId++);        }        employees.put(employee.getId(), employee);    }    public Collection&lt;Employee&gt; getAll(){        return employees.values();    }    public Employee get(Integer id){        return employees.get(id);    }    public void delete(Integer id){        employees.remove(id);    }}</code></pre><h2 id="8-2、功能清单"><a href="#8-2、功能清单" class="headerlink" title="8.2、功能清单"></a>8.2、功能清单</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>URL</strong> <strong>地址</strong></th><th><strong>请求方式</strong></th></tr></thead><tbody><tr><td>访问首页√</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>/employee</td><td>GET</td></tr><tr><td>删除√</td><td>/employee/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>/toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>/employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>/employee/2</td><td>GET</td></tr><tr><td>执行更新√</td><td>/employee</td><td>PUT</td></tr></tbody></table><h2 id="8-3、具体功能：访问首页"><a href="#8-3、具体功能：访问首页" class="headerlink" title="8.3、具体功能：访问首页"></a>8.3、具体功能：访问首页</h2><h3 id="①配置view-controller"><a href="#①配置view-controller" class="headerlink" title="①配置view-controller"></a>①配置view-controller</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mvc:view-controller path="/" view-name="index"/&gt;</code></pre><h3 id="②创建页面"><a href="#②创建页面" class="headerlink" title="②创建页面"></a>②创建页面</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8" &gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;首页&lt;/h1&gt;        &lt;a th:href="@{/employee}"&gt;访问员工信息&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="8-4、具体功能：查询所有员工数据"><a href="#8-4、具体功能：查询所有员工数据" class="headerlink" title="8.4、具体功能：查询所有员工数据"></a>8.4、具体功能：查询所有员工数据</h2><h3 id="①控制器方法"><a href="#①控制器方法" class="headerlink" title="①控制器方法"></a>①控制器方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value = "/employee", method = RequestMethod.GET)public String getEmployeeList(Model model){    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();    model.addAttribute("employeeList", employeeList);    return "employee_list";}</code></pre><h3 id="②创建employee-list-html"><a href="#②创建employee-list-html" class="headerlink" title="②创建employee_list.html"></a>②创建employee_list.html</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;Employee Info&lt;/title&gt;        &lt;script type="text/javascript" th:src="@{/static/js/vue.js}"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border="1" cellpadding="0" cellspacing="0" style="text-align:center;" id="dataTable"&gt;            &lt;tr&gt;                &lt;th colspan="5"&gt;Employee Info&lt;/th&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;lastName&lt;/th&gt;                &lt;th&gt;email&lt;/th&gt;                &lt;th&gt;gender&lt;/th&gt;                &lt;th&gt;options(&lt;a th:href="@{/toAdd}"&gt;add&lt;/a&gt;)&lt;/th&gt;            &lt;/tr&gt;            &lt;tr th:each="employee : ${employeeList}"&gt;                &lt;td th:text="${employee.id}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.lastName}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.email}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.gender}"&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a class="deleteA" @click="deleteEmployee"                       th:href="@{'/employee/'+${employee.id}}"&gt;delete&lt;/a&gt;                    &lt;a th:href="@{'/employee/'+${employee.id}}"&gt;update&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="8-5、具体功能：删除"><a href="#8-5、具体功能：删除" class="headerlink" title="8.5、具体功能：删除"></a>8.5、具体功能：删除</h2><h3 id="①创建处理delete请求方式的表单"><a href="#①创建处理delete请求方式的表单" class="headerlink" title="①创建处理delete请求方式的表单"></a>①创建处理delete请求方式的表单</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id="delete_form" method="post"&gt;    &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;    &lt;input type="hidden" name="_method" value="delete"/&gt;&lt;/form&gt;</code></pre><p>引入vue.js</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script type="text/javascript" th:src="@{/static/js/vue.js}"&gt;&lt;/script&gt;</code></pre><p>删除超链接</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a class="deleteA" @click="deleteEmployee"th:href="@{'/employee/'+${employee.id}}"&gt;delete&lt;/a&gt;</code></pre><p>通过vue处理点击事件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script type="text/javascript"&gt;    var vue = new Vue({        el:"#dataTable",        methods:{            //event表示当前事件            deleteEmployee:function (event) {                //通过id获取表单标签                var delete_form = document.getElementById("delete_form");                //将触发事件的超链接的href属性为表单的action属性赋值                delete_form.action = event.target.href;                //提交表单                delete_form.submit();                //阻止超链接的默认跳转行为                event.preventDefault();            }        }    });&lt;/script&gt;</code></pre><h3 id="②控制器方法"><a href="#②控制器方法" class="headerlink" title="②控制器方法"></a>②控制器方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable("id") Integer id){    employeeDao.delete(id);    return "redirect:/employee";}</code></pre><h2 id="8-6、具体功能：跳转到添加数据页面"><a href="#8-6、具体功能：跳转到添加数据页面" class="headerlink" title="8.6、具体功能：跳转到添加数据页面"></a>8.6、具体功能：跳转到添加数据页面</h2><h3 id="①配置view-controller-1"><a href="#①配置view-controller-1" class="headerlink" title="①配置view-controller"></a>①配置view-controller</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mvc:view-controller path="/toAdd" view-name="employee_add"&gt;&lt;/mvc:view-controller&gt;</code></pre><h3 id="②创建employee-add-html"><a href="#②创建employee-add-html" class="headerlink" title="②创建employee_add.html"></a>②创建employee_add.html</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;Add Employee&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form th:action="@{/employee}" method="post"&gt;            lastName:&lt;input type="text" name="lastName"&gt;&lt;br&gt;            email:&lt;input type="text" name="email"&gt;&lt;br&gt;            gender:&lt;input type="radio" name="gender" value="1"&gt;male            &lt;input type="radio" name="gender" value="0"&gt;female&lt;br&gt;            &lt;input type="submit" value="add"&gt;&lt;br&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="8-7、具体功能：执行保存"><a href="#8-7、具体功能：执行保存" class="headerlink" title="8.7、具体功能：执行保存"></a>8.7、具体功能：执行保存</h2><h3 id="①控制器方法-1"><a href="#①控制器方法-1" class="headerlink" title="①控制器方法"></a>①控制器方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value = "/employee", method = RequestMethod.POST)public String addEmployee(Employee employee){    employeeDao.save(employee);    return "redirect:/employee";}</code></pre><h2 id="8-8、具体功能：跳转到更新数据页面"><a href="#8-8、具体功能：跳转到更新数据页面" class="headerlink" title="8.8、具体功能：跳转到更新数据页面"></a>8.8、具体功能：跳转到更新数据页面</h2><h3 id="①修改超链接"><a href="#①修改超链接" class="headerlink" title="①修改超链接"></a>①修改超链接</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a th:href="@{'/employee/'+${employee.id}}"&gt;update&lt;/a&gt;</code></pre><h3 id="②控制器方法-1"><a href="#②控制器方法-1" class="headerlink" title="②控制器方法"></a>②控制器方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)public String getEmployeeById(@PathVariable("id") Integer id, Model model){    Employee employee = employeeDao.get(id);    model.addAttribute("employee", employee);    return "employee_update";}</code></pre><h3 id="③创建employee-update-html"><a href="#③创建employee-update-html" class="headerlink" title="③创建employee_update.html"></a>③创建employee_update.html</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;Update Employee&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form th:action="@{/employee}" method="post"&gt;            &lt;input type="hidden" name="_method" value="put"&gt;            &lt;input type="hidden" name="id" th:value="${employee.id}"&gt;            lastName:&lt;input type="text" name="lastName" th:value="${employee.lastName}"&gt;            &lt;br&gt;            email:&lt;input type="text" name="email" th:value="${employee.email}"&gt;&lt;br&gt;            &lt;!--                th:field="${employee.gender}"可用于单选框或复选框的回显                若单选框的value和employee.gender的值一致，则添加checked="checked"属性--&gt;            gender:&lt;input type="radio" name="gender" value="1"th:field="${employee.gender}"&gt;male            &lt;input type="radio" name="gender" value="0"th:field="${employee.gender}"&gt;female&lt;br&gt;            &lt;input type="submit" value="update"&gt;&lt;br&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="8-9、具体功能：执行更新"><a href="#8-9、具体功能：执行更新" class="headerlink" title="8.9、具体功能：执行更新"></a>8.9、具体功能：执行更新</h2><h3 id="①控制器方法-2"><a href="#①控制器方法-2" class="headerlink" title="①控制器方法"></a>①控制器方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value = "/employee", method = RequestMethod.PUT)public String updateEmployee(Employee employee){    employeeDao.save(employee);    return "redirect:/employee";}</code></pre><h1 id="9、SpringMVC处理ajax请求（常用）"><a href="#9、SpringMVC处理ajax请求（常用）" class="headerlink" title="9、SpringMVC处理ajax请求（常用）"></a>9、SpringMVC处理ajax请求（常用）</h1><p>ajax：在不刷新页面的情况下与服务器进行交互</p><h2 id="9-1、-RequestBody"><a href="#9-1、-RequestBody" class="headerlink" title="9.1、@RequestBody"></a>9.1、@RequestBody</h2><p><strong>@RequestBody：将请求体中的内容和控制器方法的形参进行绑定</strong></p><p>@RequestBody可以获取请求体信息，使用@RequestBody注解标识控制器方法的形参，当前请求的请求体就会为当前注解所标识的形参赋值</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--此时必须使用post请求方式，因为get请求没有请求体--&gt;&lt;form th:action="@{/test/RequestBody}" method="post"&gt;    用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;    &lt;input type="submit"&gt;&lt;/form&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/test/RequestBody")public String testRequestBody(@RequestBody String requestBody){    System.out.println("requestBody:"+requestBody);    return "success";}</code></pre><p>输出请求体信息：</p><pre class="line-numbers language-none"><code class="language-none">requestBody:username=admin&amp;password=123456</code></pre><h2 id="9-2、-RequestBody获取json格式的请求参数"><a href="#9-2、-RequestBody获取json格式的请求参数" class="headerlink" title="9.2、@RequestBody获取json格式的请求参数"></a>9.2、@RequestBody获取json格式的请求参数</h2><blockquote><p>在使用了axios发送ajax请求之后，浏览器发送到服务器的请求参数有两种格式：</p><p>1、name=value&amp;name=value…，此时的请求参数可以通过request.getParameter()获取，对应SpringMVC中，可以直接<strong>通过控制器方法的形参</strong>获取此类请求参数</p><p>2、{key:value,key:value,…}，此时无法通过request.getParameter()获取，之前我们使用操作json的相关jar包gson或jackson处理此类请求参数，可以将其转换为指定的实体类对象或map集合。在SpringMVC中，直接使用@RequestBody注解标识控制器方法的形参即可将此类请求参数转换为java对象</p></blockquote><p>==<strong>使用@RequestBody获取json格式的请求参数的条件：</strong>==</p><p>1、导入jackson的依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2、SpringMVC的配置文件中设置开启mvc的注解驱动</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt;</code></pre><p>3、在控制器方法的形参位置，设置json格式的请求参数要转换成的java类型（实体类或map）的参数，并使用@RequestBody注解标识</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type="button" value="测试@RequestBody获取json格式的请求参数"@click="testRequestBody()"&gt;&lt;br&gt;&lt;script type="text/javascript" th:src="@{/js/vue.js}"&gt;&lt;/script&gt;&lt;script type="text/javascript" th:src="@{/js/axios.min.js}"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    var vue = new Vue({        el:"#app",        methods:{            testRequestBody(){                axios.post(                    "/SpringMVC/test/RequestBody/json",                    {username:"admin",password:"123456"}                ).then(response=&gt;{                    console.log(response.data);                });            }        }    });&lt;/script&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">//将json格式的数据转换为map集合@RequestMapping("/test/RequestBody/json")public void testRequestBody(@RequestBody Map&lt;String, Object&gt; map,HttpServletResponse response) throws IOException {    System.out.println(map);    //{username=admin, password=123456}    response.getWriter().print("hello,axios");}//将json格式的数据转换为实体类对象@RequestMapping("/test/RequestBody/json")public void testRequestBody(@RequestBody User user, HttpServletResponse response) throws IOException {    System.out.println(user);    //User{id=null, username='admin', password='123456', age=null,gender='null'}response.getWriter().print("hello,axios");}</code></pre><h2 id="9-3、-ResponseBody"><a href="#9-3、-ResponseBody" class="headerlink" title="9.3、@ResponseBody"></a>9.3、@ResponseBody</h2><p>@ResponseBody用于标识一个控制器方法，可以<strong>将该方法的返回值直接作为响应报文的响应体</strong>响应到浏览器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testResponseBody")public String testResponseBody(){    //此时会跳转到逻辑视图success所对应的页面    return "success";}@RequestMapping("/testResponseBody")@ResponseBodypublic String testResponseBody(){    //此时响应浏览器数据success    return "success";}</code></pre><h2 id="9-4、-ResponseBody响应浏览器json数据"><a href="#9-4、-ResponseBody响应浏览器json数据" class="headerlink" title="9.4、@ResponseBody响应浏览器json数据"></a>9.4、@ResponseBody响应浏览器json数据</h2><p>服务器处理ajax请求之后，大多数情况都需要向浏览器<strong>响应一个java对象</strong>（规范），此时必须<strong>将java对象转换为json字符串</strong>才可以响应到浏览器，之前我们使用操作json数据的jar包gson或jackson将java对象转换为json字符串。</p><p>在SpringMVC中，我们可以直接使用@ResponseBody注解实现此功能</p><p>==<strong>@ResponseBody响应浏览器json数据的条件：</strong>==</p><p>1、导入jackson的依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2、SpringMVC的配置文件中设置开启mvc的注解驱动</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt;</code></pre><p>3、使用@ResponseBody注解标识控制器方法，在方法中，将需要转换为json字符串并响应到浏览器</p><p>的java对象作为控制器方法的返回值，此时SpringMVC就可以将此对象直接转换为json字符串并响应到浏览器</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type="button" value="测试@ResponseBody响应浏览器json格式的数据"@click="testResponseBody()"&gt;&lt;br&gt;&lt;script type="text/javascript" th:src="@{/js/vue.js}"&gt;&lt;/script&gt;&lt;script type="text/javascript" th:src="@{/js/axios.min.js}"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    var vue = new Vue({        el:"#app",        methods:{            testResponseBody(){                axios.post("/SpringMVC/test/ResponseBody/json").then(response=&gt;{                    console.log(response.data);                });            }        }    });&lt;/script&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">//响应浏览器list集合// list--&gt;json数组@RequestMapping("/test/ResponseBody/json")@ResponseBodypublic List&lt;User&gt; testResponseBody(){    User user1 = new User(1001,"admin1","123456",23,"男");    User user2 = new User(1002,"admin2","123456",23,"男");    User user3 = new User(1003,"admin3","123456",23,"男");    List&lt;User&gt; list = Arrays.asList(user1, user2, user3);    return list;}//响应浏览器map集合// map--&gt;json对象@RequestMapping("/test/ResponseBody/json")@ResponseBodypublic Map&lt;String, Object&gt; testResponseBody(){    User user1 = new User(1001,"admin1","123456",23,"男");    User user2 = new User(1002,"admin2","123456",23,"男");    User user3 = new User(1003,"admin3","123456",23,"男");    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put("1001", user1);    map.put("1002", user2);    map.put("1003", user3);    return map;}//响应浏览器实体类对象// 实体类--&gt;json对象@RequestMapping("/test/ResponseBody/json")@ResponseBodypublic User testResponseBody(){    User user = new User(1001,"admin1","123456",23,"男");    return user;}</code></pre><h2 id="9-5、-RestController注解"><a href="#9-5、-RestController注解" class="headerlink" title="9.5、@RestController注解"></a>9.5、@RestController注解</h2><pre class="line-numbers language-none"><code class="language-none">@RestController --&gt; @Controller + @ResponseBody</code></pre><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h1 id="10、文件上传和下载"><a href="#10、文件上传和下载" class="headerlink" title="10、文件上传和下载"></a>10、文件上传和下载</h1><h2 id="10-1、文件下载"><a href="#10-1、文件下载" class="headerlink" title="10.1、文件下载"></a>10.1、文件下载</h2><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是<strong>响应到浏览器的响应报文</strong>。</p><p>使用ResponseEntity实现下载文件的功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testDown")public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException {    //获取ServletContext对象    ServletContext servletContext = session.getServletContext();    //获取服务器中文件的真实路径    String realPath = servletContext.getRealPath("/static/img/1.jpg");    //创建输入流    InputStream is = new FileInputStream(realPath);    //创建字节数组    byte[] bytes = new byte[is.available()];    //将流读到字节数组中    is.read(bytes);    //创建HttpHeaders对象设置响应头信息    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();    //设置要下载方式以及下载文件的名字    headers.add("Content-Disposition", "attachment;filename=1.jpg");    //设置响应状态码    HttpStatus statusCode = HttpStatus.OK;    //创建ResponseEntity对象    ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers,statusCode);// 响应头、响应体、响应状态码    //关闭输入流    is.close();    return responseEntity;}</code></pre><h2 id="10-2、文件上传"><a href="#10-2、文件上传" class="headerlink" title="10.2、文件上传"></a>10.2、文件上传</h2><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form th:action="@{/test/up}" method="post" enctype="multipart/form-data"&gt;    头像：&lt;input type="file" name="photo"&gt;&lt;br&gt;    &lt;input type="submit" value="上传"&gt;&lt;/form&gt;</code></pre><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>上传步骤：</p><h3 id="①添加依赖："><a href="#①添加依赖：" class="headerlink" title="①添加依赖："></a>①添加依赖：</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="②在SpringMVC的配置文件中添加配置："><a href="#②在SpringMVC的配置文件中添加配置：" class="headerlink" title="②在SpringMVC的配置文件中添加配置："></a>②在SpringMVC的配置文件中添加配置：</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;</code></pre><h3 id="③控制器方法："><a href="#③控制器方法：" class="headerlink" title="③控制器方法："></a>③控制器方法：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/testUp")public String testUp(MultipartFile photo, HttpSession session) throws IOException {    //获取上传的文件的文件名    String fileName = photo.getOriginalFilename();    //处理文件重名问题    //获取上传文件的后缀名    String hzName = fileName.substring(fileName.lastIndexOf("."));    //获取UUID，拼接一个新的文件名    fileName = UUID.randomUUID().toString() + hzName;    //获取服务器中photo目录的路径    ServletContext servletContext = session.getServletContext();    String photoPath = servletContext.getRealPath("photo");    //创建photoPath对应的File对象，这里存上传的文件    File file = new File(photoPath);    //file路径不存在，则创建目录    if(!file.exists()){        file.mkdir();    }    String finalPath = photoPath + File.separator + fileName;    //实现上传功能    photo.transferTo(new File(finalPath));    return "success";}</code></pre><hr><p>上面都是重点内容</p><p>下面需要了解</p><h1 id="11、拦截器"><a href="#11、拦截器" class="headerlink" title="11、拦截器"></a>11、拦截器</h1><h2 id="11-1、拦截器的配置"><a href="#11-1、拦截器的配置" class="headerlink" title="11.1、拦截器的配置"></a>11.1、拦截器的配置</h2><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class FirstInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println("FirstInterceptor--&gt;preHandle");        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println("FirstInterceptor--&gt;postHandle");    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println("FirstInterceptor--&gt;afterCompletion");    }}</code></pre><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean class="com.atguigu.interceptor.FirstInterceptor"&gt;&lt;/bean&gt;&lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是默认对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt;    &lt;!-- 配置需要拦截的请求的请求路径 --&gt;    &lt;mvc:mapping path="/**"/&gt;    &lt;!-- 配置需要排除拦截的请求的请求路径 --&gt;    &lt;mvc:exclude-mapping path="/testRequestEntity"/&gt;    &lt;!-- 配置拦截器 --&gt;    &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!--    以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，    通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt;</code></pre><blockquote><p><code>/*</code> 表示的是所有的一层路径，若为/test1/test2则不会被拦截</p><p><code>/**</code>表示的是所有路径</p></blockquote><h2 id="11-2、拦截器的三个抽象方法"><a href="#11-2、拦截器的三个抽象方法" class="headerlink" title="11.2、拦截器的三个抽象方法"></a>11.2、拦截器的三个抽象方法</h2><p>SpringMVC中的拦截器有三个抽象方法：</p><ul><li>preHandle：<strong>控制器方法执行之前</strong>执行preHandle()，其boolean类型的返回值<strong>表示是否拦截或放行</strong>，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</li><li>postHandle：<strong>控制器方法执行之后</strong>执行postHandle()</li><li>afterCompletion：处理完视图和模型数据，<strong>渲染视图完毕之后</strong>执行afterCompletion()</li></ul><h2 id="11-3、多个拦截器的执行顺序"><a href="#11-3、多个拦截器的执行顺序" class="headerlink" title="11.3、多个拦截器的执行顺序"></a>11.3、多个拦截器的执行顺序</h2><ul><li><p>若每个拦截器的preHandle()都返回true</p><ul><li>此时多个拦截器的执行顺序<strong>和拦截器在SpringMVC的配置文件的配置顺序</strong>有关：</li><li>preHandle()会按照配置的顺序执行，而postHandle()和afterCompletion()会按照配置的反序执行</li></ul></li><li><p>若某个拦截器的preHandle()返回了false</p><ul><li>返回false的拦截器的preHandle()和它之前的拦截器的preHandle()都会执行</li><li>所有拦截器的postHandle()都不执行</li><li>返回false的拦截器之前的拦截器的afterCompletion()会执行</li></ul></li></ul><h1 id="12、异常处理器"><a href="#12、异常处理器" class="headerlink" title="12、异常处理器"></a>12、异常处理器</h1><p>异常处理器的功能：可以处理控制器方法执行过程中所出现的异常 ，并且给他设置一个新的 ModelAndView 来实现页面跳转并且共享数据</p><h2 id="12-1、基于配置的异常处理"><a href="#12-1、基于配置的异常处理" class="headerlink" title="12.1、基于配置的异常处理"></a>12.1、基于配置的异常处理</h2><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver 和 SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;    &lt;property name="exceptionMappings"&gt;        &lt;props&gt;            &lt;!--                prop的key表示处理器方法执行过程中出现的异常                prop的value表示若出现指定异常时要跳转到的页面对应的逻辑视图--&gt;            &lt;prop key="java.lang.ArithmeticException"&gt;error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;    &lt;!--exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享这样就可以在请求域中获取信息并展示在页面上--&gt;    &lt;property name="exceptionAttribute" value="ex"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="12-2、基于注解的异常处理"><a href="#12-2、基于注解的异常处理" class="headerlink" title="12.2、基于注解的异常处理"></a>12.2、基于注解的异常处理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController {    //@ExceptionHandler用于设置所标识方法处理的异常    @ExceptionHandler(ArithmeticException.class)    public String handleArithmeticException(Exception ex, Model model){        //ex表示当前请求处理中出现的异常信息        model.addAttribute("ex", ex);        return "error";    }}</code></pre><h1 id="13、注解配置SpringMVC"><a href="#13、注解配置SpringMVC" class="headerlink" title="13、注解配置SpringMVC"></a>13、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h2 id="13-1、创建初始化类，代替web-xml"><a href="#13-1、创建初始化类，代替web-xml" class="headerlink" title="13.1、创建初始化类，代替web.xml"></a>13.1、创建初始化类，代替web.xml</h2><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 </p><p>Spring提供了这个接口的实现，名为 SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {    /**     * 指定spring的配置类     * @return */    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{SpringConfig.class};    }    /**     * 指定SpringMVC的配置类     * @return     */    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{WebConfig.class};    }    /**     * 指定DispatcherServlet的映射规则，即url-pattern     * @return     */    @Override    protected String[] getServletMappings() {        return new String[]{"/"};    }    /**     * 添加过滤器     * @return     */    @Override    protected Filter[] getServletFilters() {        //创建编码过滤器        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();        encodingFilter.setEncoding("UTF-8");        encodingFilter.setForceRequestEncoding(true);        //创建处理请求方式过滤器        HiddenHttpMethodFilter hiddenHttpMethodFilter = newHiddenHttpMethodFilter();        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};    }}</code></pre><h2 id="13-2、创建SpringConfig配置类，代替spring的配置文件"><a href="#13-2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="13.2、创建SpringConfig配置类，代替spring的配置文件"></a>13.2、创建SpringConfig配置类，代替spring的配置文件</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SpringConfig {    //ssm整合之后，spring的配置信息写在此类中}</code></pre><h2 id="13-3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#13-3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="13.3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>13.3、创建WebConfig配置类，代替SpringMVC的配置文件</h2><p>扫描组件、视图解析器、默认的servlet、mvc的注解驱动、视图控制器、文件上传解析器、拦截器、异常解析器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration//1.扫描组件@ComponentScan("com.atguigu.mvc.controller")//2.开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer {    //3.使用默认的servlet处理静态资源    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable();    }    //4.配置文件上传解析器    @Bean    //@Bean注解可以将标识的方法的返回值作为bean进行管理，bean的id为方法的方法名    public CommonsMultipartResolver multipartResolver(){        return new CommonsMultipartResolver();    }    //5.配置拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) {        FirstInterceptor firstInterceptor = new FirstInterceptor();        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");    }    //6.配置视图控制器    @Overridepublic void addViewControllers(ViewControllerRegistry registry) {registry.addViewController("/").setViewName("index");}    //7.配置异常映射    @Overridepublic void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) {SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();Properties prop = new Properties();prop.setProperty("java.lang.ArithmeticException", "error");//设置异常映射exceptionResolver.setExceptionMappings(prop);//设置共享异常信息的键exceptionResolver.setExceptionAttribute("ex");resolvers.add(exceptionResolver);}    //8.配置生成模板解析器    @Bean    public ITemplateResolver templateResolver() {        WebApplicationContext webApplicationContext =ContextLoader.getCurrentWebApplicationContext();        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(webApplicationContext.getServletContext());        templateResolver.setPrefix("/WEB-INF/templates/");        templateResolver.setSuffix(".html");        templateResolver.setCharacterEncoding("UTF-8");        templateResolver.setTemplateMode(TemplateMode.HTML);        return templateResolver;    }    //9.生成模板引擎并为模板引擎注入模板解析器    @Bean    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver);        return templateEngine;    }    //10.生成视图解析器并为解析器注入模板引擎    @Bean    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();        viewResolver.setCharacterEncoding("UTF-8");        viewResolver.setTemplateEngine(templateEngine);        return viewResolver;    }}</code></pre><h2 id="13-4、测试功能"><a href="#13-4、测试功能" class="headerlink" title="13.4、测试功能"></a>13.4、测试功能</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping("/")public String index(){return "index";}</code></pre><h1 id="14、SpringMVC执行流程"><a href="#14、SpringMVC执行流程" class="headerlink" title="14、SpringMVC执行流程"></a>14、SpringMVC执行流程</h1><h2 id="14-1、SpringMVC常用组件"><a href="#14-1、SpringMVC常用组件" class="headerlink" title="14.1、SpringMVC常用组件"></a>14.1、SpringMVC常用组件</h2><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：==统一处理请求和响应，整个流程控制的中心==，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>​作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>​作用：将模型数据通过页面展示给用户</p><h2 id="14-2、DispatcherServlet初始化过程"><a href="#14-2、DispatcherServlet初始化过程" class="headerlink" title="14.2、DispatcherServlet初始化过程"></a>14.2、DispatcherServlet初始化过程</h2><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet生命周期来进行调度。</p><p><img src="33.png" alt="33"></p><h3 id="①初始化WebApplicationContext"><a href="#①初始化WebApplicationContext" class="headerlink" title="①初始化WebApplicationContext"></a>①初始化WebApplicationContext</h3><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected WebApplicationContext initWebApplicationContext() {    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());    WebApplicationContext wac = null;    if (this.webApplicationContext != null) {        // A context instance was injected at construction time -&gt; use it        wac = this.webApplicationContext;        if (wac instanceof ConfigurableWebApplicationContext) {            ConfigurableWebApplicationContext cwac =(ConfigurableWebApplicationContext) wac;            if (!cwac.isActive()) {                // The context has not yet been refreshed -&gt; provide services such as                    // setting the parent context, setting the application context id, etc                    if (cwac.getParent() == null) {                        // The context instance was injected without an explicit parent -&gt; set                            // the root application context (if any; may be null) as the parent                            cwac.setParent(rootContext);                    }                configureAndRefreshWebApplicationContext(cwac);            }        }    }    if (wac == null) {        // No context instance was injected at construction time -&gt; see if one        // has been registered in the servlet context. If one exists, it is assumed            // that the parent context (if any) has already been set and that the            // user has performed any initialization such as setting the context id            wac = findWebApplicationContext();    }    if (wac == null) {        // No context instance is defined for this servlet -&gt; create a local one        // 创建WebApplicationContext        wac = createWebApplicationContext(rootContext);    }    if (!this.refreshEventReceived) {        // Either the context is not a ConfigurableApplicationContext with refresh            // support or the context injected at construction time had already been            // refreshed -&gt; trigger initial onRefresh manually here.            synchronized (this.onRefreshMonitor) {            // 刷新WebApplicationContext            onRefresh(wac);        }    }    if (this.publishContext) {        // Publish the context as a servlet context attribute.        // 将IOC容器在应用域共享        String attrName = getServletContextAttributeName();        getServletContext().setAttribute(attrName, wac);    }    return wac;}</code></pre><h3 id="②创建WebApplicationContext"><a href="#②创建WebApplicationContext" class="headerlink" title="②创建WebApplicationContext"></a>②创建WebApplicationContext</h3><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {    Class&lt;?&gt; contextClass = getContextClass();    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass))    {        throw new ApplicationContextException("Fatal initialization error in servlet with name '" +getServletName() +                                              "': custom WebApplicationContext class [" + contextClass.getName() +                                              "] is not of type ConfigurableWebApplicationContext");    }    // 通过反射创建 IOC 容器对象    ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);    wac.setEnvironment(getEnvironment());    // 设置父容器    wac.setParent(parent);    String configLocation = getContextConfigLocation();    if (configLocation != null) {        wac.setConfigLocation(configLocation);    }    configureAndRefreshWebApplicationContext(wac);    return wac;}</code></pre><h3 id="③DispatcherServlet初始化策略"><a href="#③DispatcherServlet初始化策略" class="headerlink" title="③DispatcherServlet初始化策略"></a>③DispatcherServlet初始化策略</h3><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在</p><p>DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化</p><p>DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void initStrategies(ApplicationContext context) {    initMultipartResolver(context);    initLocaleResolver(context);    initThemeResolver(context);    initHandlerMappings(context);    initHandlerAdapters(context);    initHandlerExceptionResolvers(context);    initRequestToViewNameTranslator(context);    initViewResolvers(context);    initFlashMapManager(context);}</code></pre><h2 id="14-3、DispatcherServlet调用组件处理请求"><a href="#14-3、DispatcherServlet调用组件处理请求" class="headerlink" title="14.3、DispatcherServlet调用组件处理请求"></a>14.3、DispatcherServlet调用组件处理请求</h2><h3 id="①processRequest"><a href="#①processRequest" class="headerlink" title="①processRequest()"></a>①processRequest()</h3><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了</p><p>processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected final void processRequest(HttpServletRequest request,HttpServletResponse response)throws ServletException, IOException{    long startTime = System.currentTimeMillis();    Throwable failureCause = null;    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();    LocaleContext localeContext = buildLocaleContext(request);    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();    ServletRequestAttributes requestAttributes = buildRequestAttributes(request,response, previousAttributes);    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(),new RequestBindingInterceptor());    initContextHolders(request, localeContext, requestAttributes);    try {        // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写        doService(request, response);    }    catch (ServletException | IOException ex) {        failureCause = ex;        throw ex;    }    catch (Throwable ex) {        failureCause = ex;        throw new NestedServletException("Request processing failed", ex);    }    finally {        resetContextHolders(request, previousLocaleContext, previousAttributes);        if (requestAttributes != null) {            requestAttributes.requestCompleted();        }        logResult(request, response, failureCause, asyncManager);        publishRequestHandledEvent(request, response, startTime, failureCause);    }}</code></pre><h3 id="②doService"><a href="#②doService" class="headerlink" title="②doService()"></a>②doService()</h3><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {logRequest(request);    // Keep a snapshot of the request attributes in case of an include,    // to be able to restore the original attributes after the include.    Map&lt;String, Object&gt; attributesSnapshot = null;    if (WebUtils.isIncludeRequest(request)) {        attributesSnapshot = new HashMap&lt;&gt;();        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();        while (attrNames.hasMoreElements()) {            String attrName = (String) attrNames.nextElement();            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {                attributesSnapshot.put(attrName,request.getAttribute(attrName));            }        }    }    // Make framework objects available to handlers and view objects.    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE,getWebApplicationContext());    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());    if (this.flashMapManager != null) {        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request,response);        if (inputFlashMap != null) {            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE,Collections.unmodifiableMap(inputFlashMap));        }        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);    }    RequestPath requestPath = null;    if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) {        requestPath = ServletRequestPathUtils.parseAndCache(request);    }    try {        // 处理请求和响应        doDispatch(request, response);    }    finally {        if            (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {            // Restore the original attribute snapshot, in case of an include.            if (attributesSnapshot != null) {                restoreAttributesAfterInclude(request, attributesSnapshot);            }        }        if (requestPath != null) {            ServletRequestPathUtils.clearParsedRequestPath(request);        }    }}</code></pre><h3 id="③doDispatch"><a href="#③doDispatch" class="headerlink" title="③doDispatch()"></a>③doDispatch()</h3><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try {        ModelAndView mv = null;        Exception dispatchException = null;        try {            processedRequest = checkMultipart(request);            multipartRequestParsed = (processedRequest != request);            // Determine handler for the current request.            /*                mappedHandler：调用链                包含handler、interceptorList、interceptorIndex                handler：浏览器发送的请求所匹配的控制器方法                interceptorList：处理控制器方法的所有拦截器集合                interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行             */            mappedHandler = getHandler(processedRequest);            if (mappedHandler == null) {                noHandlerFound(processedRequest, response);                return;            }            // Determine handler adapter for the current request.            // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());            // Process last-modified header, if supported by the handler.            String method = request.getMethod();            boolean isGet = "GET".equals(method);            if (isGet || "HEAD".equals(method)) {                long lastModified = ha.getLastModified(request,mappedHandler.getHandler());                if (new ServletWebRequest(request,response).checkNotModified(lastModified) &amp;&amp; isGet) {                    return;                }            }            // 调用拦截器的preHandle()            if (!mappedHandler.applyPreHandle(processedRequest, response)) {                return;            }            // Actually invoke the handler.            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象            mv = ha.handle(processedRequest, response,mappedHandler.getHandler());            if (asyncManager.isConcurrentHandlingStarted()) {                return;            }            applyDefaultViewName(processedRequest, mv);            // 调用拦截器的postHandle()            mappedHandler.applyPostHandle(processedRequest, response, mv);        }        catch (Exception ex) {            dispatchException = ex;        }        catch (Throwable err) {            // As of 4.3, we're processing Errors thrown from handler methods as well,            // making them available for @ExceptionHandler methods and otherscenarios.            dispatchException = new NestedServletException("Handler dispatchfailed", err);         }         // 后续处理：处理模型数据和渲染视图          processDispatchResult(processedRequest, response, mappedHandler, mv,dispatchException);    }    catch (Exception ex) {        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);    }    catch (Throwable err) {        triggerAfterCompletion(processedRequest, response, mappedHandler,new NestedServletException("Handler processingfailed",                                                                                                    err));    }    finally {        if (asyncManager.isConcurrentHandlingStarted()) {            // Instead of postHandle and afterCompletion            if (mappedHandler != null) {                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);             }         }        else {            // Clean up any resources used by a multipart request.            if (multipartRequestParsed) {                cleanupMultipart(processedRequest);            }        }    }}                                                          </code></pre><h3 id="④processDispatchResult"><a href="#④processDispatchResult" class="headerlink" title="④processDispatchResult()"></a>④processDispatchResult()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void processDispatchResult(HttpServletRequest request,HttpServletResponse response,@Nullable HandlerExecutionChain                                   mappedHandler, @Nullable ModelAndView mv,@Nullable Exception exception) throws Exception {    boolean errorView = false;    if (exception != null) {        if (exception instanceof ModelAndViewDefiningException) {            logger.debug("ModelAndViewDefiningException encountered",exception);            mv = ((ModelAndViewDefiningException) exception).getModelAndView();        }        else {            Object handler = (mappedHandler != null ? mappedHandler.getHandler(): null);            mv = processHandlerException(request, response, handler, exception);            errorView = (mv != null);        }    }    // Did the handler return a view to render?    if (mv != null &amp;&amp; !mv.wasCleared()) {        // 处理模型数据和渲染视图        render(mv, request, response);        if (errorView) {            WebUtils.clearErrorRequestAttributes(request);        }    }    else {        if (logger.isTraceEnabled()) {            logger.trace("No view rendering, null ModelAndView returned.");        }    }    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {        // Concurrent handling started during a forward        return;    }    if (mappedHandler != null) {        // Exception (if any) is already handled..        // 调用拦截器的afterCompletion()        mappedHandler.triggerAfterCompletion(request, response, null);    }}                                   </code></pre><h2 id="14-4、SpringMVC的执行流程"><a href="#14-4、SpringMVC的执行流程" class="headerlink" title="14.4、SpringMVC的执行流程"></a>14.4、SpringMVC的执行流程</h2><p>1)用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p><p>2)<strong>DispatcherServlet对请求URL（资源在网络上的路径）进行解析，得到请求资源标识符URI</strong>（资源在服务器上的路径），判断请求URI对应的映射：</p><p>​a) 不存在</p><p>​i. 再判断是否配置了mvc:default-servlet-handler</p><p>​ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p><img src="34.png" alt="34"></p><p><img src="35.png" alt="35"></p><p>​iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p><img src="36.png" alt="36"></p><p><img src="37.png" alt="37"></p><p>​b) 存在则执行下面的流程</p><p>3)根据该URI，<strong>调用HandlerMapping</strong>获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后HandlerExecutionChain执行链对象的形式返回。</p><p>4)DispatcherServlet 根据获得的Handler，<strong>选择一个合适的HandlerAdapter</strong>。</p><p>5)如果成功获得HandlerAdapter，此时将开始<strong>执行拦截器</strong>的preHandler(…)方法【正向】</p><p>6)提取Request中的模型数据，填充Handler入参，开始<strong>执行Handler（Controller)方法</strong>，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><ul><li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li><li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li></ul><p>7)Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p><p>8)此时将开始<strong>执行拦截器</strong>的postHandle(…)方法【逆向】。</p><p>9)根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来<strong>渲染视图</strong>。</p><p>10)渲染视图完毕<strong>执行拦截器</strong>的afterCompletion(…)方法【逆向】。</p><p>11)将渲染结果返回给客户端。</p><h1 id="四、SSM整合"><a href="#四、SSM整合" class="headerlink" title="四、SSM整合"></a>四、SSM整合</h1><p>个人总结：web的三大组件：servlet、filter、listener。</p><p>spring和springmvc要整合，spring有一个ioc，springmvc有一个ioc，springmvc掌握@Controller，spring掌握service，在controller里面是有service这个属性的，所以在进行自动装配的时候，是需要先将springioc先初始化。</p><p>三大组件中，listener只初始化一次，filter需要多次，所以就放在listener里面进行初始化。</p><p>tomcat下面分为dispatchservlet和servlet，dispatchservlet下面又有springmvc和spring，springioc的ioc初始化要与服务器启动相关联，springmvc的ioc初始化要与dispatchservlet相关联。</p><h2 id="4-1、ContextLoaderListener"><a href="#4-1、ContextLoaderListener" class="headerlink" title="4.1、ContextLoaderListener"></a>4.1、ContextLoaderListener</h2><p>Spring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听ServletContext的状态，<strong>在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。</strong>web应用中必须在web.xml中配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;listener&gt;    &lt;!--        配置Spring的监听器，在服务器启动时加载Spring的配置文件        Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml        可通过上下文参数自定义Spring配置文件的位置和名称    --&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--自定义Spring配置文件的位置和名称--&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><h2 id="4-2、准备工作"><a href="#4-2、准备工作" class="headerlink" title="4.2、准备工作"></a>4.2、准备工作</h2><h3 id="①创建Maven-Module"><a href="#①创建Maven-Module" class="headerlink" title="①创建Maven Module"></a>①创建Maven Module</h3><h3 id="②导入依赖"><a href="#②导入依赖" class="headerlink" title="②导入依赖"></a>②导入依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt;    &lt;spring.version&gt;5.3.1&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--springmvc--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Mybatis核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mybatis和spring的整合包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 连接池 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- log4j日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;       &lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- ServletAPI --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;version&gt;2.12.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;        &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring5和Thymeleaf整合包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt; </code></pre><h3 id="③创建表"><a href="#③创建表" class="headerlink" title="③创建表"></a>③创建表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t_emp` (    `emp_id` int(11) NOT NULL AUTO_INCREMENT,    `emp_name` varchar(20) DEFAULT NULL,    `age` int(11) DEFAULT NULL,    `sex` char(1) DEFAULT NULL,    `email` varchar(50) DEFAULT NULL,    PRIMARY KEY (`emp_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8</code></pre><h2 id="4-3、配置web-xml"><a href="#4-3、配置web-xml" class="headerlink" title="4.3、配置web.xml"></a>4.3、配置web.xml</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 配置Spring的编码过滤器 --&gt;&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 配置处理请求方式PUT和DELETE的过滤器 --&gt;&lt;filter&gt;    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 配置SpringMVC的前端控制器 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- 设置SpringMVC的配置文件的位置和名称 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 设置Spring的配置文件的位置和名称 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:Spring.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置Spring的监听器 --&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><h2 id="4-4、创建SpringMVC的配置文件并配置"><a href="#4-4、创建SpringMVC的配置文件并配置" class="headerlink" title="4.4、创建SpringMVC的配置文件并配置"></a>4.4、创建SpringMVC的配置文件并配置</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--扫描组件--&gt;&lt;context:component-scan base-package="com.atguigu.ssm.controller"&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器--&gt;&lt;bean id="viewResolver"      class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;    &lt;property name="order" value="1"/&gt;    &lt;property name="characterEncoding" value="UTF-8"/&gt;    &lt;property name="templateEngine"&gt;        &lt;bean class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;            &lt;property name="templateResolver"&gt;                &lt;bean                      class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;                    &lt;!-- 视图前缀 --&gt;                    &lt;property name="prefix" value="/WEB-INF/templates/"/&gt;                    &lt;!-- 视图后缀 --&gt;                    &lt;property name="suffix" value=".html"/&gt;                    &lt;property name="templateMode" value="HTML5"/&gt;                    &lt;property name="characterEncoding" value="UTF-8" /&gt;                &lt;/bean&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置访问首页的视图控制 --&gt;&lt;mvc:view-controller path="/" view-name="index"&gt;&lt;/mvc:view-controller&gt;&lt;!-- 配置默认的servlet处理静态资源 --&gt;&lt;mvc:default-servlet-handler /&gt;&lt;!-- 开启MVC的注解驱动 --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 配置文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;</code></pre><h2 id="4-5、搭建MyBatis环境"><a href="#4-5、搭建MyBatis环境" class="headerlink" title="4.5、搭建MyBatis环境"></a>4.5、搭建MyBatis环境</h2><h3 id="①创建属性文件jdbc-properties"><a href="#①创建属性文件jdbc-properties" class="headerlink" title="①创建属性文件jdbc.properties"></a>①创建属性文件jdbc.properties</h3><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre><h3 id="②创建MyBatis的核心配置文件mybatis-config-xml"><a href="#②创建MyBatis的核心配置文件mybatis-config-xml" class="headerlink" title="②创建MyBatis的核心配置文件mybatis-config.xml"></a>②创建MyBatis的核心配置文件mybatis-config.xml</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--将下划线映射为驼峰--&gt;        &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;    &lt;/settings&gt;    &lt;plugins&gt;        &lt;!--配置分页插件--&gt;        &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt;&lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><h3 id="③创建Mapper接口和映射文件"><a href="#③创建Mapper接口和映射文件" class="headerlink" title="③创建Mapper接口和映射文件"></a>③创建Mapper接口和映射文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EmployeeMapper {List&lt;Employee&gt; getEmployeeList();}</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.atguigu.ssm.mapper.EmployeeMapper"&gt;    &lt;select id="getEmployeeList" resultType="Employee"&gt;        select * from t_emp    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="④创建日志文件log4j-xml"><a href="#④创建日志文件log4j-xml" class="headerlink" title="④创建日志文件log4j.xml"></a>④创建日志文件log4j.xml</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;    &lt;appender name="STDOUT" class="org.apache.log4j.ConsoleAppender"&gt;        &lt;param name="Encoding" value="UTF-8" /&gt;        &lt;layout class="org.apache.log4j.PatternLayout"&gt;            &lt;param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n" /&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;logger name="java.sql"&gt;        &lt;level value="debug" /&gt;    &lt;/logger&gt;    &lt;logger name="org.apache.ibatis"&gt;        &lt;level value="info" /&gt;    &lt;/logger&gt;    &lt;root&gt;        &lt;level value="debug" /&gt;        &lt;appender-ref ref="STDOUT" /&gt;    &lt;/root&gt;&lt;/log4j:configuration&gt;</code></pre><h2 id="4-6、创建Spring的配置文件并配置"><a href="#4-6、创建Spring的配置文件并配置" class="headerlink" title="4.6、创建Spring的配置文件并配置"></a>4.6、创建Spring的配置文件并配置</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"       xsi:schemaLocation="http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd"&gt;    &lt;!--扫描组件--&gt;    &lt;context:component-scan base-package="com.atguigu.ssm"&gt;        &lt;context:exclude-filter type="annotation"expression="org.springframework.stereotype.Controller"/&gt;    &lt;/context:component-scan&gt;    &lt;!-- 引入jdbc.properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"&gt;&lt;/context:property-placeholder&gt;    &lt;!-- 配置Druid数据源 --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driver}"&gt;&lt;/property&gt;        &lt;property name="url" value="${jdbc.url}"&gt;&lt;/property&gt;        &lt;property name="username" value="${jdbc.username}"&gt;&lt;/property&gt;        &lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;!--配置事务管理器--&gt;    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        开启事务的注解驱动        将使用注解@Transactional标识的方法或类中所有的方法进行事务管理    --&gt;    &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;        &lt;!-- 配置用于创建SqlSessionFactory的工厂bean --&gt;    &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt;        &lt;!-- 设置MyBatis配置文件的路径（可以不设置） --&gt;        &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;        &lt;/property&gt;        &lt;!-- 设置数据源 --&gt;        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;        &lt;!-- 设置类型别名所对应的包 --&gt;        &lt;property name="typeAliasesPackage" value="com.atguigu.ssm.pojo"&gt;        &lt;/property&gt;        &lt;!--            设置映射文件的路径            若映射文件所在路径和mapper接口所在路径一致，则不需要设置        --&gt;        &lt;!--            &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt;        --&gt;    &lt;/bean&gt;    &lt;!--        配置mapper接口的扫描        可以将指定包下所有的mapper接口，通过SqlSession创建代理实现类对象，        并将这些动态代理作为IOC容器的bean管理    --&gt;    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;        &lt;property name="basePackage" value="com.atguigu.ssm.mapper"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="4-7、测试功能"><a href="#4-7、测试功能" class="headerlink" title="4.7、测试功能"></a>4.7、测试功能</h2><h3 id="①创建组件"><a href="#①创建组件" class="headerlink" title="①创建组件"></a>①创建组件</h3><p>实体类Employee</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee {    private Integer empId;    private String empName;    private Integer age;    private String sex;    private String email;    public Employee() {    }    public Employee(Integer empId, String empName, Integer age, String sex,                    String email) {        this.empId = empId;        this.empName = empName;        this.age = age;        this.sex = sex;        this.email = email;    }    public Integer getEmpId() {        return empId;    }    public void setEmpId(Integer empId) {        this.empId = empId;    }    public String getEmpName() {        return empName;    }    public void setEmpName(String empName) {        this.empName = empName;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }}</code></pre><p>创建控制层组件EmployeeController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class EmployeeController {    @Autowired    private EmployeeService employeeService;        @RequestMapping(value = "/employee/page/{pageNum}", method = RequestMethod.GET)    public String getEmployeeList(Model model, @PathVariable("pageNum") Integer pageNum){        PageInfo&lt;Employee&gt; page = employeeService.getEmployeeList(pageNum);        model.addAttribute("page", page);        return "employee_list";    }}</code></pre><p>创建接口EmployeeService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EmployeeService {PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum);}</code></pre><p>创建实现类EmployeeServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EmployeeServiceImpl implements EmployeeService {    @Autowired    private EmployeeMapper employeeMapper;    @Override    public PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum) {        PageHelper.startPage(pageNum, 4);        List&lt;Employee&gt; list = employeeMapper.getEmployeeList();        PageInfo&lt;Employee&gt; page = new PageInfo&lt;&gt;(list, 5);        return page;    }}</code></pre><h3 id="②创建页面-1"><a href="#②创建页面-1" class="headerlink" title="②创建页面"></a>②创建页面</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;Employee Info&lt;/title&gt;        &lt;link rel="stylesheet" th:href="@{/static/css/index_work.css}"&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;th colspan="6"&gt;Employee Info&lt;/th&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;th&gt;emp_id&lt;/th&gt;                &lt;th&gt;emp_name&lt;/th&gt;                &lt;th&gt;age&lt;/th&gt;                &lt;th&gt;sex&lt;/th&gt;                &lt;th&gt;email&lt;/th&gt;                &lt;th&gt;options&lt;/th&gt;            &lt;/tr&gt;            &lt;tr th:each="employee : ${page.list}"&gt;                &lt;td th:text="${employee.empId}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.empName}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.age}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.sex}"&gt;&lt;/td&gt;                &lt;td th:text="${employee.email}"&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=""&gt;delete&lt;/a&gt;                    &lt;a href=""&gt;update&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan="6"&gt;                    &lt;span th:if="${page.hasPreviousPage}"&gt;                        &lt;a th:href="@{/employee/page/1}"&gt;首页&lt;/a&gt;                        &lt;a th:href="@{'/employee/page/'+${page.prePage}}"&gt;上一页&lt;/a&gt;                    &lt;/span&gt;                    &lt;span th:each="num : ${page.navigatepageNums}"&gt;                        &lt;a th:if="${page.pageNum==num}"                           th:href="@{'/employee/page/'+${num}}" th:text="'['+${num}+']'" style="color:red;"&gt;&lt;/a&gt;                        &lt;a th:if="${page.pageNum!=num}"                           th:href="@{'/employee/page/'+${num}}" th:text="${num} "&gt;&lt;/a&gt;                    &lt;/span&gt;                    &lt;span th:if="${page.hasNextPage}"&gt;                        &lt;a th:href="@{'/employee/page/'+${page.nextPage}}"&gt;下一页&lt;/a&gt;                        &lt;a th:href="@{'/employee/page/'+${page.pages}}"&gt;末页&lt;/a&gt;                    &lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="③访问测试分页功能"><a href="#③访问测试分页功能" class="headerlink" title="③访问测试分页功能"></a>③访问测试分页功能</h3><p>localhost:8080/employee/page/1</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/07/10/Spring/"/>
      <url>/2023/07/10/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h1><h1 id="1、Spring简介"><a href="#1、Spring简介" class="headerlink" title="1、Spring简介"></a>1、Spring简介</h1><h3 id="1-1、Spring概述"><a href="#1-1、Spring概述" class="headerlink" title="1.1、Spring概述"></a>1.1、Spring概述</h3><p>官网地址：<a href="https://spring.io/">https://spring.io/</a></p><blockquote><p>Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。</p><p>Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。</p><p>Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。</p><p>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO  编程模型来促进良好的编程实践。</p></blockquote><h3 id="1-2、Spring家族"><a href="#1-2、Spring家族" class="headerlink" title="1.2、Spring家族"></a>1.2、Spring家族</h3><p>项目列表：<a href="https://spring.io/projects">https://spring.io/projects</a></p><h3 id="1-3、Spring-Framework"><a href="#1-3、Spring-Framework" class="headerlink" title="1.3、Spring Framework"></a>1.3、Spring Framework</h3><p>Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework为基础的。</p><h4 id="1-3-1、Spring-Framework特性"><a href="#1-3-1、Spring-Framework特性" class="headerlink" title="1.3.1、Spring Framework特性"></a>1.3.1、Spring Framework特性</h4><ul><li><p>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</p></li><li><p>控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</p></li><li><p>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</p></li><li><p>容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</p></li><li><p>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</p></li><li><p>声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。</p></li><li><p>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</p></li></ul><h4 id="1-3-2、Spring-Framework五大功能模块"><a href="#1-3-2、Spring-Framework五大功能模块" class="headerlink" title="1.3.2、Spring Framework五大功能模块"></a>1.3.2、Spring Framework五大功能模块</h4><table><thead><tr><th><strong>功能模块</strong></th><th><strong>功能介绍</strong></th></tr></thead><tbody><tr><td>Core Container</td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td></tr><tr><td>AOP&amp;Aspects</td><td>面向切面编程</td></tr><tr><td>Testing</td><td>提供了对 junit 或 TestNG 测试框架的整合。</td></tr><tr><td>Data Access/Integration</td><td>提供了对数据访问/集成的功能。</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h1 id="2、IOC"><a href="#2、IOC" class="headerlink" title="2、IOC"></a>2、IOC</h1><h2 id="2-1、IOC容器"><a href="#2-1、IOC容器" class="headerlink" title="2.1、IOC容器"></a>2.1、IOC容器</h2><h3 id="2-1-1、IOC思想"><a href="#2-1-1、IOC思想" class="headerlink" title="2.1.1、IOC思想"></a>2.1.1、IOC思想</h3><p>IOC：Inversion of Control，翻译过来是<strong>反转控制</strong>。</p><h4 id="①获取资源的传统方式"><a href="#①获取资源的传统方式" class="headerlink" title="①获取资源的传统方式"></a>①获取资源的传统方式</h4><p>自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。</p><p>在应用程序中的组件需要获取资源时，传统的方式是组件<strong>主动</strong>的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</p><h4 id="②反转控制方式获取资源"><a href="#②反转控制方式获取资源" class="headerlink" title="②反转控制方式获取资源"></a>②反转控制方式获取资源</h4><p>点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。</p><p>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由<strong>容器主动的将资源推送给需要的组件</strong>，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的<strong>被动</strong>形式。</p><h4 id="③DI"><a href="#③DI" class="headerlink" title="③DI"></a>③DI</h4><p>DI：Dependency Injection，翻译过来是<strong>依赖注入</strong>。</p><p>DI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。</p><p>所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。</p><blockquote><p>IOC 好处见 <strong>2.2.14、实验十四：基于xml的自动装配</strong>：与JavaWeb原生相比</p></blockquote><h3 id="2-1-2、IOC容器在Spring中的实现"><a href="#2-1-2、IOC容器在Spring中的实现" class="headerlink" title="2.1.2、IOC容器在Spring中的实现"></a>2.1.2、IOC容器在Spring中的实现</h3><p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：</p><h4 id="①BeanFactory"><a href="#①BeanFactory" class="headerlink" title="①BeanFactory"></a>①BeanFactory</h4><p>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p><h4 id="②ApplicationContext"><a href="#②ApplicationContext" class="headerlink" title="②ApplicationContext"></a>②ApplicationContext</h4><p>BeanFactory 的子接口，提供了更多高级特性。<strong>面向 Spring 的使用者</strong>，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p><h4 id="③ApplicationContext的主要实现类"><a href="#③ApplicationContext的主要实现类" class="headerlink" title="③ApplicationContext的主要实现类"></a>③ApplicationContext的主要实现类</h4><p><img src="5.png" alt="5"></p><table><thead><tr><th><strong>类型名</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取<strong>类路径下</strong>的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>ConfigurableApplicationContext</td><td>ApplicationContext 的子接口，包含一些<strong>扩展方法refresh() 和 close()</strong> ，让ApplicationContext 具有启动、关闭和刷新上下文的能力。</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><h2 id="2-2、基于XML管理bean"><a href="#2-2、基于XML管理bean" class="headerlink" title="2.2、基于XML管理bean"></a>2.2、基于XML管理bean</h2><h3 id="2-2-1、实验一：入门案例"><a href="#2-2-1、实验一：入门案例" class="headerlink" title="2.2.1、实验一：入门案例"></a>2.2.1、实验一：入门案例</h3><h4 id="①创建Maven-Module"><a href="#①创建Maven-Module" class="headerlink" title="①创建Maven Module"></a>①创建Maven Module</h4><h4 id="②引入依赖"><a href="#②引入依赖" class="headerlink" title="②引入依赖"></a>②引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><img src="6.png" alt="6"></p><h4 id="③创建类HelloWorld"><a href="#③创建类HelloWorld" class="headerlink" title="③创建类HelloWorld"></a>③创建类HelloWorld</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld {    public void sayHello(){        System.out.println("helloworld");    }}</code></pre><p><img src="7.png" alt="7"></p><p><img src="8.png" alt="8"></p><h4 id="⑤在Spring的配置文件中配置bean"><a href="#⑤在Spring的配置文件中配置bean" class="headerlink" title="⑤在Spring的配置文件中配置bean"></a>⑤在Spring的配置文件中配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理通过bean标签配置IOC容器所管理的bean属性：id：设置bean的唯一标识class：设置bean所对应类型的全类名--&gt;&lt;bean id="helloworld" class="com.atguigu.spring.bean.HelloWorld"&gt;&lt;/bean&gt;</code></pre><h4 id="⑥创建测试类测试"><a href="#⑥创建测试类测试" class="headerlink" title="⑥创建测试类测试"></a>⑥创建测试类测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testHelloWorld(){    //获取IOC容器    ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");    //获取IOC容器中的bean    HelloWorld helloworld = (HelloWorld) ioc.getBean("helloworld");    helloworld.sayHello();}</code></pre><h4 id="⑦思路"><a href="#⑦思路" class="headerlink" title="⑦思路"></a>⑦思路</h4><p><img src="9.png" alt="9"></p><h4 id="⑧注意"><a href="#⑧注意" class="headerlink" title="⑧注意"></a>⑧注意</h4><p>Spring 底层默认通过反射技术<strong>调用组件类的无参构造器</strong>来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：</p><p><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld. &lt;init&gt;()</code></p><h3 id="2-2-2、实验二：获取bean"><a href="#2-2-2、实验二：获取bean" class="headerlink" title="2.2.2、实验二：获取bean"></a>2.2.2、实验二：获取bean</h3><h4 id="①方式一：根据id获取"><a href="#①方式一：根据id获取" class="headerlink" title="①方式一：根据id获取"></a>①方式一：根据id获取</h4><p>由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。</p><p>上个实验中我们使用的就是这种方式。</p><h4 id="②方式二：根据类型获取"><a href="#②方式二：根据类型获取" class="headerlink" title="②方式二：根据类型获取"></a>②方式二：根据类型获取</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testStudent(){    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-ioc.xml");    Student student = ioc.getBean(Student.class);    System.out.println(student);}</code></pre><p><strong>注意：</strong></p><p>当根据类型获取bean时，要求IOC容器中指定类型的bean<strong>有且只能有一个</strong></p><ul><li>若没有任何一个类型匹配的bean，当IOC容器中一共配置了两个：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentOne" class="com.atguigu.spring.pojo.Student"&gt;&lt;/bean&gt;&lt;bean id="studentTwo" class="com.atguigu.spring.pojo.Student"&gt;&lt;/bean&gt;</code></pre><p>​此时抛出异常：<code>NoSuchBeanDefinitionException</code></p><ul><li>若有多个类型匹配的bean，此时抛出异常：<code>NoUniqueBeanDefinitionException</code></li></ul><p><strong>补充：</strong></p><p>==以后获取bean多用方式二==，因为很少会出现一个class类多个不同bean对象的形式，bean默认单例模式，同时也可以通过scope属性切换多例和单例</p><h4 id="③方式三：根据id和类型"><a href="#③方式三：根据id和类型" class="headerlink" title="③方式三：根据id和类型"></a>③方式三：根据id和类型</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testStudent(){    ApplicationContext ioc = newClassPathXmlApplicationContext("applicationContext.xml");    Student student = ioc.getBean("studentTwo", Student.class);    System.out.println(student);}</code></pre><h4 id="④扩展"><a href="#④扩展" class="headerlink" title="④扩展"></a>④扩展</h4><p>如果组件类实现了接口，根据接口类型可以获取 bean 吗？</p><blockquote><p>可以，前提是bean唯一</p></blockquote><p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？</p><blockquote><p>不行，因为bean不唯一</p></blockquote><h4 id="⑤结论"><a href="#⑤结论" class="headerlink" title="⑤结论"></a>⑤结论</h4><p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。</p><p>即通过<strong>bean的类型、bean所继承的类的类型、bean所实现的接口的类型</strong>都可以获取bean</p><h3 id="2-2-3、实验三：依赖注入之setter注入"><a href="#2-2-3、实验三：依赖注入之setter注入" class="headerlink" title="2.2.3、实验三：依赖注入之setter注入"></a>2.2.3、实验三：依赖注入之setter注入</h3><p>依赖注入，简单来说就是给类的属性进行赋值</p><h4 id="①创建学生类Student"><a href="#①创建学生类Student" class="headerlink" title="①创建学生类Student"></a>①创建学生类Student</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student {    private Integer id;    private String name;    private Integer age;    private String sex;    public Student() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    @Override    public String toString() {        return "Student{" +            "id=" + id +            ", name='" + name + '\'' +            ", age=" + age +            ", sex='" + sex + '\'' +            '}';    }}</code></pre><h4 id="②配置bean时为属性赋值"><a href="#②配置bean时为属性赋值" class="headerlink" title="②配置bean时为属性赋值"></a>②配置bean时为属性赋值</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentOne" class="com.atguigu.spring.bean.Student"&gt;    &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;    &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）--&gt;    &lt;!-- value属性：指定属性值 --&gt;    &lt;property name="id" value="1001"&gt;&lt;/property&gt;    &lt;property name="name" value="张三"&gt;&lt;/property&gt;    &lt;property name="age" value="23"&gt;&lt;/property&gt;    &lt;property name="sex" value="男"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="③测试"><a href="#③测试" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDIBySet(){    ApplicationContext ioc = new ClassPathXmlApplicationContext("springdi.xml");    Student studentOne = ioc.getBean("studentOne", Student.class);    System.out.println(studentOne);}</code></pre><h3 id="2-2-4、实验四：依赖注入之构造器注入"><a href="#2-2-4、实验四：依赖注入之构造器注入" class="headerlink" title="2.2.4、实验四：依赖注入之构造器注入"></a>2.2.4、实验四：依赖注入之构造器注入</h3><h4 id="①在Student类中添加有参构造"><a href="#①在Student类中添加有参构造" class="headerlink" title="①在Student类中添加有参构造"></a>①在Student类中添加有参构造</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Student(Integer id, String name, Integer age, String sex) {    this.id = id;    this.name = name;    this.age = age;    this.sex = sex;}</code></pre><h4 id="②配置bean"><a href="#②配置bean" class="headerlink" title="②配置bean"></a>②配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentTwo" class="com.atguigu.spring.bean.Student"&gt;    &lt;constructor-arg value="1002"&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value="李四"&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value="33"&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value="女"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><blockquote><p>注意：</p><p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p><ul><li>index属性：指定参数所在位置的索引（从0开始）</li><li>name属性：指定参数名</li></ul></blockquote><h4 id="③测试-1"><a href="#③测试-1" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDIBySet(){    ApplicationContext ac = new ClassPathXmlApplicationContext("springdi.xml");    Student studentOne = ac.getBean("studentTwo", Student.class);    System.out.println(studentOne);}</code></pre><h3 id="2-2-5、实验五：特殊值处理"><a href="#2-2-5、实验五：特殊值处理" class="headerlink" title="2.2.5、实验五：特殊值处理"></a>2.2.5、实验五：特殊值处理</h3><h4 id="①字面量赋值"><a href="#①字面量赋值" class="headerlink" title="①字面量赋值"></a>①字面量赋值</h4><blockquote><p>什么是字面量？</p><p>int a = 10;</p><p>声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。</p><p>而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。</p><p>所以字面量没有引申含义，就是<strong>我们看到的这个数据本身</strong>。(比如null，看到是null，但本质不是字符串，是一个null值)</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name="name" value="张三"/&gt;</code></pre><h4 id="②null值"><a href="#②null值" class="headerlink" title="②null值"></a>②null值</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="name"&gt;&lt;null /&gt;&lt;/property&gt;</code></pre><blockquote><p>注意：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="name" value="null"&gt;&lt;/property&gt;</code></pre><p>以上写法，为name所赋的值是字符串null</p></blockquote><h4 id="③xml实体"><a href="#③xml实体" class="headerlink" title="③xml实体"></a>③xml实体</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name="expression" value="a &lt; b"/&gt; // a &lt; b</code></pre><h4 id="④CDATA节"><a href="#④CDATA节" class="headerlink" title="④CDATA节"></a>④CDATA节</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name="expression"&gt;    &lt;!-- 解决方案二：使用CDATA节 --&gt;    &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;    &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;    &lt;!-- 所以CDATA节中写什么符号都随意 --&gt;    &lt;!-- CDATA节是xml中一个特殊的标签，因此不能写在一个属性中 --&gt;    &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt;</code></pre><h3 id="2-2-6、实验六：为类类型属性赋值"><a href="#2-2-6、实验六：为类类型属性赋值" class="headerlink" title="2.2.6、实验六：为类类型属性赋值"></a>2.2.6、实验六：为类类型属性赋值</h3><h4 id="创建班级类Clazz"><a href="#创建班级类Clazz" class="headerlink" title="创建班级类Clazz"></a>创建班级类Clazz</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Clazz {    private Integer clazzId;    private String clazzName;    public Integer getClazzId() {        return clazzId;    }    public void setClazzId(Integer clazzId) {        this.clazzId = clazzId;    }    public String getClazzName() {        return clazzName;    }    public void setClazzName(String clazzName) {        this.clazzName = clazzName;    }    @Override    public String toString() {        return "Clazz{" +            "clazzId=" + clazzId +            ", clazzName='" + clazzName + '\'' +            '}';    }    public Clazz() {    }    public Clazz(Integer clazzId, String clazzName) {        this.clazzId = clazzId;        this.clazzName = clazzName;    }}</code></pre><h4 id="修改Student类"><a href="#修改Student类" class="headerlink" title="修改Student类"></a>修改Student类</h4><p>在Student类中添加以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Clazz clazz;public Clazz getClazz() {    return clazz;}public void setClazz(Clazz clazz) {    this.clazz = clazz;}</code></pre><h4 id="①方式一：引用外部已声明的bean"><a href="#①方式一：引用外部已声明的bean" class="headerlink" title="①方式一：引用外部已声明的bean"></a>①方式一：引用外部已声明的bean</h4><p>配置Clazz类型的bean：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="clazzOne" class="com.atguigu.spring.bean.Clazz"&gt;    &lt;property name="clazzId" value="1111"&gt;&lt;/property&gt;    &lt;property name="clazzName" value="财源滚滚班"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>为Student中的clazz属性赋值：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>错误演示：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;property name="clazz" value="clazzOne"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><blockquote><p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException:</p><p>Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found</p><p>意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p></blockquote><h4 id="②方式二：内部bean"><a href="#②方式二：内部bean" class="headerlink" title="②方式二：内部bean"></a>②方式二：内部bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;property name="clazz"&gt;        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;        &lt;bean id="clazzInner" class="com.atguigu.spring.bean.Clazz"&gt;            &lt;property name="clazzId" value="2222"&gt;&lt;/property&gt;            &lt;property name="clazzName" value="远大前程班"&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="③方式三：级联属性赋值（不常用）"><a href="#③方式三：级联属性赋值（不常用）" class="headerlink" title="③方式三：级联属性赋值（不常用）"></a>③方式三：级联属性赋值（不常用）</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;!-- 一定先引用某个bean为属性赋值，才可以使用级联方式更新属性 --&gt;    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;    &lt;property name="clazz.clazzId" value="3333"&gt;&lt;/property&gt;    &lt;property name="clazz.clazzName" value="最强王者班"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="2-2-7、实验七：为数组类型属性赋值"><a href="#2-2-7、实验七：为数组类型属性赋值" class="headerlink" title="2.2.7、实验七：为数组类型属性赋值"></a>2.2.7、实验七：为数组类型属性赋值</h3><h4 id="①修改Student类"><a href="#①修改Student类" class="headerlink" title="①修改Student类"></a>①修改Student类</h4><p>在Student类中添加以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private String[] hobbies;public String[] getHobbies() {    return hobbies;}public void setHobbies(String[] hobbies) {    this.hobbies = hobbies;}</code></pre><h4 id="②配置bean-1"><a href="#②配置bean-1" class="headerlink" title="②配置bean"></a>②配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;    &lt;property name="hobbies"&gt;        &lt;array&gt;            &lt;!-- 字面量类型用value --&gt;            &lt;value&gt;抽烟&lt;/value&gt;            &lt;value&gt;喝酒&lt;/value&gt;            &lt;value&gt;烫头&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="2-2-8、实验八：为集合类型属性赋值"><a href="#2-2-8、实验八：为集合类型属性赋值" class="headerlink" title="2.2.8、实验八：为集合类型属性赋值"></a>2.2.8、实验八：为集合类型属性赋值</h3><h4 id="①为List集合类型属性赋值"><a href="#①为List集合类型属性赋值" class="headerlink" title="①为List集合类型属性赋值"></a>①为List集合类型属性赋值</h4><p>在Clazz类中添加以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() {    return students;}public void setStudents(List&lt;Student&gt; students) {    this.students = students;}</code></pre><p>配置bean：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="clazzTwo" class="com.atguigu.spring.bean.Clazz"&gt;    &lt;property name="clazzId" value="4444"&gt;&lt;/property&gt;    &lt;property name="clazzName" value="Javaee0222"&gt;&lt;/property&gt;    &lt;property name="students"&gt;        &lt;list&gt;            &lt;!-- 类类型用ref --&gt;            &lt;ref bean="studentOne"&gt;&lt;/ref&gt;            &lt;ref bean="studentTwo"&gt;&lt;/ref&gt;            &lt;ref bean="studentThree"&gt;&lt;/ref&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><blockquote><p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p></blockquote><h4 id="②为Map集合类型属性赋值"><a href="#②为Map集合类型属性赋值" class="headerlink" title="②为Map集合类型属性赋值"></a>②为Map集合类型属性赋值</h4><p>创建教师类Teacher：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Teacher {    private Integer teacherId;    private String teacherName;    public Integer getTeacherId() {        return teacherId;    }    public void setTeacherId(Integer teacherId) {        this.teacherId = teacherId;    }    public String getTeacherName() {        return teacherName;    }    public void setTeacherName(String teacherName) {        this.teacherName = teacherName;    }    public Teacher(Integer teacherId, String teacherName) {        this.teacherId = teacherId;        this.teacherName = teacherName;    }    public Teacher() {    }    @Override    public String toString() {        return "Teacher{" +            "teacherId=" + teacherId +            ", teacherName='" + teacherName + '\'' +            '}';    }}</code></pre><p>在Student类中添加以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Map&lt;String, Teacher&gt; teacherMap;public Map&lt;String, Teacher&gt; getTeacherMap() {    return teacherMap;}public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) {    this.teacherMap = teacherMap;}</code></pre><p>配置bean：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="teacherOne" class="com.atguigu.spring.bean.Teacher"&gt;    &lt;property name="teacherId" value="10010"&gt;&lt;/property&gt;    &lt;property name="teacherName" value="大宝"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="teacherTwo" class="com.atguigu.spring.bean.Teacher"&gt;    &lt;property name="teacherId" value="10086"&gt;&lt;/property&gt;    &lt;property name="teacherName" value="二宝"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;    &lt;property name="hobbies"&gt;        &lt;array&gt;            &lt;value&gt;抽烟&lt;/value&gt;            &lt;value&gt;喝酒&lt;/value&gt;            &lt;value&gt;烫头&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name="teacherMap"&gt;        &lt;map&gt;            &lt;entry&gt;                &lt;key&gt;                    &lt;value&gt;10010&lt;/value&gt;                &lt;/key&gt;                &lt;ref bean="teacherOne"&gt;&lt;/ref&gt;            &lt;/entry&gt;            &lt;entry&gt;                &lt;key&gt;                    &lt;value&gt;10086&lt;/value&gt;                &lt;/key&gt;                &lt;ref bean="teacherTwo"&gt;&lt;/ref&gt;            &lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="③引用集合类型的bean"><a href="#③引用集合类型的bean" class="headerlink" title="③引用集合类型的bean"></a>③引用集合类型的bean</h4><p>可以考虑把内部bean提取出来，创建单独的bean，然后使用ref引用</p><p>但是由于bean是为类的属性赋值的，无法往里面添加数据，因此需要<strong>使用 util 命名空间</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// List&lt;bean id="clazzTwo" class="com.atguigu.spring.bean.Clazz"&gt;    &lt;property name="clazzId" value="4444"&gt;&lt;/property&gt;    &lt;property name="clazzName" value="Javaee0222"&gt;&lt;/property&gt;    &lt;property name="students" ref="students"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--list集合类型的bean--&gt;&lt;util:list id="students"&gt;    &lt;ref bean="studentOne"&gt;&lt;/ref&gt;    &lt;ref bean="studentTwo"&gt;&lt;/ref&gt;    &lt;ref bean="studentThree"&gt;&lt;/ref&gt;&lt;/util:list&gt;</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// Map&lt;bean id="studentFour" class="com.atguigu.spring.bean.Student"&gt;    &lt;property name="id" value="1004"&gt;&lt;/property&gt;    &lt;property name="name" value="赵六"&gt;&lt;/property&gt;    &lt;property name="age" value="26"&gt;&lt;/property&gt;    &lt;property name="sex" value="女"&gt;&lt;/property&gt;    &lt;property name="clazz" ref="clazzOne"&gt;&lt;/property&gt;    &lt;property name="hobbies"&gt;        &lt;array&gt;            &lt;value&gt;抽烟&lt;/value&gt;            &lt;value&gt;喝酒&lt;/value&gt;            &lt;value&gt;烫头&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name="teacherMap" ref="teacherMap"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--map集合类型的bean--&gt;&lt;util:map id="teacherMap"&gt;    &lt;entry&gt;        &lt;key&gt;            &lt;value&gt;10010&lt;/value&gt;        &lt;/key&gt;        &lt;ref bean="teacherOne"&gt;&lt;/ref&gt;    &lt;/entry&gt;    &lt;entry&gt;        &lt;key&gt;            &lt;value&gt;10086&lt;/value&gt;        &lt;/key&gt;        &lt;ref bean="teacherTwo"&gt;&lt;/ref&gt;    &lt;/entry&gt;&lt;/util:map&gt;</code></pre><blockquote><p>使用<code>util:list</code>、<code>util:map</code>标签必须引入相应的命名空间，可以通过idea的提示功能选择</p></blockquote><h3 id="2-2-9、实验九：p命名空间"><a href="#2-2-9、实验九：p命名空间" class="headerlink" title="2.2.9、实验九：p命名空间"></a>2.2.9、实验九：p命名空间</h3><p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="studentSix" class="com.atguigu.spring.bean.Student"      p:id="1006" p:name="小明" p:clazz-ref="clazzOne" p:teacherMap-ref="teacherMap"&gt;&lt;/bean&gt;</code></pre><h3 id="2-2-10、实验十：引入外部属性文件"><a href="#2-2-10、实验十：引入外部属性文件" class="headerlink" title="2.2.10、实验十：引入外部属性文件"></a>2.2.10、实验十：引入外部属性文件</h3><h4 id="①加入依赖"><a href="#①加入依赖" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.0.31&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="②创建外部属性文件"><a href="#②创建外部属性文件" class="headerlink" title="②创建外部属性文件"></a>②创建外部属性文件</h4><p><img src="10.png" alt="10"></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=rootjdbc.password=123456jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre><h4 id="③引入属性文件"><a href="#③引入属性文件" class="headerlink" title="③引入属性文件"></a>③引入属性文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre><h4 id="④配置bean"><a href="#④配置bean" class="headerlink" title="④配置bean"></a>④配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;    &lt;property name="url" value="${jdbc.url}"/&gt;    &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;    &lt;property name="username" value="${jdbc.user}"/&gt;    &lt;property name="password" value="${jdbc.password}"/&gt;&lt;/bean&gt;</code></pre><h4 id="⑤测试"><a href="#⑤测试" class="headerlink" title="⑤测试"></a>⑤测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDataSource() throws SQLException {    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-datasource.xml");    DataSource dataSource = ioc.getBean(DruidDataSource.class);    Connection connection = dataSource.getConnection();    System.out.println(connection);}</code></pre><h3 id="2-2-11、实验十一：bean的作用域"><a href="#2-2-11、实验十一：bean的作用域" class="headerlink" title="2.2.11、实验十一：bean的作用域"></a>2.2.11、实验十一：bean的作用域</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p><table><thead><tr><th><strong>取值</strong></th><th><strong>含义</strong></th><th><strong>创建对象的时机</strong></th></tr></thead><tbody><tr><td>singleton（默认）</td><td>在IOC容器中，这个bean的对象始终为单实例</td><td>IOC容器初始化时</td></tr><tr><td>prototype</td><td>这个bean在IOC容器中有多个实例</td><td>获取bean时</td></tr></tbody></table><p>如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：</p><table><thead><tr><th><strong>取值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>request</td><td>在一个请求范围内有效</td></tr><tr><td>session</td><td>在一个会话范围内有效</td></tr></tbody></table><h4 id="②创建类User"><a href="#②创建类User" class="headerlink" title="②创建类User"></a>②创建类User</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {    private Integer id;    private String username;    private String password;    private Integer age;        public User() {    }    public User(Integer id, String username, String password, Integer age) {        this.id = id;        this.username = username;        this.password = password;        this.age = age;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return "User{" +            "id=" + id +            ", username='" + username + '\'' +            ", password='" + password + '\'' +            ", age=" + age +            '}';    }}</code></pre><h4 id="③配置bean"><a href="#③配置bean" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean class="com.atguigu.bean.User" scope="prototype"&gt;&lt;/bean&gt;</code></pre><h4 id="④测试"><a href="#④测试" class="headerlink" title="④测试"></a>④测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testBeanScope(){    ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-scope.xml");    User user1 = ioc.getBean(User.class);    User user2 = ioc.getBean(User.class);    System.out.println(user1==user2); // 单例时为true，多例时为false}</code></pre><h3 id="2-2-12、实验十二：bean的生命周期"><a href="#2-2-12、实验十二：bean的生命周期" class="headerlink" title="2.2.12、实验十二：bean的生命周期"></a>2.2.12、实验十二：bean的生命周期</h3><h4 id="①具体的生命周期过程"><a href="#①具体的生命周期过程" class="headerlink" title="①具体的生命周期过程"></a>①具体的生命周期过程</h4><ul><li>bean对象创建（调用无参构造器）</li><li>给bean对象设置属性</li><li>bean对象初始化之前操作（由bean的后置处理器负责）</li><li>bean对象初始化（需在配置bean时指定初始化方法）</li><li>bean对象初始化之后操作（由bean的后置处理器负责）</li><li>bean对象就绪可以使用</li><li>bean对象销毁（需在配置bean时指定销毁方法）</li><li>IOC容器关闭</li></ul><h4 id="②修改类User"><a href="#②修改类User" class="headerlink" title="②修改类User"></a>②修改类User</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {    private Integer id;    private String username;    private String password;    private Integer age;    public User() {        System.out.println("生命周期：1、创建对象");    }    public User(Integer id, String username, String password, Integer age) {        this.id = id;        this.username = username;        this.password = password;        this.age = age;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        System.out.println("生命周期：2、依赖注入");        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public void initMethod(){        System.out.println("生命周期：3、初始化");    }    public void destroyMethod(){        System.out.println("生命周期：5、销毁");    }    @Override    public String toString() {        return "User{" +            "id=" + id +            ", username='" + username + '\'' +            ", password='" + password + '\'' +            ", age=" + age +            '}';    }}</code></pre><blockquote><p>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法</p></blockquote><h4 id="③配置bean-1"><a href="#③配置bean-1" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 使用init-method属性指定初始化方法 --&gt;&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;&lt;bean class="com.atguigu.bean.User" scope="prototype" init-method="initMethod"destroy-method="destroyMethod"&gt;    &lt;property name="id" value="1001"&gt;&lt;/property&gt;    &lt;property name="username" value="admin"&gt;&lt;/property&gt;    &lt;property name="password" value="123456"&gt;&lt;/property&gt;    &lt;property name="age" value="23"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="④测试-1"><a href="#④测试-1" class="headerlink" title="④测试"></a>④测试</h4><p>注意：</p><ul><li>若bean的作用域为单例时，生命周期的前三个步骤（创建对象、依赖注入、初始化）会在获取IOC容器时执行</li><li>若bean的作用域为多例时，生命周期的前三个步骤会在获取bean时执行。且close ioc时，不会销毁bean</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testLife(){    //ConfigurableApplicationContext是ApplicationContext的子接口，其中扩展了刷新和关闭容器的方法    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("spring-lifecycle.xml");    User bean = ac.getBean(User.class);    System.out.println("生命周期：4、通过IOC容器获取bean并使用");    ac.close();}</code></pre><h4 id="⑤bean的后置处理器"><a href="#⑤bean的后置处理器" class="headerlink" title="⑤bean的后置处理器"></a>⑤bean的后置处理器</h4><p>bean的后置处理器会在生命周期的<strong>初始化前后添加</strong>额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中。</p><p>==需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行==</p><p>创建bean的后置处理器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.spring.process;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor {    //此方法在bean的生命周期初始化之前执行    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println("☆☆☆" + beanName + " = " + bean);        return bean;    }    //此方法在bean的生命周期初始化之后执行    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println("★★★" + beanName + " = " + bean);        return bean;    }}</code></pre><p>在IOC容器中配置后置处理器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id="myBeanProcessor" class="com.atguigu.spring.process.MyBeanProcessor"/&gt;</code></pre><h3 id="2-2-13、实验十三：FactoryBean"><a href="#2-2-13、实验十三：FactoryBean" class="headerlink" title="2.2.13、实验十三：FactoryBean"></a>2.2.13、实验十三：FactoryBean</h3><h4 id="①简介"><a href="#①简介" class="headerlink" title="①简介"></a>①简介</h4><p>FactoryBean是Spring提供的一种<strong>整合第三方框架</strong>的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是<code>getObject()方法的返回值</code>。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p><p>将来我们<strong>整合Mybatis</strong>时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** Copyright 2002-2020 the original author or authors.** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at** https://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.* See the License for the specific language governing permissions and* limitations under the License.*/package org.springframework.beans.factory;import org.springframework.lang.Nullable;/*** Interface to be implemented by objects used within a {@link BeanFactory}which* are themselves factories for individual objects. If a bean implements this* interface, it is used as a factory for an object to expose, not directly as a* bean instance that will be exposed itself.** &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normalbean.&lt;/b&gt;* A FactoryBean is defined in a bean style, but the object exposed for bean* references ({@link #getObject()}) is always the object that it creates.** &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create* objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}* interface allows for exposing more fine-grained behavioral metadata.** &lt;p&gt;This interface is heavily used within the framework itself, for examplefor* the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the* {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for* custom components as well; however, this is only common for infrastructurecode.** &lt;p&gt;&lt;b&gt;{@code FactoryBean} is a programmatic contract. Implementations are not* supposed to rely on annotation-driven injection or other reflectivefacilities.&lt;/b&gt;* {@link #getObjectType()} {@link #getObject()} invocations may arrive early inthe* bootstrap process, even ahead of any post-processor setup. If you need accessto* other beans, implement {@link BeanFactoryAware} and obtain themprogrammatically.** &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of theFactoryBean* instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt;Therefore,* a destroy method on an exposed bean object (such as {@linkjava.io.Closeable#close()}* will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean shouldimplement* {@link DisposableBean} and delegate any such close call to the underlyingobject.** &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory's* synchronization of bean creation. There is usually no need for internal* synchronization other than for purposes of lazy initialization within the* FactoryBean itself (or the like).** @author Rod Johnson* @author Juergen Hoeller* @since 08.03.2003* @param &lt;T&gt; the bean type* @see org.springframework.beans.factory.BeanFactory* @see org.springframework.aop.framework.ProxyFactoryBean* @see org.springframework.jndi.JndiObjectFactoryBean*/public interface FactoryBean&lt;T&gt; {    /*** The name of an attribute that can be* {@link org.springframework.core.AttributeAccessor#setAttribute set} on a* {@link org.springframework.beans.factory.config.BeanDefinition} so that* factory beans can signal their object type when it can't be deduced from* the factory bean class.* @since 5.2*/    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";    /*** Return an instance (possibly shared or independent) of the object* managed by this factory.* &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the* Singleton and Prototype design pattern.* &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of* the call (for example because it is involved in a circular reference),* throw a corresponding {@link FactoryBeanNotInitializedException}.* &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}* objects. The factory will consider this as normal value to be used; it* will not throw a FactoryBeanNotInitializedException in this case anymore.* FactoryBean implementations are encouraged to throw* FactoryBeanNotInitializedException themselves now, as appropriate.* @return an instance of the bean (can be {@code null})* @throws Exception in case of creation errors* @see FactoryBeanNotInitializedException*/    @Nullable    T getObject() throws Exception;    /*** Return the type of object that this FactoryBean creates,* or {@code null} if not known in advance.* &lt;p&gt;This allows one to check for specific types of beans without* instantiating objects, for example on autowiring.* &lt;p&gt;In the case of implementations that are creating a singleton object,* this method should try to avoid singleton creation as far as possible;* it should rather estimate the type in advance.* For prototypes, returning a meaningful type here is advisable too.* &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has* been fully initialized. It must not rely on state created during* initialization; of course, it can still use such state if available.* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return* {@code null} here. Therefore it is highly recommended to implement* this method properly, using the current state of the FactoryBean.* @return the type of object that this FactoryBean creates,* or {@code null} if not known at the time of the call* @see ListableBeanFactory#getBeansOfType*/    @Nullable    Class&lt;?&gt; getObjectType();    /*** Is the object managed by this factory a singleton? That is,* will {@link #getObject()} always return the same object* (a reference that can be cached)?* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,* the object returned from {@code getObject()} might get cached* by the owning BeanFactory. Hence, do not return {@code true}* unless the FactoryBean always exposes the same reference.* &lt;p&gt;The singleton status of the FactoryBean itself will generally* be provided by the owning BeanFactory; usually, it has to be* defined as singleton there.* &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning {@code false} does not* necessarily indicate that returned objects are independent instances.* An implementation of the extended {@link SmartFactoryBean} interface* may explicitly indicate independent instances through its* {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}* implementations which do not implement this extended interface are* simply assumed to always return independent instances if the* {@code isSingleton()} implementation returns {@code false}.* &lt;p&gt;The default implementation returns {@code true}, since a* {@code FactoryBean} typically manages a singleton instance.* @return whether the exposed object is a singleton* @see #getObject()* @see SmartFactoryBean#isPrototype()*/    default boolean isSingleton() {        return true;    }}</code></pre><h4 id="②创建类UserFactoryBean"><a href="#②创建类UserFactoryBean" class="headerlink" title="②创建类UserFactoryBean"></a>②创建类UserFactoryBean</h4><p>FactoryBean是一个接口，需要创建一个类实现该接口</p><p>其中有三个方法：</p><ul><li>getObject()：通过一个对象交给IOC容器管理</li><li>getObjectType()：设置所提供对象的类型</li><li>isSingleton()：所提供的对象是否单例</li></ul><p>当把FactoryBean的实现类配置为bean时，会<strong>将当前类中getObject()所返回的对象交给IOC容器管理</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserFactoryBean implements FactoryBean&lt;User&gt; {    @Override    public User getObject() throws Exception {        return new User();    }    @Override    public Class&lt;?&gt; getObjectType() {        return User.class;    }}</code></pre><h4 id="③配置bean-2"><a href="#③配置bean-2" class="headerlink" title="③配置bean"></a>③配置bean</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="user" class="com.atguigu.bean.UserFactoryBean"&gt;&lt;/bean&gt;</code></pre><h4 id="④测试-2"><a href="#④测试-2" class="headerlink" title="④测试"></a>④测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testUserFactoryBean(){    //获取IOC容器    ApplicationContext ac = new ClassPathXmlApplicationContext("spring-factorybean.xml");    User user = (User) ac.getBean("user");    System.out.println(user);}</code></pre><h3 id="2-2-14、实验十四：基于xml的自动装配"><a href="#2-2-14、实验十四：基于xml的自动装配" class="headerlink" title="2.2.14、实验十四：基于xml的自动装配"></a>2.2.14、实验十四：基于xml的自动装配</h3><blockquote><p>自动装配：</p><p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型<strong>属性赋值</strong></p></blockquote><h4 id="①场景模拟"><a href="#①场景模拟" class="headerlink" title="①场景模拟"></a>①场景模拟</h4><ol><li>创建类UserController</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserController {    // 原写法：private UserService userService = new UserServiceImpl();    private UserService userService;    public void setUserService(UserService userService) {        this.userService = userService;    }    public void saveUser() {        userService.saveUser();    }}</code></pre><ol start="2"><li>创建接口UserService</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {void saveUser();}</code></pre><p>创建类UserServiceImpl实现接口UserService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService {    // 原写法：private UserDao userDao = new UserDaoImpl();    private UserDao userDao;    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    @Override    public void saveUser() {        userDao.saveUser();    }}</code></pre><ol start="3"><li>创建接口UserDao</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {void saveUser();}</code></pre><p>创建类UserDaoImpl实现接口UserDao</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserDaoImpl implements UserDao {    @Override    public void saveUser() {        System.out.println("保存成功");    }}</code></pre><p><em>不使用自动装配：</em></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController" class="com.atguigu.spring.controller.UserController" autowire="byName"&gt;    &lt;property name="userService" ref="userService"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.atguigu.spring.service.impl.UserServiceImpl" autowire="byName"&gt;    &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userDao" class="com.atguigu.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre><blockquote><p>好处：</p><p>与<strong>JavaWeb原生</strong>在实现类中对对象属性进行赋值相比，在<strong>IOC中配置</strong>更灵活。若对象UserServiceImpl、UserDaoImpl更换为其他实现类，可以直接修改ref，不需要到原文件中修改。</p></blockquote><h4 id="②配置bean-2"><a href="#②配置bean-2" class="headerlink" title="②配置bean"></a>②配置bean</h4><p>使用bean标签的autowire属性设置自动装配效果</p><p>自动装配的策略：</p><ul><li>no，default：表示不装配，即bean中的属性不会自动匹配某个bean为属性赋值，此时属性使用默认值</li><li>byType：根据要赋值的属性的类型，在IOC容器中匹配某个bean，为属性赋值</li></ul><p><strong>1.自动装配方式：byType</strong></p><p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p><p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null</p><p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController"class="com.atguigu.autowire.xml.controller.UserController" autowire="byType"&gt;&lt;/bean&gt;&lt;bean id="userService"class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byType"&gt;&lt;/bean&gt;&lt;bean id="userDao" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre><p><strong>2.自动装配方式：byName</strong></p><p>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id="userController" class="com.atguigu.autowire.xml.controller.UserController" autowire="byName"&gt;&lt;!-- 装配id="userService" --&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byName"&gt;&lt;/bean&gt;&lt;bean id="userServiceImpl" class="com.atguigu.autowire.xml.service.impl.UserServiceImpl" autowire="byName"&gt;&lt;!-- 装配id="userDao" --&gt;&lt;/bean&gt;&lt;bean id="userDao" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userDaoImpl" class="com.atguigu.autowire.xml.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre><h4 id="③测试-2"><a href="#③测试-2" class="headerlink" title="③测试"></a>③测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testAutoWireByXML(){    ApplicationContext ac = new ClassPathXmlApplicationContext("autowire-xml.xml");    UserController userController = ac.getBean(UserController.class);    userController.saveUser();}</code></pre><h2 id="2-3、基于注解管理bean"><a href="#2-3、基于注解管理bean" class="headerlink" title="2.3、基于注解管理bean"></a>2.3、基于注解管理bean</h2><h3 id="2-3-1、实验一：标记与扫描"><a href="#2-3-1、实验一：标记与扫描" class="headerlink" title="2.3.1、实验一：标记与扫描"></a>2.3.1、实验一：标记与扫描</h3><h4 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</p><p>本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p><p>举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</p><p><img src="11.png" alt="11"></p><p>班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。</p><h4 id="扫描的概念"><a href="#扫描的概念" class="headerlink" title="扫描的概念"></a>扫描的概念</h4><p>Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p><h4 id="①新建Maven-Module"><a href="#①新建Maven-Module" class="headerlink" title="①新建Maven Module"></a>①新建Maven Module</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="②创建Spring配置文件"><a href="#②创建Spring配置文件" class="headerlink" title="②创建Spring配置文件"></a>②创建Spring配置文件</h4><p><img src="12.png" alt="12"></p><h4 id="标识组件的常用注解"><a href="#标识组件的常用注解" class="headerlink" title="标识组件的常用注解"></a>标识组件的常用注解</h4><blockquote><p>@Component：将类标识为普通组件 </p><p>@Controller：将类标识为控制层组件 </p><p>@Service：将类标识为业务层组件 </p><p>@Repository：将类标识为持久层组件</p></blockquote><p>问：以上四个注解有什么关系和区别？</p><p><img src="13.png" alt="13"></p><p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是<strong>在@Component注解的基础上起了三个新的名字</strong>。</p><p>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p><p>注意：虽然它们<strong>本质上一样</strong>，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p><blockquote><h5 id="补充：组件所对应的bean的id"><a href="#补充：组件所对应的bean的id" class="headerlink" title="补充：组件所对应的bean的id"></a>补充：组件所对应的bean的id</h5><p>在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，<strong>每个组件仍然应该有一个唯一标识</strong>。</p><ol><li><p>默认情况：类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。</p></li><li><p>自定义bean的id：可通过标识组件的注解的value属性设置自定义的bean的id（不常用）</p></li></ol><p>​<code>@Service("service")</code>// 默认为userServiceImpl   public class UserServiceImpl implements UserService {}</p></blockquote><h4 id="③创建组件"><a href="#③创建组件" class="headerlink" title="③创建组件"></a>③创建组件</h4><p>创建控制层组件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController {}</code></pre><p>创建接口UserService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {}</code></pre><p>创建业务层组件UserServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class UserServiceImpl implements UserService {}</code></pre><p>创建接口UserDao</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {}</code></pre><p>创建持久层组件UserDaoImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repositorypublic class UserDaoImpl implements UserDao {}</code></pre><h4 id="④扫描组件"><a href="#④扫描组件" class="headerlink" title="④扫描组件"></a>④扫描组件</h4><p>情况一：最基本的扫描方式</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.spring"&gt;&lt;/context:component-scan&gt;</code></pre><p>情况二：指定要排除的组件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.spring"&gt;    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;    &lt;!--        type：设置排除或包含的依据        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名    --&gt;    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;    &lt;!--&lt;context:exclude-filter type="assignable"expression="com.atguigu.controller.UserController"/&gt;--&gt;&lt;/context:component-scan&gt;</code></pre><p>情况三：仅扫描指定组件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 --&gt;&lt;context:component-scan base-package="com.atguigu.spring" use-default-filters="false"&gt;    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;    &lt;!--        type：设置排除或包含的依据        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名     --&gt;    &lt;context:include-filter type="annotation"expression="org.springframework.stereotype.Controller"/&gt;    &lt;!--&lt;context:include-filter type="assignable"expression="com.atguigu.controller.UserController"/&gt;--&gt;&lt;/context:component-scan&gt;</code></pre><h4 id="⑤测试-1"><a href="#⑤测试-1" class="headerlink" title="⑤测试"></a>⑤测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testAutowireByAnnotation(){    ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");    UserController userController = ioc.getBean(UserController.class);    System.out.println(userController);    UserService userService = ioc.getBean(UserService.class);    System.out.println(userService);    UserDao userDao = ioc.getBean(UserDao.class);    System.out.println(userDao);}</code></pre><h3 id="2-3-2、实验二：基于注解的自动装配"><a href="#2-3-2、实验二：基于注解的自动装配" class="headerlink" title="2.3.2、实验二：基于注解的自动装配"></a>2.3.2、实验二：基于注解的自动装配</h3><h4 id="①场景模拟-1"><a href="#①场景模拟-1" class="headerlink" title="①场景模拟"></a>①场景模拟</h4><p>参考基于xml的自动装配：</p><p>在UserController中声明UserService对象</p><p>在UserServiceImpl中声明UserDao对象</p><h4 id="②-Autowired注解"><a href="#②-Autowired注解" class="headerlink" title="②@Autowired注解"></a>②@Autowired注解</h4><p>在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController {    @Autowired    private UserService userService;    public void saveUser(){        userService.saveUser();    }}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserService {    void saveUser();}@Servicepublic class UserServiceImpl implements UserService {    @Autowired    private UserDao userDao;    @Override    public void saveUser() {        userDao.saveUser();    }}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserDao {void saveUser();}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repositorypublic class UserDaoImpl implements UserDao {    @Override    public void saveUser() {        System.out.println("保存成功");    }}</code></pre><blockquote><p>@Autowired注解还可以标记在 构造器 和 set 方法上</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController { private UserService userService; @Autowired public UserController(UserService userService){     this.userService = userService; } public void saveUser(){     userService.saveUser(); }}</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController { private UserService userService; @Autowired public void setUserService(UserService userService){     this.userService = userService; } public void saveUser(){     userService.saveUser(); }}</code></pre></blockquote><h4 id="③-Autowired工作流程"><a href="#③-Autowired工作流程" class="headerlink" title="③@Autowired工作流程"></a>③@Autowired工作流程</h4><p><img src="14.png" alt="14"></p><ul><li>首先根据所需要的组件类型到IOC容器中查找（默认使用byType方式）<ul><li>能够找到唯一的bean：直接执行装配</li><li>如果完全找不到匹配这个类型的bean：装配失败</li><li>和所需类型匹配的bean不止一个<ul><li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配（使用byName方式）<ul><li>能够找到：执行装配</li><li>找不到：装配失败</li></ul></li><li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配<ul><li>能够找到：执行装配</li><li>找不到：装配失败</li></ul></li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController {    @Autowired    @Qualifier("userServiceImpl")    private UserService userService;    public void saveUser(){        userService.saveUser();    }}</code></pre><blockquote><p>@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败。</p><p>可以将属性required的值设置为true，则表示能装就装，装不上就不装，自动装配的属性为默认值</p><p>但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。</p></blockquote><h1 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h1><h2 id="3-1、场景模拟"><a href="#3-1、场景模拟" class="headerlink" title="3.1、场景模拟"></a>3.1、场景模拟</h2><h3 id="3-1-1、声明接口"><a href="#3-1-1、声明接口" class="headerlink" title="3.1.1、声明接口"></a>3.1.1、声明接口</h3><p>声明计算器接口Calculator，包含加减乘除的抽象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Calculator {    int add(int i, int j);    int sub(int i, int j);    int mul(int i, int j);    int div(int i, int j);}</code></pre><h3 id="3-1-2、创建实现类"><a href="#3-1-2、创建实现类" class="headerlink" title="3.1.2、创建实现类"></a>3.1.2、创建实现类</h3><p><img src="15.png" alt="15"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorPureImpl implements Calculator {    @Override    public int add(int i, int j) {        int result = i + j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int sub(int i, int j) {        int result = i - j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int mul(int i, int j) {        int result = i * j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int div(int i, int j) {        int result = i / j;        System.out.println("方法内部 result = " + result);        return result;    }}</code></pre><h3 id="3-1-3、创建带日志功能的实现类"><a href="#3-1-3、创建带日志功能的实现类" class="headerlink" title="3.1.3、创建带日志功能的实现类"></a>3.1.3、创建带日志功能的实现类</h3><p><img src="16.png" alt="16"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorLogImpl implements Calculator {    @Override    public int add(int i, int j) {        System.out.println("[日志] add 方法开始了，参数是：" + i + "," + j);        int result = i + j;        System.out.println("方法内部 result = " + result);        System.out.println("[日志] add 方法结束了，结果是：" + result);        return result;    }    @Override    public int sub(int i, int j) {        System.out.println("[日志] sub 方法开始了，参数是：" + i + "," + j);        int result = i - j;        System.out.println("方法内部 result = " + result);        System.out.println("[日志] sub 方法结束了，结果是：" + result);        return result;    }    @Override    public int mul(int i, int j) {        System.out.println("[日志] mul 方法开始了，参数是：" + i + "," + j);        int result = i * j;        System.out.println("方法内部 result = " + result);        System.out.println("[日志] mul 方法结束了，结果是：" + result);        return result;    }    @Override    public int div(int i, int j) {        System.out.println("[日志] div 方法开始了，参数是：" + i + "," + j);        int result = i / j;        System.out.println("方法内部 result = " + result);        System.out.println("[日志] div 方法结束了，结果是：" + result);        return result;    }}</code></pre><h3 id="3-1-4、提出问题"><a href="#3-1-4、提出问题" class="headerlink" title="3.1.4、提出问题"></a>3.1.4、提出问题</h3><h4 id="①现有代码缺陷"><a href="#①现有代码缺陷" class="headerlink" title="①现有代码缺陷"></a>①现有代码缺陷</h4><p>针对带日志功能的实现类，我们发现有如下缺陷：</p><ul><li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li><li>附加功能分散在各个业务功能方法中，不利于统一维护</li></ul><h4 id="②解决思路"><a href="#②解决思路" class="headerlink" title="②解决思路"></a>②解决思路</h4><p>解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p><h4 id="③困难"><a href="#③困难" class="headerlink" title="③困难"></a>③困难</h4><p>解决问题的困难：要抽取的代码在方法内部且分散，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。</p><h2 id="3-2、代理模式"><a href="#3-2、代理模式" class="headerlink" title="3.2、代理模式"></a>3.2、代理模式</h2><h3 id="3-2-1、概念"><a href="#3-2-1、概念" class="headerlink" title="3.2.1、概念"></a>3.2.1、概念</h3><h4 id="①介绍"><a href="#①介绍" class="headerlink" title="①介绍"></a>①介绍</h4><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p><img src="17.png" alt="17"></p><p>使用代理后：</p><p><img src="18.png" alt="18"></p><h4 id="②生活中的代理"><a href="#②生活中的代理" class="headerlink" title="②生活中的代理"></a>②生活中的代理</h4><ul><li>广告商找大明星拍广告需要经过经纪人</li><li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li><li>房产中介是买卖双方的代理</li></ul><h4 id="③相关术语"><a href="#③相关术语" class="headerlink" title="③相关术语"></a>③相关术语</h4><ul><li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>目标：被代理“套用”了非核心逻辑代码的类、对象、方法。</li></ul><h3 id="3-2-2、静态代理"><a href="#3-2-2、静态代理" class="headerlink" title="3.2.2、静态代理"></a>3.2.2、静态代理</h3><p>创建静态代理类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CalculatorStaticProxy implements Calculator {    // 将被代理的目标对象声明为成员变量    private Calculator target;    public CalculatorStaticProxy(Calculator target) {        this.target = target;    }    @Override    public int add(int i, int j) {        // 附加功能由代理类中的代理方法来实现        System.out.println("[日志] add 方法开始了，参数是：" + i + "," + j);        // 通过目标对象来实现核心业务逻辑        int addResult = target.add(i, j);        System.out.println("[日志] add 方法结束了，结果是：" + addResult);        return addResult;    }}</code></pre><blockquote><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p><p>提出进一步的需求：<strong>将日志功能集中到一个代理类</strong>中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p></blockquote><h3 id="3-2-3、动态代理"><a href="#3-2-3、动态代理" class="headerlink" title="3.2.3、动态代理"></a>3.2.3、动态代理</h3><p><img src="19.png" alt="19"></p><p>生产代理对象的工厂类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ProxyFactory {    private Object target;    public ProxyFactory(Object target) {        this.target = target;    }        public Object getProxy(){        /**         * newProxyInstance()：创建一个代理实例         * 其中有三个参数：         * 1、classLoader：加载动态生成的代理类的类加载器         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法         */        ClassLoader classLoader = this.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                /**                 * proxy：代理对象                 * method：代理对象需要实现的方法，即其中需要重写的方法                 * args：method所对应方法的参数                 */                Object result = null;                try {                    System.out.println("[动态代理][日志] "+method.getName()+"，参数："+ Arrays.toString(args));                result = method.invoke(target, args);                System.out.println("[动态代理][日志] "+method.getName()+"，结果："+ result);                 } catch (Exception e) {                    e.printStackTrace();                    System.out.println("[动态代理][日志] "+method.getName()+"，异常："+ e.getMessage());                  } finally {                     System.out.println("[动态代理][日志] "+method.getName()+"，方法执行完毕");                  }                  return result;            }           };                return Proxy.newProxyInstance(classLoader, interfaces,invocationHandler);    }}                                     </code></pre><blockquote><p>动态代理有两种：</p><ol><li><p>jdk动态代理，要求必须有接口，最终生成的代理类和目标类实现相同的接口。在com.sun.proxy包下，类名为$proxy2</p></li><li><p>cglib动态代理，最终生成的代理类会继承目标类，并且和目标类在相同的包下</p></li></ol><p>jdk动态代理无法很好的兼容组件扫描，但是cglib可以直接将动态代理类生成在目标类路径下，扫描包时可以直接一起扫描</p></blockquote><h3 id="3-2-4、测试"><a href="#3-2-4、测试" class="headerlink" title="3.2.4、测试"></a>3.2.4、测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDynamicProxy(){    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());    Calculator proxy = (Calculator) factory.getProxy();    proxy.div(1,0);    //proxy.div(1,1);}</code></pre><h2 id="3-3、AOP概念及相关术语"><a href="#3-3、AOP概念及相关术语" class="headerlink" title="3.3、AOP概念及相关术语"></a>3.3、AOP概念及相关术语</h2><h3 id="3-3-1、概述"><a href="#3-3-1、概述" class="headerlink" title="3.3.1、概述"></a>3.3.1、概述</h3><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在<strong>不修改源代码的情况下给程序动态统一添加额外功能</strong>的一种技术。</p><h3 id="3-3-2、相关术语"><a href="#3-3-2、相关术语" class="headerlink" title="3.3.2、相关术语"></a>3.3.2、相关术语</h3><h4 id="①横切关注点"><a href="#①横切关注点" class="headerlink" title="①横切关注点"></a>①横切关注点</h4><p>从每个方法中抽取出来的<strong>同一类非核心业务</strong>。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p><p>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<img src="20.png" alt="20"></p><h4 id="②通知"><a href="#②通知" class="headerlink" title="②通知"></a>②通知</h4><p>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li><li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li><li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li><li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所</li></ul><p>有位置<img src="21.png" alt="21"></p><h4 id="③切面"><a href="#③切面" class="headerlink" title="③切面"></a>③切面</h4><p>封装通知方法的类。<img src="22.png" alt="22"></p><h4 id="④目标"><a href="#④目标" class="headerlink" title="④目标"></a>④目标</h4><p>被代理的目标对象。</p><h4 id="⑤代理"><a href="#⑤代理" class="headerlink" title="⑤代理"></a>⑤代理</h4><p>向目标对象应用通知之后创建的代理对象。</p><h4 id="⑥连接点"><a href="#⑥连接点" class="headerlink" title="⑥连接点"></a>⑥连接点</h4><p>这也是一个纯逻辑概念，不是语法定义的。</p><p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</p><p><img src="23.png" alt="23"></p><h4 id="⑦切入点"><a href="#⑦切入点" class="headerlink" title="⑦切入点"></a>⑦切入点</h4><p>定位连接点的方式。</p><p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。</p><p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p><p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。</p><p>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><h3 id="3-3-3、作用"><a href="#3-3-3、作用" class="headerlink" title="3.3.3、作用"></a>3.3.3、作用</h3><ul><li><p>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</p></li><li><p>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</p></li></ul><h2 id="3-4、基于注解的AOP"><a href="#3-4、基于注解的AOP" class="headerlink" title="3.4、基于注解的AOP"></a>3.4、基于注解的AOP</h2><h3 id="3-4-1、技术说明"><a href="#3-4-1、技术说明" class="headerlink" title="3.4.1、技术说明"></a>3.4.1、技术说明</h3><p><img src="24.png" alt="24"></p><ul><li><p>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</p></li><li><p>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p></li><li><p>AspectJ：本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</p></li></ul><h3 id="3-4-2、准备工作"><a href="#3-4-2、准备工作" class="headerlink" title="3.4.2、准备工作"></a>3.4.2、准备工作</h3><h4 id="①添加依赖"><a href="#①添加依赖" class="headerlink" title="①添加依赖"></a>①添加依赖</h4><p>在IOC所需依赖基础上再加入下面依赖即可：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="②准备被代理的目标资源"><a href="#②准备被代理的目标资源" class="headerlink" title="②准备被代理的目标资源"></a>②准备被代理的目标资源</h4><p>接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Calculator {    int add(int i, int j);    int sub(int i, int j);    int mul(int i, int j);    int div(int i, int j);}</code></pre><p>实现类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class CalculatorPureImpl implements Calculator {    @Override    public int add(int i, int j) {        int result = i + j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int sub(int i, int j) {        int result = i - j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int mul(int i, int j) {        int result = i * j;        System.out.println("方法内部 result = " + result);        return result;    }    @Override    public int div(int i, int j) {        int result = i / j;        System.out.println("方法内部 result = " + result);        return result;    }}</code></pre><h3 id="3-4-3、创建切面类并配置（总）"><a href="#3-4-3、创建切面类并配置（总）" class="headerlink" title="3.4.3、创建切面类并配置（总）"></a>3.4.3、创建切面类并配置（总）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect {    @Before("execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))")    //@Before("execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))")public void beforeMethod(JoinPoint joinPoint){        //获取连接点所对应方法的签名信息        String signature = joinPoint.getSignature();        //获取连接点所对应方法的参数        String args = Arrays.toString(joinPoint.getArgs());        System.out.println("Logger--&gt;前置通知，方法名："+signature.getName()+"，参数："+args);}        @After("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")public void afterMethod(JoinPoint joinPoint){String methodName = joinPoint.getSignature().getName();System.out.println("Logger--&gt;后置通知，方法名："+methodName);}        @AfterReturning(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")public void afterReturningMethod(JoinPoint joinPoint, Object result){String methodName = joinPoint.getSignature().getName();System.out.println("Logger--&gt;返回通知，方法名："+methodName+"，结果："+result);}         @AfterThrowing(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){String methodName = joinPoint.getSignature().getName();System.out.println("Logger--&gt;异常通知，方法名："+methodName+"，异常："+ex);}        @Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")public Object aroundMethod(ProceedingJoinPoint joinPoint){        String methodName = joinPoint.getSignature().getName();String args = Arrays.toString(joinPoint.getArgs());Object result = null;        try {            System.out.println("环绕通知--&gt;目标对象方法执行之前");            //目标对象（连接点）方法的执行            result = joinPoint.proceed();            System.out.println("环绕通知--&gt;目标对象方法返回值之后");} catch (Throwable throwable) {            throwable.printStackTrace();            System.out.println("环绕通知--&gt;目标对象方法出现异常时");} finally {System.out.println("环绕通知--&gt;目标对象方法执行完毕");}return result;}}</code></pre><p>在Spring的配置文件中配置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">  &lt;!--       基于注解的AOP的实现：       1、将目标对象和切面交给IOC容器管理（注解+扫描）       2、开启AspectJ的自动代理，为目标对象自动生成代理       3、将切面类通过注解@Aspect标识--&gt;&lt;context:component-scan base-package="com.atguigu.aop.annotation"&gt;&lt;/context:component-scan&gt;&lt;!-- 开启基于注解的AOP --&gt;&lt;aop:aspectj-autoproxy /&gt;</code></pre><h3 id="3-4-4、各种通知"><a href="#3-4-4、各种通知" class="headerlink" title="3.4.4、各种通知"></a>3.4.4、各种通知</h3><ul><li>前置通知：使用@Before注解标识，在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：使用@AfterReturning注解标识，在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li><li>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li><li>后置通知：使用@After注解标识，在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）<code>finally字句中执行</code></li><li>环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li></ul><blockquote><p>各种通知的执行顺序：</p><ul><li>Spring版本5.3.x以前：<ul><li>前置通知</li><li>目标操作</li><li>后置通知</li><li>返回通知或异常通知</li></ul></li><li>Spring版本5.3.x以后：<ul><li>前置通知</li><li>目标操作</li><li>返回通知或异常通知</li><li>后置通知</li></ul></li></ul></blockquote><h3 id="3-4-5、切入点表达式语法"><a href="#3-4-5、切入点表达式语法" class="headerlink" title="3.4.5、切入点表达式语法"></a>3.4.5、切入点表达式语法</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><p><img src="25.png" alt="25"></p><h4 id="②语法细节"><a href="#②语法细节" class="headerlink" title="②语法细节"></a>②语法细节</h4><ul><li>用*号代替“权限修饰符”和“返回值”部分 表示“权限修饰符”和“返回值”不限</li><li>在包名的部分，一个“<em>”号只能代表包的层次结构中的一层，表示这一层是任意的。</em><ul><li><em>例如：</em>.Hello匹配com.Hello，不匹配com.atguigu.Hello</li></ul></li><li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意*</li><li><em>在类名的部分，类名部分整体用</em>号代替，表示类名任意</li><li>在类名的部分，可以使用<em>号代替类名的一部分</em><ul><li><em>例如：</em>Service匹配所有名称以Service结尾的类或接口</li></ul></li><li>在方法名部分，可以使用<em>号表示方法名任意</em></li><li><em>在方法名部分，可以使用</em>号代替方法名的一部分<ul><li>例如：*Operation匹配所有方法名以Operation结尾的方法</li></ul></li><li>​在方法参数列表部分，使用(..)表示参数列表任意</li><li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li><li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的<ul><li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li></ul></li><li>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符<ul><li>例如：execution(public int <em>..<em>Service.</em>(.., int)) 正确</em></li><li><em>例如：execution(</em> int *..<em>Service.</em>(.., int)) 错误</li></ul></li></ul><p><img src="26.png" alt="26"></p><h3 id="3-4-6、复用切入点表达式"><a href="#3-4-6、复用切入点表达式" class="headerlink" title="3.4.6、复用切入点表达式"></a>3.4.6、复用切入点表达式</h3><h4 id="①声明"><a href="#①声明" class="headerlink" title="①声明"></a>①声明</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Pointcut("execution(* com.atguigu.aop.annotation.*.*(..))")public void pointCut(){}</code></pre><h4 id="②在同一个切面中使用"><a href="#②在同一个切面中使用" class="headerlink" title="②在同一个切面中使用"></a>②在同一个切面中使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("pointCut()")public void beforeMethod(JoinPoint joinPoint){    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);}</code></pre><h4 id="③在不同切面中使用"><a href="#③在不同切面中使用" class="headerlink" title="③在不同切面中使用"></a>③在不同切面中使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("com.atguigu.aop.CommonPointCut.pointCut()") // 使用在com.atguigu.aop.CommonPointCut包中的poinCutpublic void beforeMethod(JoinPoint joinPoint){    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);}</code></pre><h3 id="3-4-7、获取通知的相关信息"><a href="#3-4-7、获取通知的相关信息" class="headerlink" title="3.4.7、获取通知的相关信息"></a>3.4.7、获取通知的相关信息</h3><h4 id="①获取连接点信息"><a href="#①获取连接点信息" class="headerlink" title="①获取连接点信息"></a>①获取连接点信息</h4><p>获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Before("execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))")public void beforeMethod(JoinPoint joinPoint){    //获取连接点的签名信息    String methodName = joinPoint.getSignature().getName();    //获取目标方法到的实参信息    String args = Arrays.toString(joinPoint.getArgs());    System.out.println("Logger--&gt;前置通知，方法名："+methodName+"，参数："+args);}</code></pre><h4 id="②获取目标方法的返回值"><a href="#②获取目标方法的返回值" class="headerlink" title="②获取目标方法的返回值"></a>②获取目标方法的返回值</h4><p>@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterReturning(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")    public void afterReturningMethod(JoinPoint joinPoint, Object result){    String methodName = joinPoint.getSignature().getName();    System.out.println("Logger--&gt;返回通知，方法名："+methodName+"，结果："+result);}</code></pre><h4 id="③获取目标方法的异常"><a href="#③获取目标方法的异常" class="headerlink" title="③获取目标方法的异常"></a>③获取目标方法的异常</h4><p>@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AfterThrowing(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){    String methodName = joinPoint.getSignature().getName();    System.out.println("Logger--&gt;异常通知，方法名："+methodName+"，异常："+ex);}</code></pre><h3 id="3-4-8、环绕通知"><a href="#3-4-8、环绕通知" class="headerlink" title="3.4.8、环绕通知"></a>3.4.8、环绕通知</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")public Object aroundMethod(ProceedingJoinPoint joinPoint){    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    Object result = null;    try {        System.out.println("环绕通知--&gt;目标对象方法执行之前");        //目标方法的执行，目标方法的返回值一定要返回给外界调用者        result = joinPoint.proceed();        System.out.println("环绕通知--&gt;目标对象方法返回值之后");    } catch (Throwable throwable) {        throwable.printStackTrace();        System.out.println("环绕通知--&gt;目标对象方法出现异常时");    } finally {        System.out.println("环绕通知--&gt;目标对象方法执行完毕");    }    return result;}</code></pre><h3 id="3-4-9、切面的优先级"><a href="#3-4-9、切面的优先级" class="headerlink" title="3.4.9、切面的优先级"></a>3.4.9、切面的优先级</h3><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><p><img src="27.png" alt="27"></p><p>优先级高的先执行</p><h2 id="3-5、基于XML的AOP（了解）"><a href="#3-5、基于XML的AOP（了解）" class="headerlink" title="3.5、基于XML的AOP（了解）"></a>3.5、基于XML的AOP（了解）</h2><h3 id="3-5-1、准备工作"><a href="#3-5-1、准备工作" class="headerlink" title="3.5.1、准备工作"></a>3.5.1、准备工作</h3><p>参考基于注解的AOP环境</p><h3 id="3-5-2、实现"><a href="#3-5-2、实现" class="headerlink" title="3.5.2、实现"></a>3.5.2、实现</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;context:component-scan base-package="com.atguigu.aop.xml"&gt;&lt;/context:componentscan&gt;&lt;aop:config&gt;    &lt;!--配置切面类--&gt;    &lt;aop:aspect ref="loggerAspect"&gt;        &lt;aop:pointcut id="pointCut" expression="execution(*com.atguigu.aop.xml.CalculatorImpl.*(..))"/&gt;        &lt;aop:before method="beforeMethod" pointcut-ref="pointCut"&gt;&lt;/aop:before&gt;        &lt;aop:after method="afterMethod" pointcut-ref="pointCut"&gt;&lt;/aop:after&gt;        &lt;aop:after-returning method="afterReturningMethod" returning="result" pointcut-ref="pointCut"&gt;&lt;/aop:after-returning&gt;        &lt;aop:after-throwing method="afterThrowingMethod" throwing="ex" pointcut-ref="pointCut"&gt;&lt;/aop:after-throwing&gt;        &lt;aop:around method="aroundMethod" pointcut-ref="pointCut"&gt;&lt;/aop:around&gt;    &lt;/aop:aspect&gt;    &lt;aop:aspect ref="validateAspect" order="1"&gt;        &lt;aop:before method="validateBeforeMethod" pointcut-ref="pointCut"&gt;        &lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h1 id="4、声明式事务"><a href="#4、声明式事务" class="headerlink" title="4、声明式事务"></a>4、声明式事务</h1><h2 id="4-1、JdbcTemplate"><a href="#4-1、JdbcTemplate" class="headerlink" title="4.1、JdbcTemplate"></a>4.1、JdbcTemplate</h2><h3 id="4-1-1、简介"><a href="#4-1-1、简介" class="headerlink" title="4.1.1、简介"></a>4.1.1、简介</h3><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><h3 id="4-1-2、准备工作"><a href="#4-1-2、准备工作" class="headerlink" title="4.1.2、准备工作"></a>4.1.2、准备工作</h3><h4 id="①加入依赖-1"><a href="#①加入依赖-1" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 持久化层支持jar包 --&gt;    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 测试相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.31&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="②创建jdbc-properties"><a href="#②创建jdbc-properties" class="headerlink" title="②创建jdbc.properties"></a>②创建jdbc.properties</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre><h4 id="③配置Spring的配置文件"><a href="#③配置Spring的配置文件" class="headerlink" title="③配置Spring的配置文件"></a>③配置Spring的配置文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 导入外部属性文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;    &lt;property name="url" value="${atguigu.url}"/&gt;    &lt;property name="driverClassName" value="${atguigu.driver}"/&gt;    &lt;property name="username" value="${atguigu.username}"/&gt;    &lt;property name="password" value="${atguigu.password}"/&gt;&lt;/bean&gt;&lt;!-- 配置 JdbcTemplate --&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;    &lt;!-- 装配数据源 --&gt;    &lt;property name="dataSource" ref="druidDataSource"/&gt;&lt;/bean&gt;</code></pre><h3 id="4-1-3、测试"><a href="#4-1-3、测试" class="headerlink" title="4.1.3、测试"></a>4.1.3、测试</h3><h4 id="①在测试类装配-JdbcTemplate"><a href="#①在测试类装配-JdbcTemplate" class="headerlink" title="①在测试类装配 JdbcTemplate"></a>①在测试类装配 JdbcTemplate</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//指定当前测试类在Spring的测试环境中执行，此时就可以通过注入的方式直接获取IOC容器中bean@RunWith(SpringJUnit4ClassRunner.class)//设置Spring测试环境的配置文件@ContextConfiguration("classpath:spring-jdbc.xml")public class JDBCTemplateTest {    @Autowired    private JdbcTemplate jdbcTemplate;}</code></pre><h4 id="②测试增删改功能"><a href="#②测试增删改功能" class="headerlink" title="②测试增删改功能"></a>②测试增删改功能</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//测试增删改功能public void testUpdate(){    String sql = "insert into t_emp values(null,?,?,?)";    int result = jdbcTemplate.update(sql, "张三", 23, "男");    System.out.println(result);}</code></pre><h4 id="③查询一条数据为实体类对象"><a href="#③查询一条数据为实体类对象" class="headerlink" title="③查询一条数据为实体类对象"></a>③查询一条数据为实体类对象</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//查询一条数据为一个实体类对象public void testSelectEmpById(){    String sql = "select * from t_emp where id = ?";    Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 1);    System.out.println(emp);}</code></pre><h4 id="④查询多条数据为一个list集合"><a href="#④查询多条数据为一个list集合" class="headerlink" title="④查询多条数据为一个list集合"></a>④查询多条数据为一个list集合</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//查询多条数据为一个list集合public void testSelectList(){    String sql = "select * from t_emp";    List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class));    list.forEach(emp -&gt; System.out.println(emp));}</code></pre><h4 id="⑤查询单行单列的值"><a href="#⑤查询单行单列的值" class="headerlink" title="⑤查询单行单列的值"></a>⑤查询单行单列的值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test//查询单行单列的值public void selectCount(){    String sql = "select count(id) from t_emp";    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);    System.out.println(count);}</code></pre><h2 id="4-2、声明式事务概念"><a href="#4-2、声明式事务概念" class="headerlink" title="4.2、声明式事务概念"></a>4.2、声明式事务概念</h2><h3 id="4-2-1、编程式事务"><a href="#4-2-1、编程式事务" class="headerlink" title="4.2.1、编程式事务"></a>4.2.1、编程式事务</h3><p>事务功能的相关操作全部通过自己编写代码来实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn = ...;try {    // 开启事务：关闭事务的自动提交    conn.setAutoCommit(false);    // 核心操作    // 提交事务    conn.commit();}catch(Exception e){    // 回滚事务    conn.rollBack();}finally{    // 释放数据库连接    conn.close();}</code></pre><p>编程式的实现方式存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li><li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li></ul><h3 id="4-2-2、声明式事务"><a href="#4-2-2、声明式事务" class="headerlink" title="4.2.2、声明式事务"></a>4.2.2、声明式事务</h3><p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p><p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p><ul><li>好处1：提高开发效率</li><li>好处2：消除了冗余的代码</li><li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性</li></ul><p>能等各个方面的优化</p><p>所以，我们可以总结下面两个概念：</p><ul><li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li><li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li></ul><h2 id="4-3、基于注解的声明式事务"><a href="#4-3、基于注解的声明式事务" class="headerlink" title="4.3、基于注解的声明式事务"></a>4.3、基于注解的声明式事务</h2><h3 id="4-3-1、准备工作"><a href="#4-3-1、准备工作" class="headerlink" title="4.3.1、准备工作"></a>4.3.1、准备工作</h3><h4 id="①加入依赖-2"><a href="#①加入依赖-2" class="headerlink" title="①加入依赖"></a>①加入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 持久化层支持jar包 --&gt;    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 测试相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.31&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="②创建jdbc-properties-1"><a href="#②创建jdbc-properties-1" class="headerlink" title="②创建jdbc.properties"></a>②创建jdbc.properties</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre><h4 id="③配置Spring的配置文件-1"><a href="#③配置Spring的配置文件-1" class="headerlink" title="③配置Spring的配置文件"></a>③配置Spring的配置文件</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--扫描组件--&gt;&lt;context:component-scan base-package="com.atguigu.spring.tx.annotation"&gt;&lt;/context:component-scan&gt;&lt;!-- 导入外部属性文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;    &lt;property name="url" value="${jdbc.url}"/&gt;    &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;    &lt;property name="username" value="${jdbc.username}"/&gt;    &lt;property name="password" value="${jdbc.password}"/&gt;&lt;/bean&gt;&lt;!-- 配置 JdbcTemplate --&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;    &lt;!-- 装配数据源 --&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;</code></pre><h4 id="④创建表"><a href="#④创建表" class="headerlink" title="④创建表"></a>④创建表</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t_book` (    `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',    `book_name` varchar(20) DEFAULT NULL COMMENT '图书名称',    `price` int(11) DEFAULT NULL COMMENT '价格',    `stock` int(10) unsigned DEFAULT NULL COMMENT '库存（无符号）',    PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,'斗破苍穹',80,100),(2,'斗罗大陆',50,100);CREATE TABLE `t_user` (    `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',    `username` varchar(20) DEFAULT NULL COMMENT '用户名',    `balance` int(10) unsigned DEFAULT NULL COMMENT '余额（无符号）',    PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,'admin',50);</code></pre><h4 id="⑤创建组件"><a href="#⑤创建组件" class="headerlink" title="⑤创建组件"></a>⑤创建组件</h4><p>创建BookController：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class BookController {    @Autowired    private BookService bookService;    public void buyBook(Integer bookId, Integer userId){        bookService.buyBook(bookId, userId);    }}</code></pre><p>创建接口BookService：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookService {void buyBook(Integer bookId, Integer userId);}</code></pre><p>创建实现类BookServiceImpl：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class BookServiceImpl implements BookService {    @Autowired    private BookDao bookDao;    @Override    public void buyBook(Integer bookId, Integer userId) {        //查询图书的价格        Integer price = bookDao.getPriceByBookId(bookId);        //更新图书的库存        bookDao.updateStock(bookId);        //更新用户的余额        bookDao.updateBalance(userId, price);    }}</code></pre><p>创建接口BookDao：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookDao {    Integer getPriceByBookId(Integer bookId);    void updateStock(Integer bookId);    void updateBalance(Integer userId, Integer price);}</code></pre><p>创建实现类BookDaoImpl：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repositorypublic class BookDaoImpl implements BookDao {    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Integer getPriceByBookId(Integer bookId) {        String sql = "select price from t_book where book_id = ?";        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);    }    @Override    public void updateStock(Integer bookId) {        String sql = "update t_book set stock = stock - 1 where book_id = ?";        jdbcTemplate.update(sql, bookId);    }    @Override    public void updateBalance(Integer userId, Integer price) {        String sql = "update t_user set balance = balance - ? where user_id =?";            jdbcTemplate.update(sql, price, userId);    }}</code></pre><h3 id="4-3-2、测试无事务情况"><a href="#4-3-2、测试无事务情况" class="headerlink" title="4.3.2、测试无事务情况"></a>4.3.2、测试无事务情况</h3><h4 id="①创建测试类"><a href="#①创建测试类" class="headerlink" title="①创建测试类"></a>①创建测试类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:tx-annotation.xml")public class TxByAnnotationTest {    // 直接通过注入方式获取IOC中的bean    @Autowired    private BookController bookController;        @Test    public void testBuyBook(){        bookController.buyBook(1, 1);    }}</code></pre><h4 id="②模拟场景"><a href="#②模拟场景" class="headerlink" title="②模拟场景"></a>②模拟场景</h4><p>用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额</p><p>假设用户id为1的用户，购买id为1的图书</p><p>用户余额为50，而图书价格为80</p><p>购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段</p><p>此时执行sql语句会抛出SQLException</p><h4 id="③观察结果"><a href="#③观察结果" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>因为没有添加事务，图书的库存更新了，但是用户的余额没有更新</p><p>显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败</p><h3 id="4-3-3、加入事务"><a href="#4-3-3、加入事务" class="headerlink" title="4.3.3、加入事务"></a>4.3.3、加入事务</h3><h4 id="①添加事务配置"><a href="#①添加事务配置" class="headerlink" title="①添加事务配置"></a>①添加事务配置</h4><p>在Spring的配置文件中添加配置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--配置事务管理器，事务需要数据源--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--    开启事务的注解驱动，相当于一个环绕通知    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;</code></pre><p>注意：导入的名称空间需要 <strong>tx</strong> <strong>结尾</strong>的那个。</p><p><img src="28.png" alt="28"></p><h4 id="②添加事务注解"><a href="#②添加事务注解" class="headerlink" title="②添加事务注解"></a>②添加事务注解</h4><p>因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此<strong>处理事务一般在service层处理</strong></p><p>在BookServiceImpl的buybook()添加注解@Transactional</p><h4 id="③观察结果-1"><a href="#③观察结果-1" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>由于使用了Spring的声明式事务，更新库存和更新余额都没有执行</p><h3 id="4-3-4、-Transactional注解标识的位置"><a href="#4-3-4、-Transactional注解标识的位置" class="headerlink" title="4.3.4、@Transactional注解标识的位置"></a>4.3.4、@Transactional注解标识的位置</h3><p>@Transactional标识在方法上，咋只会影响该方法</p><p>@Transactional标识的类上，咋会影响类中所有的方法</p><h3 id="4-3-5、事务属性：只读"><a href="#4-3-5、事务属性：只读" class="headerlink" title="4.3.5、事务属性：只读"></a>4.3.5、事务属性：只读</h3><h4 id="①介绍-1"><a href="#①介绍-1" class="headerlink" title="①介绍"></a>①介绍</h4><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p><h4 id="②使用方式"><a href="#②使用方式" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) {    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    //System.out.println(1/0);}</code></pre><h4 id="③注意"><a href="#③注意" class="headerlink" title="③注意"></a>③注意</h4><p>对增删改操作设置只读会抛出下面异常：</p><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification</p><p>are not allowed</p><h3 id="4-3-6、事务属性：超时"><a href="#4-3-6、事务属性：超时" class="headerlink" title="4.3.6、事务属性：超时"></a>4.3.6、事务属性：超时</h3><h4 id="①介绍-2"><a href="#①介绍-2" class="headerlink" title="①介绍"></a>①介绍</h4><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p><p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><h4 id="②使用方式-1"><a href="#②使用方式-1" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) {    try {        TimeUnit.SECONDS.sleep(5);    } catch (InterruptedException e) {        e.printStackTrace();    }    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    //System.out.println(1/0);}</code></pre><h4 id="③观察结果-2"><a href="#③观察结果-2" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>执行过程中抛出异常：</p><p>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out:</p><p>deadline was Fri Jun 04 16:25:39 CST 2022</p><h3 id="4-3-7、事务属性：回滚策略"><a href="#4-3-7、事务属性：回滚策略" class="headerlink" title="4.3.7、事务属性：回滚策略"></a>4.3.7、事务属性：回滚策略</h3><h4 id="①介绍-3"><a href="#①介绍-3" class="headerlink" title="①介绍"></a>①介绍</h4><p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。</p><p>可以通过@Transactional中相关属性设置回滚策略</p><ul><li>rollbackFor属性：需要设置一个Class类型的对象</li><li>rollbackForClassName属性：需要设置一个字符串类型的全类名</li><li>noRollbackFor属性：需要设置一个Class类型的对象</li><li>rollbackFor属性：需要设置一个字符串类型的全类名</li></ul><h4 id="②使用方式-2"><a href="#②使用方式-2" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = "java.lang.ArithmeticException")public void buyBook(Integer bookId, Integer userId) {    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    System.out.println(1/0);}</code></pre><h4 id="③观察结果-3"><a href="#③观察结果-3" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当</p><p>出现ArithmeticException不发生回滚，因此购买图书的操作正常执行</p><h3 id="4-3-8、事务属性：事务隔离级别"><a href="#4-3-8、事务属性：事务隔离级别" class="headerlink" title="4.3.8、事务属性：事务隔离级别"></a>4.3.8、事务属性：事务隔离级别</h3><h4 id="①介绍-4"><a href="#①介绍-4" class="headerlink" title="①介绍"></a>①介绍</h4><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事</p><p>务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同</p><p>的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p><p>隔离级别一共有四种：</p><ul><li>读未提交：READ UNCOMMITTED</li></ul><p>允许Transaction01读取Transaction02未提交的修改。</p><ul><li>读已提交：READ COMMITTED、</li></ul><p>要求Transaction01只能读取Transaction02已提交的修改。</p><ul><li>可重复读：REPEATABLE READ</li></ul><p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它</p><p>事务对这个字段进行更新。</p><ul><li>串行化：SERIALIZABLE</li></ul><p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它</p><p>事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p><p>各个隔离级别解决并发问题的能力见下表：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>有</td><td>有</td><td>有</td></tr><tr><td>READ COMMITTED</td><td>无</td><td>有</td><td>有</td></tr><tr><td>REPEATABLE READ</td><td>无</td><td>无</td><td>有</td></tr><tr><td>SERIALIZABLE</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><p>各种数据库产品对事务隔离级别的支持程度：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>Oracle</strong></th><th><strong>MySQL</strong></th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>×</td><td>√</td></tr><tr><td>READ COMMITTED</td><td>√(默认)</td><td>√</td></tr><tr><td>REPEATABLE READ</td><td>×</td><td>√(默认)</td></tr><tr><td>SERIALIZABLE</td><td>√</td><td>√</td></tr></tbody></table><h4 id="②使用方式-3"><a href="#②使用方式-3" class="headerlink" title="②使用方式"></a>②使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化</code></pre><h3 id="4-3-9、事务属性：事务传播行为"><a href="#4-3-9、事务属性：事务传播行为" class="headerlink" title="4.3.9、事务属性：事务传播行为"></a>4.3.9、事务属性：事务传播行为</h3><h4 id="①介绍-5"><a href="#①介绍-5" class="headerlink" title="①介绍"></a>①介绍</h4><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><h4 id="②测试"><a href="#②测试" class="headerlink" title="②测试"></a>②测试</h4><p>创建接口CheckoutService：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CheckoutService {void checkout(Integer userId, Integer[] bookIds);}</code></pre><p>创建实现类CheckoutServiceImpl：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class CheckoutServiceImpl implements CheckoutService {    @Autowired    private BookService bookService;    @Override    @Transactional    //一次购买多本图书    public void checkout(Integer userId, Integer[] bookIds) {        for (Integer bookId : bookIds) {            bookService.buyBook(userId, bookId);        }    }}</code></pre><p>在BookController中添加方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer userId, Integer[] bookIds){    checkoutService.checkout(userId, bookIds);}</code></pre><p>在数据库中将用户的余额修改为100元</p><h4 id="③观察结果-4"><a href="#③观察结果-4" class="headerlink" title="③观察结果"></a>③观察结果</h4><p>可以通过@Transactional中的<strong>propagation属性</strong>设置事务传播行为</p><p>修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性</p><ul><li><p><code>@Transactional(propagation = Propagation.REQUIRED)</code>，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。</p><ul><li>经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了</li></ul></li><li><p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>，表示不管当前线程上是否有已经开启的事务，<strong>都要开启新事务</strong>。</p><ul><li>同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本</li></ul></li></ul><h2 id="4-4、基于XML的声明式事务"><a href="#4-4、基于XML的声明式事务" class="headerlink" title="4.4、基于XML的声明式事务"></a>4.4、基于XML的声明式事务</h2><h3 id="4-3-1、场景模拟"><a href="#4-3-1、场景模拟" class="headerlink" title="4.3.1、场景模拟"></a>4.3.1、场景模拟</h3><p>参考基于注解的声明式事务</p><h3 id="4-3-2、修改Spring配置文件"><a href="#4-3-2、修改Spring配置文件" class="headerlink" title="4.3.2、修改Spring配置文件"></a>4.3.2、修改Spring配置文件</h3><p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:config&gt;    &lt;!-- 配置事务通知和切入点表达式 --&gt;    &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(*com.atguigu.spring.tx.xml.service.impl.*.*(..))"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;&lt;!-- tx:advice标签：配置事务通知 --&gt;&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;&lt;!-- transaction-manager属性：关联事务管理器 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;    &lt;tx:attributes&gt;        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;        &lt;tx:method name="get*" read-only="true"/&gt;        &lt;tx:method name="query*" read-only="true"/&gt;        &lt;tx:method name="find*" read-only="true"/&gt;        &lt;!-- read-only属性：设置只读属性 --&gt;        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;        &lt;!-- timeout属性：设置事务的超时属性 --&gt;        &lt;!-- propagation属性：设置事务的传播行为 --&gt;        &lt;tx:method name="save*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;        &lt;tx:method name="update*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;        &lt;tx:method name="delete*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><blockquote><p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖(需要aop切面，aspectJ可以实现)</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;  &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/07/02/MyBatis/"/>
      <url>/2023/07/02/MyBatis/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20230715115728839.png" alt="image-20230715115728839"></p><h1 id="一、MyBatis"><a href="#一、MyBatis" class="headerlink" title="一、MyBatis"></a>一、MyBatis</h1><h1 id="1、MyBatis简介"><a href="#1、MyBatis简介" class="headerlink" title="1、MyBatis简介"></a>1、MyBatis简介</h1><h3 id="1-1、MyBatis历史"><a href="#1-1、MyBatis历史" class="headerlink" title="1.1、MyBatis历史"></a>1.1、MyBatis历史</h3><p>MyBatis最初是Apache的一个开源项目<strong>iBatis</strong>, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。</p><p>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</p><h3 id="1-2、MyBatis特性"><a href="#1-2、MyBatis特性" class="headerlink" title="1.2、MyBatis特性"></a>1.2、MyBatis特性</h3><p>1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</p><p>2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</p><p>3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</p><p>4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</p><h3 id="1-3、MyBatis下载"><a href="#1-3、MyBatis下载" class="headerlink" title="1.3、MyBatis下载"></a>1.3、MyBatis下载</h3><p>MyBatis下载地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><h3 id="1-4、和其它持久化层技术对比"><a href="#1-4、和其它持久化层技术对比" class="headerlink" title="1.4、和其它持久化层技术对比"></a>1.4、和其它持久化层技术对比</h3><ul><li>JDBC<ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h1 id="2、搭建MyBatis"><a href="#2、搭建MyBatis" class="headerlink" title="2、搭建MyBatis"></a>2、搭建MyBatis</h1><h2 id="2-1、开发环境"><a href="#2-1、开发环境" class="headerlink" title="2.1、开发环境"></a>2.1、开发环境</h2><p>IDE：idea 2019.2</p><p>构建工具：maven 3.5.4</p><p>MySQL版本：MySQL 8</p><p>MyBatis版本：MyBatis 3.5.7</p><blockquote><p>MySQL不同版本的注意事项</p><p>1、驱动类driver-class-name</p><p>MySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.Driver</p><p>MySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver</p><p>2、连接地址url</p><p>MySQL 5版本的url：jdbc:mysql://localhost:3306/ssm</p><p>MySQL 8版本的url：jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC</p><p>否则运行测试用例报告如下错误：</p><p>java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more</p></blockquote><h2 id="2-2、创建maven工程"><a href="#2-2、创建maven工程" class="headerlink" title="2.2、创建maven工程"></a>2.2、创建maven工程</h2><p><strong>①打包方式：jar</strong></p><p><strong>②引入依赖</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;   &lt;!-- Mybatis核心 --&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.mybatis&lt;/groupId&gt;       &lt;artifactId&gt;mybatis&lt;/artifactId&gt;       &lt;version&gt;3.5.7&lt;/version&gt;   &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;   &lt;dependency&gt;       &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;       &lt;scope&gt;test&lt;/scope&gt;   &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;   &lt;dependency&gt;       &lt;groupId&gt;mysql&lt;/groupId&gt;       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;       &lt;version&gt;8.0.16&lt;/version&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="2-3、创建MyBatis的核心配置文件"><a href="#2-3、创建MyBatis的核心配置文件" class="headerlink" title="2.3、创建MyBatis的核心配置文件"></a>2.3、创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p><p>核心配置文件主要用于<strong>配置连接数据库的环境以及MyBatis的全局配置信息（怎样连接数据库）</strong></p><p>核心配置文件存放的位置是src/main/resources目录下</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt;&lt;environments default="development"&gt;&lt;environment id="development"&gt;&lt;transactionManager type="JDBC"/&gt;&lt;dataSource type="POOLED"&gt;&lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;&lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8"/&gt;&lt;property name="username" value="root"/&gt;&lt;property name="password" value="123456"/&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;    &lt;!--引入映射文件--&gt;    &lt;mappers&gt;        &lt;mapper resource="mappers/UserMapper.xml"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="2-4、创建mapper接口"><a href="#2-4、创建mapper接口" class="headerlink" title="2.4、创建mapper接口"></a>2.4、创建mapper接口</h2><blockquote><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。<strong>（怎样操作数据库）</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserMapper {    /**    * 添加用户信息    */    int insertUser();}</code></pre><h2 id="2-5、创建MyBatis的映射文件"><a href="#2-5、创建MyBatis的映射文件" class="headerlink" title="2.5、创建MyBatis的映射文件"></a>2.5、创建MyBatis的映射文件</h2><p>==mapper接口中的方法 —&gt; 对应映射文件中的sql语句==</p><ul><li><p>映射文件的<strong>命名规则</strong>：</p><ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</li></ul></li><li><p>因此一个映射文件对应一个实体类，对应一张表的操作</p><ul><li><p><strong>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></p></li><li><p>MyBatis映射文件存放的位置是src/main/resources/mappers目录下</p></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;    &lt;!--        mapper接口和映射文件要保证两个一致：        1、mapper接口的全类名和映射文件的namespace一致        2、mapper接口中的方法的方法名要和映射文件中的sql的id保持一致    --&gt;    &lt;!--int insertUser();--&gt;    &lt;insert id="insertUser"&gt;    insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><blockquote><p>相关概念：<strong>ORM</strong>（<strong>O</strong>bject <strong>R</strong>elationship <strong>M</strong>apping）对象关系映射。</p><ul><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul><table><thead><tr><th><strong>Java概念</strong></th><th><strong>数据库概念</strong></th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段/列</td></tr><tr><td>对象</td><td>记录/行</td></tr></tbody></table></blockquote><h2 id="2-6、通过junit测试功能"><a href="#2-6、通过junit测试功能" class="headerlink" title="2.6、通过junit测试功能"></a>2.6、通过junit测试功能</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">//读取MyBatis的核心配置文件InputStream is = Resources.getResourceAsStream("mybatis-config.xml");//创建SqlSessionFactoryBuilder对象SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务//SqlSession sqlSession = sqlSessionFactory.openSession();//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交SqlSession sqlSession = sqlSessionFactory.openSession(true);//通过代理模式创建UserMapper接口的代理实现类对象// 此步骤就是找UserMapper接口对应的映射文件UserMapper userMapper = sqlSession.getMapper(UserMapper.class);//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句int result = userMapper.insertUser();//sqlSession.commit();System.out.println("结果："+result);</code></pre><blockquote><ul><li><p>SqlSession：代表Java程序和<strong>数据库</strong>之间的<strong>会话</strong>。（HttpSession是Java程序和浏览器之间的会话）</p></li><li><p>SqlSessionFactory：是“生产”SqlSession的“工厂”。</p></li><li><p>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的</p></li></ul><p>相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</p></blockquote><h2 id="2-7、加入log4j日志功能"><a href="#2-7、加入log4j日志功能" class="headerlink" title="2.7、加入log4j日志功能"></a>2.7、加入log4j日志功能</h2><h3 id="①加入依赖"><a href="#①加入依赖" class="headerlink" title="①加入依赖"></a>①加入依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- log4j日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="②加入log4j的配置文件"><a href="#②加入log4j的配置文件" class="headerlink" title="②加入log4j的配置文件"></a>②加入log4j的配置文件</h3><blockquote><p>log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;&lt;appender name="STDOUT" class="org.apache.log4j.ConsoleAppender"&gt;&lt;param name="Encoding" value="UTF-8" /&gt;&lt;layout class="org.apache.log4j.PatternLayout"&gt;&lt;param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS}%m (%F:%L) \n" /&gt;&lt;/layout&gt;&lt;/appender&gt;&lt;logger name="java.sql"&gt;&lt;level value="debug" /&gt;&lt;/logger&gt;&lt;logger name="org.apache.ibatis"&gt;&lt;level value="info" /&gt;&lt;/logger&gt;&lt;root&gt;&lt;level value="debug" /&gt;&lt;appender-ref ref="STDOUT" /&gt;&lt;/root&gt;&lt;/log4j:configuration&gt;</code></pre><blockquote><p><strong>日志的级别</strong></p><p>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)</p><p>从左到右打印的内容越来越详细</p></blockquote><h1 id="3、核心配置文件详解"><a href="#3、核心配置文件详解" class="headerlink" title="3、核心配置文件详解"></a>3、核心配置文件详解</h1><ul><li>environments</li><li>properties：dataSource属性配置文件</li><li>typeAliases：pojo的类型别名</li><li>mappers：以包的形式引入映射文件</li></ul><blockquote><p>核心配置文件中的标签必须按照固定的顺序：</p><p>properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!--      MyBatis核心配置文件中，标签的顺序：      properties?,settings?,typeAliases?,typeHandlers?,         objectFactory?,objectWrapperFactory?,reflectorFactory?,         plugins?,environments?,databaseIdProvider?,mappers?--&gt;&lt;!--引入properties文件，此后就可以在当前文件dataSource中使用${key}的方式访问value--&gt;&lt;properties resource="jdbc.properties" /&gt;&lt;!--设置类型别名--&gt;&lt;typeAliases&gt;&lt;!--         typeAlias：设置某个类型的别名         属性：             type：设置需要设置别名的类型             alias：设置某个类型的别名，若不设置该属性，那么该类型拥有默认的别名，即 类名 且不区分大小写--&gt;&lt;!--&lt;typeAlias type="com.atguigu.mybatis.pojo.User"&gt;&lt;/typeAlias&gt;--&gt;&lt;!--以包为单位，将包下所有的类型设置默认的类型别名，即 类名 且不区分大小写--&gt;&lt;package name="com.atguigu.mybatis.pojo"/&gt;&lt;/typeAliases&gt;&lt;!--environments：配置多个连接数据库的环境属性：default：设置默认使用的环境的id--&gt;&lt;environments default="development"&gt;     &lt;!--            environment：配置某个具体的环境            属性：             id：表示连接数据库的环境的唯一标识，不能重复     --&gt;&lt;environment id="development"&gt;         &lt;!--             transactionManager：设置事务管理方式             属性：                 type="JDBC|MANAGED"                 JDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事务的提交或回滚需要手动处理                 MANAGED：被管理，例如Spring         --&gt;&lt;transactionManager type="JDBC"/&gt;&lt;!--dataSource：配置数据源属性：           type：设置数据源的类型              type="POOLED|UNPOOLED|JNDI"                 POOLED：表示使用数据库连接池缓存数据库连接                 UNPOOLED：表示不使用数据库连接池                 JNDI：表示使用上下文中的数据源--&gt;&lt;dataSource type="POOLED"&gt;                &lt;!--设置连接数据库的驱动--&gt;                &lt;property name="driver" value="${jdbc.driver}"/&gt;                &lt;!--设置连接数据库的连接地址--&gt;                &lt;property name="url" value="${jdbc.url}"/&gt;                &lt;!--设置连接数据库的用户名--&gt;                &lt;property name="username" value="${jdbc.username}"/&gt;                &lt;!--设置连接数据库的密码--&gt;                &lt;property name="password" value="${jdbc.password}"/&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;environment id="test"&gt;         &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;                &lt;property name="url"value="jdbc:mysql://localhost:3306/ssmserverTimezone=UTC"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="123456"/&gt;            &lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;!--引入映射文件--&gt;&lt;mappers&gt;&lt;!--&lt;mapper resource="mappers/UserMapper.xml"/&gt;--&gt;&lt;!--      以包为单位引入映射文件         要求：         1、mapper接口所在的包要和映射文件所在的包一致         2、mapper接口要和映射文件的名字一致--&gt;&lt;package name="com.atguigu.mybatis.mapper"/&gt;&lt;/mappers&gt;&lt;/configuration&gt;</code></pre></blockquote><h1 id="4、MyBatis的增删改查"><a href="#4、MyBatis的增删改查" class="headerlink" title="4、MyBatis的增删改查"></a>4、MyBatis的增删改查</h1><h2 id="4-1、新增"><a href="#4-1、新增" class="headerlink" title="4.1、新增"></a>4.1、新增</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int insertUser();--&gt;&lt;insert id="insertUser"&gt;insert into t_user values(null,'admin','123456',23,'男')&lt;/insert&gt;</code></pre><h2 id="4-2、删除"><a href="#4-2、删除" class="headerlink" title="4.2、删除"></a>4.2、删除</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int deleteUser();--&gt;&lt;delete id="deleteUser"&gt;delete from t_user where id = 7&lt;/delete&gt;</code></pre><h2 id="4-3、修改"><a href="#4-3、修改" class="headerlink" title="4.3、修改"></a>4.3、修改</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int updateUser();--&gt;&lt;update id="updateUser"&gt;update t_user set username='ybc',password='123' where id = 6&lt;/update&gt;</code></pre><h2 id="4-4、查询一个实体类对象"><a href="#4-4、查询一个实体类对象" class="headerlink" title="4.4、查询一个实体类对象"></a>4.4、查询一个实体类对象</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--User getUserById();--&gt;&lt;select id="getUserById" resultType="com.atguigu.mybatis.bean.User"&gt;select * from t_user where id = 2&lt;/select&gt;</code></pre><h2 id="4-5、查询list集合"><a href="#4-5、查询list集合" class="headerlink" title="4.5、查询list集合"></a>4.5、查询list集合</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id="getUserList" resultType="com.atguigu.mybatis.bean.User"&gt;select * from t_user&lt;/select&gt;</code></pre><blockquote><p>注意：</p><p>1、<strong>查询的标签select必须设置属性resultType或resultMap</strong>，用于设置实体类和数据库表的映射关系</p><p>resultType：自动映射，用于属性名和表中字段名一致的情况</p><p>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</p><p>（详细在8、）</p></blockquote><h1 id="5、MyBatis获取参数值的两种方式"><a href="#5、MyBatis获取参数值的两种方式" class="headerlink" title="5、MyBatis获取参数值的两种方式"></a>5、MyBatis获取参数值的两种方式</h1><blockquote><p>MyBatis获取参数值的两种方式：<code>${}</code>和<code>#{}</code></p><ul><li><p><code>${}</code>的本质就是字符串拼接，<code>#{}</code>的本质就是占位符赋值</p></li><li><p>${}使用<strong>字符串拼接</strong>的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要<strong>手动加单引号</strong>；</p></li><li><p>#{}使用<strong>占位符赋值</strong>的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以<strong>自动添加单引号</strong></p></li></ul></blockquote><h2 id="5-1、单个字面量类型的参数"><a href="#5-1、单个字面量类型的参数" class="headerlink" title="5.1、单个字面量类型的参数"></a>5.1、单个字面量类型的参数</h2><p>若mapper接口方法的参数为单个的字面量类型：</p><ul><li>此时可以通过<code>#{}</code>和<code>${}</code>以任意的内容获取参数值，一定要注意<code>${}</code>的单引号问题</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">// UserMapper接口User getUserByUsername(String username);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 映射文件&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;    &lt;select id="getUserByUsername" resultType="User"&gt;        select * from t_user where username = #{username}        &lt;!--select * from t_user where username = '${username}'--&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="5-2、多个字面量类型的参数"><a href="#5-2、多个字面量类型的参数" class="headerlink" title="5.2、多个字面量类型的参数"></a>5.2、多个字面量类型的参数</h2><p>若mapper接口中的方法参数为多个时：</p><p>此时MyBatis会自动将这些参数<strong>放在一个map集合中</strong>，以两种方式存储数据</p><ul><li><p>以<code>arg0、arg1...</code>为键，以参数为值</p></li><li><p>以<code>param1、param2...</code>为键，以参数为值</p></li></ul><p>因此只需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，注意<code>${}</code>需要手动加单引号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// UserMapper接口User checkLogin(String username, String password);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 映射文件&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;    &lt;select id="checkLogin" resultType="User"&gt;        select * from t_user where username = #{param1} and password = #{param2}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><blockquote><p>参数为<code>List&lt;Emp&gt; emps</code>等 list 结构时，参数以map形式存储：<strong>list为键</strong>，emps为值</p><p>参数为<code>Integer[] empIds</code>等数组结构时，参数以map形式存储：<strong>array为键</strong>，empIds为值</p></blockquote><h2 id="5-3、map集合类型的参数"><a href="#5-3、map集合类型的参数" class="headerlink" title="5.3、map集合类型的参数"></a>5.3、map集合类型的参数</h2><p>若mapper接口中的方法需要的参数为多个时：</p><ul><li>此时可以手动创建map集合，将这些数据放在map中</li><li>通过<code>${}</code>和<code>#{}</code><strong>访问map集合的键</strong>就可以获取相对应的值，注意<code>${}</code>需要手动加单引号</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">// UserMapper接口User checkLoginByMap(Map&lt;String, Object&gt; map);// Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();// map.put("username", "admin");// map.put("password", "123456");</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 映射文件&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;    &lt;select id="checkLoginByMap" resultType="User"&gt;        select * from t_user where username = #{username} and password = #{password}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="5-4、实体类类型的参数"><a href="#5-4、实体类类型的参数" class="headerlink" title="5.4、实体类类型的参数"></a>5.4、实体类类型的参数</h2><p>若mapper接口中的方法参数为实体类对象时：</p><p>此时可以使用<code>${}</code>和<code>#{}</code>，通过访问实体类对象中的<strong>属性名</strong>（属性名是指get/set方法名去掉get/set的名称，与对象的成员变量无关）获取属性值，注意<code>${}</code>需要手动加单引号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// UserMapper接口void insertUser(User user);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 映射文件&lt;insert id="insertUser"&gt;insert into t_user values (null,#{username},#{password},#{age},#{gender},#{email})&lt;/insert&gt;</code></pre><h2 id="5-5、使用-Param标识参数（常用）"><a href="#5-5、使用-Param标识参数（常用）" class="headerlink" title="5.5、使用@Param标识参数（常用）"></a>5.5、使用@Param标识参数（常用）</h2><p>可以通过**@Param注解**标识mapper接口中的方法参数：</p><p>此时，会将这些参数放在map集合中，以两种方式存储数据</p><ul><li><p><strong>以@Param注解的value属性值为键</strong>，以参数为值；</p></li><li><p>以param1,param2…为键，以参数为值</p></li></ul><p>只需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，注意<code>${}</code>需要手动加单引号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// UserMapper接口User checkLoginByParam(@Param("username") String username, @Param("password") String password);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">// 映射文件&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;    &lt;select id="checkLoginByParam" resultType="User"&gt;        select * from t_user where username = #{username} and password = #{password}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h1 id="6、MyBatis的各种查询功能"><a href="#6、MyBatis的各种查询功能" class="headerlink" title="6、MyBatis的各种查询功能"></a>6、MyBatis的各种查询功能</h1><h2 id="6-1、查询一个实体类对象"><a href="#6-1、查询一个实体类对象" class="headerlink" title="6.1、查询一个实体类对象"></a>6.1、查询一个实体类对象</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 根据用户id查询用户信息* @param id* @return*/User getUserById(@Param("id") int id);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--User getUserById(@Param("id") int id);--&gt;&lt;select id="getUserById" resultType="User"&gt;select * from t_user where id = #{id}&lt;/select&gt;</code></pre><h2 id="6-2、查询一个list集合"><a href="#6-2、查询一个list集合" class="headerlink" title="6.2、查询一个list集合"></a>6.2、查询一个list集合</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 查询所有用户信息* @return*/List&lt;User&gt; getUserList();</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id="getUserList" resultType="User"&gt;select * from t_user&lt;/select&gt;</code></pre><blockquote><p>当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常TooManyResultsException；</p><p>但是若查询的数据只有一条，可以<strong>使用实体类或集合List作为返回值</strong></p></blockquote><h2 id="6-3、查询单个数据"><a href="#6-3、查询单个数据" class="headerlink" title="6.3、查询单个数据"></a>6.3、查询单个数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 查询用户的总记录数* @return* 在MyBatis中，对于Java中常用的类型都设置了类型别名* 例如： java.lang.Integer--&gt;int|integer* 例如： int--&gt;_int|_integer* 例如： Map--&gt;map,List--&gt;list*/int getCount();</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int getCount();--&gt;&lt;select id="getCount" resultType="_integer"&gt;select count(id) from t_user&lt;/select&gt;</code></pre><p><strong>常用类型别名：</strong></p><p><img src="image-20230717122139983.png" alt="image-20230717122139983"></p><p><img src="image-20230717122214095.png" alt="image-20230717122214095"></p><h2 id="6-4、查询一条数据为map集合"><a href="#6-4、查询一条数据为map集合" class="headerlink" title="6.4、查询一条数据为map集合"></a>6.4、查询一条数据为map集合</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 根据用户id查询用户信息为map集合* @param id* @return*/Map&lt;String, Object&gt; getUserToMap(@Param("id") int id);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param("id") int id);--&gt;&lt;!--结果： {password=123456, sex=男 , id=1, age=23, username=admin}--&gt;&lt;select id="getUserToMap" resultType="map"&gt;select * from t_user where id = #{id}&lt;/select&gt;</code></pre><blockquote><p>map集合相当于实体类对象，但如果表中某一行数据没有某个属性，map不会显示，而实体类对象会显示null</p></blockquote><h2 id="6-5、查询多条数据为map集合"><a href="#6-5、查询多条数据为map集合" class="headerlink" title="6.5、查询多条数据为map集合"></a>6.5、查询多条数据为map集合</h2><h3 id="①方式一"><a href="#①方式一" class="headerlink" title="①方式一"></a>①方式一</h3><p>使用List获取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 查询所有用户信息为map集合* @return* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取*/List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;&lt;select id="getAllUserToMap" resultType="map"&gt;select * from t_user&lt;/select&gt;</code></pre><h3 id="②方式二"><a href="#②方式二" class="headerlink" title="②方式二"></a>②方式二</h3><p>设置注解@MapKey()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 查询所有用户信息为map集合* @return* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据需要通过@MapKey注解设置某个字段的值，作为 大的map集合的键 ，值是每条数据所对应的map集合*/@MapKey("id")Map&lt;String, Object&gt; getAllUserToMap();</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;&lt;!--{    1={password=123456, sex=男, id=1, age=23, username=admin},    2={password=123456, sex=男, id=2, age=23, username=张三},    3={password=123456, sex=男, id=3, age=23, username=张三}}--&gt;&lt;select id="getAllUserToMap" resultType="map"&gt;select * from t_user&lt;/select&gt;</code></pre><h1 id="7、特殊SQL的执行"><a href="#7、特殊SQL的执行" class="headerlink" title="7、特殊SQL的执行"></a>7、特殊SQL的执行</h1><h2 id="7-1、模糊查询"><a href="#7-1、模糊查询" class="headerlink" title="7.1、模糊查询"></a>7.1、模糊查询</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 测试模糊查询* @param mohu* @return*/List&lt;User&gt; testMohu(@Param("mohu") String mohu);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;User&gt; testMohu(@Param("mohu") String mohu);--&gt;&lt;select id="testMohu" resultType="User"&gt;    &lt;!--select * from t_user where username like '%${mohu}%'--&gt;    &lt;!--select * from t_user where username like concat('%',#{mohu},'%')--&gt;select * from t_user where username like "%"#{mohu}"%"&lt;/select&gt;</code></pre><h2 id="7-2、批量删除"><a href="#7-2、批量删除" class="headerlink" title="7.2、批量删除"></a>7.2、批量删除</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 批量删除* @param ids* @return*/int deleteMore(@Param("ids") String ids); // "5,7"</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int deleteMore(@Param("ids") String ids);--&gt;&lt;delete id="deleteMore"&gt;delete from t_user where id in (${ids})&lt;/delete&gt;</code></pre><h2 id="7-3、动态设置表名"><a href="#7-3、动态设置表名" class="headerlink" title="7.3、动态设置表名"></a>7.3、动态设置表名</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 动态设置表名，查询所有的用户信息* @param tableName* @return*/List&lt;User&gt; getAllUser(@Param("tableName") String tableName);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;User&gt; getAllUser(@Param("tableName") String tableName);--&gt;&lt;select id="getAllUser" resultType="User"&gt;select * from ${tableName}&lt;/select&gt;</code></pre><h2 id="7-4、添加功能获取自增的主键"><a href="#7-4、添加功能获取自增的主键" class="headerlink" title="7.4、添加功能获取自增的主键"></a>7.4、添加功能获取自增的主键</h2><blockquote><p>场景模拟：</p><p>t_clazz(clazz_id,clazz_name)</p><p>t_student(student_id,student_name,clazz_id)</p><p>1、添加班级信息</p><p>2、获取新添加的班级的id</p><p>3、为班级分配学生，即将某学的班级id修改为新添加的班级的id</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 添加用户信息* @param user* @return* useGeneratedKeys：当前功能使用了自增的主键* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数User对象的某个属性中*/void insertUser(User user);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int insertUser(User user);--&gt;&lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt;insert into t_user values(null,#{username},#{password},#{age},#{gender},#{email})&lt;/insert&gt;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testInsertUser() {    SqlSession sqlSession = SqlSessionUtil.getSqlSession();    SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class);    User user = new User(null, "xiaoming", "123456", 22, "男", "123@qq.com");    mapper.insertUser(user);    System.out.println(user);    // User{id=15, username='xiaoming', password='123456', age=22, gender='男', email='123@qq.com'}}</code></pre><blockquote><p>若不设置useGeneratedKeys和keyPropert，则打印User对象时id项为null</p><p>此功能作用：<strong>将数据库中自增的id添加到实体类对象User的id属性上</strong>。即添加一个数据并在id上回显添加成功的这次id</p></blockquote><h1 id="8、自定义映射resultMap"><a href="#8、自定义映射resultMap" class="headerlink" title="8、自定义映射resultMap"></a>8、自定义映射resultMap</h1><h2 id="8-1、resultMap处理字段和属性的映射关系"><a href="#8-1、resultMap处理字段和属性的映射关系" class="headerlink" title="8.1、resultMap处理字段和属性的映射关系"></a>8.1、resultMap处理字段和属性的映射关系</h2><p>① 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    resultMap：设置自定义映射    属性：    id：表示自定义映射的唯一标识    type：查询的数据要映射的实体类的类型    子标签：    id：设置主键的映射关系    result：设置普通字段的映射关系    association：设置多对一的映射关系    collection：设置一对多的映射关系    属性：    property：设置映射关系中实体类中的属性名    column：设置映射关系中表中的字段名--&gt;&lt;resultMap id="empResultMap" type="Emp"&gt;    &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;    &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;    &lt;result column="age" property="age"&gt;&lt;/result&gt;    &lt;result column="gender" property="gender"&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpByEmpId(@Param("empId") Integer empId);--&gt;&lt;select id="getEmpByEmpId" resultMap="empResultMap"&gt;select * from t_emp where emp_id = #{empId}&lt;/select&gt;</code></pre><p>② 若字段名和实体类中的属性名不一致，<strong>但是字段名符合数据库的规则（使用_），而实体类中的属性名符合Java的规则（使用驼峰）</strong>：</p><p>此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系</p><ol><li><p>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致</p></li><li><p>可以在MyBatis的核心配置文件中<strong>设置一个全局配置信息mapUnderscoreToCamelCase</strong>，可以在查询表中数据时，自动将_类型的字段名转换为驼峰。</p><ol><li>例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;settings&gt;&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;&lt;/settings&gt;</code></pre><h2 id="8-2、多对一映射处理"><a href="#8-2、多对一映射处理" class="headerlink" title="8.2、多对一映射处理"></a>8.2、多对一映射处理</h2><blockquote><p>场景模拟：</p><p>查询员工信息以及员工所对应的部门信息（多个员工对应同一个部门）</p></blockquote><h3 id="8-2-1、级联方式处理映射关系"><a href="#8-2-1、级联方式处理映射关系" class="headerlink" title="8.2.1、级联方式处理映射关系"></a>8.2.1、级联方式处理映射关系</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;resultMap id="empAndDeptResultMap" type="Emp"&gt;    &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;    &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;    &lt;result column="age" property="age"&gt;&lt;/result&gt;    &lt;result column="gender" property="gender"&gt;&lt;/result&gt;    &lt;result column="dept_id" property="dept.deptId"&gt;&lt;/result&gt;    &lt;result column="dept_name" property="dept.deptName"&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param("empId") Integer empId);--&gt;&lt;select id="getEmpAndDeptByEmpId" resultMap="empAndDeptResultMap"&gt;    select    t_emp.*,t_dept.*    from t_emp    left join t_dept    on t_emp.dept_id = t_dept.dept_id    where t_emp.emp_id = #{empId}&lt;/select&gt;</code></pre><h3 id="8-2-2、使用association处理映射关系"><a href="#8-2-2、使用association处理映射关系" class="headerlink" title="8.2.2、使用association处理映射关系"></a>8.2.2、使用association处理映射关系</h3><p>专门用来处理多对一的映射关系（也可以处理一对一）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;resultMap id="empAndDeptResultMap" type="Emp"&gt;&lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;    &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;    &lt;result column="age" property="age"&gt;&lt;/result&gt;    &lt;result column="gender" property="gender"&gt;&lt;/result&gt;    &lt;!--        association：处理多对一的映射关系（处理实体类类型的属性）        property：设置需要处理映射关系的属性的属性名        javaType：设置要处理的属性的类型    --&gt;    &lt;association property="dept" javaType="Dept"&gt;        &lt;id column="dept_id" property="deptId"&gt;&lt;/id&gt;        &lt;result column="dept_name" property="deptName"&gt;&lt;/result&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param("empId") Integer empId);--&gt;&lt;select id="getEmpAndDeptByEmpId" resultMap="empAndDeptResultMap"&gt;    select    t_emp.*,t_dept.*    from t_emp    left join t_dept    on t_emp.dept_id = t_dept.dept_id    where t_emp.emp_id = #{empId}&lt;/select&gt;</code></pre><h3 id="8-2-3、分步查询"><a href="#8-2-3、分步查询" class="headerlink" title="8.2.3、分步查询"></a>8.2.3、分步查询</h3><h4 id="①查询员工信息"><a href="#①查询员工信息" class="headerlink" title="①查询员工信息"></a>①查询员工信息</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 分步查询的第一步：根据empId查询员工信息* @param empId* @return*/Emp getEmpAndDeptByStepOne(@Param("empId") Integer empId);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;resultMap id="empAndDeptByStepResultMap" type="Emp"&gt;    &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;    &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;    &lt;result column="age" property="age"&gt;&lt;/result&gt;    &lt;result column="gender" property="gender"&gt;&lt;/result&gt;&lt;!--property：设置需要处理映射关系的属性的属性名        select：设置分步查询，下一步查询某个属性的值的sql的标识（namespace.sqlId）        column：将sql以及查询结果中的某个字段设置为 下一步分步查询的条件--&gt;&lt;association property="dept"                 select="com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo"                 column="dept_id"&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Emp getEmpAndDeptByStepOne(@Param("empId") Integer empId); --&gt;&lt;select id="getEmpAndDeptByStepOne" resultMap="empAndDeptByStepResultMap"&gt;    select * from t_emp where emp_id = #{empId}&lt;/select&gt;</code></pre><h4 id="②根据员工所对应的部门id查询部门信息"><a href="#②根据员工所对应的部门id查询部门信息" class="headerlink" title="②根据员工所对应的部门id查询部门信息"></a>②根据员工所对应的部门id查询部门信息</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 分步查询的第二步： 根据员工所对应的deptId查询部门信息* @param deptId* @return*/Dept getEmpAndDeptByStepTwo(@Param("deptId") Integer deptId);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Dept getEmpAndDeptByStepTwo(@Param("deptId") Integer deptId);--&gt;&lt;select id="getEmpAndDeptByStepTwo" resultType="Dept"&gt;    select * from t_dept where dept_id = #{deptId}&lt;/select&gt;</code></pre><h2 id="8-3、一对多映射处理"><a href="#8-3、一对多映射处理" class="headerlink" title="8.3、一对多映射处理"></a>8.3、一对多映射处理</h2><p>一个部门有多个员工</p><h3 id="8-3-1、collection"><a href="#8-3-1、collection" class="headerlink" title="8.3.1、collection"></a>8.3.1、collection</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 根据部门id查新部门以及部门中的员工信息* @param deptId* @return*/Dept getDeptAndEmpByDeptId(@Param("deptId") Integer deptId);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;resultMap id="deptAndEmpResultMap" type="Dept"&gt;    &lt;id column="dept_id" property="deptId"&gt;&lt;/id&gt;    &lt;result column="dept_name" property="deptName"&gt;&lt;/result&gt;    &lt;!--            ofType：设置集合类型的属性中存储的数据的类型        --&gt;    &lt;collection property="emps" ofType="Emp"&gt;        &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;        &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;        &lt;result column="age" property="age"&gt;&lt;/result&gt;        &lt;result column="gender" property="gender"&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmpByDeptId(@Param("deptId") Integer deptId);--&gt;&lt;select id="getDeptAndEmpByDeptId" resultMap="deptAndEmpResultMap"&gt;    SELECT *    FROM t_dept    LEFT JOIN t_emp    ON t_dept.dept_id = t_emp.dept_id    WHERE t_dept.dept_id = #{deptId}&lt;/select&gt;</code></pre><h3 id="8-3-2、分步查询"><a href="#8-3-2、分步查询" class="headerlink" title="8.3.2、分步查询"></a>8.3.2、分步查询</h3><h3 id="①查询部门信息"><a href="#①查询部门信息" class="headerlink" title="①查询部门信息"></a>①查询部门信息</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 分步查询部门和部门中的员工* @param deptId* @return*/Dept getDeptAndEmpByStepOne(@Param("deptId") Integer deptId);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;resultMap id="deptAndEmpResultMapByStep" type="Dept"&gt;    &lt;id column="dept_id" property="deptId"&gt;&lt;/id&gt;    &lt;result column="dept_name" property="deptName"&gt;&lt;/result&gt;    &lt;collection property="emps"                select="com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo"                column="dept_id"&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmpByStepOne(@Param("deptId") Integer deptId);--&gt;&lt;select id="getDeptAndEmpByStepOne" resultMap="deptAndEmpResultMapByStep"&gt;    select * from t_dept where dept_id = #{deptId}&lt;/select&gt;</code></pre><h3 id="②根据部门id查询部门中的所有员工"><a href="#②根据部门id查询部门中的所有员工" class="headerlink" title="②根据部门id查询部门中的所有员工"></a>②根据部门id查询部门中的所有员工</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 根据部门id查询员工信息* @param deptId* @return*/List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param("deptId") Integer deptId);</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param("deptId") Integer deptId);--&gt;&lt;select id="getDeptAndEmpByStepTwo" resultType="Emp"&gt;    select * from t_emp where dept_id = #{deptId}&lt;/select&gt;</code></pre><blockquote><p>分步查询的优点：可以<strong>实现延迟加载</strong>（若结果不需要部门信息，则只执行第一步即可）</p><p>但是必须在==Mybatis 核心配置文件==中设置全局配置信息：</p><ul><li><p><code>lazyLoadingEnabled</code>：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</p></li><li><p><code>aggressiveLazyLoading</code>：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载。此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。</p></li></ul><p>若想对<strong>单独</strong>的步骤设置是否延迟加载，此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载， fetchType=”lazy(延迟加载) | eager(立即加载)”</p></blockquote><h1 id="9、动态SQL"><a href="#9、动态SQL" class="headerlink" title="9、动态SQL"></a>9、动态SQL</h1><p>Mybatis框架的动态SQL技术是一种<strong>根据特定条件动态拼装SQL语句</strong>的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。</p><h2 id="9-1、if"><a href="#9-1、if" class="headerlink" title="9.1、if"></a>9.1、if</h2><blockquote><p>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;Emp&gt; getEmpListByCondition(Emp emp);--&gt;&lt;select id="getEmpListByMoreTJ" resultType="Emp"&gt;    select * from t_emp where 1=1    &lt;if test="ename != '' and ename != null"&gt;and ename = #{ename}&lt;/if&gt;&lt;if test="age != '' and age != null"&gt;and age = #{age}&lt;/if&gt;&lt;if test="sex != '' and sex != null"&gt;and sex = #{sex}&lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="9-2、where"><a href="#9-2、where" class="headerlink" title="9.2、where"></a>9.2、where</h2><blockquote><p>where和if一般结合使用：</p><ul><li><p>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</p></li><li><p>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去掉</p></li></ul><p>注意：where标签不能去掉条件后方多余的and</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;select id="getEmpListByMoreTJ2" resultType="Emp"&gt;select * from t_emp&lt;where&gt;&lt;if test="ename != '' and ename != null"&gt;ename = #{ename}&lt;/if&gt;&lt;if test="age != '' and age != null"&gt;and age = #{age}&lt;/if&gt;&lt;if test="sex != '' and sex != null"&gt;and sex = #{sex}&lt;/if&gt;&lt;/where&gt;&lt;/select&gt;</code></pre><h2 id="9-3、trim"><a href="#9-3、trim" class="headerlink" title="9.3、trim"></a>9.3、trim</h2><blockquote><p>trim用于<strong>去掉或添加标签中的内容</strong></p><p>常用属性：</p><p>prefix：在trim标签中的内容的前面添加某些内容</p><p>prefixOverrides：在trim标签中的内容的前面去掉某些内容</p><p>suffix：在trim标签中的内容的后面添加某些内容</p><p>suffixOverrides：在trim标签中的内容的后面去掉某些内容</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;select id="getEmpListByMoreTJ" resultType="Emp"&gt;select * from t_emp&lt;trim prefix="where" suffixOverrides="and"&gt;&lt;if test="ename != '' and ename != null"&gt;ename = #{ename} and&lt;/if&gt;&lt;if test="age != '' and age != null"&gt;age = #{age} and&lt;/if&gt;&lt;if test="sex != '' and sex != null"&gt;sex = #{sex}&lt;/if&gt;&lt;/trim&gt;&lt;/select&gt;</code></pre><h2 id="9-4、choose、when、otherwise"><a href="#9-4、choose、when、otherwise" class="headerlink" title="9.4、choose、when、otherwise"></a>9.4、choose、when、otherwise</h2><blockquote><p>choose、when、 otherwise相当于<strong>if…else if..else</strong></p><p>多个when自上而下若有一个满足条件，则不会考虑下面的when</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;&lt;select id="getEmpListByChoose" resultType="Emp"&gt;select &lt;include refid="empColumns"&gt;&lt;/include&gt; from t_emp&lt;where&gt;&lt;choose&gt;&lt;when test="ename != '' and ename != null"&gt;ename = #{ename}&lt;/when&gt;&lt;when test="age != '' and age != null"&gt;age = #{age}&lt;/when&gt;&lt;when test="sex != '' and sex != null"&gt;sex = #{sex}&lt;/when&gt;&lt;when test="email != '' and email != null"&gt;email = #{email}&lt;/when&gt;&lt;/choose&gt;&lt;/where&gt;&lt;/select&gt;</code></pre><h2 id="9-5、foreach"><a href="#9-5、foreach" class="headerlink" title="9.5、foreach"></a>9.5、foreach</h2><p>批量添加：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;&lt;insert id="insertMoreEmp"&gt;insert into t_emp values&lt;foreach collection="emps" item="emp" separator=","&gt;(null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)&lt;/foreach&gt;&lt;/insert&gt;</code></pre><p>批量删除：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!--int deleteMoreByArray(int[] eids);--&gt;&lt;delete id="deleteMoreByArray"&gt;delete from t_emp where&lt;foreach collection="eids" item="eid" separator="or"&gt;eid = #{eid}&lt;/foreach&gt;&lt;/delete&gt;        &lt;!--int deleteMoreByArray(int[] eids);--&gt;&lt;delete id="deleteMoreByArray"&gt;delete from t_emp where eid in&lt;foreach collection="eids" item="eid" separator="," open="(" close=")"&gt;#{eid}&lt;/foreach&gt;&lt;/delete&gt;</code></pre><h2 id="9-6、SQL片段"><a href="#9-6、SQL片段" class="headerlink" title="9.6、SQL片段"></a>9.6、SQL片段</h2><blockquote><p>sql片段，可以<strong>记录一段公共sql片段</strong>，在使用的地方通过include标签进行引入</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;sql id="empColumns"&gt;eid,ename,age,sex,did&lt;/sql&gt;select &lt;include refid="empColumns"&gt;&lt;/include&gt; from t_emp</code></pre><h1 id="10、MyBatis的缓存"><a href="#10、MyBatis的缓存" class="headerlink" title="10、MyBatis的缓存"></a>10、MyBatis的缓存</h1><h2 id="10-1、MyBatis的一级缓存"><a href="#10-1、MyBatis的一级缓存" class="headerlink" title="10.1、MyBatis的一级缓存"></a>10.1、MyBatis的一级缓存</h2><p>一级缓存是<strong>SqlSession级别</strong>的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p><p>MyBatis的一级缓存是默认开启的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testGetEmpById() {    SqlSession sqlSession1 = SqlSessionUtil.getSqlSession();    CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class);    Emp emp1 = mapper1.getEmpById(1);    System.out.println(emp1);    Emp emp2 = mapper1.getEmpById(1);    System.out.println(emp2);    SqlSession sqlSession2 = SqlSessionUtil.getSqlSession();    CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class);    Emp emp3 = mapper2.getEmpById(1);    System.out.println(emp3);}</code></pre><pre class="line-numbers language-none"><code class="language-none">// 结果DEBUG 07-19 11:51:39,829 ==&gt;  Preparing: select * from t_emp where emp_id = ?  (BaseJdbcLogger.java:137) //执行第一次DEBUG 07-19 11:51:39,874 ==&gt; Parameters: 1(Integer)  (BaseJdbcLogger.java:137) DEBUG 07-19 11:51:39,890 &lt;==      Total: 1  (BaseJdbcLogger.java:137) Emp{empId=1, empName='zhangsan', age=23, gender='男'}Emp{empId=1, empName='zhangsan', age=23, gender='男'}DEBUG 07-19 11:51:39,938 ==&gt;  Preparing: select * from t_emp where emp_id = ?  (BaseJdbcLogger.java:137) //执行第二次 DEBUG 07-19 11:51:39,938 ==&gt; Parameters: 1(Integer)  (BaseJdbcLogger.java:137) DEBUG 07-19 11:51:39,938 &lt;==      Total: 1  (BaseJdbcLogger.java:137) Emp{empId=1, empName='zhangsan', age=23, gender='男'}</code></pre><p>使一级缓存失效的四种情况：</p><ol><li><p>不同的SqlSession对应不同的一级缓存</p></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p></li><li><p>同一个SqlSession两次查询期间手动清空了缓存 <code>sqlSession.clearCache()</code></p></li></ol><h2 id="10-2、MyBatis的二级缓存"><a href="#10-2、MyBatis的二级缓存" class="headerlink" title="10.2、MyBatis的二级缓存"></a>10.2、MyBatis的二级缓存</h2><p>二级缓存是<strong>SqlSessionFactory级别</strong>，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache></cache></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口 <code>implements Serializable</code></li></ol><p>使二级缓存失效的情况：</p><ol><li>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</li></ol><h2 id="10-3、二级缓存的相关配置"><a href="#10-3、二级缓存的相关配置" class="headerlink" title="10.3、二级缓存的相关配置"></a>10.3、二级缓存的相关配置</h2><p>在mapper配置文件中添加的cache标签可以设置一些属性：</p><p>①<strong>eviction属性</strong>：缓存回收策略，默认的是 LRU。</p><p>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</p><p>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>②<strong>flushInterval属性</strong>：刷新间隔，单位毫秒</p><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p><p>③<strong>size属性</strong>：引用数目，正整数</p><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p><p>④<strong>readOnly属性</strong>：只读， true/false</p><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。</p><p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p><h2 id="10-4、MyBatis缓存查询的顺序"><a href="#10-4、MyBatis缓存查询的顺序" class="headerlink" title="10.4、MyBatis缓存查询的顺序"></a>10.4、MyBatis缓存查询的顺序</h2><ol><li><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</p></li><li><p>如果二级缓存没有命中，再查询一级缓存</p></li><li><p>如果一级缓存也没有命中，则查询数据库</p></li><li><p>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</p></li></ol><h2 id="10-5、整合第三方缓存EHCache"><a href="#10-5、整合第三方缓存EHCache" class="headerlink" title="10.5、整合第三方缓存EHCache"></a>10.5、整合第三方缓存EHCache</h2><p>注意：针对二级缓存</p><h3 id="10-5-1、添加依赖"><a href="#10-5-1、添加依赖" class="headerlink" title="10.5.1、添加依赖"></a>10.5.1、添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="10-5-2、各jar包功能"><a href="#10-5-2、各jar包功能" class="headerlink" title="10.5.2、各jar包功能"></a>10.5.2、各jar包功能</h3><table><thead><tr><th><strong>jar包名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="10-5-3、创建EHCache的配置文件ehcache-xml"><a href="#10-5-3、创建EHCache的配置文件ehcache-xml" class="headerlink" title="10.5.3、创建EHCache的配置文件ehcache.xml"></a>10.5.3、创建EHCache的配置文件ehcache.xml</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt;&lt;!-- 磁盘保存路径 --&gt;&lt;diskStore path="D:\atguigu\ehcache"/&gt;&lt;defaultCache        maxElementsInMemory="1000"        maxElementsOnDisk="10000000"        eternal="false"        overflowToDisk="true"        timeToIdleSeconds="120"        timeToLiveSeconds="120"        diskExpiryThreadIntervalSeconds="120"        memoryStoreEvictionPolicy="LRU"&gt;&lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><h3 id="10-5-4、设置二级缓存的类型"><a href="#10-5-4、设置二级缓存的类型" class="headerlink" title="10.5.4、设置二级缓存的类型"></a>10.5.4、设置二级缓存的类型</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;</code></pre><h3 id="10-5-5、加入logback日志"><a href="#10-5-5、加入logback日志" class="headerlink" title="10.5.5、加入logback日志"></a>10.5.5、加入logback日志</h3><blockquote><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。 创建logback的配置文件logback.xml</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt;&lt;!-- 指定日志输出的位置 --&gt;&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;&lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是： 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行--&gt;&lt;pattern&gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger][%msg]%n&lt;/pattern&gt;&lt;/encoder&gt;&lt;/appender&gt;    &lt;!-- 设置全局日志级别。日志级别按顺序分别是： DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level="DEBUG"&gt;&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;&lt;appender-ref ref="STDOUT" /&gt;&lt;/root&gt;&lt;!-- 根据特殊需求指定局部日志级别 --&gt;&lt;logger name="com.atguigu.crowd.mapper" level="DEBUG"/&gt;&lt;/configuration&gt;</code></pre><h3 id="10-5-6、EHCache配置文件说明"><a href="#10-5-6、EHCache配置文件说明" class="headerlink" title="10.5.6、EHCache配置文件说明"></a>10.5.6、EHCache配置文件说明</h3><table><thead><tr><th><strong>属性名</strong></th><th><strong>是否必须</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU （最近最少使用），可选的有LFU （最不常使用）和FIFO （先进先出）</td></tr></tbody></table><h1 id="11、MyBatis的逆向工程"><a href="#11、MyBatis的逆向工程" class="headerlink" title="11、MyBatis的逆向工程"></a>11、MyBatis的逆向工程</h1><blockquote><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工程的。</p><p>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</p><ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ul></blockquote><h2 id="11-1、创建逆向工程的步骤"><a href="#11-1、创建逆向工程的步骤" class="headerlink" title="11.1、创建逆向工程的步骤"></a>11.1、创建逆向工程的步骤</h2><h3 id="①添加依赖和插件"><a href="#①添加依赖和插件" class="headerlink" title="①添加依赖和插件"></a>①添加依赖和插件</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 依赖MyBatis核心包 --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- log4j日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;        &lt;version&gt;5.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt;    &lt;!-- 构建过程中用到的插件 --&gt;    &lt;plugins&gt;        &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;            &lt;!-- 插件的依赖 --&gt;            &lt;dependencies&gt;                &lt;!-- 逆向工程的核心依赖 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                    &lt;version&gt;1.3.2&lt;/version&gt;                &lt;/dependency&gt;                &lt;!-- MySQL驱动 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;8.0.16&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h3 id="②创建MyBatis的核心配置文件"><a href="#②创建MyBatis的核心配置文件" class="headerlink" title="②创建MyBatis的核心配置文件"></a>②创建MyBatis的核心配置文件</h3><h3 id="③创建逆向工程的配置文件"><a href="#③创建逆向工程的配置文件" class="headerlink" title="③创建逆向工程的配置文件"></a>③创建逆向工程的配置文件</h3><blockquote><p>文件名必须是：generatorConfig.xml</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;&lt;!--targetRuntime: 执行生成的逆向工程的版本                MyBatis3Simple: 生成基本的CRUD（清新简洁版）                MyBatis3: 生成带条件的CRUD（奢华尊享版）--&gt;&lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt;&lt;!-- 数据库的连接信息 --&gt;&lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"connectionURL="jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC"userId="root"password="123456"&gt;&lt;/jdbcConnection&gt;&lt;!-- javaBean的生成策略--&gt;&lt;javaModelGenerator targetPackage="com.atguigu.mybatis.pojo" targetProject=".\src\main\java"&gt;            &lt;property name="enableSubPackages" value="true" /&gt;            &lt;property name="trimStrings" value="true" /&gt;&lt;/javaModelGenerator&gt;&lt;!-- SQL映射文件的生成策略 --&gt;&lt;sqlMapGenerator targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\resources"&gt;&lt;property name="enableSubPackages" value="true" /&gt;&lt;/sqlMapGenerator&gt;&lt;!-- Mapper接口的生成策略 --&gt;&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\java"&gt;&lt;property name="enableSubPackages" value="true" /&gt;&lt;/javaClientGenerator&gt;        &lt;!-- 逆向分析的表 --&gt;        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;        &lt;table tableName="t_emp" domainObjectName="Emp"/&gt;        &lt;table tableName="t_dept" domainObjectName="Dept"/&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="④执行MBG插件的generate目标"><a href="#④执行MBG插件的generate目标" class="headerlink" title="④执行MBG插件的generate目标"></a>④执行MBG插件的generate目标</h3><p><img src="3.png" alt="3"></p><h3 id="⑤效果"><a href="#⑤效果" class="headerlink" title="⑤效果"></a>⑤效果</h3><p><img src="4.png" alt="4"></p><h2 id="11-2、QBC查询"><a href="#11-2、QBC查询" class="headerlink" title="11.2、QBC查询"></a>11.2、QBC查询</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testMBG(){    try {InputStream is = Resources.getResourceAsStream("mybatis-config.xml");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);SqlSession sqlSession = sqlSessionFactory.openSession(true);EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);        //查询所有数据        /*List&lt;Emp&gt; list = mapper.selectByExample(null);        list.forEach(emp -&gt; System.out.println(emp));*/        //根据条件查询        /*EmpExample example = new EmpExample();        example.createCriteria().andEmpNameEqualTo("张三").andAgeGreaterThanOrEqualTo(20);        example.or().andDidIsNotNull();List&lt;Emp&gt; list = mapper.selectByExample(example);        list.forEach(emp -&gt; System.out.println(emp));*/        mapper.updateByPrimaryKeySelective(newEmp(1,"admin",22,null,"456@qq.com",3));} catch (IOException e) {e.printStackTrace();}}</code></pre><h1 id="12、分页插件"><a href="#12、分页插件" class="headerlink" title="12、分页插件"></a>12、分页插件</h1><p>limit index, pageSize</p><p>pageSize：每页显示的条数</p><p>pageNum：当前页的页码</p><p>index：当前页的起始索引，<code>index=(pageNum-1)*pageSize</code></p><pre class="line-numbers language-none"><code class="language-none">pageSize=4，pageNum=1，index=0 limit 0,4pageSize=4，pageNum=3，index=8 limit 8,4pageSize=4，pageNum=6，index=20 limit 8,4</code></pre><p>count：总记录数</p><p>totalPage：总页数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">totalPage = count / pageSize;if(count % pageSize != 0){totalPage += 1;}</code></pre><p>首页 上一页 2 3 4 5 6 下一页 末页</p><h2 id="12-1、分页插件的使用步骤"><a href="#12-1、分页插件的使用步骤" class="headerlink" title="12.1、分页插件的使用步骤"></a>12.1、分页插件的使用步骤</h2><h3 id="①添加依赖"><a href="#①添加依赖" class="headerlink" title="①添加依赖"></a>①添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="②配置分页插件"><a href="#②配置分页插件" class="headerlink" title="②配置分页插件"></a>②配置分页插件</h3><p>在MyBatis的核心配置文件中配置插件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;plugins&gt;    &lt;!--设置分页插件--&gt;    &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt;&lt;/plugin&gt;&lt;/plugins&gt;</code></pre><h2 id="12-2、分页插件的使用"><a href="#12-2、分页插件的使用" class="headerlink" title="12.2、分页插件的使用"></a>12.2、分页插件的使用</h2><ol><li>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</li></ol><blockquote><p>pageNum：当前页的页码</p><p>pageSize：每页显示的条数</p></blockquote><ol start="2"><li>在查询获取list集合之后，使用PageInfo<t> pageInfo = new PageInfo&lt;&gt;(List<t> list, int navigatePages)获取分页相关数据</t></t></li></ol><blockquote><p>list：分页之后的数据</p><p>navigatePages：导航分页的页码数</p></blockquote><ol start="3"><li>分页相关数据</li></ol><blockquote><p>PageInfo{</p><p>pageNum=8, pageSize=4, size=2, </p><p>startRow=29, endRow=30,</p><p>total=30, pages=8,</p><p>list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false},</p><p>prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, </p><p>hasPreviousPage=true, hasNextPage=false, </p><p>navigatePages=5, navigateFirstPage=4, navigateLastPage=8,</p><p>navigatepageNums=[4, 5, 6, 7, 8]</p><p>}</p><p>pageNum：当前页的页码</p><p>pageSize：每页显示的条数</p><p>size：当前页显示的真实条数</p><p>total：总记录数</p><p>pages：总页数</p><p>prePage：上一页的页码</p><p>nextPage：下一页的页码</p><p>isFirstPage/isLastPage：是否为第一页/最后一页</p><p>hasPreviousPage/hasNextPage：是否存在上一页/下一页</p><p>navigatePages：导航分页的页码数</p><p>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2023/06/17/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/17/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SQL"><a href="#一、SQL" class="headerlink" title="一、SQL"></a>一、SQL</h1><p>SQL 是操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><p><strong>SQL通用语法：</strong></p><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： <ul><li>单行注释：– 注释内容 或 # 注释内容</li><li>多行注释：/* 注释内容 */</li></ul></li></ol><p><strong>SQL分类：</strong></p><table><thead><tr><th align="center">分 类</th><th align="center">全 称</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Languag</td><td align="center">数据定义语言，用来<strong>定义数据库对象</strong>(数据库，表， 字段)</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，用来<strong>对数据库表中的数据进行增删改</strong></td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，用来<strong>查询数据库中表的记录</strong></td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，用来<strong>创建数据库用户</strong>、控制数据库的<strong>访问权限</strong></td></tr></tbody></table><h2 id="1-DDL-数据定义语言"><a href="#1-DDL-数据定义语言" class="headerlink" title="1. DDL(数据定义语言)"></a>1. DDL(数据定义语言)</h2><p>用来定义数据库对象（数据库，表，字段）。</p><h3 id="1-1-数据库操作"><a href="#1-1-数据库操作" class="headerlink" title="1.1 数据库操作"></a>1.1 数据库操作</h3><p>1）查询所有数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show databases;</code></pre><p>2）查询当前数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select database() ;</code></pre><p>3）创建数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><ul><li>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</li><li>可以通过if not exists 参数来解决这个问题，数据库不存在，则创建该数据库；如果存在，则不创建（不报错）。</li></ul><p>4）删除数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">drop database [ if exists ] 数据库名 ;</code></pre><ul><li>如果删除一个不存在的数据库，将会报错。</li><li>可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除（不报错）。</li></ul><p>5）切换数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">use 数据库名 ;</code></pre><h3 id="1-2-表操作"><a href="#1-2-表操作" class="headerlink" title="1.2 表操作"></a>1.2 表操作</h3><h4 id="1-2-1-数据类型"><a href="#1-2-1-数据类型" class="headerlink" title="1.2.1 数据类型"></a>1.2.1 数据类型</h4><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1）数值类型</p><p><img src="image-20230628220038458.png" alt="image-20230628220038458"></p><blockquote><p>分数 – 总分100分, 最多出现一位小数 </p><p>score double(4,1) // 共4位，1位小数</p></blockquote><p>2）字符串类型</p><p><img src="image-20230628220240322.png" alt="image-20230628220240322"></p><ul><li>char是定长字符串，<strong>指定长度多长，就占用多少个字符</strong>，和字段值的长度无关 。</li><li>而varchar是变长字符串，<strong>指定的长度为最大占用长度</strong> 。相对来说，char的性能会更高些。</li></ul><blockquote><p>1). 用户名 username ——&gt; 长度不定, 最长不会超过50 </p><p>username varchar(50) </p><p>2). 性别 gender ———&gt; 存储值, 不是男,就是女 </p><p>gender char(1) </p><p>3). 手机号 phone ——–&gt; 固定长度为11 </p><p>phone char(11)</p></blockquote><p>3）日期时间类型</p><p><img src="image-20230628220429109.png" alt="image-20230628220429109"></p><h4 id="1-2-2-查询-创建表"><a href="#1-2-2-查询-创建表" class="headerlink" title="1.2.2 查询&amp;创建表"></a>1.2.2 查询&amp;创建表</h4><p>1）查询当前数据库所有表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show tables;</code></pre><p>2）查看指定表结构</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">desc 表名 ;</code></pre><p><img src="image-20230628220737834.png" alt="image-20230628220737834"></p><p>3）查询指定表的建表语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show create table 表名 ;</code></pre><p><img src="image-20230628220818933.png" alt="image-20230628220818933"></p><p>4）创建表结构</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;</code></pre><h4 id="1-2-3-修改表"><a href="#1-2-3-修改表" class="headerlink" title="1.2.3 修改表"></a>1.2.3 修改表</h4><p>1）添加字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>2）修改数据类型</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);</code></pre><p>3）修改字段名和字段类型</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>4）删除字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 DROP 字段名;</code></pre><p>5）修改表名</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 RENAME TO 新表名;</code></pre><h4 id="1-2-4-删除表"><a href="#1-2-4-删除表" class="headerlink" title="1.2.4 删除表"></a>1.2.4 删除表</h4><p>1）删除表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>2）删除指定表, 并重新创建表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">TRUNCATE TABLE 表名;</code></pre><hr><p><strong>总结</strong></p><p><img src="image-20230627155134728.png" alt="image-20230627155134728"></p><h2 id="2-DML-数据操作语言"><a href="#2-DML-数据操作语言" class="headerlink" title="2. DML(数据操作语言)"></a>2. DML(数据操作语言)</h2><p>用来对数据库中表的数据记录进行增、删、改操作。</p><h3 id="2-1-添加数据"><a href="#2-1-添加数据" class="headerlink" title="2.1 添加数据"></a>2.1 添加数据</h3><p>1）给指定字段添加数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>2）给全部字段添加数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>3）批量添加数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><blockquote><p>字符串和日期型数据应该包含在引号中。</p></blockquote><h3 id="2-2-修改-删除数据"><a href="#2-2-修改-删除数据" class="headerlink" title="2.2 修改&amp;删除数据"></a>2.2 修改&amp;删除数据</h3><p>修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ];</code></pre><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><blockquote><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。 </li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。</li></ul></blockquote><hr><p><strong>总结</strong></p><p><img src="image-20230627171309203.png" alt="image-20230627171309203"></p><h2 id="3-DQL-数据查询语言"><a href="#3-DQL-数据查询语言" class="headerlink" title="3. DQL(数据查询语言)"></a>3. DQL(数据查询语言)</h2><p>用来查询数据库中表的记录。</p><p><strong>语法结构</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT字段列表FROM表名列表WHERE条件列表GROUP BY分组字段列表HAVING分组后条件列表ORDER BY排序字段列表LIMIT分页参数</code></pre><h3 id="3-1-基础查询"><a href="#3-1-基础查询" class="headerlink" title="3.1 基础查询"></a>3.1 基础查询</h3><p>1）查询多个字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;SELECT * FROM 表名 ;</code></pre><p>2）字段设置别名</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3）去除重复记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="3-2-条件查询"><a href="#3-2-条件查询" class="headerlink" title="3.2 条件查询"></a>3.2 条件查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>比较运算符：</p><p><img src="image-20230629110212108.png" alt="image-20230629110212108"></p><p>逻辑运算符：</p><p><img src="image-20230629110244240.png" alt="image-20230629110244240"></p><blockquote><ul><li><p>查询年龄等于18 或 20 或 40 的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where age = 18 or age = 20 or age =40;select * from emp where age in(18,20,40);</code></pre></li><li><p>查询姓名为两个字的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where name like '__';</code></pre></li><li><p>查询身份证号最后一位是X的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where idcard like '%X';</code></pre></li></ul></blockquote><h3 id="3-3-聚合函数"><a href="#3-3-聚合函数" class="headerlink" title="3.3 聚合函数"></a>3.3 聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算 。</p><p><img src="image-20230629110652934.png" alt="image-20230629110652934"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><h3 id="3-4-分组查询"><a href="#3-4-分组查询" class="headerlink" title="3.4 分组查询"></a>3.4 分组查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>where与having区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是<strong>分组之后对结果进行过滤</strong>。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><blockquote><p>注意事项: </p><ul><li>分组之后，<strong>查询的字段一般为聚合函数和分组字段</strong>，查询其他字段无任何意义。</li><li>执行顺序: <strong>where &gt; 聚合函数 &gt; having</strong> 。</li><li>支持多字段分组, 具体语法为 : group by columnA,columnB</li></ul></blockquote><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select gender, count(*) from emp group by gender ;</code></pre><p>B. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select workaddress, count(*) address_count from emp where age &lt; 45 group by workaddress having address_count &gt;= 3;</code></pre><p>C. 统计各个工作地址上班的男性及女性员工的数量</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select workaddress, gender, count(*) '数量' from emp group by gender , workaddress;</code></pre><h3 id="3-5-排序查询"><a href="#3-5-排序查询" class="headerlink" title="3.5 排序查询"></a>3.5 排序查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>排序方式：</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><blockquote><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul></blockquote><h3 id="3-6-分页查询"><a href="#3-6-分页查询" class="headerlink" title="3.6 分页查询"></a>3.6 分页查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><blockquote><p>注意事项:</p><ul><li>起始索引从0开始，<code>起始索引 = （查询页码 - 1）* 每页显示记录数</code>。</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</li><li>如果查询的是<strong>第一页数据，起始索引可以省略</strong>，直接简写为 limit 10。</li></ul></blockquote><h3 id="3-7-执行顺序"><a href="#3-7-执行顺序" class="headerlink" title="3.7 执行顺序"></a>3.7 执行顺序</h3><p><img src="image-20230629112958600.png" alt="image-20230629112958600"></p><h2 id="4-DCL-数据控制语言"><a href="#4-DCL-数据控制语言" class="headerlink" title="4. DCL(数据控制语言)"></a>4. DCL(数据控制语言)</h2><p>用来管理数据库用户、控制数据库的访问权限。</p><h3 id="4-1-管理用户"><a href="#4-1-管理用户" class="headerlink" title="4.1 管理用户"></a>4.1 管理用户</h3><p>1）查询用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from mysql.user;</code></pre><p>2）创建用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</code></pre><p>3）修改用户密码</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;</code></pre><p>4）删除用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP USER '用户名'@'主机名' ;</code></pre><ul><li>主机名可以使用 % 通配，表示可以在任意主机访问该数据库。</li></ul><h3 id="4-2-权限控制"><a href="#4-2-权限控制" class="headerlink" title="4.2 权限控制"></a>4.2 权限控制</h3><p><img src="image-20230629113901483.png" alt="image-20230629113901483"></p><p>1）查询权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW GRANTS FOR '用户名'@'主机名' ;</code></pre><p>2）授予权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';</code></pre><p>3）撤销权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';</code></pre><p>A. 授予 ‘heima‘@’%’ 用户itcast数据库所有表的插入、修改操作权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant insert,update on itcast.* to 'heima'@'%';</code></pre><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h2><p><img src="image-20230629114302133.png" alt="image-20230629114302133"></p><ul><li>SUBSTRING(str,start,len)，start从1开始</li></ul><h2 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h2><p><img src="image-20230629114830889.png" alt="image-20230629114830889"></p><p>案例：通过数据库的函数，生成一个六位数的随机验证码。 </p><p>思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础 上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select lpad(round(rand()*1000000 , 0), 6, '0');</code></pre><h2 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h2><p><img src="image-20230629115115213.png" alt="image-20230629115115213"></p><h2 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4. 流程函数"></a>4. 流程函数</h2><p><img src="image-20230629115318270.png" alt="image-20230629115318270"></p><p>A. ifnull</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select ifnull('','Default');// ''select ifnull(null,'Default');// Default</code></pre><p>B. case when then else end</p><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">selectname,( case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end ) as '工作地址'from emp;</code></pre><h1 id="三、约束"><a href="#三、约束" class="headerlink" title="三、约束"></a>三、约束</h1><p>约束是作用于<strong>表中字段</strong>上的规则，用于限制存储在表中的数据。</p><p>可以在<strong>创建表/修改表</strong>的时候添加约束。</p><p><img src="image-20230629120030398.png" alt="image-20230629120030398"></p><h2 id="1-表内约束"><a href="#1-表内约束" class="headerlink" title="1. 表内约束"></a>1. 表内约束</h2><p>建表语句示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE tb_user(id int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',name varchar(10) NOT NULL UNIQUE COMMENT '姓名' ,age int check (age &gt; 0 &amp;&amp; age &lt;= 120) COMMENT '年龄' ,status char(1) default '1' COMMENT '状态',gender char(1) COMMENT '性别');</code></pre><h2 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2. 外键约束"></a>2. 外键约束</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="image-20230629120900172.png" alt="image-20230629120900172"></p><p>删除id为1的部门信息。若无外键约束，则删除成功。部门表不存在id为1的部门，而在emp表中还有很多的员 工，关联的为id为1的部门，此时就出现了数据的不完整性。 </p><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><p>1）添加外键</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE 表名(字段名 数据类型,...[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;</code></pre><p>案例：</p><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);-- 此时不能删除或更新父表(dept表)记录</code></pre><p>2）删除外键</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><h3 id="2-3-删除-更新行为"><a href="#2-3-删除-更新行为" class="headerlink" title="2.3 删除/更新行为"></a>2.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的<strong>约束行为</strong>，我们就称为删除/更新行为。</p><p><img src="image-20230629121558650.png" alt="image-20230629121558650"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></pre><h1 id="四、多表查询"><a href="#四、多表查询" class="headerlink" title="四、多表查询"></a>四、多表查询</h1><h2 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1. 多表关系"></a>1. 多表关系</h2><p>由于业务之间相互关联，各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一) </li><li>多对多 </li><li>一对一</li></ul><h3 id="1-1-一对多"><a href="#1-1-一对多" class="headerlink" title="1.1 一对多"></a>1.1 一对多</h3><p>案例: 部门与员工的关系 </p><p>关系: 一个部门对应多个员工，一个员工对应一个部门 </p><p>实现: 在多的一方建立外键，指向一的一方的主键</p><p><img src="image-20230629122221973.png" alt="image-20230629122221973"></p><h3 id="1-2-多对多"><a href="#1-2-多对多" class="headerlink" title="1.2 多对多"></a>1.2 多对多</h3><p>案例: 学生与课程的关系 </p><p>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </p><p>实现: <strong>建立第三张中间表</strong>，中间表至少包含两个外键，分别关联两方主键</p><p><img src="image-20230629122301079.png" alt="image-20230629122301079"></p><h3 id="1-3-一对一"><a href="#1-3-一对一" class="headerlink" title="1.3 一对一"></a>1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 </p><p>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且<strong>设置外键为唯一的(UNIQUE)</strong></p><p><img src="image-20230629122606871.png" alt="image-20230629122606871"></p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>多表查询会导致笛卡尔积，即两个集合A集合 和 B集合的所有组合情况。</p><p>此时需要加上<strong>连接查询的条件</strong>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp , dept where emp.dept_id = dept.id;</code></pre><p>分类：</p><ul><li>连接查询 <ul><li>内连接：相当于查询A、B交集部分数据 </li><li>外连接： <ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据 </li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul><h2 id="3-连接查询"><a href="#3-连接查询" class="headerlink" title="3. 连接查询"></a>3. 连接查询</h2><p><img src="image-20230629123330702.png" alt="image-20230629123330702"></p><h3 id="3-1-内连接"><a href="#3-1-内连接" class="headerlink" title="3.1 内连接"></a>3.1 内连接</h3><p>内连接查询的是两张表<strong>交集</strong>部分的数据。(也就是绿色部分的数据)</p><p>1）隐式内连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2）显式内连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><h3 id="3-2-外连接"><a href="#3-2-外连接" class="headerlink" title="3.2 外连接"></a>3.2 外连接</h3><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1）左外连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表A(左表)的所有数据，当然也包含表A和表B交集部分的数据。</p><p>2）右外连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表B(右表)的所有数据，当然也包含表A和表B交集部分的数据。</p><h3 id="3-3-自连接"><a href="#3-3-自连接" class="headerlink" title="3.3 自连接"></a>3.3 自连接</h3><h4 id="3-3-1-自连接查询"><a href="#3-3-1-自连接查询" class="headerlink" title="3.3.1 自连接查询"></a>3.3.1 自连接查询</h4><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><p>可以是内连接查询，也可以是外连接查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>案例：</p><p>A.  查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid = b.id;</code></pre><blockquote><p>注意事项: </p><p>在自连接查询中，必须要为表<strong>起别名</strong>，要不然我们不清楚所指定的条件、返回的字段，到底 是哪一张表的字段。</p></blockquote><h4 id="3-3-2-联合查询"><a href="#3-3-2-联合查询" class="headerlink" title="3.3.2 联合查询"></a>3.3.2 联合查询</h4><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的<strong>列数</strong>必须保持一致，<strong>字段类型</strong>也需要保持一致。 </li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据<strong>去重</strong>。</li></ul><p>案例: </p><p>A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们 也可以通过union/union all来联合查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><h2 id="4-子查询"><a href="#4-子查询" class="headerlink" title="4. 子查询"></a>4. 子查询</h2><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>根据子查询结果不同，分为： </p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询(子查询结果为一列) </li><li>行子查询(子查询结果为一行) </li><li>表子查询(子查询结果为多行多列)</li></ul><h3 id="4-1-标量子查询"><a href="#4-1-标量子查询" class="headerlink" title="4.1 标量子查询"></a>4.1 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式。</p><p>常用的操作符：=  &lt;&gt;  &gt;  &gt;=  &lt;  &lt;= </p><p>A. 查询 “销售部” 的所有员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where dept_id = (select id from dept where name = '销售部');</code></pre><h3 id="4-2-列子查询"><a href="#4-2-列子查询" class="headerlink" title="4.2 列子查询"></a>4.2 列子查询</h3><p>子查询返回的结果是一列（可以是多行）。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><p><img src="image-20230629151747021.png" alt="image-20230629151747021"></p><p>案例：</p><p>A. 查询比研发部其中任意一人工资高的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where salary &gt; any ( select salary from emp where dept_id = (select id from dept where name = '研发部') );</code></pre><h3 id="4-3-行子查询"><a href="#4-3-行子查询" class="headerlink" title="4.3 行子查询"></a>4.3 行子查询</h3><p>子查询返回的结果是一行（可以是多列）。</p><p>常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');</code></pre><h3 id="4-4-表子查询"><a href="#4-4-表子查询" class="headerlink" title="4.4 表子查询"></a>4.4 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例：</p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select e.*, d.* from (select * from emp where entrydate &gt; '2006-01-01') e left join dept d on e.dept_id = d.id ;</code></pre><h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会<strong>把所有的操作作为一个整体</strong>一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><img src="image-20230629153142370.png" alt="image-20230629153142370"></p><blockquote><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p></blockquote><h2 id="1-事务操作"><a href="#1-事务操作" class="headerlink" title="1. 事务操作"></a>1. 事务操作</h2><h3 id="1-1-方式一"><a href="#1-1-方式一" class="headerlink" title="1.1 方式一"></a>1.1 方式一</h3><p>1）查看/设置事务提交方式</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2）提交事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">COMMIT;</code></pre><p>3）回滚事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ROLLBACK;</code></pre><h3 id="1-2-方式二"><a href="#1-2-方式二" class="headerlink" title="1.2 方式二"></a>1.2 方式二</h3><p>1）开启事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">START TRANSACTION 或 BEGIN ;</code></pre><p>2）提交事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">COMMIT;</code></pre><p>3）回滚事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ROLLBACK;</code></pre><h2 id="2-事务四大特性"><a href="#2-事务四大特性" class="headerlink" title="2. 事务四大特性"></a>2. 事务四大特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 </li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="3-并发事务问题"><a href="#3-并发事务问题" class="headerlink" title="3. 并发事务问题"></a>3. 并发事务问题</h2><h3 id="3-1-脏读"><a href="#3-1-脏读" class="headerlink" title="3.1 脏读"></a>3.1 脏读</h3><p>一个事务读到另外一个事务<strong>还没有提交</strong>的数据。</p><p><img src="image-20230629153806493.png" alt="image-20230629153806493"></p><p>比如B读取到了A未提交的数据。</p><h3 id="3-2-不可重复读"><a href="#3-2-不可重复读" class="headerlink" title="3.2 不可重复读"></a>3.2 不可重复读</h3><p>一个事务先后读取同一条记录，因为<strong>事务B中途提交了数据</strong>，使事务A两次读取的数据不同，称之为不可重复读。</p><p><img src="image-20230629153834079.png" alt="image-20230629153834079"></p><p>事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><h3 id="3-3-幻读"><a href="#3-3-幻读" class="headerlink" title="3.3 幻读"></a>3.3 幻读</h3><p>一个事务按照条件查询数据时，没有对应的数据行，但是<strong>在插入数据时</strong>，又发现这行数据已经存在，好像出现了 “幻影”。</p><p><img src="image-20230629153930798.png" alt="image-20230629153930798"></p><h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h2><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><p><img src="image-20230629154408848.png" alt="image-20230629154408848"></p><ul><li>Serializable采用类似于Java多线程锁的机制，同一时间只能有一个事务操作数据库。</li><li>其他都是在事务A操作时，对于事务A不同步其他事务操作导致更改的数据。在事务A提交以后，才可看到其他事务操作产生影响的结果。</li></ul><p>1）查看事务隔离级别</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2）设置事务隔离级别</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL 隔离级别</code></pre><ul><li>SESSION | GLOBAL：当前会话 | 全部</li></ul><blockquote><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术</title>
      <link href="/2023/05/20/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/20/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p><strong>今日目标</strong> </p><blockquote><ul><li><p>理解什么是会话跟踪技术</p></li><li><p>掌握Cookie的使用</p></li><li><p>掌握Session的使用</p></li><li><p>完善用户登录注册案例的功能</p></li></ul></blockquote><h2 id="1-会话跟踪技术的概述"><a href="#1-会话跟踪技术的概述" class="headerlink" title="1. 会话跟踪技术的概述"></a>1. 会话跟踪技术的概述</h2><p>对于<code>会话跟踪</code>这四个词，我们需要拆开来进行解释，首先要理解什么是<code>会话</code>，然后再去理解什么是<code>会话跟踪</code>:</p><ul><li><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含==多次==请求和响应。</p><ul><li>从浏览器发出请求到服务端响应数据给前端之后，一次会话(在浏览器和服务器之间)就被建立了</li><li>会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着</li><li>浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称之为==会话==。</li></ul></li></ul><p>用实际场景来理解下会话，比如在我们访问京东的时候，当打开浏览器进入京东首页后，浏览器和京东的服务器之间就建立了一次会话，后面的搜索商品,查看商品的详情,加入购物车等都是在这一次会话中完成。</p><p>思考:下图中总共建立了几个会话?</p><p><img src="1629382713180.png" alt="1629382713180"></p><p>每个浏览器都会与服务端建立了一个会话，加起来总共是==3==个会话。</p><ul><li><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间==共享数据==。</p><ul><li>服务器会收到多个请求，这多个请求可能来自多个浏览器，如上图中的6个请求来自3个浏览器</li><li>服务器需要用来识别请求是否来自同一个浏览器</li><li>服务器用来识别浏览器的过程，这个过程就是==会话跟踪==</li><li>服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据</li></ul></li></ul><p>那么我们又有一个问题需要思考，一个会话中的多次请求为什么要共享数据呢?有了这个数据共享功能后能实现哪些功能呢?</p><ul><li><p>购物车: <code>加入购物车</code>和<code>去购物车结算</code>是两次请求，但是后面这次请求要想展示前一次请求所添加的商品，就需要用到数据共享。</p><p><img src="1629383655260.png" alt="1629383655260"></p></li><li><p>页面展示用户登录信息:很多网站，登录后访问多个功能发送多次请求后，浏览器上都会有当前登录用户的信息[用户名]，比如百度、京东、码云等。</p><p><img src="1629383767654.png" alt="1629383767654"></p></li><li><p>网站登录页面的<code>记住我</code>功能:当用户登录成功后，勾选<code>记住我</code>按钮后下次再登录的时候，网站就会自动填充用户名和密码，简化用户的登录操作，多次登录就会有多次请求，他们之间也涉及到共享数据</p><p><img src="1629383921990.png" alt="1629383921990"></p></li><li><p>登录页面的验证码功能:生成验证码和输入验证码点击注册这也是两次请求，这两次请求的数据之间要进行对比，相同则允许注册，不同则拒绝注册，该功能的实现也需要在同一次会话中共享数据。</p><p><img src="1629384004179.png" alt="1629384004179"></p></li></ul><hr><p>通过这几个例子的讲解，相信大家对<code>会话追踪</code>技术已经有了一定的理解，该技术在实际开发中也非常重要。那么接下来我们就需要去学习下<code>会话跟踪</code>技术，在学习这些技术之前，我们需要思考:为什么现在浏览器和服务器不支持数据共享呢?</p><ul><li>浏览器和服务器之间使用的是HTTP请求来进行数据传输</li><li>HTTP协议是==无状态==的，每次浏览器向服务器请求时，服务器都会将该请求视为==新的==请求</li><li>HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响</li><li>请求与请求之间独立后，就无法实现多次请求之间的数据共享</li></ul><p>分析完具体的原因后，那么该如何实现会话跟踪技术呢? 具体的实现方式有:</p><p>(1)客户端会话跟踪技术：==Cookie==</p><p>(2)服务端会话跟踪技术：==Session==</p><p>这两个技术都可以实现会话跟踪，它们之间最大的区别:==Cookie是存储在浏览器端而Session是存储在服务器端==</p><p>具体的学习思路为:</p><ul><li>CooKie的基本使用、原理、使用细节</li><li>Session的基本使用、原理、使用细节</li><li>Cookie和Session的综合案例</li></ul><p><strong>小结</strong></p><p>在这节中，我们主要介绍了下什么是会话和会话跟踪技术，需要注意的是:</p><ul><li>HTTP协议是无状态的，靠HTTP协议是无法实现会话跟踪</li><li>想要实现会话跟踪，就需要用到Cookie和Session</li></ul><p>这个Cookie和Session具体该如何使用，接下来就先从Cookie来学起。</p><h2 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h2><p>学习Cookie，我们主要解决下面几个问题:</p><ul><li>什么是Cookie?</li><li>Cookie如何来使用?</li><li>Cookie是如何实现的?</li><li>Cookie的使用注意事项有哪些?</li></ul><h3 id="2-1-Cookie的基本使用"><a href="#2-1-Cookie的基本使用" class="headerlink" title="2.1 Cookie的基本使用"></a>2.1 Cookie的基本使用</h3><p><strong>1.概念</strong></p><p>==Cookie==：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。</p><p><strong>2.Cookie的工作流程</strong></p><p><img src="1629386230207.png" alt="1629386230207"></p><ul><li>服务端提供了两个Servlet，分别是ServletA和ServletB</li><li>浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理</li><li>服务端ServletA在处理的过程中可以创建一个Cookie对象并将<code>name=zs</code>的数据存入Cookie</li><li>服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器</li><li>浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就==建立了一次会话==</li><li>==在同一次会话==中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据</li><li>ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享</li></ul><p><strong>3.Cookie的基本使用</strong></p><p>对于Cookie的使用，我们更关注的应该是后台代码如何操作Cookie，对于Cookie的操作主要分两大类，分别是==发送Cookie==和==获取Cookie==，对于上面这两块内容，分别该如何实现呢?</p><p>3.1 发送Cookie</p><ul><li>创建Cookie对象，并设置数据</li></ul><pre class="line-numbers language-none"><code class="language-none">Cookie cookie = new Cookie("key","value");</code></pre><ul><li>发送Cookie到客户端：使用==response==对象</li></ul><pre class="line-numbers language-none"><code class="language-none">response.addCookie(cookie);</code></pre><p>介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Cookie的发送，具体实现步骤为:</p><blockquote><p>需求:在Servlet中生成Cookie对象并存入数据，然后将数据发送给浏览器</p><p>1.创建Maven项目,项目名称为cookie-demo，并在pom.xml添加依赖</p><p>2.编写Servlet类，名称为AServlet</p><p>3.在AServlet中创建Cookie对象，存入数据，发送给前端</p><p>4.启动测试，在浏览器查看Cookie对象中的值</p></blockquote><p>(1)创建Maven项目cookie-demo，并在pom.xml添加依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;properties&gt;    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!--servlet--&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--jsp--&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--jstl--&gt;    &lt;dependency&gt;        &lt;groupId&gt;jstl&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;taglibs&lt;/groupId&gt;        &lt;artifactId&gt;standard&lt;/artifactId&gt;        &lt;version&gt;1.1.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>(2)编写Servlet类，名称为AServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/aServlet")public class AServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)在Servlet中创建Cookie对象，存入数据，发送给前端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/aServlet")public class AServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //发送Cookie        //1. 创建Cookie对象        Cookie cookie = new Cookie("username","zs");        //2. 发送Cookie，response        response.addCookie(cookie);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>（4）启动测试，在浏览器查看Cookie对象中的值</p><p>访问<code>http://localhost:8080/cookie-demo/aServlet</code></p><p>chrome浏览器查看Cookie的值，有两种方式,分布式:</p><p>方式一:</p><p><img src="1629389317463.png" alt="1629389317463"></p><p>方式二:选中打开开发者工具或者 使用快捷键F12 或者 Ctrl+Shift+I</p><p><img src="1629390237936.png" alt="1629390237936"></p><p>3.2 获取Cookie</p><ul><li>获取客户端携带的所有Cookie，使用==request==对象</li></ul><pre class="line-numbers language-none"><code class="language-none">Cookie[] cookies = request.getCookies();</code></pre><ul><li>遍历数组，获取每一个Cookie对象：for</li><li>使用Cookie对象方法获取数据</li></ul><pre class="line-numbers language-none"><code class="language-none">cookie.getName();cookie.getValue();</code></pre><p>介绍完获取Cookie对应的步骤后，接下面再通过一个案例来完成Cookie的获取，具体实现步骤为:</p><blockquote><p>需求:在Servlet中获取前一个案例存入在Cookie对象中的数据</p><p>1.编写一个新Servlet类，名称为BServlet</p><p>2.在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值</p><p>3.启动测试，在控制台打印出获取的值</p></blockquote><p>(1)编写一个新Servlet类，名称为BServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/bServlet")public class BServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>（2）在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/bServlet")public class BServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取Cookie        //1. 获取Cookie数组        Cookie[] cookies = request.getCookies();        //2. 遍历数组        for (Cookie cookie : cookies) {            //3. 获取数据            String name = cookie.getName();            if("username".equals(name)){                String value = cookie.getValue();                System.out.println(name+":"+value);                break;            }        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>（3）启动测试，在控制台打印出获取的值</p><p>访问<code>http://localhost:8080/cookie-demo/bServlet</code></p><p><img src="1629391020081.png" alt="1629391020081"></p><p>在IDEA控制台就能看到输出的结果:</p><p><img src="1629391061140.png" alt="1629391061140"></p><p>==思考:==测试的时候</p><ul><li>在访问AServlet和BServlet的中间把关闭浏览器,重启浏览器后访问BServlet能否获取到Cookie中的数据?</li></ul><p>这个问题，我们会在Cookie的使用细节中讲，大家可以动手先试下。</p><p><strong>小结</strong></p><p>在这节中，我们主要讲解了Cookie的基本使用,包含两部分内容</p><ul><li>发送Cookie:<ul><li>创建Cookie对象，并设置值:Cookie cookie = new Cookie(“key”,”value”);</li><li>发送Cookie到客户端使用的是Reponse对象:response.addCookie(cookie);</li></ul></li><li>获取Cookie:<ul><li>使用Request对象获取Cookie数组:Cookie[] cookies = request.getCookies();</li><li>遍历数组</li><li>获取数组中每个Cookie对象的值:cookie.getName()和cookie.getValue()</li></ul></li></ul><p>介绍完Cookie的基本使用之后，那么Cookie的底层到底是如何实现一次会话两次请求之间的数据共享呢?</p><h3 id="2-2-Cookie的原理分析"><a href="#2-2-Cookie的原理分析" class="headerlink" title="2.2 Cookie的原理分析"></a>2.2 Cookie的原理分析</h3><p>对于Cookie的实现原理是基于HTTP协议的,其中设计到HTTP协议中的两个请求头信息:</p><ul><li>响应头:set-cookie</li><li>请求头: cookie</li></ul><p><img src="1629393289338.png" alt="1629393289338"></p><ul><li>前面的案例中已经能够实现，AServlet给前端发送Cookie,BServlet从request中获取Cookie的功能</li><li>对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据</li><li>当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在响应头中添加一行数据==<code>Set-Cookie:username=zs</code>==</li><li>浏览器获取到响应结果后，从响应头中就可以获取到<code>Set-Cookie</code>对应值<code>username=zs</code>,并将数据存储在浏览器的内存中</li><li>浏览器再次发送请求给BServlet的时候，浏览器会自动在请求头中添加==<code>Cookie: username=zs</code>==发送给服务端BServlet</li><li>Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组</li><li>BServlet通过Request对象获取到Cookie[]后，就可以从中获取自己需要的数据</li></ul><p>接下来，使用刚才的案例，把上述结论验证下:</p><p>(1)访问AServlet对应的地址<code>http://localhost:8080/cookie-demo/aServlet</code></p><p>使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看==响应头==中的数据</p><p><img src="1629393428733.png" alt="1629393428733"></p><p>（2）访问BServlet对应的地址`<a href="http://localhost:8080/cookie-demo/bServlet">http://localhost:8080/cookie-demo/bServlet</a></p><p>使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看==请求头==中的数据</p><p><img src="1629393578667.png" alt="1629393578667"></p><h3 id="2-3-Cookie的使用细节"><a href="#2-3-Cookie的使用细节" class="headerlink" title="2.3 Cookie的使用细节"></a>2.3 Cookie的使用细节</h3><p>在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。</p><h4 id="2-3-1-Cookie的存活时间"><a href="#2-3-1-Cookie的存活时间" class="headerlink" title="2.3.1 Cookie的存活时间"></a>2.3.1 Cookie的存活时间</h4><p>前面让大家思考过一个问题:</p><p><img src="1629423321737.png" alt="1629423321737"></p><p>(1)浏览器发送请求给AServlet,AServlet会响应一个存有<code>usernanme=zs</code>的Cookie对象给浏览器</p><p>(2)浏览器接收到响应数据将cookie存入到浏览器内存中</p><p>(3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据</p><p>(4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据?</p><p>==注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。==</p><p>针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢?</p><ul><li>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</li></ul><p>这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如:</p><p><img src="1629423629887.png" alt="1629423629887"></p><p>上面这个网站的登录页面上有一个<code>记住我</code>的功能，这个功能大家都比较熟悉</p><ul><li>第一次输入用户名和密码并勾选<code>记住我</code>然后进行登录</li><li>下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录</li><li>比如<code>记住我</code>这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题</li><li>因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于<code>记住我</code>功能就无法实现</li></ul><p>所以我们现在就遇到一个难题是如何将Cookie持久化存储?</p><p>Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是==setMaxAge==,</p><ul><li>设置Cookie存活时间</li></ul><pre class="line-numbers language-none"><code class="language-none">setMaxAge(int seconds)</code></pre><p>参数值为:</p><p>1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</p><p>2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p><p>3.零：删除对应Cookie</p><p>接下来，咱们就在AServlet中去设置Cookie的存活时间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/aServlet")public class AServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //发送Cookie        //1. 创建Cookie对象        Cookie cookie = new Cookie("username","zs");        //设置存活时间   ，1周 7天        cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算//cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算        //2. 发送Cookie，response        response.addCookie(cookie);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>修改完代码后，启动测试，访问<code>http://localhost:8080/cookie-demo/aServlet</code></p><ul><li>访问一个AServlet后，把浏览器关闭重启后，再去访问<code>http://localhost:8080/cookie-demo/bServet</code>,能在控制台打印出<code>username:zs</code>,说明Cookie没有随着浏览器关闭而被销毁</li><li>通过浏览器查看Cookie的内容，会发现Cookie的相关信息</li></ul><p><img src="1629424844041.png" alt="1629424844041"></p><h4 id="2-3-2-Cookie存储中文"><a href="#2-3-2-Cookie存储中文" class="headerlink" title="2.3.2 Cookie存储中文"></a>2.3.2 Cookie存储中文</h4><p>首先，先来演示一个效果，将之前<code>username=zs</code>的值改成<code>username=张三</code>，把汉字<code>张三</code>存入到Cookie中，看是什么效果:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/aServlet")public class AServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie        String value = "张三";        Cookie cookie = new Cookie("username",value);        //设置存活时间   ，1周 7天        cookie.setMaxAge(60*60*24*7);        //2. 发送Cookie，response        response.addCookie(cookie);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>启动访问测试，访问<code>http://localhost:8080/cookie-demo/aServlet</code>会发现浏览器会提示错误信息</p><p><img src="1629425945465.png" alt="1629425945465"></p><p>通过上面的案例演示，我们得到一个结论:</p><ul><li>Cookie不能直接存储中文</li></ul><p>Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢?</p><p>这个时候，我们可以使用之前学过的一个知识点叫<code>URL编码</code>，所以如果需要存储中文，就需要进行转码，具体的实现思路为:</p><blockquote><p>1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中</p><p>2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值</p><p>3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值</p></blockquote><p>(1)在AServlet中对中文进行<strong>URL编码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/aServlet")public class AServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //发送Cookie        String value = "张三";        //对中文进行URL编码        value = URLEncoder.encode(value, "UTF-8");        System.out.println("存储数据："+value);        //将编码后的值存入Cookie中        Cookie cookie = new Cookie("username",value);        //设置存活时间   ，1周 7天        cookie.setMaxAge(60*60*24*7);        //2. 发送Cookie，response        response.addCookie(cookie);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)在BServlet中获取值，并对值进行<strong>URL解码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/bServlet")public class BServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取Cookie        //1. 获取Cookie数组        Cookie[] cookies = request.getCookies();        //2. 遍历数组        for (Cookie cookie : cookies) {            //3. 获取数据            String name = cookie.getName();            if("username".equals(name)){                String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89                //URL解码                value = URLDecoder.decode(value,"UTF-8");                System.out.println(name+":"+value);//value解码后为 张三                break;            }        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>至此，我们就可以将中文存入Cookie中进行使用。</p><p><strong>小结</strong></p><p>Cookie的使用细节中，我们讲了Cookie的<code>存活时间</code>和<code>存储中文</code>:</p><ul><li><p>存活时间，需要掌握setMaxAage()API的使用</p></li><li><p>存储中文，需要掌握URL编码和解码的使用</p></li></ul><h2 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h2><p>Cookie已经能完成一次会话多次请求之间的数据共享，之前我们还提到过Session也可以实现，那么:</p><ul><li>什么是Session?</li><li>Session如何来使用?</li><li>Session是如何实现的?</li><li>Session的使用注意事项有哪些?</li></ul><h3 id="3-1-Session的基本使用"><a href="#3-1-Session的基本使用" class="headerlink" title="3.1 Session的基本使用"></a>3.1 Session的基本使用</h3><p><strong>1.概念</strong></p><p>==Session==：服务端会话跟踪技术：将数据保存到服务端。</p><ul><li>Session是存储在服务端而Cookie是存储在客户端</li><li>存储在客户端的数据容易被窃取和截获，存在很多不安全的因素</li><li>存储在服务端的数据相比于客户端来说就更安全</li></ul><p><strong>2.Session的工作流程</strong></p><p> <img src="1629427173389.png" alt="1629427173389"></p><ul><li>在服务端的AServlet获取一个Session对象，把数据存入其中</li><li>在服务端的BServlet获取到相同的Session对象，从中取出数据</li><li>就可以实现一次会话中多次请求之间的数据共享了</li><li>现在最大的问题是如何保证AServlet和BServlet使用的是同一个Session对象(在原理分析会讲解)?</li></ul><p><strong>3.Session的基本使用</strong></p><p>在JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能。</p><p>具体的使用步骤为:</p><ul><li>获取Session对象,使用的是request对象</li></ul><pre class="line-numbers language-none"><code class="language-none">HttpSession session = request.getSession();</code></pre><ul><li><p>Session对象提供的功能:</p><ul><li><p>存储数据到 session 域中</p><pre class="line-numbers language-none"><code class="language-none">void setAttribute(String name, Object o)</code></pre></li><li><p>根据 key，获取值</p><pre class="line-numbers language-none"><code class="language-none">Object getAttribute(String name)</code></pre></li><li><p>根据 key，删除该键值对</p><pre class="line-numbers language-none"><code class="language-none">void removeAttribute(String name)</code></pre></li></ul></li></ul><p>介绍完Session相关的API后，接下来通过一个案例来完成对Session的使用，具体实现步骤为:</p><blockquote><p>需求:在一个Servlet中往Session中存入数据，在另一个Servlet中获取Session中存入的数据</p><p>1.创建名为SessionDemo1的Servlet类</p><p>2.创建名为SessionDemo2的Servlet类</p><p>3.在SessionDemo1的方法中:获取Session对象、存储数据</p><p>4.在SessionDemo2的方法中:获取Session对象、获取数据</p><p>5.启动测试</p></blockquote><p>(1)创建名为SessionDemo1的Servlet类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo1")public class SessionDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)创建名为SessionDemo2的Servlet类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo2")public class SessionDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)SessionDemo1:获取Session对象、存储数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo1")public class SessionDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //存储到Session中        //1. 获取Session对象        HttpSession session = request.getSession();        //2. 存储数据        session.setAttribute("username","zs");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(4)SessionDemo2:获取Session对象、获取数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo2")public class SessionDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取数据，从session中        //1. 获取Session对象        HttpSession session = request.getSession();        //2. 获取数据        Object username = session.getAttribute("username");        System.out.println(username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(5)启动测试，</p><ul><li>先访问<code>http://localhost:8080/cookie-demo/demo1</code>,将数据存入Session</li><li>在访问<code>http://localhost:8080/cookie-demo/demo2</code>,从Session中获取数据</li><li>查看控制台</li></ul><p><img src="1629428292373.png" alt="1629428292373"></p><p>通过案例的效果，能看到Session是能够在一次会话中两次请求之间共享数据。</p><p><strong>小结</strong></p><p>至此Session的基本使用就已经完成了，重点要掌握的是:</p><ul><li><p>Session的获取</p><pre class="line-numbers language-none"><code class="language-none">HttpSession session = request.getSession();</code></pre></li><li><p>Session常用方法的使用</p><pre class="line-numbers language-none"><code class="language-none">void setAttribute(String name, Object o)Object getAttribute(String name)</code></pre><p>**注意:**Session中可以存储的是一个Object类型的数据，也就是说Session中可以存储任意数据类型。</p></li></ul><p>介绍完Session的基本使用之后，那么Session的底层到底是如何实现一次会话两次请求之间的数据共享呢?</p><h3 id="3-2-Session的原理分析"><a href="#3-2-Session的原理分析" class="headerlink" title="3.2 Session的原理分析"></a>3.2 Session的原理分析</h3><ul><li>Session是基于Cookie实现的</li></ul><p>这句话其实不太能详细的说明Session的底层实现，接下来，咱们一步步来分析下Session的具体实现原理:</p><p>(1)前提条件</p><p><img src="1629429063101.png" alt="1629429063101"></p><p>Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。</p><p>那么它们是一个对象么？要验证这个结论也很简单，只需要在上面案例中的两个Servlet中分别打印下Session对象</p><p>SessionDemo1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo1")public class SessionDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    //存储到Session中        //1. 获取Session对象        HttpSession session = request.getSession();        System.out.println(session);        //2. 存储数据        session.setAttribute("username","zs");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>SessionDemo2</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo2")public class SessionDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取数据，从session中        //1. 获取Session对象        HttpSession session = request.getSession();        System.out.println(session);        //2. 获取数据        Object username = session.getAttribute("username");        System.out.println(username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>启动测试，分别访问</p><p><code>http://localhost:8080/cookie-demo/demo1</code></p><p><code>http://localhost:8080/cookie-demo/demo2</code></p><p><img src="1629429239409.png" alt="1629429239409"></p><p>通过打印可以得到如下结论:</p><ul><li>两个Servlet类中获取的Session对象是同一个</li><li>把demo1和demo2请求刷新多次，控制台最终打印的结果都是同一个</li></ul><p>那么问题又来了，如果新开一个浏览器，访问demo1或者demo2,打印在控制台的Session还是同一个对象么?</p><p><img src="1629429788264.png" alt="1629429788264"></p><p>==注意:在一台电脑上演示的时候，如果是相同的浏览器必须要把浏览器全部关掉重新打开，才算新开的一个浏览器。==</p><p>当然也可以使用不同的浏览器进行测试，就不需要把之前的浏览器全部关闭。</p><p>测试的结果：如果是不同浏览器或者重新打开浏览器后，打印的Session就不一样了。</p><p>所以Session实现的也是一次会话中的多次请求之间的数据共享。</p><p>那么最主要的问题就来了，Session是如何保证在一次会话中获取的Session对象是同一个呢?</p><p><img src="1629430754825.png" alt="1629430754825"></p><p>(1)demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是<code>id:10</code></p><p>(2)demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器</p><p>(3)Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识<code>id:10</code>当做一个cookie，添加<code>Set-Cookie:JESSIONID=10</code>到响应头中，并响应给浏览器</p><p>(4)浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中</p><p>(5)浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照<code>cookie: JESSIONID=10</code>的格式添加到请求头中并发送给服务器Tomcat</p><p>(6)demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找<code>id:10</code>的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象</p><p>(7)关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象</p><p>至此，<code>Session是基于Cookie来实现的</code>这就话，我们就解释完了，接下来通过实例来演示下:</p><p>(1)使用chrome浏览器访问<code>http://localhost:8080/cookie-demo/demo1</code>,打开开发者模式(F12或Ctrl+Shift+I),查看==响应头(Response Headers)==数据:</p><p><img src="1629430891071.png" alt="1629430891071"></p><p>(2)使用chrome浏览器再次访问<code>http://localhost:8080/cookie-demo/demo2</code>，查看==请求头(Request Headers)==数据:</p><p><img src="1629431299195.png" alt="1629431299195"></p><p><strong>小结</strong></p><p>介绍完Session的原理，我们只需要记住</p><ul><li>Session是基于Cookie来实现的</li></ul><h3 id="3-3-Session的使用细节"><a href="#3-3-Session的使用细节" class="headerlink" title="3.3 Session的使用细节"></a>3.3 Session的使用细节</h3><p>这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？</p><h4 id="3-3-1-Session钝化与活化"><a href="#3-3-1-Session钝化与活化" class="headerlink" title="3.3.1 Session钝化与活化"></a>3.3.1 Session钝化与活化</h4><p>首先需要大家思考的问题是: </p><ul><li>服务器重启后，Session中的数据是否还在?</li></ul><p>要想回答这个问题，我们可以先看下下面这幅图，</p><p><img src="1629438984314.png" alt="1629438984314"> </p><p>(1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中</p><p>(2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了</p><p>所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢?</p><p>举个例子说明下，</p><p>(1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中</p><p>(2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了</p><p>(3)正在用户打电话的时候，购物网站因为某些原因需要重启</p><p>(4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失</p><p>(5)用户想再次发起支付，就会出为问题</p><p>所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。</p><p>分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下:</p><p>==注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。==</p><p>那如何才是正常关闭Tomcat服务器呢?</p><p>需要使用命令行的方式来启动和停止Tomcat服务器:</p><p>==启动==:进入到项目pom.xml所在目录，执行<code>tomcat7:run</code></p><p><img src="1629439800328.png" alt="1629439800328"></p><p>==停止==:在启动的命令行界面，输入<code>ctrl+c</code></p><p><img src="1629439879596.png" alt="1629439879596"></p><p>有了上述两个正常启动和关闭的方式后，接下来的测试流程是:</p><p>(1)先启动Tomcat服务器</p><p>(2)访问<code>http://localhost:8080/cookie-demo/demo1</code>将数据存入session中</p><p>(3)正确停止Tomcat服务器</p><p>(4)再次重新启动Tomcat服务器</p><p>(5)访问<code>http://localhost:8080/cookie-demo/demo2</code> 查看是否能获取到session中的数据</p><p><img src="1629440018238.png" alt="1629440018238"></p><p>经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。</p><p>那么Tomcat服务器到底是如何做到的呢?</p><p>具体的原因就是:Session的钝化和活化:</p><ul><li><p>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中</p><ul><li><p>钝化的数据路径为:<code>项目目录\target\tomcat\work\Tomcat\localhost\项目名称\SESSIONS.ser</code></p><p><img src="1629440576828.png" alt="1629440576828"></p></li></ul></li><li><p>活化：再次启动服务器后，从文件中加载数据到Session中</p><ul><li>数据加载到Session中后，路径中的<code>SESSIONS.ser</code>文件会被删除掉</li></ul></li></ul><p>对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。</p><p><strong>小结</strong></p><p>Session的钝化和活化介绍完后，需要我们注意的是:</p><ul><li><p>session数据存储在服务端，服务器重启后，session数据会被保存</p></li><li><p>浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象</p></li><li><p>session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据</p></li><li><p>cookie是存储在客户端，是可以长期保存</p></li></ul><h4 id="3-3-2-Session销毁"><a href="#3-3-2-Session销毁" class="headerlink" title="3.3.2 Session销毁"></a>3.3.2 Session销毁</h4><p>session的销毁会有两种方式:</p><ul><li><p>默认情况下，无操作，30分钟自动销毁</p><ul><li><p>对于这个失效时间，是可以通过配置进行修改的</p><ul><li><p>在项目的web.xml中配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"         version="3.1"&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;100&lt;/session-timeout&gt;    &lt;/session-config&gt;&lt;/web-app&gt;</code></pre></li><li><p>如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的</p><p><img src="1629441687613.png" alt="1629441687613"></p></li></ul></li></ul></li><li><p>调用Session对象的invalidate()进行销毁</p><ul><li><p>在SessionDemo2类中添加session销毁的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo2")public class SessionDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取数据，从session中        //1. 获取Session对象        HttpSession session = request.getSession();        System.out.println(session);        // 销毁        session.invalidate();        //2. 获取数据        Object username = session.getAttribute("username");        System.out.println(username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre></li><li><p>启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据</p><p><img src="1629441900843.png" alt="1629441900843"></p></li><li><p>该销毁方法一般会在用户退出的时候，需要将session销毁掉。</p></li></ul></li></ul><p><strong>Cookie和Session小结</strong></p><ul><li>Cookie 和 Session 都是来完成一次会话内多次请求间==数据共享==的。</li></ul><p>所需两个对象放在一块，就需要思考:</p><p>Cookie和Session的区别是什么?</p><p>Cookie和Session的应用场景分别是什么?</p><ul><li>区别:<ul><li>存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端</li><li>安全性：Cookie不安全，Session安全</li><li>数据大小：Cookie最大3KB，Session无大小限制</li><li>存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟</li><li>服务器性能：Cookie不占服务器资源，Session占用服务器资源</li></ul></li><li>应用场景:<ul><li>购物车:使用Cookie来存储</li><li>以登录用户的名称展示:使用Session来存储</li><li>记住我功能:使用Cookie来存储</li><li>验证码:使用session来存储</li></ul></li><li>结论<ul><li>Cookie是用来保证用户在未登录情况下的身份识别</li><li>Session是用来保存用户登录后的数据</li></ul></li></ul><p>介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。</p><h2 id="4-用户登录注册案例"><a href="#4-用户登录注册案例" class="headerlink" title="4. 用户登录注册案例"></a>4. 用户登录注册案例</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p> 需求说明：</p><ol><li><p>完成用户登录功能，如果用户勾选“记住用户” ，则下次访问登录页面==自动==填充用户名密码</p></li><li><p>完成注册功能，并实现==验证码==功能</p></li></ol><p><img src="1629442826981.png" alt="1629442826981"></p><h3 id="4-2-用户登录功能"><a href="#4-2-用户登录功能" class="headerlink" title="4.2 用户登录功能"></a>4.2 用户登录功能</h3><ol><li>需求:</li></ol><p><img src="1629443152010.png" alt="1629443152010"></p><ul><li>用户登录成功后，跳转到列表页面，并在页面上展示当前登录的用户名称</li><li>用户登录失败后，跳转回登录页面，并在页面上展示对应的错误信息</li></ul><ol start="2"><li>实现流程分析</li></ol><p><img src="1629443379531.png" alt="1629443379531"></p><p>(1)前端通过表单发送请求和数据给Web层的LoginServlet</p><p>(2)在LoginServlet中接收请求和数据[用户名和密码]</p><p>(3)LoginServlet接收到请求和数据后，调用Service层完成根据用户名和密码查询用户对象</p><p>(4)在Service层需要编写UserService类，在类中实现login方法，方法中调用Dao层的UserMapper</p><p>(5)在UserMapper接口中，声明一个根据用户名和密码查询用户信息的方法</p><p>(6)Dao层把数据查询出来以后，将返回数据封装到User对象，将对象交给Service层</p><p>(7)Service层将数据返回给Web层</p><p>(8)Web层获取到User对象后，判断User对象，如果为Null,则将错误信息响应给登录页面，如果不为Null，则跳转到列表页面，并把当前登录用户的信息存入Session携带到列表页面。</p><ol start="3"><li>具体实现</li></ol><p>(1)完成Dao层的代码编写</p><p>(1.1)将<code>04-资料\1. 登录注册案例\2. MyBatis环境\UserMapper.java</code>放到com.itheima.mapper`包下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserMapper {    /**     * 根据用户名和密码查询用户对象     * @param username     * @param password     * @return     */    @Select("select * from tb_user where username = #{username} and password = #{password}")    User select(@Param("username") String username,@Param("password")  String password);    /**     * 根据用户名查询用户对象     * @param username     * @return     */    @Select("select * from tb_user where username = #{username}")    User selectByUsername(String username);    /**     * 添加用户     * @param user     */    @Insert("insert into tb_user values(null,#{username},#{password})")    void add(User user);}</code></pre><p>(1.2)将<code>04-资料\1. 登录注册案例\2. MyBatis环境\User.java</code>放到<code>com.itheima.pojo</code>包下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {    private Integer id;    private String username;    private String password;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    @Override    public String toString() {        return "User{" +                "id=" + id +                ", username='" + username + '\'' +                ", password='" + password + '\'' +                '}';    }}</code></pre><p>(1.3)将<code>04-资料\1. 登录注册案例\2. MyBatis环境\UserMapper.xml</code>放入到resources/com/itheima/mapper`目录下:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.mapper.UserMapper"&gt;&lt;/mapper&gt;</code></pre><p>(2)完成Service层的代码编写</p><p>(2.1)在<code>com.itheima.service</code>包下，创建UserService类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserService {    //1.使用工具类获取SqlSessionFactory    SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory();    /**     * 登录方法     * @param username     * @param password     * @return     */    public User login(String username,String password){        //2. 获取SqlSession        SqlSession sqlSession = factory.openSession();        //3. 获取UserMapper        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        //4. 调用方法        User user = mapper.select(username, password);        //释放资源        sqlSession.close();        return  user;    }}</code></pre><p>(3)完成页面和Web层的代码编写</p><p>(3.1)将<code>04-资料\1. 登录注册案例\1. 静态页面</code>拷贝到项目的<code>webapp</code>目录下:</p><p><img src="1629444649629.png" alt="1629444649629"></p><p>(3.2)将login.html内容修改成login.jsp</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;login&lt;/title&gt;    &lt;link href="css/login.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="loginDiv" style="height: 350px"&gt;    &lt;form action="/brand-demo/loginServlet" method="post" id="form"&gt;        &lt;h1 id="loginMsg"&gt;LOGIN IN&lt;/h1&gt;        &lt;div id="errorMsg"&gt;用户名或密码不正确&lt;/div&gt;        &lt;p&gt;Username:&lt;input id="username" name="username" type="text"&gt;&lt;/p&gt;        &lt;p&gt;Password:&lt;input id="password" name="password" type="password"&gt;&lt;/p&gt;        &lt;p&gt;Remember:&lt;input id="remember" name="remember" type="checkbox"&gt;&lt;/p&gt;        &lt;div id="subDiv"&gt;            &lt;input type="submit" class="button" value="login up"&gt;            &lt;input type="reset" class="button" value="reset"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;            &lt;a href="register.html"&gt;没有账号？&lt;/a&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(3.3)创建LoginServlet类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/loginServlet")public class LoginServlet extends HttpServlet {    private UserService service = new UserService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 获取用户名和密码        String username = request.getParameter("username");        String password = request.getParameter("password");           //2. 调用service查询        User user = service.login(username, password);        //3. 判断        if(user != null){            //登录成功，跳转到查询所有的BrandServlet                        //将登陆成功后的user对象，存储到session            HttpSession session = request.getSession();            session.setAttribute("user",user);                        String contextPath = request.getContextPath();            response.sendRedirect(contextPath+"/selectAllServlet");        }else {            // 登录失败,            // 存储错误信息到request            request.setAttribute("login_msg","用户名或密码错误");            // 跳转到login.jsp            request.getRequestDispatcher("/login.jsp").forward(request,response);        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3.4)在brand.jsp中标签下添加欢迎当前用户的提示信息:</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;h1&gt;${user.username},欢迎您&lt;/h1&gt;</code></pre><p>(3.5) 修改login.jsp，将错误信息使用EL表达式来获取</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">修改前内容:&lt;div id="errorMsg"&gt;用户名或密码不正确&lt;/div&gt;修改后内容: &lt;div id="errorMsg"&gt;${login_msg}&lt;/div&gt;</code></pre><p>(4)启动，访问测试</p><p>(4.1) 进入登录页面，输入错误的用户名或密码</p><p><img src="1629445376407.png" alt="1629445376407"></p><p>(4.2)输入正确的用户和密码信息</p><p><img src="1629445415216.png" alt="1629445415216"></p><p><strong>小结</strong></p><ul><li>在LoginServlet中，将登录成功的用户数据存入session中，方法在列表页面中获取当前登录用户信息进行展示</li><li>在LoginServlet中，将登录失败的错误信息存入到request中，如果存入到session中就会出现这次会话的所有请求都有登录失败的错误信息，这个是不需要的，所以不用存入到session中</li></ul><h3 id="4-3-记住我-设置Cookie"><a href="#4-3-记住我-设置Cookie" class="headerlink" title="4.3 记住我-设置Cookie"></a>4.3 记住我-设置Cookie</h3><ol><li>需求:</li></ol><p>如果用户勾选“记住用户” ，则下次访问登陆页面自动填充用户名密码。这样可以提升用户的体验。</p><p><img src="1629445835281.png" alt="1629445835281"></p><p>对应上面这个需求，最大的问题就是: 如何自动填充用户名和密码?</p><ol start="2"><li>实现流程分析</li></ol><p>因为<code>记住我</code>功能要实现的效果是，就算用户把浏览器关闭过几天再来访问也能自动填充，所以需要将登陆信息存入一个可以长久保存，并且能够在浏览器关闭重新启动后依然有效的地方，就是我们前面讲的==Cookie==,所以:</p><ul><li><p>将用户名和密码写入==Cookie==中，并且持久化存储Cookie,下次访问浏览器会自动携带Cookie</p></li><li><p>在页面获取Cookie数据后，设置到用户名和密码框中</p></li><li><p>何时写入Cookie?</p><ul><li>用户必须登陆成功后才需要写</li><li>用户必须在登录页面勾选了<code>记住我</code>的复选框</li></ul></li></ul><p><img src="1629446248511.png" alt="1629446248511"></p><p>(1)前端需要在发送请求和数据的时候，多携带一个用户是否勾选<code>Remember</code>的数据</p><p>(2)LoginServlet获取到数据后，调用Service完成用户名和密码的判定</p><p>(3)登录成功，并且用户在前端勾选了<code>记住我</code>，需要往Cookie中写入用户名和密码的数据，并设置Cookie存活时间</p><p>(4)设置成功后，将数据响应给前端</p><ol start="3"><li>具体实现</li></ol><p>(1)在login.jsp为复选框设置值</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;login&lt;/title&gt;    &lt;link href="css/login.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="loginDiv" style="height: 350px"&gt;    &lt;form action="/brand-demo/loginServlet" method="post" id="form"&gt;        &lt;h1 id="loginMsg"&gt;LOGIN IN&lt;/h1&gt;        &lt;div id="errorMsg"&gt;${login_msg}&lt;/div&gt;        &lt;p&gt;Username:&lt;input id="username" name="username" type="text"&gt;&lt;/p&gt;        &lt;p&gt;Password:&lt;input id="password" name="password" type="password"&gt;&lt;/p&gt;        &lt;p&gt;Remember:&lt;input id="remember" name="remember" value="1" type="checkbox"&gt;&lt;/p&gt;        &lt;div id="subDiv"&gt;            &lt;input type="submit" class="button" value="login up"&gt;            &lt;input type="reset" class="button" value="reset"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;            &lt;a href="register.html"&gt;没有账号？&lt;/a&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(2)在LoginServlet获取复选框的值并在登录成功后进行设置Cookie</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/loginServlet")public class LoginServlet extends HttpServlet {    private UserService service = new UserService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 获取用户名和密码        String username = request.getParameter("username");        String password = request.getParameter("password");        //获取复选框数据        String remember = request.getParameter("remember");        //2. 调用service查询        User user = service.login(username, password);        //3. 判断        if(user != null){            //登录成功，跳转到查询所有的BrandServlet            //判断用户是否勾选记住我，字符串写前面是为了避免出现空指针异常            if("1".equals(remember)){                //勾选了，发送Cookie                //1. 创建Cookie对象                Cookie c_username = new Cookie("username",username);                Cookie c_password = new Cookie("password",password);                // 设置Cookie的存活时间                c_username.setMaxAge( 60 * 60 * 24 * 7);                c_password.setMaxAge( 60 * 60 * 24 * 7);                //2. 发送                response.addCookie(c_username);                response.addCookie(c_password);            }            //将登陆成功后的user对象，存储到session            HttpSession session = request.getSession();            session.setAttribute("user",user);            String contextPath = request.getContextPath();            response.sendRedirect(contextPath+"/selectAllServlet");        }else {            // 登录失败,            // 存储错误信息到request            request.setAttribute("login_msg","用户名或密码错误");            // 跳转到login.jsp            request.getRequestDispatcher("/login.jsp").forward(request,response);        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)启动访问测试，</p><p>只有当前用户名和密码输入正确，并且勾选了Remeber的复选框，在响应头中才可以看得cookie的相关数据</p><p><img src="1629447232217.png" alt="1629447232217"></p><h3 id="4-4-记住我-获取Cookie"><a href="#4-4-记住我-获取Cookie" class="headerlink" title="4.4 记住我-获取Cookie"></a>4.4 记住我-获取Cookie</h3><ol><li>需求</li></ol><p>登录成功并勾选了Remeber后，后端返回给前端的Cookie数据就已经存储好了，接下来就需要在页面获取Cookie中的数据，并把数据设置到登录页面的用户名和密码框中。</p><p><img src="1629449100282.png" alt="1629449100282"></p><p>如何在页面直接获取Cookie中的值呢?</p><ol start="2"><li>实现流程分析</li></ol><p>在页面可以使用EL表达式，${cookie.==key==.value}</p><p>key:指的是存储在cookie中的键名称</p><p><img src="1629449234735.png" alt="1629449234735"></p><p>(1)在login.jsp用户名的表单输入框使用value值给表单元素添加默认值，value可以使用<code>${cookie.username.value}</code></p><p>(2)在login.jsp密码的表单输入框使用value值给表单元素添加默认值，value可以使用<code>${cookie.password.value}</code></p><ol start="3"><li>具体实现</li></ol><p>(1)修改login.jsp页面</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;login&lt;/title&gt;    &lt;link href="css/login.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="loginDiv" style="height: 350px"&gt;    &lt;form action="/brand-demo/loginServlet" method="post" id="form"&gt;        &lt;h1 id="loginMsg"&gt;LOGIN IN&lt;/h1&gt;        &lt;div id="errorMsg"&gt;${login_msg}&lt;/div&gt;        &lt;p&gt;Username:&lt;input id="username" name="username" value="${cookie.username.value}" type="text"&gt;&lt;/p&gt;        &lt;p&gt;Password:&lt;input id="password" name="password" value="${cookie.password.value}" type="password"&gt;&lt;/p&gt;        &lt;p&gt;Remember:&lt;input id="remember" name="remember" value="1" type="checkbox"&gt;&lt;/p&gt;        &lt;div id="subDiv"&gt;            &lt;input type="submit" class="button" value="login up"&gt;            &lt;input type="reset" class="button" value="reset"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;            &lt;a href="register.html"&gt;没有账号？&lt;/a&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="4"><li>访问测试，重新访问登录页面，就可以看得用户和密码已经被填充。</li></ol><p><img src="1629449530886.png" alt="1629449530886"></p><h3 id="4-5-用户注册功能"><a href="#4-5-用户注册功能" class="headerlink" title="4.5 用户注册功能"></a>4.5 用户注册功能</h3><ol><li>需求</li></ol><ul><li>注册功能：保存用户信息到数据库</li><li>验证码功能<ul><li>展示验证码：展示验证码图片，并可以点击切换</li><li>校验验证码：验证码填写不正确，则注册失败</li></ul></li></ul><p><img src="1629449648793.png" alt="1629449648793"></p><ol start="2"><li>实现流程分析</li></ol><p><img src="1629449720005.png" alt="1629449720005"></p><p>(1)前端通过表单发送请求和数据给Web层的RegisterServlet</p><p>(2)在RegisterServlet中接收请求和数据[用户名和密码]</p><p>(3)RegisterServlet接收到请求和数据后，调用Service层完成用户信息的保存</p><p>(4)在Service层需要编写UserService类，在类中实现register方法，需要判断用户是否已经存在，如果不存在，则完成用户数据的保存</p><p>(5)在UserMapper接口中，声明两个方法，一个是根据用户名查询用户信息方法，另一个是保存用户信息方法</p><p>(6)在UserService类中保存成功则返回true，失败则返回false,将数据返回给Web层</p><p>(7)Web层获取到结果后，如果返回的是true,则提示<code>注册成功</code>，并转发到登录页面，如果返回false则提示<code>用户名已存在</code>并转发到注册页面</p><ol start="3"><li>具体实现</li></ol><p>(1)Dao层代码参考资料中的内容完成</p><p>(2)编写Service层代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserService {    //1.使用工具类获取SqlSessionFactory    SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory();    /**     * 注册方法     * @return     */    public boolean register(User user){        //2. 获取SqlSession        SqlSession sqlSession = factory.openSession();        //3. 获取UserMapper        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        //4. 判断用户名是否存在        User u = mapper.selectByUsername(user.getUsername());        if(u == null){            // 用户名不存在，注册            mapper.add(user);            sqlSession.commit();        }        sqlSession.close();        return u == null;    }}</code></pre><p>(3)完成页面和Web层的代码编写</p><p>(3.1)将register.html内容修改成register.jsp</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;欢迎注册&lt;/title&gt;    &lt;link href="css/register.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="form-div"&gt;    &lt;div class="reg-content"&gt;        &lt;h1&gt;欢迎注册&lt;/h1&gt;        &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href="login.html"&gt;登录&lt;/a&gt;    &lt;/div&gt;    &lt;form id="reg-form" action="/brand-demo/registerServlet" method="post"&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名&lt;/td&gt;                &lt;td class="inputs"&gt;                    &lt;input name="username" type="text" id="username"&gt;                    &lt;br&gt;                    &lt;span id="username_err" class="err_msg" style="display:none"&gt;用户名不太受欢迎&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码&lt;/td&gt;                &lt;td class="inputs"&gt;                    &lt;input name="password" type="password" id="password"&gt;                    &lt;br&gt;                    &lt;span id="password_err" class="err_msg" style="display: none"&gt;密码格式有误&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;验证码&lt;/td&gt;                &lt;td class="inputs"&gt;                    &lt;input name="checkCode" type="text" id="checkCode"&gt;                    &lt;img src="imgs/a.jpg"&gt;                    &lt;a href="#" id="changeImg" &gt;看不清？&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;div class="buttons"&gt;            &lt;input value="注 册" type="submit" id="reg_btn"&gt;        &lt;/div&gt;        &lt;br class="clear"&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(3.2)编写RegisterServlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/registerServlet")public class RegisterServlet extends HttpServlet {    private UserService service = new UserService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {       //1. 获取用户名和密码数据        String username = request.getParameter("username");        String password = request.getParameter("password");                User user = new User();        user.setUsername(username);        user.setPassword(password);        //2. 调用service 注册        boolean flag = service.register(user);        //3. 判断注册成功与否        if(flag){             //注册功能，跳转登陆页面            request.setAttribute("register_msg","注册成功，请登录");            request.getRequestDispatcher("/login.jsp").forward(request,response);        }else {            //注册失败，跳转到注册页面            request.setAttribute("register_msg","用户名已存在");            request.getRequestDispatcher("/register.jsp").forward(request,response);        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3.3)需要在页面上展示后台返回的错误信息，需要修改register.jsp</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">修改前:&lt;span id="username_err" class="err_msg" style="display:none"&gt;用户名不太受欢迎&lt;/span&gt;修改后:&lt;span id="username_err" class="err_msg"&gt;${register_msg}&lt;/span&gt;</code></pre><p>(3.4)如果注册成功，需要把成功信息展示在登录页面，所以也需要修改login.jsp</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">修改前:&lt;div id="errorMsg"&gt;${login_msg}&lt;/div&gt;修改后:&lt;div id="errorMsg"&gt;${login_msg} ${register_msg}&lt;/div&gt;</code></pre><p>(3.5)修改login.jsp，将注册跳转地址修改为register.jsp</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">修改前：&lt;a href="register.html"&gt;没有账号？&lt;/a&gt;修改后: &lt;a href="register.jsp"&gt;没有账号？&lt;/a&gt;</code></pre><p>(3.6)启动测试，</p><p>如果是注册的用户信息已经存在:</p><p><img src="1629451535605.png" alt="1629451535605"></p><p>如果注册的用户信息不存在，注册成功:</p><p><img src="1629451567428.png" alt="1629451567428"></p><h3 id="4-6-验证码-展示"><a href="#4-6-验证码-展示" class="headerlink" title="4.6 验证码-展示"></a>4.6 验证码-展示</h3><ol><li>需求分析</li></ol><p>展示验证码：展示验证码图片，并可以点击切换</p><p><img src="1629451646831.png" alt="1629451646831"></p><p>验证码的生成是通过工具类来实现的，具体的工具类参考</p><p><code>04-资料\1. 登录注册案例\CheckCodeUtil.java</code></p><p>在该工具类中编写main方法进行测试:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws IOException {    //生成验证码的图片位置    OutputStream fos = new FileOutputStream("d://a.jpg");    //checkCode为最终验证码的数据    String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4);    System.out.println(checkCode);}</code></pre><p>生成完验证码以后，我们就可以知晓:</p><ul><li>验证码就是使用Java代码生成的一张图片</li><li>验证码的作用:防止机器自动注册，攻击服务器</li></ul><ol start="2"><li>实现流程分析</li></ol><p><img src="1629452623289.png" alt="1629452623289"></p><p>(1)前端发送请求给CheckCodeServlet</p><p>(2)CheckCodeServlet接收到请求后，生成验证码图片，将图片用Reponse对象的输出流写回到前端</p><p>思考:如何将图片写回到前端浏览器呢?</p><p>(1)Java中已经有工具类生成验证码图片，测试类中只是把图片生成到磁盘上<br>(2)生成磁盘的过程中使用的是OutputStream流，如何把这个图片生成在页面呢?<br>(3)前面在将Reponse对象的时候，它有一个方法可以获取其字节输出流，getOutputStream()<br>(4)综上所述，我们可以把写往磁盘的流对象更好成Response的字节流，即可完成图片响应给前端</p><ol start="3"><li>具体实现</li></ol><p>(1)修改Register.jsp页面，将验证码的图片从后台获取</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;tr&gt;    &lt;td&gt;验证码&lt;/td&gt;        &lt;td class="inputs"&gt;        &lt;input name="checkCode" type="text" id="checkCode"&gt;        &lt;img id="checkCodeImg" src="/brand-demo/checkCodeServlet"&gt;        &lt;a href="#" id="changeImg" &gt;看不清？&lt;/a&gt;    &lt;/td&gt;&lt;/tr&gt;&lt;script&gt;    document.getElementById("changeImg").onclick = function () {       //路径后面添加时间戳的目的是避免浏览器进行缓存静态资源        document.getElementById("checkCodeImg").src = "/brand-demo/checkCodeServlet?"+new Date().getMilliseconds();    }&lt;/script&gt;</code></pre><p>(2)编写CheckCodeServlet类，用来接收请求生成验证码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/checkCodeServlet")public class CheckCodeServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // 生成验证码        ServletOutputStream os = response.getOutputStream();        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h3 id="4-7验证码-校验"><a href="#4-7验证码-校验" class="headerlink" title="4.7验证码-校验"></a>4.7验证码-校验</h3><ol><li>需求</li></ol><ul><li>判断程序生成的验证码 和 用户输入的验证码 是否一样，如果不一样，则阻止注册</li><li>验证码图片访问和提交注册表单是==两次==请求，所以要将程序生成的验证码存入Session中</li></ul><p><img src="1629452835571.png" alt="1629452835571"></p><p>思考:为什么要把验证码数据存入到Session中呢?</p><ul><li>生成验证码和校验验证码是两次请求，此处就需要在一个会话的两次请求之间共享数据</li><li>验证码属于安全数据类的，所以我们选中Session来存储验证码数据。</li></ul><ol start="2"><li>实现流程分析</li></ol><p><img src="1629452966499.png" alt="1629452966499"></p><p>(1)在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象</p><p>(2)前端将验证码和注册数据提交到后台，交给RegisterServlet类</p><p>(3)RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比</p><p>(4)如果一致，则完成注册，如果不一致，则提示错误信息</p><ol start="3"><li>具体实现</li></ol><p>(1)修改CheckCodeServlet类，将验证码存入Session对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/checkCodeServlet")public class CheckCodeServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // 生成验证码        ServletOutputStream os = response.getOutputStream();        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4);        // 存入Session        HttpSession session = request.getSession();        session.setAttribute("checkCodeGen",checkCode);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)在RegisterServlet中，获取页面的和session对象中的验证码，进行对比</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import com.itheima.pojo.User;import com.itheima.service.UserService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.IOException;@WebServlet("/registerServlet")public class RegisterServlet extends HttpServlet {    private UserService service = new UserService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {       //1. 获取用户名和密码数据        String username = request.getParameter("username");        String password = request.getParameter("password");        User user = new User();        user.setUsername(username);        user.setPassword(password);        // 获取用户输入的验证码        String checkCode = request.getParameter("checkCode");        // 程序生成的验证码，从Session获取        HttpSession session = request.getSession();        String checkCodeGen = (String) session.getAttribute("checkCodeGen");        // 比对        if(!checkCodeGen.equalsIgnoreCase(checkCode)){            request.setAttribute("register_msg","验证码错误");            request.getRequestDispatcher("/register.jsp").forward(request,response);            // 不允许注册            return;        }        //2. 调用service 注册        boolean flag = service.register(user);        //3. 判断注册成功与否        if(flag){             //注册功能，跳转登陆页面            request.setAttribute("register_msg","注册成功，请登录");            request.getRequestDispatcher("/login.jsp").forward(request,response);        }else {            //注册失败，跳转到注册页面            request.setAttribute("register_msg","用户名已存在");            request.getRequestDispatcher("/register.jsp").forward(request,response);        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>至此，用户的注册登录功能就已经完成了。</p><p>(8)</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener&amp;Ajax</title>
      <link href="/2023/05/20/Filter-Listener-Ajax/"/>
      <url>/2023/05/20/Filter-Listener-Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Filter"><a href="#1-Filter" class="headerlink" title="1. Filter"></a>1. Filter</h2><h3 id="1-1-Filter概述"><a href="#1-1-Filter概述" class="headerlink" title="1.1  Filter概述"></a>1.1  Filter概述</h3><p>Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener 我们今天都会进行学习。</p><p>过滤器可以把对资源的请求==拦截==下来，从而实现一些特殊的功能。</p><p>如下图所示，浏览器可以访问服务器上的所有的资源（servlet、jsp、html等）</p><img src="image-20210823184519509.png" alt="image-20210823184519509" style="zoom:50%;"><p>而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter，如下图</p><img src="image-20210823184657328.png" alt="image-20210823184657328" style="zoom:57%;"><p>拦截器拦截到后可以做什么功能呢？</p><p>==过滤器一般完成一些通用的操作。==比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码吧，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。</p><p>我们之前做的品牌数据管理的案例中就已经做了登陆的功能，而如果我们不登录能不能访问到数据呢？我们可以在浏览器直接访问首页 ，可以看到 <code>查询所有</code> 的超链接</p><img src="image-20210823185720197.png" alt="image-20210823185720197" style="zoom:70%;"><p>当我点击该按钮，居然可以看到品牌的数据</p><img src="image-20210823185932418.png" alt="image-20210823185932418" style="zoom:70%;"><p>这显然和我们的要求不符。我们希望实现的效果是用户如果登陆过了就跳转到品牌数据展示的页面；如果没有登陆就跳转到登陆页面让用户进行登陆，要实现这个效果需要在每一个资源中都写上这段逻辑，而像这种通用的操作，我们就可以放在过滤器中进行实现。这个就是==权限控制==，以后我们还会进行细粒度权限控制。过滤器还可以做 <code>统一编码处理</code>、 <code>敏感字符处理</code> 等等…</p><h3 id="1-2-Filter快速入门"><a href="#1-2-Filter快速入门" class="headerlink" title="1.2  Filter快速入门"></a>1.2  Filter快速入门</h3><h4 id="1-2-1-开发步骤"><a href="#1-2-1-开发步骤" class="headerlink" title="1.2.1  开发步骤"></a>1.2.1  开发步骤</h4><p>进行 <code>Filter</code> 开发分成以下三步实现</p><ul><li><p>定义类，实现 Filter接口，并重写其所有方法</p><img src="image-20210823191006878.png" alt="image-20210823191006878" style="zoom:60%;"></li><li><p>配置Filter拦截资源的路径：在类上定义 <code>@WebFilter</code> 注解。而注解的 <code>value</code> 属性值 <code>/*</code> 表示拦截所有的资源</p><img src="image-20210823191037163.png" alt="image-20210823191037163" style="zoom:67%;"></li><li><p>在doFilter方法中输出一句话，并放行</p><img src="image-20210823191200201.png" alt="image-20210823191200201" style="zoom:60%;"><blockquote><p>上述代码中的 <code>chain.doFilter(request,response);</code> 就是放行，也就是让其访问本该访问的资源。</p></blockquote></li></ul><h4 id="1-2-2-代码演示"><a href="#1-2-2-代码演示" class="headerlink" title="1.2.2  代码演示"></a>1.2.2  代码演示</h4><p>创建一个项目，项目下有一个 <code>hello.jsp</code> 页面，项目结构如下：</p><img src="image-20210823191855765.png" alt="image-20210823191855765" style="zoom:80%;"><p><code>pom.xml</code> 配置文件内容如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;filter-demo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;port&gt;80&lt;/port&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p><code>hello.jsp</code> 页面内容如下：</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;hello JSP~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们现在在浏览器输入 <code>http://localhost/filter-demo/hello.jsp</code> 访问 <code>hello.jsp</code> 页面，这里是可以访问到 <code>hello.jsp</code> 页面内容的。</p><img src="image-20210823192353031.png" alt="image-20210823192353031" style="zoom:67%;"><p>接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 <code>filter</code> 创建在 <code>com.itheima.web.filter</code> 包下，起名为 <code>FilterDemo</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class FilterDemo implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        System.out.println("FilterDemo...");    }    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void destroy() {    }}</code></pre><p>重启启动服务器，再次重新访问 <code>hello.jsp</code> 页面，这次发现页面没有任何效果，但是在 <code>idea</code> 的控制台可以看到如下内容</p><img src="image-20210823193759365.png" alt="image-20210823193759365" style="zoom:70%;"><p>上述效果说明 <code>FilterDemo</code> 这个过滤器的 <code>doFilter()</code> 方法执行了，但是为什么在浏览器上看不到 <code>hello.jsp</code> 页面的内容呢？这是因为在 <code>doFilter()</code> 方法中添加放行的方法才能访问到 <code>hello.jsp</code> 页面。那就在 <code>doFilter()</code> 方法中添加放行的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//放行 chain.doFilter(request,response);</code></pre><p>再次重启服务器并访问 <code>hello.jsp</code> 页面，发现这次就可以在浏览器上看到页面效果。</p><p><strong><code>FilterDemo</code> 过滤器完整代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class FilterDemo implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        System.out.println("1.FilterDemo...");        //放行        chain.doFilter(request,response);    }    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void destroy() {    }}</code></pre><h3 id="1-3-Filter执行流程"><a href="#1-3-Filter执行流程" class="headerlink" title="1.3  Filter执行流程"></a>1.3  Filter执行流程</h3><img src="image-20210823194830074.png" alt="image-20210823194830074" style="zoom:70%;"><p>如上图是使用过滤器的流程，我们通过以下问题来研究过滤器的执行流程：</p><ul><li><p>放行后访问对应资源，资源访问完成后，还会回到Filter中吗？</p><p>从上图就可以看出肯定 ==会== 回到Filter中</p></li><li><p>如果回到Filter中，是重头执行还是执行放行后的逻辑呢？</p><p>如果是重头执行的话，就意味着 <code>放行前逻辑</code> 会被执行两次，肯定不会这样设计了；所以访问完资源后，会回到 <code>放行后逻辑</code>，执行该部分代码。</p></li></ul><p>通过上述的说明，我们就可以总结Filter的执行流程如下：</p><img src="image-20210823195434581.png" alt="image-20210823195434581" style="zoom:70%;"><p>接下来我们通过代码验证一下，在 <code>doFilter()</code> 方法前后都加上输出语句，如下</p><img src="image-20210823195828596.png" alt="image-20210823195828596" style="zoom:70%;"><p>同时在 <code>hello.jsp</code> 页面加上输出语句，如下</p><img src="image-20210823200028284.png" alt="image-20210823200028284" style="zoom:70%;"><p>执行访问该资源打印的顺序是按照我们标记的标号进行打印的话，说明我们上边总结出来的流程是没有问题的。启动服务器访问 <code>hello.jsp</code> 页面，在控制台打印的内容如下：</p><img src="image-20210823200202153.png" alt="image-20210823200202153" style="zoom:80%;"><p>以后我们可以将对请求进行处理的代码放在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行逻辑处理。</p><h3 id="1-4-Filter拦截路径配置"><a href="#1-4-Filter拦截路径配置" class="headerlink" title="1.4  Filter拦截路径配置"></a>1.4  Filter拦截路径配置</h3><p>拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 <code>@WebFilter</code> 注解进行配置。如：<code>@WebFilter("拦截路径")</code> </p><p>拦截路径有如下四种配置方式：</p><ul><li>拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截</li><li>目录拦截：/user/*：访问/user下的所有资源，都会被拦截</li><li>后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截</li><li>拦截所有：/*：访问所有资源，都会被拦截</li></ul><p>通过上面拦截路径的学习，大家会发现拦截路径的配置方式和 <code>Servlet</code> 的请求资源路径配置方式一样，但是表示的含义不同。</p><h3 id="1-5-过滤器链"><a href="#1-5-过滤器链" class="headerlink" title="1.5  过滤器链"></a>1.5  过滤器链</h3><h4 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1  概述"></a>1.5.1  概述</h4><p>过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p><p>如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程</p><img src="image-20210823215835812.png" alt="image-20210823215835812" style="zoom:70%;"><p>上图中的过滤器链执行是按照以下流程执行：</p><ol><li>执行 <code>Filter1</code> 的放行前逻辑代码</li><li>执行 <code>Filter1</code> 的放行代码</li><li>执行 <code>Filter2</code> 的放行前逻辑代码</li><li>执行 <code>Filter2</code> 的放行代码</li><li>访问到资源</li><li>执行 <code>Filter2</code> 的放行后逻辑代码</li><li>执行 <code>Filter1</code> 的放行后逻辑代码</li></ol><p>以上流程串起来就像一条链子，故称之为过滤器链。</p><h4 id="1-5-2-代码演示"><a href="#1-5-2-代码演示" class="headerlink" title="1.5.2  代码演示"></a>1.5.2  代码演示</h4><ul><li><p>编写第一个过滤器 <code>FilterDemo</code> ，配置成拦截所有资源</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class FilterDemo implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        //1. 放行前，对 request数据进行处理        System.out.println("1.FilterDemo...");        //放行        chain.doFilter(request,response);        //2. 放行后，对Response 数据进行处理        System.out.println("3.FilterDemo...");    }    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void destroy() {    }}</code></pre></li><li><p>编写第二个过滤器 <code>FilterDemo2</code> ，配置炒年糕拦截所有资源</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class FilterDemo2 implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        //1. 放行前，对 request数据进行处理        System.out.println("2.FilterDemo...");        //放行        chain.doFilter(request,response);        //2. 放行后，对Response 数据进行处理        System.out.println("4.FilterDemo...");    }    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void destroy() {    }}</code></pre></li><li><p>修改 <code>hello.jsp</code> 页面中脚本的输出语句</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;hello JSP~&lt;/h1&gt;    &lt;%        System.out.println("3.hello jsp");    %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>启动服务器，在浏览器输入 <code>http://localhost/filter-demo/hello.jsp</code> 进行测试，在控制台打印内容如下</p><img src="image-20210823221222468.png" alt="image-20210823221222468" style="zoom:70%;"><p>从结果可以看到确实是按照我们之前说的执行流程进行执行的。</p></li></ul><h4 id="1-5-3-问题"><a href="#1-5-3-问题" class="headerlink" title="1.5.3  问题"></a>1.5.3  问题</h4><p>上面代码中为什么是先执行 <code>FilterDemo</code> ，后执行 <code>FilterDemo2</code> 呢？</p><p>我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。</p><p>比如有如下两个名称的过滤器 ： <code>BFilterDemo</code> 和 <code>AFilterDemo</code> 。那一定是 <code>AFilterDemo</code> 过滤器先执行。</p><h3 id="1-6-案例"><a href="#1-6-案例" class="headerlink" title="1.6  案例"></a>1.6  案例</h3><h4 id="1-6-1-需求"><a href="#1-6-1-需求" class="headerlink" title="1.6.1  需求"></a>1.6.1  需求</h4><p>访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面</p><h4 id="1-6-2-分析"><a href="#1-6-2-分析" class="headerlink" title="1.6.2  分析"></a>1.6.2  分析</h4><p>我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 <code>Filter</code> ，在该过滤器中进行登陆状态校验即可。而在该 <code>Filter</code> 中逻辑如下：</p><img src="image-20210823223214525.png" alt="image-20210823223214525" style="zoom:70%;"><h4 id="1-6-3-代码实现"><a href="#1-6-3-代码实现" class="headerlink" title="1.6.3  代码实现"></a>1.6.3  代码实现</h4><h5 id="1-6-3-1-创建Filter"><a href="#1-6-3-1-创建Filter" class="headerlink" title="1.6.3.1  创建Filter"></a>1.6.3.1  创建Filter</h5><p>在 <code>brand-demo</code> 工程创建 <code>com.itheima.web.filter</code>  包，在该下创建名为 <code>LoginFilter</code> 的过滤器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class LoginFilter implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {          }    public void init(FilterConfig config) throws ServletException {    }    public void destroy() {    }}</code></pre><h5 id="1-6-3-2-编写逻辑代码"><a href="#1-6-3-2-编写逻辑代码" class="headerlink" title="1.6.3.2  编写逻辑代码"></a>1.6.3.2  编写逻辑代码</h5><p>在 <code>doFilter()</code> 方法中编写登陆状态校验的逻辑代码。</p><p>我们首先需要从 <code>session</code> 对象中获取用户信息，但是 <code>ServletRequest</code> 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 <code>HttpServletRequest</code> 对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">HttpServletRequest req = (HttpServletRequest) request;</code></pre><p>然后完成以下逻辑</p><ul><li>获取Session对象</li><li>从Session对象中获取名为 <code>user</code> 的数据</li><li>判断获取到的数据是否是 null<ul><li>如果不是，说明已经登陆，放行</li><li>如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面</li></ul></li></ul><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class LoginFilter implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {        HttpServletRequest req = (HttpServletRequest) request;           //1. 判断session中是否有user        HttpSession session = req.getSession();        Object user = session.getAttribute("user");        //2. 判断user是否为null        if(user != null){            // 登录过了            //放行            chain.doFilter(request, response);        }else {            // 没有登陆，存储提示信息，跳转到登录页面            req.setAttribute("login_msg","您尚未登陆！");            req.getRequestDispatcher("/login.jsp").forward(req,response);        }    }    public void init(FilterConfig config) throws ServletException {    }    public void destroy() {    }}</code></pre><h5 id="1-6-3-3-测试并抛出问题"><a href="#1-6-3-3-测试并抛出问题" class="headerlink" title="1.6.3.3  测试并抛出问题"></a>1.6.3.3  测试并抛出问题</h5><p>在浏览器上输入 <code>http://localhost:8080/brand-demo/</code> ，可以看到如下页面效果</p><img src="image-20210823224843179.png" alt="image-20210823224843179" style="zoom:60%;"><p>从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？</p><h5 id="1-6-3-4-问题分析及解决"><a href="#1-6-3-4-问题分析及解决" class="headerlink" title="1.6.3.4  问题分析及解决"></a>1.6.3.4  问题分析及解决</h5><p>因为登陆页面需要 <code>css/login.css</code> 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解</p><img src="image-20210823225411925.png" alt="image-20210823225411925" style="zoom:70%;"><p>而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。</p><p>综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断访问资源路径是否和登录注册相关//1,在数组中存储登陆和注册相关的资源路径String[] urls = {"/login.jsp","/imgs/","/css/","/loginServlet","/register.jsp","/registerServlet","/checkCodeServlet"};//2,获取当前访问的资源路径String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径for (String u : urls) {    //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串    /*    比如当前访问的资源路径是  /brand-demo/login.jsp    而字符串 /brand-demo/login.jsp 包含了  字符串 /login.jsp ，所以这个字符串就需要放行    */    if(url.contains(u)){        //找到了，放行        chain.doFilter(request, response);        //break;        return;    }}</code></pre><h5 id="1-6-3-5-过滤器完整代码"><a href="#1-6-3-5-过滤器完整代码" class="headerlink" title="1.6.3.5  过滤器完整代码"></a>1.6.3.5  过滤器完整代码</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebFilter("/*")public class LoginFilter implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {        HttpServletRequest req = (HttpServletRequest) request;                //判断访问资源路径是否和登录注册相关        //1,在数组中存储登陆和注册相关的资源路径        String[] urls = {"/login.jsp","/imgs/","/css/","/loginServlet","/register.jsp","/registerServlet","/checkCodeServlet"};        //2,获取当前访问的资源路径        String url = req.getRequestURL().toString();         //3,遍历数组，获取到每一个需要放行的资源路径        for (String u : urls) {            //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串            /*                比如当前访问的资源路径是  /brand-demo/login.jsp                而字符串 /brand-demo/login.jsp 包含了  字符串 /login.jsp ，所以这个字符串就需要放行            */            if(url.contains(u)){                //找到了，放行                chain.doFilter(request, response);                //break;                return;            }        }           //1. 判断session中是否有user        HttpSession session = req.getSession();        Object user = session.getAttribute("user");        //2. 判断user是否为null        if(user != null){            // 登录过了            //放行            chain.doFilter(request, response);        }else {            // 没有登陆，存储提示信息，跳转到登录页面            req.setAttribute("login_msg","您尚未登陆！");            req.getRequestDispatcher("/login.jsp").forward(req,response);        }    }    public void init(FilterConfig config) throws ServletException {    }    public void destroy() {    }}</code></pre><h2 id="2-Listener"><a href="#2-Listener" class="headerlink" title="2. Listener"></a>2. Listener</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1  概述"></a>2.1  概述</h3><ul><li><p>Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。</p></li><li><p>监听器可以监听就是在 <code>application</code>，<code>session</code>，<code>request</code> 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p><p>request 和 session 我们学习过。而 <code>application</code> 是 <code>ServletContext</code> 类型的对象。</p><p><code>ServletContext</code> 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象。</p></li></ul><h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2  分类"></a>2.2  分类</h3><p>JavaWeb 提供了8个监听器：</p><img src="image-20210823230820586.png" alt="image-20210823230820586" style="zoom:80%;"><p>这里面只有 <code>ServletContextListener</code> 这个监听器后期我们会接触到，<code>ServletContextListener</code> 是用来监听 <code>ServletContext</code> 对象的创建和销毁。</p><p><code>ServletContextListener</code> 接口中有以下两个方法</p><ul><li><code>void contextInitialized(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被创建了会自动执行的方法</li><li><code>void contextDestroyed(ServletContextEvent sce)</code>：<code>ServletContext</code> 对象被销毁时会自动执行的方法</li></ul><h3 id="2-3-代码演示"><a href="#2-3-代码演示" class="headerlink" title="2.3  代码演示"></a>2.3  代码演示</h3><p>我们只演示一下 <code>ServletContextListener</code> 监听器</p><ul><li>定义一个类，实现<code>ServletContextListener</code> 接口</li><li>重写所有的抽象方法</li><li>使用 <code>@WebListener</code> 进行配置</li></ul><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebListenerpublic class ContextLoaderListener implements ServletContextListener {    @Override    public void contextInitialized(ServletContextEvent sce) {        //加载资源        System.out.println("ContextLoaderListener...");    }    @Override    public void contextDestroyed(ServletContextEvent sce) {        //释放资源    }}</code></pre><p>启动服务器，就可以在启动的日志信息中看到 <code>contextInitialized()</code> 方法输出的内容，同时也说明了 <code>ServletContext</code> 对象在服务器启动的时候被创建了。</p><h2 id="3-Ajax"><a href="#3-Ajax" class="headerlink" title="3. Ajax"></a>3. Ajax</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1  概述"></a>3.1  概述</h3><p>==<code>AJAX</code> (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。==</p><p>我们先来说概念中的 <code>JavaScript</code> 和 <code>XML</code>，<code>JavaScript</code> 表明该技术和前端相关；<code>XML</code> 是指以此进行数据交换。而这两个我们之前都学习过。</p><h4 id="3-1-1-作用"><a href="#3-1-1-作用" class="headerlink" title="3.1.1  作用"></a>3.1.1  作用</h4><p>AJAX 作用有以下两方面：</p><ol><li><strong>与服务器进行数据交换</strong>：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图</li></ol><p>我们先来看之前做功能的流程，如下图：</p><img src="image-20210823235114367.png" alt="image-20210823235114367" style="zoom:70%;"><p>如上图，<code>Servlet</code> 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 <code>jsp</code> 页面，在页面上使用 <code>EL表达式</code> 和 <code>JSTL</code> 标签库进行数据的展示。</p><p>而我们学习了AJAX 后，就可以==使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面==了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。</p><img src="image-20210823235006847.png" alt="image-20210823235006847" style="zoom:70%;"><ol start="2"><li><strong>异步交互</strong>：可以在==不重新加载整个页面==的情况下，与服务器交换数据并==更新部分网页==的技术，如：搜索联想、用户名是否可用校验，等等…</li></ol><img src="image-20210824000706401.png" alt="image-20210824000706401" style="zoom:80%;"><p>上图所示的效果我们经常见到，在我们输入一些关键字（例如 <code>奥运</code>）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 ==更新局部页面== 的效果。再如下图：</p><img src="image-20210824001015706.png" alt="image-20210824001015706" style="zoom:80%;"><p>我们在用户名的输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 ==更新局部页面== 的效果。</p><h4 id="3-1-2-同步和异步"><a href="#3-1-2-同步和异步" class="headerlink" title="3.1.2  同步和异步"></a>3.1.2  同步和异步</h4><p>知道了局部刷新后，接下来我们再聊聊同步和异步:</p><ul><li>同步发送请求过程如下</li></ul><img src="image-20210824001443897.png" alt="image-20210824001443897" style="zoom:80%;"><p>​浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。</p><ul><li><p>异步发送请求过程如下</p><img src="image-20210824001608916.png" alt="image-20210824001608916" style="zoom:80%;"><p>浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</p></li></ul><h3 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2  快速入门"></a>3.2  快速入门</h3><h4 id="3-2-1-服务端实现"><a href="#3-2-1-服务端实现" class="headerlink" title="3.2.1 服务端实现"></a>3.2.1 服务端实现</h4><p>在项目的创建 <code>com.itheima.web.servlet</code> ，并在该包下创建名为  <code>AjaxServlet</code> 的servlet</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/ajaxServlet")public class AjaxServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 响应数据        response.getWriter().write("hello ajax~");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h4 id="3-2-2-客户端实现"><a href="#3-2-2-客户端实现" class="headerlink" title="3.2.2  客户端实现"></a>3.2.2  客户端实现</h4><p>在 <code>webapp</code> 下创建名为 <code>01-ajax-demo1.html</code> 的页面，在该页面书写 <code>ajax</code> 代码</p><ul><li><p>创建核心对象，不同的浏览器创建的对象是不同的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> var xhttp;if (window.XMLHttpRequest) {    xhttp = new XMLHttpRequest();} else {    // code for IE6, IE5    xhttp = new ActiveXObject("Microsoft.XMLHTTP");}</code></pre></li><li><p>发送请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//建立连接xhttp.open("GET", "http://localhost:8080/ajax-demo/ajaxServlet");//发送请求xhttp.send();</code></pre></li><li><p>获取响应</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">xhttp.onreadystatechange = function() {    if (this.readyState == 4 &amp;&amp; this.status == 200) {        // 通过 this.responseText 可以获取到服务端响应的数据        alert(this.responseText);    }};</code></pre></li></ul><p><strong>完整代码如下：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    //1. 创建核心对象    var xhttp;    if (window.XMLHttpRequest) {        xhttp = new XMLHttpRequest();    } else {        // code for IE6, IE5        xhttp = new ActiveXObject("Microsoft.XMLHTTP");    }    //2. 发送请求    xhttp.open("GET", "http://localhost:8080/ajax-demo/ajaxServlet");    xhttp.send();    //3. 获取响应    xhttp.onreadystatechange = function() {        if (this.readyState == 4 &amp;&amp; this.status == 200) {            alert(this.responseText);        }    };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3  测试"></a>3.2.3  测试</h4><p>在浏览器地址栏输入 <code>http://localhost:8080/ajax-demo/01-ajax-demo1.html</code> ，在 <code>01-ajax-demo1.html</code>加载的时候就会发送 <code>ajax</code> 请求，效果如下</p><img src="image-20210824005956117.png" alt="image-20210824005956117" style="zoom:67%;"><p>我们可以通过 <code>开发者模式</code> 查看发送的 AJAX 请求。在浏览器上按 <code>F12</code> 快捷键</p><img src="image-20210824010247642.png" alt="image-20210824010247642" style="zoom:80%;"><p>这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 <code>All</code> 旁边的 <code>XHR</code>，会发现只展示 Type 是 <code>xhr</code> 的请求。如下图：</p><img src="image-20210824010438260.png" alt="image-20210824010438260" style="zoom:80%;"> <h3 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h3><p>需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在</p><img src="image-20210824201415745.png" alt="image-20210824201415745" style="zoom:60%;"><h4 id="3-3-1-分析"><a href="#3-3-1-分析" class="headerlink" title="3.3.1  分析"></a>3.3.1  分析</h4><ul><li><strong>前端完成的逻辑</strong><ol><li>给用户名输入框绑定光标失去焦点事件 <code>onblur</code></li><li>发送 ajax请求，携带username参数</li><li>处理响应：是否显示提示信息</li></ol></li><li><strong>后端完成的逻辑</strong><ol><li>接收用户名</li><li>调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理</li><li>返回标记</li></ol></li></ul><p>整体流程如下：</p><img src="image-20210829183854285.png" alt="image-20210829183854285" style="zoom:80%;"><h4 id="3-3-2-后端实现"><a href="#3-3-2-后端实现" class="headerlink" title="3.3.2  后端实现"></a>3.3.2  后端实现</h4><p>在 <code>com.ithiema.web.servlet</code> 包中定义名为 <code>SelectUserServlet</code>  的servlet。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/selectUserServlet")public class SelectUserServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 接收用户名        String username = request.getParameter("username");        //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用        boolean flag = true;        //3. 响应标记        response.getWriter().write("" + flag);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h4 id="3-3-3-前端实现"><a href="#3-3-3-前端实现" class="headerlink" title="3.3.3  前端实现"></a>3.3.3  前端实现</h4><p>将 <code>04-资料\1. 验证用户名案例\1. 静态页面</code> 下的文件整体拷贝到项目下 <code>webapp</code> 下。并在 <code>register.html</code> 页面的 <code>body</code> 结束标签前编写 <code>script</code> 标签，在该标签中实现如下逻辑</p><p><strong>第一步：给用户名输入框绑定光标失去焦点事件 <code>onblur</code></strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1. 给用户名输入框绑定 失去焦点事件document.getElementById("username").onblur = function () {    }</code></pre><p><strong>第二步：发送 ajax请求，携带username参数</strong></p><p>在 <code>第一步</code> 绑定的匿名函数中书写发送 ajax 请求的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//2. 发送ajax请求//2.1. 创建核心对象var xhttp;if (window.XMLHttpRequest) {    xhttp = new XMLHttpRequest();} else {    // code for IE6, IE5    xhttp = new ActiveXObject("Microsoft.XMLHTTP");}//2.2. 发送请求xhttp.open("GET", "http://localhost:8080/ajax-demo/selectUserServlet);xhttp.send();//2.3. 获取响应xhttp.onreadystatechange = function() {    if (this.readyState == 4 &amp;&amp; this.status == 200) {        //处理响应的结果    }};</code></pre><p>由于我们==发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据==。而我们在 <code>第一步</code> 绑定的匿名函数中通过以下代码可以获取用户名数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 获取用户名的值var username = this.value;  //this ： 给谁绑定的事件，this就代表谁</code></pre><p>而携带数据需要将 URL 修改为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">xhttp.open("GET", "http://localhost:8080/ajax-demo/selectUserServlet?username="+username);</code></pre><p><strong>第三步：处理响应：是否显示提示信息</strong></p><p>当 <code>this.readyState == 4 &amp;&amp; this.status == 200</code> 条件满足时，说明已经成功响应数据了。</p><p>此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//判断if(this.responseText == "true"){    //用户名存在，显示提示信息    document.getElementById("username_err").style.display = '';}else {    //用户名不存在 ，清楚提示信息    document.getElementById("username_err").style.display = 'none';}</code></pre><p><strong>综上所述，前端完成代码如下：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1. 给用户名输入框绑定 失去焦点事件document.getElementById("username").onblur = function () {    //2. 发送ajax请求    // 获取用户名的值    var username = this.value;    //2.1. 创建核心对象    var xhttp;    if (window.XMLHttpRequest) {        xhttp = new XMLHttpRequest();    } else {        // code for IE6, IE5        xhttp = new ActiveXObject("Microsoft.XMLHTTP");    }    //2.2. 发送请求    xhttp.open("GET", "http://localhost:8080/ajax-demo/selectUserServlet?username="+username);    xhttp.send();    //2.3. 获取响应    xhttp.onreadystatechange = function() {        if (this.readyState == 4 &amp;&amp; this.status == 200) {            //alert(this.responseText);            //判断            if(this.responseText == "true"){                //用户名存在，显示提示信息                document.getElementById("username_err").style.display = '';            }else {                //用户名不存在 ，清楚提示信息                document.getElementById("username_err").style.display = 'none';            }        }    };}</code></pre><h2 id="4-axios"><a href="#4-axios" class="headerlink" title="4. axios"></a>4. axios</h2><p>Axios 对原生的AJAX进行封装，简化书写。</p><p>Axios官网是：<code>https://www.axios-http.cn</code></p><h3 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1  基本使用"></a>4.1  基本使用</h3><p>axios 使用是比较简单的，分为以下两步：</p><ul><li><p>引入 axios 的 js 文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;</code></pre></li><li><p>使用axios 发送请求，并获取响应结果</p><ul><li><p>发送 get 请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios({    method:"get",    url:"http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan"}).then(function (resp){    alert(resp.data);})</code></pre></li><li><p>发送 post 请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios({    method:"post",    url:"http://localhost:8080/ajax-demo1/aJAXDemo1",    data:"username=zhangsan"}).then(function (resp){    alert(resp.data);});</code></pre></li></ul></li></ul><p><code>axios()</code> 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：</p><ul><li><code>method</code> 属性：用来设置请求方式的。取值为 <code>get</code> 或者 <code>post</code>。</li><li><code>url</code> 属性：用来书写请求的资源路径。如果是 <code>get</code> 请求，需要将请求参数拼接到路径的后面，格式为： <code>url?参数名=参数值&amp;参数名2=参数值2</code>。</li><li><code>data</code> 属性：作为请求体被发送的数据。也就是说如果是 <code>post</code> 请求的话，数据需要作为 <code>data</code> 属性的值。</li></ul><p><code>then()</code> 需要传递一个匿名函数。我们将 <code>then()</code> 中传递的匿名函数称为 ==回调函数==，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 <code>resp</code> 参数是对响应的数据进行封装的对象，通过 <code>resp.data</code> 可以获取到响应的数据。</p><h3 id="4-2-快速入门"><a href="#4-2-快速入门" class="headerlink" title="4.2  快速入门"></a>4.2  快速入门</h3><h4 id="4-2-1-后端实现"><a href="#4-2-1-后端实现" class="headerlink" title="4.2.1  后端实现"></a>4.2.1  后端实现</h4><p>定义一个用于接收请求的servlet，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/axiosServlet")public class AxiosServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("get...");        //1. 接收请求参数        String username = request.getParameter("username");        System.out.println(username);        //2. 响应数据        response.getWriter().write("hello Axios~");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("post...");        this.doGet(request, response);    }}</code></pre><h4 id="4-2-2-前端实现"><a href="#4-2-2-前端实现" class="headerlink" title="4.2.2  前端实现"></a>4.2.2  前端实现</h4><ul><li><p>引入 js 文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;</code></pre></li><li><p>发送 ajax 请求</p><ul><li><p>get 请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios({    method:"get",    url:"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan"}).then(function (resp) {    alert(resp.data);})</code></pre></li><li><p>post 请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios({    method:"post",    url:"http://localhost:8080/ajax-demo/axiosServlet",    data:"username=zhangsan"}).then(function (resp) {    alert(resp.data);})</code></pre></li></ul></li></ul><p><strong>整体页面代码如下：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;&lt;script&gt;    //1. get   /* axios({        method:"get",        url:"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan"    }).then(function (resp) {        alert(resp.data);    })*/    //2. post  在js中{} 表示一个js对象，而这个js对象中有三个属性    axios({        method:"post",        url:"http://localhost:8080/ajax-demo/axiosServlet",        data:"username=zhangsan"    }).then(function (resp) {        alert(resp.data);    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="4-3-请求方法别名"><a href="#4-3-请求方法别名" class="headerlink" title="4.3  请求方法别名"></a>4.3  请求方法别名</h3><p>为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：</p><ul><li><p><code>get</code> 请求 ： <code>axios.get(url[,config])</code></p></li><li><p><code>delete</code> 请求 ： <code>axios.delete(url[,config])</code></p></li><li><p><code>head</code> 请求 ： <code>axios.head(url[,config])</code></p></li><li><p><code>options</code> 请求 ： <code>axios.option(url[,config])</code></p></li><li><p><code>post</code> 请求：<code>axios.post(url[,data[,config])</code></p></li><li><p><code>put</code> 请求：<code>axios.put(url[,data[,config])</code></p></li><li><p><code>patch</code> 请求：<code>axios.patch(url[,data[,config])</code></p></li></ul><p>而我们只关注 <code>get</code> 请求和 <code>post</code> 请求。</p><p>入门案例中的 <code>get</code> 请求代码可以改为如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios.get("http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan").then(function (resp) {    alert(resp.data);});</code></pre><p>入门案例中的 <code>post</code> 请求代码可以改为如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios.post("http://localhost:8080/ajax-demo/axiosServlet","username=zhangsan").then(function (resp) {    alert(resp.data);})</code></pre><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5. JSON"></a>5. JSON</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1  概述"></a>5.1  概述</h3><p>==概念：<code>JavaScript Object Notation</code>。JavaScript 对象表示法.==</p><p>如下是 <code>JavaScript</code> 对象的定义格式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">{name:"zhangsan",age:23,city:"北京"}</code></pre><p>接下来我们再看看 <code>JSON</code> 的格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{"name":"zhangsan","age":23,"city":"北京"}</code></pre><p>通过上面 js 对象格式和 json 格式进行对比，发现两个格式特别像。只不过 js 对象中的属性名可以使用引号（可以是单引号，也可以是双引号）；而 <code>json</code> 格式中的键要求必须使用双引号括起来，这是 <code>json</code> 格式的规定。<code>json</code> 格式的数据有什么作用呢？</p><p>作用：由于其语法格式简单，层次结构鲜明，现多用于作为==数据载体==，在网络中进行数据传输。如下图所示就是服务端给浏览器响应的数据，这个数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该以何种数据传输呢？</p><img src="image-20210830232718632.png" alt="image-20210830232718632" style="zoom:80%;"><p>大家还记得 <code>ajax</code> 的概念吗？ 是 ==异步的 JavaScript 和 xml==。这里的 xml就是以前进行数据传递的方式，如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;student&gt;    &lt;name&gt;张三&lt;/name&gt;    &lt;age&gt;23&lt;/age&gt;    &lt;city&gt;北京&lt;/city&gt;&lt;/student&gt;</code></pre><p>再看 <code>json</code> 描述以上数据的写法：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{"name":"张三",    "age":23,    "city":"北京"}</code></pre><p>上面两种格式进行对比后就会发现 <code>json</code> 格式数据的简单，以及所占的字节数少等优点。</p><h3 id="5-2-JSON-基础语法"><a href="#5-2-JSON-基础语法" class="headerlink" title="5.2  JSON 基础语法"></a>5.2  JSON 基础语法</h3><h4 id="5-2-1-定义格式"><a href="#5-2-1-定义格式" class="headerlink" title="5.2.1  定义格式"></a>5.2.1  定义格式</h4><p><code>JSON</code> 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var 变量名 = '{"key":value,"key":value,...}';</code></pre><p><code>JSON</code> 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下</p><ul><li>数字（整数或浮点数）</li><li>字符串（使用双引号括起来）</li><li>逻辑值（true或者false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsonStr = '{"name":"zhangsan","age":23,"addr":["北京","上海","西安"]}'</code></pre><h4 id="5-2-2-代码演示"><a href="#5-2-2-代码演示" class="headerlink" title="5.2.2  代码演示"></a>5.2.2  代码演示</h4><p>创建一个页面，在该页面的 <code>&lt;script&gt;</code> 标签中定义json字符串</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    //1. 定义JSON字符串    var jsonStr = '{"name":"zhangsan","age":23,"addr":["北京","上海","西安"]}'    alert(jsonStr);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>通过浏览器打开，页面效果如下图所示</p><img src="image-20210831223339530.png" alt="image-20210831223339530" style="zoom:80%;"><p>现在我们需要获取到该 <code>JSON</code> 串中的 <code>name</code> 属性值，应该怎么处理呢？</p><p>如果它是一个 js 对象，我们就可以通过 <code>js对象.属性名</code> 的方式来获取数据。JS 提供了一个对象 <code>JSON</code> ，该对象有如下两个方法：</p><ul><li><code>parse(str)</code> ：将 JSON串转换为 js 对象。使用方式是： ==<code>var jsObject = JSON.parse(jsonStr);</code>==</li><li><code>stringify(obj)</code> ：将 js 对象转换为 JSON 串。使用方式是：==<code>var jsonStr = JSON.stringify(jsObject)</code>==</li></ul><p>代码演示：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    //1. 定义JSON字符串    var jsonStr = '{"name":"zhangsan","age":23,"addr":["北京","上海","西安"]}'    alert(jsonStr);    //2. 将 JSON 字符串转为 JS 对象    let jsObject = JSON.parse(jsonStr);    alert(jsObject)    alert(jsObject.name)    //3. 将 JS 对象转换为 JSON 字符串    let jsonStr2 = JSON.stringify(jsObject);    alert(jsonStr2)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="5-2-3-发送异步请求携带参数"><a href="#5-2-3-发送异步请求携带参数" class="headerlink" title="5.2.3  发送异步请求携带参数"></a>5.2.3  发送异步请求携带参数</h4><p>后面我们使用 <code>axios</code> 发送请求时，如果要携带复杂的数据时都会以 <code>JSON</code> 格式进行传递，如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios({    method:"post",    url:"http://localhost:8080/ajax-demo/axiosServlet",    data:"username=zhangsan"}).then(function (resp) {    alert(resp.data);})</code></pre><p>请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 <code>JSON.stringify(js对象)</code> 转换为 <code>JSON</code> 串，再将该 <code>JSON</code> 串作为 <code>axios</code> 的 <code>data</code> 属性值进行请求参数的提交。如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsObject = {name:"张三"};axios({    method:"post",    url:"http://localhost:8080/ajax-demo/axiosServlet",    data: JSON.stringify(jsObject)}).then(function (resp) {    alert(resp.data);})</code></pre><p>而 <code>axios</code> 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 <code>axios</code> 的 <code>data</code> 属性值进行，它会自动将 js 对象转换为 <code>JSON</code> 串进行提交。如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsObject = {name:"张三"};axios({    method:"post",    url:"http://localhost:8080/ajax-demo/axiosServlet",    data:jsObject  //这里 axios 会将该js对象转换为 json 串的}).then(function (resp) {    alert(resp.data);})</code></pre><blockquote><p>==注意：==</p><ul><li>js 提供的 <code>JSON</code> 对象我们只需要了解一下即可。因为 <code>axios</code> 会自动对 js 对象和 <code>JSON</code> 串进行想换转换。</li><li>发送异步请求时，如果请求参数是 <code>JSON</code> 格式，那请求方式必须是 <code>POST</code>。因为 <code>JSON</code> 串需要放在请求体中。</li></ul></blockquote><h3 id="5-3-JSON串和Java对象的相互转换"><a href="#5-3-JSON串和Java对象的相互转换" class="headerlink" title="5.3  JSON串和Java对象的相互转换"></a>5.3  JSON串和Java对象的相互转换</h3><p>学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。</p><img src="image-20210831104901912.png" alt="image-20210831104901912" style="zoom:70%;"><p>在后端我们就需要重点学习以下两部分操作：</p><ul><li>请求数据：JSON字符串转为Java对象</li><li>响应数据：Java对象转为JSON字符串</li></ul><p>接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 <code>Fastjson</code></p><h4 id="5-3-1-Fastjson-概述"><a href="#5-3-1-Fastjson-概述" class="headerlink" title="5.3.1  Fastjson 概述"></a>5.3.1  Fastjson 概述</h4><p><code>Fastjson</code> 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 <code>JSON</code> 库，是目前Java语言中最快的 <code>JSON</code> 库，可以实现 <code>Java</code> 对象和 <code>JSON</code> 字符串的相互转换。</p><h4 id="5-3-2-Fastjson-使用"><a href="#5-3-2-Fastjson-使用" class="headerlink" title="5.3.2  Fastjson 使用"></a>5.3.2  Fastjson 使用</h4><p><code>Fastjson</code> 使用也是比较简单的，分为以下三步完成</p><ol><li><p><strong>导入坐标</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p><strong>Java对象转JSON</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String jsonStr = JSON.toJSONString(obj);</code></pre><p>将 Java 对象转换为 JSON 串，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>toJSONString()</code> 静态方法即可。</p></li><li><p><strong>JSON字符串转Java对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">User user&nbsp;=&nbsp;JSON.parseObject(jsonStr, User.class);</code></pre><p>将 json 转换为 Java 对象，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>parseObject()</code> 静态方法即可。</p></li></ol><h4 id="5-3-3-代码演示"><a href="#5-3-3-代码演示" class="headerlink" title="5.3.3  代码演示"></a>5.3.3  代码演示</h4><ul><li><p>引入坐标</p></li><li><p>创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FastJsonDemo {    public static void main(String[] args) {        //1. 将Java对象转为JSON字符串        User user = new User();        user.setId(1);        user.setUsername("zhangsan");        user.setPassword("123");        String jsonString = JSON.toJSONString(user);        System.out.println(jsonString);//{"id":1,"password":"123","username":"zhangsan"}        //2. 将JSON字符串转为Java对象        User u = JSON.parseObject("{\"id\":1,\"password\":\"123\",\"username\":\"zhangsan\"}", User.class);        System.out.println(u);    }}</code></pre></li></ul><h2 id="6-案例"><a href="#6-案例" class="headerlink" title="6. 案例"></a>6. 案例</h2><h3 id="6-1-需求"><a href="#6-1-需求" class="headerlink" title="6.1  需求"></a>6.1  需求</h3><p>使用Axios + JSON 完成品牌列表数据查询和添加。页面效果还是下图所示：</p><img src="image-20210830234803335.png" alt="image-20210830234803335" style="zoom:60%;"><h3 id="6-2-查询所有功能"><a href="#6-2-查询所有功能" class="headerlink" title="6.2  查询所有功能"></a>6.2  查询所有功能</h3><p><img src="image-20210831085332612.png" alt="image-20210831085332612"></p><p>如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据</p><p><img src="image-20210831090839336.png" alt="image-20210831090839336"></p><h4 id="6-2-1-环境准备"><a href="#6-2-1-环境准备" class="headerlink" title="6.2.1  环境准备"></a>6.2.1  环境准备</h4><p>将 <code>02-AJAX\04-资料\3. 品牌列表案例\初始工程</code> 下的 <code>brand-demo</code> 工程拷贝到我们自己 <code>工作空间</code> ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下：</p><img src="image-20210831091604457.png" alt="image-20210831091604457" style="zoom:80%;"><p>==注意：==</p><ul><li>在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现</li><li>要根据自己的数据库环境去修改连接数据库的信息，在 <code>mybatis-config.xml</code> 核心配置文件中修改</li></ul><h4 id="6-2-2-后端实现"><a href="#6-2-2-后端实现" class="headerlink" title="6.2.2  后端实现"></a>6.2.2  后端实现</h4><p>在 <code>com.itheima.web</code> 包下创建名为 <code>SelectAllServlet</code> 的 <code>servlet</code>，具体的逻辑如下：</p><ul><li>调用 service 的 <code>selectAll()</code> 方法进行查询所有的逻辑处理</li><li>将查询到的集合数据转换为 json 数据。我们将此过程称为 ==序列化==；如果是将 json 数据转换为 Java 对象，我们称之为 ==反序列化==</li><li>将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 <code>response.setContentType("text/json;charset=utf-8");</code></li></ul><p><code>SelectAllServlet</code> 代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/selectAllServlet")public class SelectAllServlet extends HttpServlet {    private BrandService brandService = new BrandService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 调用Service查询        List&lt;Brand&gt; brands = brandService.selectAll();        //2. 将集合转换为JSON数据   序列化        String jsonString = JSON.toJSONString(brands);        //3. 响应数据  application/json   text/json        response.setContentType("text/json;charset=utf-8");        response.getWriter().write(jsonString);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h4 id="6-2-3-前端实现"><a href="#6-2-3-前端实现" class="headerlink" title="6.2.3  前端实现"></a>6.2.3  前端实现</h4><ol><li><strong>引入 js 文件</strong></li></ol><p>在 <code>brand.html</code> 页面引入 <code>axios</code> 的 js 文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;</code></pre><ol start="2"><li><strong>绑定 <code>页面加载完毕</code> 事件</strong></li></ol><p>在 <code>brand.html</code> 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.onload = function() {}</code></pre><ol start="3"><li><strong>发送异步请求</strong></li></ol><p>在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> //2. 发送ajax请求axios({    method:"get",    url:"http://localhost:8080/brand-demo/selectAllServlet"}).then(function (resp) {});</code></pre><ol start="4"><li><strong>处理响应数据</strong></li></ol><p>在 <code>then</code> 中的回调函数中通过 <code>resp.data</code> 可以获取响应回来的数据，而数据格式如下</p><img src="image-20210831093617083.png" alt="image-20210831093617083" style="zoom:80%;"><p>现在我们需要拼接字符串，将下面表格中的所有的 <code>tr</code> 拼接到一个字符串中，然后使用 <code>document.getElementById("brandTable").innerHTML = 拼接好的字符串</code>  就可以动态的展示出用户想看到的数据</p><img src="image-20210831093938057.png" alt="image-20210831093938057" style="zoom:70%;"><p>而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//获取数据let brands = resp.data;let tableData = " &lt;tr&gt;\n" +    "        &lt;th&gt;序号&lt;/th&gt;\n" +    "        &lt;th&gt;品牌名称&lt;/th&gt;\n" +    "        &lt;th&gt;企业名称&lt;/th&gt;\n" +    "        &lt;th&gt;排序&lt;/th&gt;\n" +    "        &lt;th&gt;品牌介绍&lt;/th&gt;\n" +    "        &lt;th&gt;状态&lt;/th&gt;\n" +    "        &lt;th&gt;操作&lt;/th&gt;\n" +    "    &lt;/tr&gt;";</code></pre><p>接下来遍历响应回来的数据 <code>brands</code> ，拿到每一条品牌数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i = 0; i &lt; brands.length ; i++) {    let brand = brands[i];}</code></pre><p>紧接着就是从 <code>brand</code> 对象中获取数据并且拼接 <code>数据行</code>，累加到 <code>tableData</code> 字符串变量中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tableData += "\n" +    "    &lt;tr align=\"center\"&gt;\n" +    "        &lt;td&gt;"+(i+1)+"&lt;/td&gt;\n" +    "        &lt;td&gt;"+brand.brandName+"&lt;/td&gt;\n" +    "        &lt;td&gt;"+brand.companyName+"&lt;/td&gt;\n" +    "        &lt;td&gt;"+brand.ordered+"&lt;/td&gt;\n" +    "        &lt;td&gt;"+brand.description+"&lt;/td&gt;\n" +    "        &lt;td&gt;"+brand.status+"&lt;/td&gt;\n" +    "\n" +    "        &lt;td&gt;&lt;a href=\"#\"&gt;修改&lt;/a&gt; &lt;a href=\"#\"&gt;删除&lt;/a&gt;&lt;/td&gt;\n" +    "    &lt;/tr&gt;";</code></pre><p>最后再将拼接好的字符串写到表格中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 设置表格数据document.getElementById("brandTable").innerHTML = tableData;</code></pre><p><strong>整体页面代码如下：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="addBrand.html"&gt;&lt;input type="button" value="新增"&gt;&lt;/a&gt;&lt;br&gt;&lt;hr&gt;&lt;table id="brandTable" border="1" cellspacing="0" width="100%"&gt;   &lt;/table&gt;&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;&lt;script&gt;    //1. 当页面加载完成后，发送ajax请求    window.onload = function () {        //2. 发送ajax请求        axios({            method:"get",            url:"http://localhost:8080/brand-demo/selectAllServlet"        }).then(function (resp) {            //获取数据            let brands = resp.data;            let tableData = " &lt;tr&gt;\n" +                "        &lt;th&gt;序号&lt;/th&gt;\n" +                "        &lt;th&gt;品牌名称&lt;/th&gt;\n" +                "        &lt;th&gt;企业名称&lt;/th&gt;\n" +                "        &lt;th&gt;排序&lt;/th&gt;\n" +                "        &lt;th&gt;品牌介绍&lt;/th&gt;\n" +                "        &lt;th&gt;状态&lt;/th&gt;\n" +                "        &lt;th&gt;操作&lt;/th&gt;\n" +                "    &lt;/tr&gt;";            for (let i = 0; i &lt; brands.length ; i++) {                let brand = brands[i];                tableData += "\n" +                    "    &lt;tr align=\"center\"&gt;\n" +                    "        &lt;td&gt;"+(i+1)+"&lt;/td&gt;\n" +                    "        &lt;td&gt;"+brand.brandName+"&lt;/td&gt;\n" +                    "        &lt;td&gt;"+brand.companyName+"&lt;/td&gt;\n" +                    "        &lt;td&gt;"+brand.ordered+"&lt;/td&gt;\n" +                    "        &lt;td&gt;"+brand.description+"&lt;/td&gt;\n" +                    "        &lt;td&gt;"+brand.status+"&lt;/td&gt;\n" +                    "\n" +                    "        &lt;td&gt;&lt;a href=\"#\"&gt;修改&lt;/a&gt; &lt;a href=\"#\"&gt;删除&lt;/a&gt;&lt;/td&gt;\n" +                    "    &lt;/tr&gt;";            }            // 设置表格数据            document.getElementById("brandTable").innerHTML = tableData;        })    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-3-添加品牌功能"><a href="#6-3-添加品牌功能" class="headerlink" title="6.3  添加品牌功能"></a>6.3  添加品牌功能</h3><p><img src="image-20210831100117014.png" alt="image-20210831100117014"></p><p>如上所示，当我们点击 <code>新增</code> 按钮，会跳转到 <code>addBrand.html</code> 页面。在 <code>addBrand.html</code> 页面输入数据后点击 <code>提交</code> 按钮，就会将数据提交到后端，而后端将数据保存到数据库中。</p><p>具体的前后端交互的流程如下：</p><p><img src="image-20210831100329698.png" alt="image-20210831100329698"></p><p>==说明：==</p><p>前端需要将用户输入的数据提交到后端，这部分数据需要以 json 格式进行提交，数据格式如下：</p><p><img src="image-20210831101234467.png" alt="image-20210831101234467"></p><h4 id="6-3-1-后端实现"><a href="#6-3-1-后端实现" class="headerlink" title="6.3.1  后端实现"></a>6.3.1  后端实现</h4><p>在 <code>com.itheima.web</code> 包下创建名为 <code>AddServlet</code> 的 <code>servlet</code>，具体的逻辑如下：</p><ul><li><p>获取请求参数</p><p>由于前端提交的是 json 格式的数据，所以我们不能使用 <code>request.getParameter()</code> 方法获取请求参数</p><ul><li>如果提交的数据格式是 <code>username=zhangsan&amp;age=23</code> ，后端就可以使用 <code>request.getParameter()</code> 方法获取</li><li>如果提交的数据格式是 json，后端就需要通过 request 对象获取输入流，再通过输入流读取数据</li></ul></li><li><p>将获取到的请求参数（json格式的数据）转换为 <code>Brand</code> 对象</p></li><li><p>调用 service 的 <code>add()</code> 方法进行添加数据的逻辑处理</p></li><li><p>将 json 数据响应回给浏览器。</p></li></ul><p><code>AddServlet</code> 代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/addServlet")public class AddServlet extends HttpServlet {    private BrandService brandService = new BrandService();    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 接收数据,request.getParameter 不能接收json的数据       /* String brandName = request.getParameter("brandName");        System.out.println(brandName);*/        // 获取请求体数据        BufferedReader br = request.getReader();        String params = br.readLine();        // 将JSON字符串转为Java对象        Brand brand = JSON.parseObject(params, Brand.class);        //2. 调用service 添加        brandService.add(brand);        //3. 响应成功标识        response.getWriter().write("success");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h4 id="6-3-2-前端实现"><a href="#6-3-2-前端实现" class="headerlink" title="6.3.2  前端实现"></a>6.3.2  前端实现</h4><p>在 <code>addBrand.html</code> 页面给 <code>提交</code> 按钮绑定点击事件，并在绑定的匿名函数中发送异步请求，代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1. 给按钮绑定单击事件document.getElementById("btn").onclick = function () {    //2. 发送ajax请求    axios({        method:"post",        url:"http://localhost:8080/brand-demo/addServlet",        data:???    }).then(function (resp) {        // 判断响应数据是否为 success        if(resp.data == "success"){            location.href = "http://localhost:8080/brand-demo/brand.html";        }    })}</code></pre><p>现在我们只需要考虑如何获取页面上用户输入的数据即可。</p><p>首先我们先定义如下的一个 js 对象，该对象是用来封装页面上输入的数据，并将该对象作为上面发送异步请求时 <code>data</code> 属性的值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 将表单数据转为jsonvar formData = {    brandName:"",    companyName:"",    ordered:"",    description:"",    status:"",};</code></pre><p>接下来获取输入框输入的数据，并将获取到的数据赋值给 <code>formData</code> 对象指定的属性。比如获取用户名的输入框数据，并把该数据赋值给 <code>formData</code> 对象的 <code>brandName</code> 属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 获取表单数据let brandName = document.getElementById("brandName").value;// 设置数据formData.brandName = brandName;</code></pre><p>==说明：其他的输入框都用同样的方式获取并赋值。==但是有一个比较特殊，就是状态数据，如下图是页面内容</p><img src="image-20210831103843798.png" alt="image-20210831103843798" style="zoom:80%;"><p>我们需要判断哪儿个被选中，再将选中的单选框数据赋值给 <code>formData</code> 对象的 <code>status</code> 属性，代码实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let status = document.getElementsByName("status");for (let i = 0; i &lt; status.length; i++) {    if(status[i].checked){        //        formData.status = status[i].value ;    }}</code></pre><p><strong>整体页面代码如下：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;添加品牌&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;添加品牌&lt;/h3&gt;&lt;form action="" method="post"&gt;    品牌名称：&lt;input id="brandName" name="brandName"&gt;&lt;br&gt;    企业名称：&lt;input id="companyName" name="companyName"&gt;&lt;br&gt;    排序：&lt;input id="ordered" name="ordered"&gt;&lt;br&gt;    描述信息：&lt;textarea rows="5" cols="20" id="description" name="description"&gt;&lt;/textarea&gt;&lt;br&gt;    状态：    &lt;input type="radio" name="status" value="0"&gt;禁用    &lt;input type="radio" name="status" value="1"&gt;启用&lt;br&gt;    &lt;input type="button" id="btn"  value="提交"&gt;&lt;/form&gt;&lt;script src="js/axios-0.18.0.js"&gt;&lt;/script&gt;&lt;script&gt;    //1. 给按钮绑定单击事件    document.getElementById("btn").onclick = function () {        // 将表单数据转为json        var formData = {            brandName:"",            companyName:"",            ordered:"",            description:"",            status:"",        };        // 获取表单数据        let brandName = document.getElementById("brandName").value;        // 设置数据        formData.brandName = brandName;        // 获取表单数据        let companyName = document.getElementById("companyName").value;        // 设置数据        formData.companyName = companyName;        // 获取表单数据        let ordered = document.getElementById("ordered").value;        // 设置数据        formData.ordered = ordered;        // 获取表单数据        let description = document.getElementById("description").value;        // 设置数据        formData.description = description;        let status = document.getElementsByName("status");        for (let i = 0; i &lt; status.length; i++) {            if(status[i].checked){                //                formData.status = status[i].value ;            }        }        //console.log(formData);        //2. 发送ajax请求        axios({            method:"post",            url:"http://localhost:8080/brand-demo/addServlet",            data:formData        }).then(function (resp) {            // 判断响应数据是否为 success            if(resp.data == "success"){                location.href = "http://localhost:8080/brand-demo/brand.html";            }        })    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>==说明：==</p><p><code>查询所有</code> 功能和 <code>添加品牌</code> 功能就全部实现，大家肯定会感觉前端的代码很复杂；而这只是暂时的，后面学习了 <code>vue</code> 前端框架后，这部分前端代码就可以进行很大程度的简化。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> filter </tag>
            
            <tag> listener </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP&amp;Tomcat&amp;Servlet</title>
      <link href="/2023/05/20/HTTP-Tomcat-Servlet/"/>
      <url>/2023/05/20/HTTP-Tomcat-Servlet/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-Tomcat-Servlet"><a href="#HTTP-Tomcat-Servlet" class="headerlink" title="HTTP&amp;Tomcat&amp;Servlet"></a>HTTP&amp;Tomcat&amp;Servlet</h2><p><strong>今日目标：</strong></p><blockquote><ul><li>了解JavaWeb开发的技术栈</li><li>理解HTTP协议和HTTP请求与响应数据的格式</li><li>掌握Tomcat的使用</li><li>掌握在IDEA中使用Tomcat插件</li><li>理解Servlet的执行流程和生命周期</li><li>掌握Servlet的使用和相关配置</li></ul></blockquote><h2 id="1-Web概述"><a href="#1-Web概述" class="headerlink" title="1. Web概述"></a>1. Web概述</h2><h3 id="1-1-Web和JavaWeb的概念"><a href="#1-1-Web和JavaWeb的概念" class="headerlink" title="1.1 Web和JavaWeb的概念"></a>1.1 Web和JavaWeb的概念</h3><p>==Web是全球广域网，也称为万维网(www)，能够通过浏览器访问的网站。==<br>在我们日常的生活中，经常会使用浏览器去访问<code>百度</code>、<code>京东</code>、<code>传智官网</code>等这些网站，这些网站统称为Web网站。如下就是通过浏览器访问传智官网的界面:<br><img src="1627031023395.png" alt="1627031023395"><br>我们知道了什么是Web，那么JavaWeb又是什么呢？顾名思义==JavaWeb就是用Java技术来解决相关web互联网领域的技术栈。==<br>等学习完JavaWeb之后，同学们就可以使用Java语言开发我们上述所说的网站。而国内很多大型网站公司也是首选Java语言来解决web互联网相关的问题。那都有哪些公司的系统是使用Java语言的呢?<br> <img src="../../../%25E5%2590%258E%25E7%25AB%25AF%25E8%25AE%25B0%25E8%25A6%2581/%25E5%2590%258E%25E7%25AB%25AF/JavaWeb/HTTP&amp;Tomcat&amp;Servlet/assets/20210717183958532.png"><br>使用Java语言开发互联网系统是有很多技术栈需要大家了解，具体都有哪些呢?</p><h3 id="1-2-JavaWeb技术栈"><a href="#1-2-JavaWeb技术栈" class="headerlink" title="1.2 JavaWeb技术栈"></a>1.2 JavaWeb技术栈</h3><p>了解JavaWeb技术栈之前，有一个很重要的概念要介绍。</p><h4 id="1-2-1-B-S架构"><a href="#1-2-1-B-S架构" class="headerlink" title="1.2.1 B/S架构"></a>1.2.1 B/S架构</h4><p>什么是B/S架构?<br>B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程:<br><img src="1627031933553.png" alt="1627031933553"></p><ul><li>打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容</li><li>思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的</li><li>日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容</li><li>所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。<br>了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢?</li></ul><h4 id="1-2-2-静态资源"><a href="#1-2-2-静态资源" class="headerlink" title="1.2.2 静态资源"></a>1.2.2 静态资源</h4><ul><li>静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。</li><li>我们之前已经学过前端网页制作<code>三剑客</code>(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。</li><li>在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果:<br><img src="1627037814180.png" alt="1627037814180"><br><code>张三</code>登录以后在网页的右上角看到的是 <code>张三</code>，而<code>李四</code>登录以后看到的则是<code>李四</code>。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。</li></ul><h4 id="1-2-3-动态资源"><a href="#1-2-3-动态资源" class="headerlink" title="1.2.3 动态资源"></a>1.2.3 动态资源</h4><ul><li>动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。</li><li>动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。</li><li>动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入<code>用户名</code>和<code>密码</code>,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢?<br><img src="1627038674340.png" alt="1627038674340"></li></ul><h4 id="1-2-4-数据库"><a href="#1-2-4-数据库" class="headerlink" title="1.2.4 数据库"></a>1.2.4 数据库</h4><ul><li>数据库主要负责存储数据。</li><li>整个Web的访问过程就如下图所示:<br><img src="1627039320220.png" alt="1627039320220"><br>(1)浏览器发送一个请求到服务端，去请求所需要的相关资源;<br>(2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;<br>(3)在Java代码可以进行业务处理也可以从数据库中读取数据;<br>(4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;<br>(5)服务端将静态资源响应给浏览器;<br>(6)浏览器将这些资源进行解析;<br>(7)解析后将效果展示在浏览器，用户就可以看到最终的结果。<br>在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢?</li></ul><h4 id="1-2-5-HTTP协议"><a href="#1-2-5-HTTP协议" class="headerlink" title="1.2.5 HTTP协议"></a>1.2.5 HTTP协议</h4><ul><li>HTTP协议:主要定义通信规则</li><li>浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。</li></ul><h4 id="1-2-6-Web服务器"><a href="#1-2-6-Web服务器" class="headerlink" title="1.2.6 Web服务器"></a>1.2.6 Web服务器</h4><ul><li>Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据</li><li>浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器</li><li>Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器</li></ul><p>到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。</p><h3 id="1-3-Web核心课程安排"><a href="#1-3-Web核心课程安排" class="headerlink" title="1.3 Web核心课程安排"></a>1.3 Web核心课程安排</h3><p><img src="1627043194238.png" alt="1627043194238"></p><p>整个Web核心，我们总共有六天的学习内容，分别是:</p><ul><li>第一天：HTTP、Tomcat、Servlet</li><li>第二天：Request(请求)、Response(响应)</li><li>第三天：JSP、会话技术(Cookie、Session)</li><li>第四天：Filter(过滤器)、Listener(监听器)</li><li>第五天：Ajax、Vue、ElementUI</li><li>第六天：综合案例</li></ul><p>(1)Request是从客户端向服务端发出的请求对象，</p><p>(2)Response是从服务端响应给客户端的结果对象，</p><p>(3)JSP是动态网页技术,</p><p>(4)会话技术是用来存储客户端和服务端交互所产生的数据，</p><p>(5)过滤器是用来拦截客户端的请求,</p><p>(6)监听器是用来监听特定事件,</p><p>(7)Ajax、Vue、ElementUI都是属于前端技术</p><p>这些技术都该如何来使用，我们后面会一个个进行详细的讲解。接下来我们来学习下HTTP、Tomcat和Servlet。 </p><h2 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>HTTP概念</strong></p><p>HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间==数据传输的规则==。</p><ul><li>数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</li><li>如果想知道具体的格式，可以打开浏览器，点击<code>F12</code>打开开发者工具，点击<code>Network</code>来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示:</li></ul><p><img src="1627046235092.png" alt="1627046235092"></p><blockquote><p>注意:在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除。</p></blockquote><p>==所以学习HTTP主要就是学习请求和响应数据的具体格式内容。==</p><p><strong>HTTP协议特点</strong></p><p>HTTP协议有它自己的一些特点，分别是:</p><ul><li><p>基于TCP协议: 面向连接，安全</p><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p></li><li><p>基于请求-响应模型的:一次请求对应一次响应</p><p>请求和响应是一一对应关系</p></li><li><p>HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的</p><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，</p><ul><li>缺点:多次请求间不能共享数据</li><li>优点:速度快</li></ul><p>请求之间无法共享数据会引发的问题，如:</p><ul><li>京东购物，<code>加入购物车</code>和<code>去购物车结算</code>是两次请求，</li><li>HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用<code>会话技术(Cookie、Session)</code>来解决这个问题。具体如何来做，我们后面会详细讲到。刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?</p></li></ul><h3 id="2-2-请求数据格式"><a href="#2-2-请求数据格式" class="headerlink" title="2.2 请求数据格式"></a>2.2 请求数据格式</h3><h4 id="2-2-1-格式介绍"><a href="#2-2-1-格式介绍" class="headerlink" title="2.2.1 格式介绍"></a>2.2.1 格式介绍</h4><p>请求数据总共分为三部分内容，分别是==请求行==、==请求头==、==请求体==</p><p><img src="1627050004221.png" alt="1627050004221"></p><ul><li><p>请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本]</p><p>请求方式有七种,最常用的是GET和POST</p></li><li><p>请求头: 第二行开始，格式为key: value形式</p><p>请求头中会包含若干个属性，常见的HTTP请求头有:</p><pre class="line-numbers language-none"><code class="language-none">Host: 表示请求的主机名User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</code></pre><p> ==这些数据有什么用处?==</p><p>举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如:</p><ul><li>不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li><li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果</li><li>这就是我们常说的浏览器兼容问题</li></ul></li><li><p>请求体: POST请求的最后一部分，存储请求参数</p><p><img src="1627050930378.png" alt="1627050930378"></p><p>如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了:</p><ul><li>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</li><li>GET请求请求参数大小有限制，POST没有</li></ul></li></ul><h4 id="2-2-2-实例演示"><a href="#2-2-2-实例演示" class="headerlink" title="2.2.2 实例演示"></a>2.2.2 实例演示</h4><p>把 <code>代码\http</code> 拷贝到IDEA的工作目录中，比如<code>D:\workspace\web</code>目录，</p><p><img src="1627278511902.png" alt="1627278511902"></p><p>使用IDEA打开</p><p><img src="1627278583127.png" alt="1627278583127"></p><p>打开后，可以点击项目中的<code>html\19-表单验证.html</code>，使用浏览器打开，通过修改页面中form表单的method属性来测试GET请求和POST请求的参数携带方式。</p><p><img src="1627278725007.png" alt="1627278725007"></p><p><strong>小结</strong>:</p><ol><li><p>请求数据中包含三部分内容，分别是请求行、请求头和请求体</p></li><li><p>POST请求数据在请求体中，GET请求数据在请求行上</p></li></ol><h3 id="2-3-响应数据格式"><a href="#2-3-响应数据格式" class="headerlink" title="2.3 响应数据格式"></a>2.3 响应数据格式</h3><h4 id="2-3-1-格式介绍"><a href="#2-3-1-格式介绍" class="headerlink" title="2.3.1 格式介绍"></a>2.3.1 格式介绍</h4><p>响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体==</p><p><img src="1627053710214.png" alt="1627053710214"></p><ul><li><p>响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]</p></li><li><p>响应头：第二行开始，格式为key：value形式</p><p>响应头中会包含若干个属性，常见的HTTP响应头有:</p><pre class="line-numbers language-none"><code class="language-none">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒</code></pre></li><li><p>响应体： 最后一部分。存放响应数据</p><p>上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。</p></li></ul><h4 id="2-3-2-响应状态码"><a href="#2-3-2-响应状态码" class="headerlink" title="2.3.2 响应状态码"></a>2.3.2 响应状态码</h4><p>参考: 资料/1.HTTP/《响应状态码.md》</p><p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握:</p><ul><li>200  ok 客户端请求成功</li><li>404  Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul><h4 id="2-3-3-自定义服务器"><a href="#2-3-3-自定义服务器" class="headerlink" title="2.3.3 自定义服务器"></a>2.3.3 自定义服务器</h4><p>在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是<code>ServerSocket</code>和<code>Socket</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima;import sun.misc.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.nio.file.Files;/*    自定义服务器 */public class Server {    public static void main(String[] args) throws IOException {        ServerSocket ss = new ServerSocket(8080); // 监听指定端口        System.out.println("server is running...");        while (true){            Socket sock = ss.accept();            System.out.println("connected from " + sock.getRemoteSocketAddress());            Thread t = new Handler(sock);            t.start();        }    }}class Handler extends Thread {    Socket sock;    public Handler(Socket sock) {        this.sock = sock;    }    public void run() {        try (InputStream input = this.sock.getInputStream()) {            try (OutputStream output = this.sock.getOutputStream()) {                handle(input, output);            }        } catch (Exception e) {            try {                this.sock.close();            } catch (IOException ioe) {            }            System.out.println("client disconnected.");        }    }    private void handle(InputStream input, OutputStream output) throws IOException {        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));        // 读取HTTP请求:        boolean requestOk = false;        String first = reader.readLine();        if (first.startsWith("GET / HTTP/1.")) {            requestOk = true;        }        for (;;) {            String header = reader.readLine();            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕                break;            }            System.out.println(header);        }        System.out.println(requestOk ? "Response OK" : "Response Error");        if (!requestOk) {            // 发送错误响应:            writer.write("HTTP/1.0 404 Not Found\r\n");            writer.write("Content-Length: 0\r\n");            writer.write("\r\n");            writer.flush();        } else {            // 发送成功响应:            //读取html文件，转换为字符串            BufferedReader br = new BufferedReader(new FileReader("http/html/a.html"));            StringBuilder data = new StringBuilder();            String line = null;            while ((line = br.readLine()) != null){                data.append(line);            }            br.close();            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;            writer.write("HTTP/1.1 200 OK\r\n");            writer.write("Connection: keep-alive\r\n");            writer.write("Content-Type: text/html\r\n");            writer.write("Content-Length: " + length + "\r\n");            writer.write("\r\n"); // 空行标识Header和Body的分隔            writer.write(data.toString());            writer.flush();        }    }}</code></pre><p>上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat==</p><p><strong>小结</strong></p><ol><li><p>响应数据中包含三部分内容，分别是响应行、响应头和响应体</p></li><li><p>掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误</p></li></ol><h2 id="3-Tomcat"><a href="#3-Tomcat" class="headerlink" title="3. Tomcat"></a>3. Tomcat</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><h4 id="3-1-1-什么是Web服务器"><a href="#3-1-1-什么是Web服务器" class="headerlink" title="3.1.1 什么是Web服务器"></a>3.1.1 什么是Web服务器</h4><p>Web服务器是一个应用程序（==软件==），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p><img src="1627058356051.png" alt="1627058356051"></p><p> Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:</p><p><img src="1627060368806.png" alt="1627060368806"></p><p>Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:</p><ol><li><p>简介: 初步认识下Tomcat</p></li><li><p>基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作</p></li><li><p>IDEA中如何创建Maven Web项目</p></li><li><p>IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式</p></li></ol><p>首选我们来认识下Tomcat。</p><p><strong>Tomcat</strong></p><p>Tomcat的相关概念:</p><ul><li><p>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。</p></li><li><p>概念中提到了JavaEE规范，那什么又是JavaEE规范呢?</p><p>JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。</p></li><li><p>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。</p></li><li><p>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> 从官网上可以下载对应的版本进行使用。</p></li></ul><p><strong>Tomcat的LOGO</strong></p><p><img src="1627176045795.png" alt="1627176045795"></p><p><strong>小结</strong></p><p>通过这一节的学习，我们需要掌握以下内容:</p><ol><li>Web服务器的作用</li></ol><blockquote><p>封装HTTP协议操作，简化开发</p><p>可以将Web项目部署到服务器中，对外提供网上浏览服务</p></blockquote><ol start="2"><li>Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。</li></ol><h3 id="3-2-基本使用"><a href="#3-2-基本使用" class="headerlink" title="3.2 基本使用"></a>3.2 基本使用</h3><p>Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。</p><h4 id="3-2-1-下载"><a href="#3-2-1-下载" class="headerlink" title="3.2.1 下载"></a>3.2.1 下载</h4><p>直接从官网下载</p><p><img src="1627178001030.png" alt="1627178001030"></p><p>大家可以自行下载，也可以直接使用资料中已经下载好的资源，</p><p>Tomcat的软件程序  资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip</p><p>Tomcat的源码资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip</p><h4 id="3-2-2-安装"><a href="#3-2-2-安装" class="headerlink" title="3.2.2 安装"></a>3.2.2 安装</h4><p>Tomcat是绿色版,直接解压即可</p><ul><li><p>在D盘的software目录下，将<code>apache-tomcat-8.5.68-windows-x64.zip</code>进行解压缩，会得到一个<code>apache-tomcat-8.5.68</code>的目录，Tomcat就已经安装成功。</p><p>==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。</p></li><li><p>打开<code>apache-tomcat-8.5.68</code>目录就能看到如下目录结构，每个目录中包含的内容需要认识下,</p><p><img src="1627178815892.png" alt="1627178815892"></p><p>bin:目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows系统的可执行文件，一种是以<code>.sh</code>结尾的，是Linux系统的可执行文件。</p><p>webapps:就是以后项目部署的目录</p><p>到此，Tomcat的安装就已经完成。</p></li></ul><h4 id="3-2-3-卸载"><a href="#3-2-3-卸载" class="headerlink" title="3.2.3 卸载"></a>3.2.3 卸载</h4><p>卸载比较简单，可以直接删除目录即可</p><h4 id="3-2-4-启动"><a href="#3-2-4-启动" class="headerlink" title="3.2.4 启动"></a>3.2.4 启动</h4><p>双击: bin\startup.bat</p><p><img src="1627179006011.png" alt="1627179006011"></p><p>启动后，通过浏览器访问 <code>http://localhost:8080</code>能看到Apache Tomcat的内容就说明Tomcat已经启动成功。</p><p><img src="1627199957728.png" alt="1627199957728"></p><p>==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties</p><p><img src="1627199827589.png" alt="1627199827589"></p><h4 id="3-2-5-关闭"><a href="#3-2-5-关闭" class="headerlink" title="3.2.5 关闭"></a>3.2.5 关闭</h4><p>关闭有三种方式 </p><ul><li>直接x掉运行窗口:强制关闭[不建议]</li><li>bin\shutdown.bat：正常关闭</li><li>ctrl+c： 正常关闭</li></ul><h4 id="3-2-6-配置"><a href="#3-2-6-配置" class="headerlink" title="3.2.6 配置"></a>3.2.6 配置</h4><p><strong>修改端口</strong></p><ul><li>Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml</li></ul><p><img src="1627200509883.png" alt="1627200509883"></p><blockquote><p>注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p></blockquote><p><strong>启动时可能出现的错误</strong></p><ul><li><p>Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误</p><p><img src="1627200780590.png" alt="1627200780590"></p></li><li><p>Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置</p></li></ul><p><img src="1627201248802.png" alt="1627201248802"></p><h4 id="3-2-7-部署"><a href="#3-2-7-部署" class="headerlink" title="3.2.7 部署"></a>3.2.7 部署</h4><ul><li><p>Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。</p><ul><li><p>将 <code>资料/2. Tomcat/hello</code> 目录拷贝到Tomcat的webapps目录下</p></li><li><p>通过浏览器访问<code>http://localhost/hello/a.html</code>，能看到下面的内容就说明项目已经部署成功。</p><p><img src="1627201572748.png" alt="1627201572748"></p><p>但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢?</p></li></ul></li><li><p>一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件</p><ul><li><p>将 <code>资料/2. Tomcat/haha.war</code>目录拷贝到Tomcat的webapps目录下</p></li><li><p>Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录</p></li><li><p>通过浏览器访问<code>http://localhost/haha/a.html</code>，能看到下面的内容就说明项目已经部署成功。</p><p><img src="1627201868752.png" alt="1627201868752"></p></li></ul></li></ul><p>至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。</p><h3 id="3-3-Maven创建Web项目"><a href="#3-3-Maven创建Web项目" class="headerlink" title="3.3 Maven创建Web项目"></a>3.3 Maven创建Web项目</h3><p>介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢?</p><p>在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么?</p><h4 id="3-3-1-Web项目结构"><a href="#3-3-1-Web项目结构" class="headerlink" title="3.3.1 Web项目结构"></a>3.3.1 Web项目结构</h4><p>Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下:</p><ul><li><p>Maven Web项目结构: 开发中的项目</p><p><img src="1627202865978.png" alt="1627202865978"></p></li><li><p>开发完成部署的Web项目</p><p><img src="1627202903750.png" alt="1627202903750"></p><ul><li>开发项目通过执行Maven打包命令==package==,可以获取到部署的Web项目目录</li><li>编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下</li><li>pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下</li></ul></li></ul><h4 id="3-3-2-创建Maven-Web项目"><a href="#3-3-2-创建Maven-Web项目" class="headerlink" title="3.3.2 创建Maven Web项目"></a>3.3.2 创建Maven Web项目</h4><p>介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架</p><p><strong>使用骨架</strong></p><blockquote><p>具体的步骤包含:</p><p>1.创建Maven项目</p><p>2.选择使用Web项目骨架</p><p>3.输入Maven项目坐标创建项目</p><p>4.确认Maven相关的配置信息后，完成项目创建</p><p>5.删除pom.xml中多余内容</p><p>6.补齐Maven Web项目缺失的目录结构</p></blockquote><ol><li><p>创建Maven项目</p><p><img src="1627227574092.png" alt="1627227574092"></p></li><li><p>选择使用Web项目骨架</p><p><img src="image-20230714211428871.png" alt="image-20230714211428871"></p></li><li><p>输入Maven项目坐标创建项目</p><p><img src="1627228065007.png" alt="1627228065007"></p></li><li><p>确认Maven相关的配置信息后，完成项目创建</p><p><img src="1627228413280.png" alt="1627228413280"></p></li><li><p>删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别</p><p><img src="1627228584625.png" alt="1627228584625"></p></li><li><p>补齐Maven Web项目缺失的目录结构，<strong>默认没有java和resources目录，需要手动完成创建补齐</strong>，最终的目录结果如下</p><p><img src="1627228673162.png"></p></li></ol><p><strong>不使用骨架</strong></p><blockquote><p>具体的步骤包含:</p><p>1.创建Maven项目</p><p>2.选择不使用Web项目骨架</p><p>3.输入Maven项目坐标创建项目</p><p>4.在pom.xml设置打包方式为war</p><p>5.补齐Maven Web项目缺失webapp的目录结构</p><p>6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构</p></blockquote><ol><li><p>创建Maven项目</p><p><img src="1627229111549.png" alt="1627229111549"></p></li><li><p>选择不使用Web项目骨架</p><p><img src="image-20230714212649595.png" alt="image-20230714212649595"></p></li><li><p>输入Maven项目坐标创建项目</p><p><img src="1627229371251.png" alt="1627229371251"></p></li><li><p>在pom.xml设置打包方式为war,默认是不写代表打包方式为jar</p><p><img src="1627229428161.png" alt="1627229428161"></p></li><li><p>补齐Maven Web项目缺失webapp的目录结构</p><p><img src="1627229584134.png" alt="1627229584134"></p></li><li><p>补齐Maven Web项目缺失WEB-INF/web.xml的目录结构</p><p><img src="1627229676800.png" alt="1627229676800"></p></li><li><p>补充完后，最终的项目结构如下:</p><p><img src="1627229478030.png" alt="1627229478030"></p></li></ol><p>上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。</p><p><strong>小结</strong></p><p>1.掌握Maven Web项目的目录结构</p><p>2.掌握使用骨架的方式创建Maven Web项目</p><p><img src="1627204022604.png" alt="1627204022604"></p><blockquote><p>3.掌握不使用骨架的方式创建Maven Web项目</p></blockquote><p><img src="1627204076090.png" alt="1627204076090"></p><h3 id="3-4-IDEA使用Tomcat"><a href="#3-4-IDEA使用Tomcat" class="headerlink" title="3.4 IDEA使用Tomcat"></a>3.4 IDEA使用Tomcat</h3><ul><li>Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。</li><li>然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的</li><li>如何在IDEA中能快速使用Tomcat呢?</li></ul><p>在IDEA中集成使用Tomcat有两种方式，分别是==集成本地Tomcat==和==Tomcat Maven插件==</p><h4 id="3-4-1-集成本地Tomcat"><a href="#3-4-1-集成本地Tomcat" class="headerlink" title="3.4.1 集成本地Tomcat"></a>3.4.1 集成本地Tomcat</h4><p>目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤</p><ol><li><p>打开添加本地Tomcat的面板</p><p><img src="1627229992900.png" alt="1627229992900"></p></li><li><p>指定本地Tomcat的具体路径</p><p><img src="1627230313062.png" alt="1627230313062"></p></li><li><p>修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80</p><p><img src="1627230366658.png" alt="1627230366658"></p></li><li><p>将开发项目部署项目到Tomcat中</p><p><img src="1627230913259.png" alt="1627230913259"></p><p>扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别?</p><ul><li><p>war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上</p></li><li><p>war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上</p></li><li><p>war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容</p></li><li><p>war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署</p></li><li><p>建议大家都选war模式进行部署，更符合项目部署的实际情况</p></li></ul></li><li><p>部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面</p><p><img src="1627233265351.png" alt="1627233265351"></p></li><li><p>启动成功后，可以通过浏览器进行访问测试</p><p><img src="1627232743706.png" alt="1627232743706"></p></li><li><p>最终的注意事项</p><p><img src="1627232916624.png" alt="1627232916624"></p></li></ol><p>至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。</p><p><img src="1627205657117.png" alt="1627205657117"></p><h4 id="3-4-2-Tomcat-Maven插件"><a href="#3-4-2-Tomcat-Maven插件" class="headerlink" title="3.4.2 Tomcat Maven插件"></a>3.4.2 Tomcat Maven插件</h4><p>在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是:</p><ol><li><p><strong>在pom.xml中添加Tomcat插件</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;    &lt;plugins&gt;    &lt;!--Tomcat插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p><strong>使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven –&gt; tomcat7:run</strong></p></li></ol><p><img src="1627233963315.png" alt="1627233963315"></p><p>==注意:==</p><ul><li>如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File –&gt; Settings –&gt; Plugins –&gt; Maven Helper —&gt; Install,安装完后按照提示重启IDEA，就可以看到了。</li></ul><p><img src="1627234184076.png" alt="1627234184076"></p><ul><li>Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用</li><li>使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;    &lt;plugins&gt;    &lt;!--Tomcat插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;configuration&gt;            &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt;                &lt;!--项目访问路径未配置访问路径: http://localhost:80/tomcat-demo2/a.html配置/后访问路径: http://localhost:80/a.html如果配置成 /hello,访问路径会变成什么?答案: http://localhost:80/hello/a.html--&gt;                &lt;path&gt;/&lt;/path&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p><strong>小结</strong></p><p>通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。</p><h2 id="4-Servlet"><a href="#4-Servlet" class="headerlink" title="4. Servlet"></a>4. Servlet</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p><img src="1627234763207.png" alt="1627234763207"></p><ul><li><p>Servlet是JavaWeb最为核心的内容，它是Java提供的一门==动态==web资源开发技术。</p></li><li><p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。</p></li><li><p>Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p><p><img src="1627234972853.png" alt="1627234972853"></p></li></ul><p>介绍完Servlet是什么以后，接下来我们就按照<code>快速入门</code>-&gt;<code>执行流程</code>-&gt;<code>生命周期</code>-&gt;<code>体系结构</code>-&gt;<code>urlPattern配置</code>-&gt;<code>XML配置</code>的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。</p><h3 id="4-2-快速入门"><a href="#4-2-快速入门" class="headerlink" title="4.2 快速入门"></a>4.2 快速入门</h3><p>==需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。==</p><p>具体的实现步骤为:</p><ol><li>创建Web项目<code>web-demo</code>，导入Servlet依赖坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;!--      此处为什么需要添加该标签?      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错    --&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet {    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        System.out.println("servlet hello world~");    }    public void init(ServletConfig servletConfig) throws ServletException {    }    public ServletConfig getServletConfig() {        return null;    }    public String getServletInfo() {        return null;    }    public void destroy() {    }}</code></pre><ol start="3"><li>配置:在类上使用@WebServlet注解，配置该Servlet的访问路径</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo1")</code></pre><ol start="4"><li>访问:启动Tomcat,浏览器中输入URL地址访问该Servlet</li></ol><pre class="line-numbers language-none"><code class="language-none">http://localhost:8080/web-demo/demo1</code></pre><ol start="5"><li>器访问后，在控制台会打印<code>servlet hello world~</code> 说明servlet程序已经成功运行。</li></ol><p>至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。</p><h3 id="4-3-执行流程"><a href="#4-3-执行流程" class="headerlink" title="4.3 执行流程"></a>4.3 执行流程</h3><p>Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了<code>servlet hello world~</code>这句话呢?</p><p>要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。</p><p><img src="1627236923139.png" alt="1627236923139"></p><ul><li>浏览器发出<code>http://localhost:8080/web-demo/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code><ul><li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li><li>根据<code>web-demo</code>可以找到部署在Tomcat服务器上的web-demo项目</li><li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li></ul></li><li>找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法<ul><li>ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li><li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li></ul></li></ul><p><strong>小结</strong></p><p>介绍完Servlet的执行流程，需要大家掌握两个问题：</p><ol><li>Servlet由谁创建?Servlet方法由谁调用?</li></ol><blockquote><p>Servlet由web服务器创建，Servlet方法由web服务器调用</p></blockquote><ol start="2"><li>服务器怎么知道Servlet中一定有service方法?</li></ol><blockquote><p>因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法</p></blockquote><h3 id="4-4-生命周期"><a href="#4-4-生命周期" class="headerlink" title="4.4 生命周期"></a>4.4 生命周期</h3><p>介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。</p><p>接下来咱们再来思考一个问题:==Tomcat什么时候创建的Servlet对象?==</p><p>要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。</p><ul><li><p>生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。</p></li><li><p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>==加载和实例化==：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?@WebServlet(urlPatterns = "/demo1",loadOnStartup = 1)loadOnstartup的取值有两类情况（1）负整数:第一次访问时创建Servlet对象（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</code></pre><ol start="2"><li>==初始化==：在Servlet实例化之后，容器将调用Servlet的==init()==方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只==调用一次==</li><li>==请求处理==：==每次==请求Servlet时，Servlet容器都会调用Servlet的==service()==方法对请求进行处理</li><li>==服务终止==：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的==destroy()==方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ol></li><li><p>通过案例演示下上述的生命周期</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/*** Servlet生命周期方法*/@WebServlet(urlPatterns = "/demo2",loadOnStartup = 1)public class ServletDemo2 implements Servlet {    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException {        System.out.println("init...");    }    /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        System.out.println("servlet hello world~");    }    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() {        System.out.println("destroy...");    }    public ServletConfig getServletConfig() {        return null;    }    public String getServletInfo() {        return null;    }}</code></pre><p>==注意:如何才能让Servlet中的destroy方法被执行？==</p><p><img src="1627239292226.png" alt="1627239292226"></p></li></ul><p>在Terminal命令行中，先使用<code>mvn tomcat7:run</code>启动，然后再使用<code>ctrl+c</code>关闭tomcat</p><p><strong>小结</strong></p><p>这节中需要掌握的内容是:</p><ol><li>Servlet对象在什么时候被创建的?</li></ol><blockquote><p>默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns = “/demo2”,loadOnStartup = 1)的loadOnStartup 修改成在服务器启动的时候创建。</p></blockquote><ol start="2"><li>Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次?</li></ol><blockquote><p>涉及到三个方法，分别是 init()、service()、destroy()</p><p>init方法在Servlet对象被创建的时候执行，只执行1次</p><p>service方法在Servlet被访问的时候调用，每访问1次就调用1次</p><p>destroy方法在Servlet对象被销毁的时候调用，只执行1次</p></blockquote><h3 id="4-5-方法介绍"><a href="#4-5-方法介绍" class="headerlink" title="4.5 方法介绍"></a>4.5 方法介绍</h3><p>Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？</p><p>我们先来回顾下前面讲的三个方法，分别是:</p><ul><li>初始化方法，在Servlet被创建时执行，只执行一次</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void init(ServletConfig config) </code></pre><ul><li>提供服务方法， 每次Servlet被访问，都会调用该方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void service(ServletRequest&nbsp;req, ServletResponse&nbsp;res)</code></pre><ul><li>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void destroy() </code></pre><p>剩下的两个方法是:</p><ul><li>获取Servlet信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() {    return "";}</code></pre><ul><li>获取ServletConfig对象</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">ServletConfig getServletConfig()</code></pre><p>ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * Servlet方法介绍 */@WebServlet(urlPatterns = "/demo3",loadOnStartup = 1)public class ServletDemo3 implements Servlet {    private ServletConfig servletConfig;    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException {        this.servletConfig = config;        System.out.println("init...");    }    public ServletConfig getServletConfig() {        return servletConfig;    }        /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        System.out.println("servlet hello world~");    }    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() {        System.out.println("destroy...");    }        public String getServletInfo() {        return "";    }}</code></pre><p>getServletInfo()和getServletConfig()这两个方法使用的不是很多，大家了解下。</p><h3 id="4-6-体系结构"><a href="#4-6-体系结构" class="headerlink" title="4.6 体系结构"></a>4.6 体系结构</h3><p>通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢?</p><p>要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解:</p><p><img src="1627240593506.png" alt="1627240593506"></p><p>因为我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承==HttpServlet==</p><p>具体的编写格式如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo4")public class ServletDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //TODO GET 请求方式处理逻辑        System.out.println("get...");    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //TODO Post 请求方式处理逻辑        System.out.println("post...");    }}</code></pre><ul><li>要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送<code>http://localhost:8080/web-demo/demo4</code>,就能看到doGet方法被执行了</li><li>要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个<code>a.html</code>页面，内容如下:</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="/web-demo/demo4" method="post"&gt;        &lt;input name="username"/&gt;&lt;input type="submit"/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>启动测试，即可看到doPost方法被执行了。</p><p>Servlet的简化编写就介绍完了，接着需要思考两个问题:</p><ol><li>HttpServlet中为什么要根据请求方式的不同，调用不同的方法?</li><li>如何调用?</li></ol><p>针对问题一，我们需要回顾之前的知识点==前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中==，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/demo5")public class ServletDemo5 implements Servlet {    public void init(ServletConfig config) throws ServletException {    }    public ServletConfig getServletConfig() {        return null;    }    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        //如何调用?        //获取请求方式，根据不同的请求方式进行不同的业务处理        HttpServletRequest request = (HttpServletRequest)req;       //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if("GET".equals(method)){            // get方式的处理逻辑        }else if("POST".equals(method)){            // post方式的处理逻辑        }    }    public String getServletInfo() {        return null;    }    public void destroy() {    }}</code></pre><p>要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class MyHttpServlet implements Servlet {    public void init(ServletConfig config) throws ServletException {    }    public ServletConfig getServletConfig() {        return null;    }    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        HttpServletRequest request = (HttpServletRequest)req;        //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if("GET".equals(method)){            // get方式的处理逻辑            doGet(req,res);        }else if("POST".equals(method)){            // post方式的处理逻辑            doPost(req,res);        }    }    protected void doPost(ServletRequest req, ServletResponse res) {    }    protected void doGet(ServletRequest req, ServletResponse res) {    }    public String getServletInfo() {        return null;    }    public void destroy() {    }}</code></pre><p>有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo5")public class ServletDemo5 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {        System.out.println("post...");    }}</code></pre><p>将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。</p><p>类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索<code>service()</code>方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void service(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException    {        String method = req.getMethod();        if (method.equals(METHOD_GET)) {            long lastModified = getLastModified(req);            if (lastModified == -1) {                // servlet doesn't support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            } else {                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) {                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                } else {                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                }            }        } else if (method.equals(METHOD_HEAD)) {            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        } else if (method.equals(METHOD_POST)) {            doPost(req, resp);                    } else if (method.equals(METHOD_PUT)) {            doPut(req, resp);                    } else if (method.equals(METHOD_DELETE)) {            doDelete(req, resp);                    } else if (method.equals(METHOD_OPTIONS)) {            doOptions(req,resp);                    } else if (method.equals(METHOD_TRACE)) {            doTrace(req,resp);                    } else {            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString("http.method_not_implemented");            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);                        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        }    }</code></pre><p><strong>小结</strong></p><p>通过这一节的学习，要掌握:</p><ol><li>HttpServlet的使用步骤</li></ol><blockquote><p>继承HttpServlet</p><p>重写doGet和doPost方法</p></blockquote><ol start="2"><li>HttpServlet原理</li></ol><blockquote><p>获取请求方式，并根据不同的请求方式，调用不同的doXxx方法</p></blockquote><h3 id="4-7-urlPattern配置"><a href="#4-7-urlPattern配置" class="headerlink" title="4.7 urlPattern配置"></a>4.7 urlPattern配置</h3><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径（==urlPattern==）</p><ul><li><p>一个Servlet,可以配置多个urlPattern</p><p><img src="1627272805178.png" alt="1627272805178"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/*** urlPattern: 一个Servlet可以配置多个访问路径*/@WebServlet(urlPatterns = {"/demo7","/demo8"})public class ServletDemo7 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {                System.out.println("demo7 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>在浏览器上输入<code>http://localhost:8080/web-demo/demo7</code>,<code>http://localhost:8080/web-demo/demo8</code>这两个地址都能访问到ServletDemo7的doGet方法。</p></li><li><p>==urlPattern配置规则==</p><ul><li><p>精确匹配</p><p><img src="1627273174144.png" alt="1627273174144"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * UrlPattern: * * 精确匹配 */@WebServlet(urlPatterns = "/user/select")public class ServletDemo8 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo8 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>访问路径<code>http://localhost:8080/web-demo/user/select</code></p></li><li><p>目录匹配</p><p><img src="1627273184095.png" alt="1627273184095"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 目录匹配: /user/* */@WebServlet(urlPatterns = "/user/*")public class ServletDemo9 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo9 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>访问路径<code>http://localhost:8080/web-demo/user/任意</code></p><p>==思考:==</p><ol><li>访问路径<code>http://localhost:8080/web-demo/user</code>是否能访问到demo9的doGet方法?</li><li>访问路径<code>http://localhost:8080/web-demo/user/a/b</code>是否能访问到demo9的doGet方法?</li><li>访问路径<code>http://localhost:8080/web-demo/user/select</code>是否能访问到demo9还是demo8的doGet方法?</li></ol><p>答案是: 能、能、demo8，进而我们可以得到的结论是<code>/user/*</code>中的<code>/*</code>代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。</p></li><li><p>扩展名匹配</p><p><img src="1627273194118.png" alt="1627273194118"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 扩展名匹配: *.do */@WebServlet(urlPatterns = "*.do")public class ServletDemo10 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo10 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>访问路径<code>http://localhost:8080/web-demo/任意.do</code></p><p>==注意==:</p><ol><li>如果路径配置的不是扩展名，那么在路径的前面就必须要加<code>/</code>否则会报错</li></ol><p><img src="1627274483755.png" alt="1627274483755"></p><ol start="2"><li>如果路径配置的是<code>*.do</code>,那么在*.do的前面不能加<code>/</code>,否则会报错</li></ol><p><img src="1627274368245.png" alt="1627274368245"></p></li><li><p>任意匹配</p><p><img src="1627273201370.png" alt="1627273201370"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 任意匹配： / */@WebServlet(urlPatterns = "/")public class ServletDemo11 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo11 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>访问路径<code>http://localhost:8080/demo-web/任意</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/** * UrlPattern: * * 任意匹配： /* */@WebServlet(urlPatterns = "/*")public class ServletDemo12 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo12 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><p>访问路径`<a href="http://localhost:8080/demo-web/%E4%BB%BB%E6%84%8F">http://localhost:8080/demo-web/任意</a></p><p>==注意:==<code>/</code>和<code>/*</code>的区别?</p><ol><li><p>当我们的项目中的Servlet配置了 “/“,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet</p></li><li><p>当我们的项目中配置了”/*”,意味着匹配任意访问路径</p></li><li><p>DefaultServlet是用来处理静态资源，如果配置了”/“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问</p></li></ol></li></ul></li></ul><p><strong>小结</strong></p><ol><li><p>urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配</p></li><li><p>五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; /* &gt; / ,无需记，以最终运行结果为准。</p></li></ol><h3 id="4-8-XML配置"><a href="#4-8-XML配置" class="headerlink" title="4.8 XML配置"></a>4.8 XML配置</h3><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p><p>对于XML的配置步骤有两步:</p><ul><li>编写Servlet类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;public class ServletDemo13 extends MyHttpServlet {    @Override    protected void doGet(ServletRequest req, ServletResponse res) {        System.out.println("demo13 get...");    }    @Override    protected void doPost(ServletRequest req, ServletResponse res) {    }}</code></pre><ul><li>在web.xml中配置该Servlet</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"         version="4.0"&gt;                &lt;!--         Servlet 全类名    --&gt;    &lt;servlet&gt;        &lt;!-- servlet的名称，名字任意--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!--servlet的类全名--&gt;        &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;!--         Servlet 访问路径    --&gt;    &lt;servlet-mapping&gt;        &lt;!-- servlet的名称，要和上面的名称一致--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!-- servlet的访问路径--&gt;        &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。</p><h2 id="5-Request-Response"><a href="#5-Request-Response" class="headerlink" title="5. Request&amp;Response"></a>5. Request&amp;Response</h2><p><strong>今日目标</strong></p><blockquote><ul><li>掌握Request对象的概念与使用</li><li>掌握Response对象的概念与使用</li><li>能够完成用户登录注册案例的实现</li><li>能够完成SqlSessionFactory工具类的抽取</li></ul></blockquote><h3 id="1-Request和Response的概述"><a href="#1-Request和Response的概述" class="headerlink" title="1. Request和Response的概述"></a>1. Request和Response的概述</h3><p>==Request是请求对象，Response是响应对象。==这两个对象在我们使用Servlet的时候有看到：<img src="1628735216156.png" alt="1628735216156"></p><p>此时，我们就需要思考一个问题request和response这两个参数的作用是什么?</p><p><img src="1628735746602.png" alt="1628735746602"></p><ul><li>request:==获取==请求数据<ul><li>浏览器会发送HTTP请求到后台服务器[Tomcat]</li><li>HTTP的请求中会包含很多请求数据[请求行+请求头+请求体]</li><li>后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中</li><li>所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li></ul></li><li>response:==设置==响应数据<ul><li>业务处理完后，后台就需要给前端返回业务处理的结果即响应数据</li><li>把响应数据封装到response对象中</li><li>后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li></ul></li></ul><p>对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo3")public class ServletDemo3 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //使用request对象 获取请求数据        String name = request.getParameter("name");//url?name=zhangsan        //使用response对象 设置响应数据        response.setHeader("content-type","text/html;charset=utf-8");        response.getWriter().write("&lt;h1&gt;"+name+",欢迎您！&lt;/h1&gt;");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("Post...");    }}</code></pre><p>启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容:</p><p><img src="1628738273049.png" alt="1628738273049"></p><p><strong>小结</strong></p><p>在这节中，我们主要认识了下request对象和reponse对象:</p><ul><li>request对象是用来封装请求数据的对象</li><li>response对象是用来封装响应数据的对象</li></ul><p>目前我们只知道这两个对象是用来干什么的，那么它们具体是如何实现的，就需要我们继续深入的学习。接下来，就先从Request对象来学习,主要学习下面这些内容:</p><ul><li><p>request继承体系</p></li><li><p>request获取请求参数</p></li><li><p>request请求转发</p></li></ul><h3 id="2-Request对象"><a href="#2-Request对象" class="headerlink" title="2. Request对象"></a>2. Request对象</h3><h4 id="2-1-Request继承体系"><a href="#2-1-Request继承体系" class="headerlink" title="2.1 Request继承体系"></a>2.1 Request继承体系</h4><p>在学习这节内容之前，我们先思考一个问题，前面在介绍Request和Reponse对象的时候，比较细心的同学可能已经发现：</p><ul><li>当我们的Servlet类实现的是Servlet接口的时候，service方法中的参数是ServletRequest和ServletResponse</li><li>当我们的Servlet类继承的是HttpServlet类的时候，doGet和doPost方法中的参数就变成HttpServletRequest和HttpServletReponse</li></ul><p>那么，</p><ul><li>ServletRequest和HttpServletRequest的关系是什么?</li><li>request对象是有谁来创建的?</li><li>request提供了哪些API,这些API从哪里查?</li></ul><p>首先，我们先来看下Request的继承体系:</p><p><img src="1628740441008.png" alt="1628740441008"></p><p>从上图中可以看出，ServletRequest和HttpServletRequest都是Java提供的，所以我们可以打开JavaEE提供的API文档[参考: 资料/JavaEE7-api.chm],打开后可以看到:</p><p><img src="1628741839475.png" alt="1628741839475"></p><p>所以ServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象，这个时候就引发了下面这个问题:</p><p><img src="1628742224589.png" alt="1628742224589"></p><p>这个时候，我们就需要用到Request继承体系中的<code>RequestFacade</code>:</p><ul><li>该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。</li><li>Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建</li><li>要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法</li></ul><p>对于上述结论，要想验证，可以编写一个Servlet，在方法中把request对象打印下，就能看到最终的对象是不是RequestFacade,代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/demo2")public class ServletDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println(request);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }}</code></pre><p>启动服务器，运行访问<code>http://localhost:8080/request-demo/demo2</code>,得到运行结果:</p><p><img src="1628743040046.png" alt="1628743040046"></p><p><strong>小结</strong></p><ul><li>Request的继承体系为ServletRequest–&gt;HttpServletRequest–&gt;RequestFacade</li><li>Tomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法</li><li>使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明</li></ul><h4 id="2-2-Request获取请求数据"><a href="#2-2-Request获取请求数据" class="headerlink" title="2.2 Request获取请求数据"></a>2.2 Request获取请求数据</h4><p>HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取?</p><h5 id="2-2-1-获取请求行数据"><a href="#2-2-1-获取请求行数据" class="headerlink" title="2.2.1 获取请求行数据"></a>2.2.1 获取请求行数据</h5><p>请求行包含三块内容，分别是<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code></p><p><img src="1628748240075.png" alt="1628748240075"></p><p>对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:</p><ul><li>获取请求方式: <code>GET</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getMethod()</code></pre><ul><li>获取虚拟目录(项目访问路径): <code>/request-demo</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getContextPath()</code></pre><ul><li>获取URL(统一资源定位符): <code>http://localhost:8080/request-demo/req1</code></li></ul><pre class="line-numbers language-none"><code class="language-none">StringBuffer getRequestURL()</code></pre><ul><li>获取URI(统一资源标识符): <code>/request-demo/req1</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getRequestURI()</code></pre><ul><li>获取请求参数(GET方式): <code>username=zhangsan&amp;password=123</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getQueryString()</code></pre><p>介绍完上述方法后，咱们通过代码把上述方法都使用下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 获取请求数据 */@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // String getMethod()：获取请求方式： GET        String method = req.getMethod();        System.out.println(method);//GET        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo        String contextPath = req.getContextPath();        System.out.println(contextPath);        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1        StringBuffer url = req.getRequestURL();        System.out.println(url.toString());        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1        String uri = req.getRequestURI();        System.out.println(uri);        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan        String queryString = req.getQueryString();        System.out.println(queryString);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }}</code></pre><p>启动服务器，访问<code>http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123</code>，获取的结果如下:</p><p><img src="1628762794935.png" alt="1628762794935"></p><h5 id="2-2-2-获取请求头数据"><a href="#2-2-2-获取请求头数据" class="headerlink" title="2.2.2 获取请求头数据"></a>2.2.2 获取请求头数据</h5><p>对于请求头的数据，格式为<code>key: value</code>如下:</p><p><img src="1628768652535.png" alt="1628768652535"></p><p>所以根据请求头名称获取对应值的方法为:</p><pre class="line-numbers language-none"><code class="language-none">String getHeader(String name)</code></pre><p>接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 获取请求数据 */@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //获取请求头: user-agent: 浏览器的版本信息        String agent = req.getHeader("user-agent");System.out.println(agent);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }}</code></pre><p>重新启动服务器后，<code>http://localhost:8080/request-demo/req1?username=zhangsan&amp;passwrod=123</code>，获取的结果如下:</p><p><img src="1628769145524.png" alt="1628769145524"></p><h5 id="2-2-3-获取请求体数据"><a href="#2-2-3-获取请求体数据" class="headerlink" title="2.2.3 获取请求体数据"></a>2.2.3 获取请求体数据</h5><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:</p><p><img src="1628768665185.png" alt="1628768665185"></p><p>对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是:</p><ul><li>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</li></ul><pre class="line-numbers language-none"><code class="language-none">ServletInputStream getInputStream()该方法可以获取字节</code></pre><ul><li>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</li></ul><pre class="line-numbers language-none"><code class="language-none">BufferedReader getReader()</code></pre><p>接下来，大家需要思考，要想获取到请求体的内容该如何实现?</p><blockquote><p>具体实现的步骤如下:</p><p>1.准备一个页面，在页面中添加form表单,用来发送post请求</p><p>2.在Servlet的doPost方法中获取请求体数据</p><p>3.在doPost方法中使用request的getReader()或者getInputStream()来获取</p><p>4.访问测试</p></blockquote><ol><li>在项目的webapp目录下添加一个html页面，名称为：<code>req.html</code></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--     action:form表单提交的请求地址    method:请求方式，指定为post--&gt;&lt;form action="/request-demo/req1" method="post"&gt;    &lt;input type="text" name="username"&gt;    &lt;input type="password" name="password"&gt;    &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="2"><li>在Servlet的doPost方法中获取数据</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 获取请求数据 */@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //在此处获取请求体中的数据    }}</code></pre><ol start="3"><li>调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 获取请求数据 */@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         //获取post 请求体：请求参数        //1. 获取字符输入流        BufferedReader br = req.getReader();        //2. 读取数据        String line = br.readLine();        System.out.println(line);    }}</code></pre><p>==注意==</p><p>BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。</p><ol start="4"><li>启动服务器，通过浏览器访问<code>http://localhost:8080/request-demo/req.html</code></li></ol><p><img src="1628770516387.png" alt="1628770516387"></p><p>点击<code>提交</code>按钮后，就可以在控制台看到前端所发送的请求数据</p><p><img src="1628770585480.png" alt="1628770585480"></p><p><strong>小结</strong></p><p>HTTP请求数据中包含了<code>请求行</code>、<code>请求头</code>和<code>请求体</code>，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值:</p><ul><li>请求行<ul><li>getMethod()获取请求方式</li><li>getContextPath()获取项目访问路径</li><li>getRequestURL()获取请求URL</li><li>getRequestURI()获取请求URI</li><li>getQueryString()获取GET请求方式的请求参数</li></ul></li><li>请求头<ul><li>getHeader(String name)根据请求头名称获取其对应的值</li></ul></li><li>请求体<ul><li>注意: ==浏览器发送的POST请求才有请求体==</li><li>如果是纯文本数据:getReader()</li><li>如果是字节数据如文件数据:getInputStream()</li></ul></li></ul><h5 id="2-2-4-获取请求参数的通用方式"><a href="#2-2-4-获取请求参数的通用方式" class="headerlink" title="2.2.4 获取请求参数的通用方式"></a>2.2.4 获取请求参数的通用方式</h5><p>在学习下面内容之前，我们先提出两个问题:</p><ul><li>什么是请求参数?</li><li>请求参数和请求数据的关系是什么?</li></ul><p>1.什么是请求参数?</p><p>为了能更好的回答上述两个问题，我们拿用户登录的例子来说明</p><p>1.1 想要登录网址，需要进入登录页面</p><p>1.2 在登录页面输入用户名和密码</p><p>1.3 将用户名和密码提交到后台</p><p>1.4 后台校验用户名和密码是否正确</p><p>1.5 如果正确，则正常登录，如果不正确，则提示用户名或密码错误</p><p>上述例子中，用户名和密码其实就是我们所说的请求参数。</p><p>2.什么是请求数据?</p><p>请求数据则是包含请求行、请求头和请求体的所有数据</p><p>3.请求参数和请求数据的关系是什么?</p><p>3.1 请求参数是请求数据中的部分内容</p><p>3.2 如果是GET请求，请求参数在请求行中</p><p>3.3 如果是POST请求，请求参数一般在请求体中</p><p>对于请求参数的获取,常用的有以下两种:</p><ul><li>GET方式:</li></ul><pre class="line-numbers language-none"><code class="language-none">String getQueryString()</code></pre><ul><li>POST方式:</li></ul><pre class="line-numbers language-none"><code class="language-none">BufferedReader getReader();</code></pre><p>有了上述的知识储备，我们来实现一个案例需求:</p><p>（1）发送一个GET请求并携带用户名，后台接收后打印到控制台</p><p>（2）发送一个POST请求并携带用户名，后台接收后打印到控制台</p><p>此处大家需要注意的是GET请求和POST请求接收参数的方式不一样，具体实现的代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String result = req.getQueryString();        System.out.println(result);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        BufferedReader br = req.getReader();        String result = br.readLine();        System.out.println(result);    }}</code></pre><ul><li>对于上述的代码，会存在什么问题呢?</li></ul><p><img src="1628776252445.png" alt="1628776252445"></p><ul><li>如何解决上述重复代码的问题呢?</li></ul><p><img src="1628776433318.png" alt="1628776433318"></p><p>当然，也可以在doGet中调用doPost,在doPost中完成参数的获取和打印,另外需要注意的是，doGet和doPost方法都必须存在，不能删除任意一个。</p><p>==GET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢?==</p><p>要想实现，我们就需要==思考==:</p><p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种==统一==获取请求参数的方式，从而==统一==doGet和doPost方法内的代码?</p><p>解决方案一:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/req1")public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //获取请求方式        String method = req.getMethod();        //获取请求参数        String params = "";        if("GET".equals(method)){            params = req.getQueryString();        }else if("POST".equals(method)){            BufferedReader reader = req.getReader();            params = reader.readLine();        }        //将请求参数进行打印控制台        System.out.println(params);          }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req,resp);    }}</code></pre><p>使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用</p><p>解决方案二:</p><p>request对象已经将上述获取请求参数的方法进行了封装，并且request提供的方法实现的功能更强大，以后只需要调用request提供的方法即可，在request的方法中都实现了哪些操作?</p><p>(1)根据不同的请求方式获取请求参数，获取的内容如下:</p><p><img src="1628778931277.png" alt="1628778931277"></p><p>(2)把获取到的内容进行分割，内容如下:</p><p><img src="1628779067793.png" alt="1628779067793"></p><p>(3)把分割后端数据，存入到一个Map集合中:</p><p><img src="1628779368501.png" alt="1628779368501"></p><p><strong>注意</strong>:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。</p><p>基于上述理论，request对象为我们提供了如下方法:</p><ul><li>获取所有参数Map集合</li></ul><pre class="line-numbers language-none"><code class="language-none">Map&lt;String,String[]&gt; getParameterMap()</code></pre><ul><li>根据名称获取参数值（数组）</li></ul><pre class="line-numbers language-none"><code class="language-none">String[] getParameterValues(String name)</code></pre><ul><li>根据名称获取参数值(单个值)</li></ul><pre class="line-numbers language-none"><code class="language-none">String getParameter(String name)</code></pre><p>接下来，我们通过案例来把上述的三个方法进行实例演示:</p><p>1.修改req.html页面，添加爱好选项，爱好可以同时选多个</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/request-demo/req2" method="get"&gt;    &lt;input type="text" name="username"&gt;&lt;br&gt;    &lt;input type="password" name="password"&gt;&lt;br&gt;    &lt;input type="checkbox" name="hobby" value="1"&gt; 游泳    &lt;input type="checkbox" name="hobby" value="2"&gt; 爬山 &lt;br&gt;    &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="1628780937599.png" alt="1628780937599"></p><p>2.在Servlet代码中获取页面传递GET请求的参数值</p><p> 2.1获取GET方式的所有请求参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 通用方式获取请求参数 */@WebServlet("/req2")public class RequestDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //GET请求逻辑        System.out.println("get....");        //1. 获取所有参数的Map集合        Map&lt;String, String[]&gt; map = req.getParameterMap();        for (String key : map.keySet()) {            // username:zhangsan lisi            System.out.print(key+":");            //获取值            String[] values = map.get(key);            for (String value : values) {                System.out.print(value + " ");            }            System.out.println();        }    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }}</code></pre><p>获取的结果为:</p><p><img src="1628780965283.png" alt="1628780965283"></p><p> 2.2获取GET请求参数中的爱好，结果是数组值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 通用方式获取请求参数 */@WebServlet("/req2")public class RequestDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //GET请求逻辑        //...        System.out.println("------------");        String[] hobbies = req.getParameterValues("hobby");        for (String hobby : hobbies) {            System.out.println(hobby);        }    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }}</code></pre><p>获取的结果为:</p><p><img src="1628781031437.png" alt="1628781031437"></p><p> 2.3获取GET请求参数中的用户名和密码，结果是单个值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * request 通用方式获取请求参数 */@WebServlet("/req2")public class RequestDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //GET请求逻辑        //...        String username = req.getParameter("username");        String password = req.getParameter("password");        System.out.println(username);        System.out.println(password);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    }}</code></pre><p>获取的结果为:</p><p><img src="1628781176434.png" alt="1628781176434"></p><p>3.在Servlet代码中获取页面传递POST请求的参数值</p><p> 3.1将req.html页面form表单的提交方式改成post</p><p> 3.2将doGet方法中的内容复制到doPost方法中即可</p><p><strong>小结</strong></p><ul><li><p>req.getParameter()方法使用的频率会比较高</p></li><li><p>以后我们再写代码的时候，就只需要按照如下格式来编写:</p></li></ul><pre class="line-numbers language-none"><code class="language-none">public class RequestDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {       //采用request提供的获取请求参数的通用方式来获取请求参数       //编写其他的业务代码...    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req,resp);    }}</code></pre><h4 id="2-3-IDEA快速创建Servlet"><a href="#2-3-IDEA快速创建Servlet" class="headerlink" title="2.3 IDEA快速创建Servlet"></a>2.3 IDEA快速创建Servlet</h4><p>使用通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同，则代码可以定义如下格式:</p><p><img src="1628781419752.png" alt="1628781419752"></p><p>由于格式固定，所以我们可以使用IDEA提供的模板来制作一个Servlet的模板，这样我们后期在创建Servlet的时候就会更高效，具体如何实现:</p><p>(1)按照自己的需求，修改Servlet创建的模板内容</p><p><img src="1628781545912.png" alt="1628781545912"></p><p>（2）使用servlet模板创建Servlet类</p><p><img src="1628782117420.png" alt="1628782117420"></p><h4 id="2-4-请求参数中文乱码问题"><a href="#2-4-请求参数中文乱码问题" class="headerlink" title="2.4 请求参数中文乱码问题"></a>2.4 请求参数中文乱码问题</h4><p>问题展示:</p><p>(1)将req.html页面的请求方式修改为get</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/request-demo/req2" method="get"&gt;    &lt;input type="text" name="username"&gt;&lt;br&gt;    &lt;input type="password" name="password"&gt;&lt;br&gt;    &lt;input type="checkbox" name="hobby" value="1"&gt; 游泳    &lt;input type="checkbox" name="hobby" value="2"&gt; 爬山 &lt;br&gt;    &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(2)在Servlet方法中获取参数，并打印</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 中文乱码问题解决方案 */@WebServlet("/req4")public class RequestDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {       //1. 获取username       String username = request.getParameter("username");       System.out.println(username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>（3）启动服务器，页面上输入中文参数</p><p><img src="1628784323297.png" alt="1628784323297"></p><p>（4）查看控制台打印内容</p><p><img src="1628784356157.png" alt="1628784356157"></p><p>（5）把req.html页面的请求方式改成post,再次发送请求和中文参数</p><p><img src="1628784425182.png" alt="1628784425182"></p><p>（6）查看控制台打印内容，依然为乱码</p><p><img src="1628784356157.png" alt="1628784356157"></p><p>通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？</p><h5 id="2-4-1-POST请求解决方案"><a href="#2-4-1-POST请求解决方案" class="headerlink" title="2.4.1 POST请求解决方案"></a>2.4.1 POST请求解决方案</h5><ul><li>分析出现中文乱码的原因：<ul><li>POST的请求参数是通过request的getReader()来获取流中的数据</li><li>TOMCAT在获取流的时候采用的编码是ISO-8859-1</li><li>ISO-8859-1编码是不支持中文的，所以会出现乱码</li></ul></li><li>解决方案：<ul><li>页面设置的编码格式为UTF-8</li><li>把TOMCAT在获取流数据之前的编码设置为UTF-8</li><li>通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写</li></ul></li></ul><p>修改后的代码为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 中文乱码问题解决方案 */@WebServlet("/req4")public class RequestDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 解决乱码: POST getReader()        //设置字符输入流的编码，设置的字符集要和页面保持一致        request.setCharacterEncoding("UTF-8");       //2. 获取username       String username = request.getParameter("username");       System.out.println(username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>重新发送POST请求，就会在控制台看到正常展示的中文结果。</p><p>至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。</p><h5 id="2-4-2-GET请求解决方案"><a href="#2-4-2-GET请求解决方案" class="headerlink" title="2.4.2 GET请求解决方案"></a>2.4.2 GET请求解决方案</h5><p>刚才提到一个问题是<code>POST请求的中文乱码解决方案为什么不适用GET请求？</code></p><ul><li>GET请求获取请求参数的方式是<code>request.getQueryString()</code></li><li>POST请求获取请求参数的方式是<code>request.getReader()</code></li><li>request.setCharacterEncoding(“utf-8”)是设置request处理流的编码</li><li>getQueryString方法并没有通过流的方式获取数据</li></ul><p>所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? </p><ol><li>首先我们需要先分析下GET请求出现乱码的原因:</li></ol><p> <img src="1628829610823.png" alt="1628829610823"></p><p>(1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat)</p><p>(2)浏览器在发送HTTP的过程中会对中文数据进行URL==编码==</p><p>(3)在进行URL编码的时候会采用页面<code>&lt;meta&gt;</code>标签指定的UTF-8的方式进行编码，<code>张三</code>编码后的结果为<code>%E5%BC%A0%E4%B8%89</code></p><p>(4)后台服务器(Tomcat)接收到<code>%E5%BC%A0%E4%B8%89</code>后会默认按照<code>ISO-8859-1</code>进行URL==解码==</p><p>(5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。</p><p>思考: 如果把<code>req.html</code>页面的<code>&lt;meta&gt;</code>标签的charset属性改成<code>ISO-8859-1</code>,后台不做操作，能解决中文乱码问题么?</p><p>答案是否定的，因为<code>ISO-8859-1</code>本身是不支持中文展示的，所以改了<meta>标签的charset属性后，会导致页面上的中文内容都无法正常展示。</p><p>分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是==URL编码==和==URL解码==，什么是URL编码，什么又是URL解码呢?</p><p><strong>URL编码</strong></p><p>这块知识我们只需要了解下即可,具体编码过程分两步，分别是:</p><p>(1)将字符串按照编码方式转为二进制</p><p>(2)每个字节转为2个16进制数并在前边加上%</p><p><code>张三</code>按照UTF-8的方式转换成二进制的结果为:</p><pre class="line-numbers language-none"><code class="language-none">1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001</code></pre><p>这个结果是如何计算的?</p><p>使用<code>http://www.mytju.com/classcode/tools/encode_utf8.asp</code>，输入<code>张三</code></p><p><img src="1628833310473.png" alt="1628833310473"></p><p>就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果:</p><p><img src="1628833496171.png" alt="1628833496171"></p><p>在计算的十六进制结果中，每两位前面加一个%,就可以获取到<code>%E5%BC%A0%E4%B8%89</code>。</p><p>当然你从上面所提供的网站中就已经能看到编码16进制的结果了:</p><p><img src="1628833310474.png" alt="1628833310473"></p><p>但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码:</p><p>编码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java.net.URLEncoder.encode("需要被编码的内容","字符集(UTF-8)")</code></pre><p>解码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java.net.URLDecoder.decode("需要被解码的内容","字符集(UTF-8)")</code></pre><p>接下来咱们对<code>张三</code>来进行编码和解码</p><pre class="line-numbers language-none"><code class="language-none">public class URLDemo {  public static void main(String[] args) throws UnsupportedEncodingException {        String username = "张三";        //1. URL编码        String encode = URLEncoder.encode(username, "utf-8");        System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89       //2. URL解码       //String decode = URLDecoder.decode(encode, "utf-8");//打印:张三       String decode = URLDecoder.decode(encode, "ISO-8859-1");//打印:`å¼&nbsp;ä¸ `       System.out.println(decode);    }}</code></pre><p>到这，我们就可以分析出GET请求中文参数出现乱码的原因了，</p><ul><li>浏览器把中文参数按照<code>UTF-8</code>进行URL编码</li><li>Tomcat对获取到的内容进行了<code>ISO-8859-1</code>的URL解码</li><li>在控制台就会出现类上<code>å¼ ä¸</code>的乱码，最后一位是个空格</li></ul><ol start="2"><li>清楚了出现乱码的原因，接下来我们就需要想办法进行解决</li></ol><p><img src="1628846824194.png" alt="1628846824194"></p><p>从上图可以看住，</p><ul><li><p>在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的<code>%E5%BC%A0%E4%B8%89</code>是一致的</p></li><li><p>那他们对应的二进制值也是一样的，为:</p><ul><li><pre><code>1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001<pre class="line-numbers language-none"><code class="language-none">* 为所以我们可以考虑把`å¼ ä¸`转换成字节，在把字节转换成`张三`，在转换的过程中是它们的编码一致，就可以解决中文乱码问题。具体的实现步骤为:&gt;1.按照ISO-8859-1编码获取乱码`å¼ ä¸`对应的字节数组&gt;&gt;2.按照UTF-8编码获取字节数组对应的字符串实现代码如下:</code></pre></code></pre></li></ul></li></ul><p>public class URLDemo {</p><p>  public static void main(String[] args) throws UnsupportedEncodingException {<br>        String username = “张三”;<br>        //1. URL编码<br>        String encode = URLEncoder.encode(username, “utf-8”);<br>        System.out.println(encode);<br>        //2. URL解码<br>        String decode = URLDecoder.decode(encode, “ISO-8859-1”);</p><pre><code>    System.out.println(decode); //此处打印的是对应的乱码数据    //3. 转换为字节数据,编码    byte[] bytes = decode.getBytes("ISO-8859-1");    for (byte b : bytes) {        System.out.print(b + " ");    }    //此处打印的是:-27 -68 -96 -28 -72 -119    //4. 将字节数组转为字符串，解码    String s = new String(bytes, "utf-8");    System.out.println(s); //此处打印的是张三}</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">**说明**:在第18行中打印的数据是`-27 -68 -96 -28 -72 -119`和`张三`转换成的二进制数据`1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001`为什么不一样呢？其实打印出来的是十进制数据，我们只需要使用计算机换算下就能得到他们的对应关系，如下图:![1628849231208](HTTP-Tomcat-Servlet/1628849231208.png)至此对于GET请求中文乱码的解决方案，我们就已经分析完了，最后在代码中去实现下:```java/** * 中文乱码问题解决方案 */@WebServlet("/req4")public class RequestDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 解决乱码：POST，getReader()        //request.setCharacterEncoding("UTF-8");//设置字符输入流的编码        //2. 获取username        String username = request.getParameter("username");        System.out.println("解决乱码前："+username);        //3. GET,获取参数的方式：getQueryString        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1       /* //3.1 先对乱码数据进行编码：转为字节数组        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);        //3.2 字节数组解码        username = new String(bytes, StandardCharsets.UTF_8);*/        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);        System.out.println("解决乱码后："+username);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p><strong>注意</strong></p><ul><li>把<code>request.setCharacterEncoding("UTF-8")</code>代码注释掉后，会发现GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了</li><li>只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。</li></ul><p>另外需要说明一点的是==Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8==</p><p><strong>小结</strong></p><ol><li>中文乱码解决方案</li></ol><ul><li><p>POST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题</p><p>GET请求在Tomcat8.0以后的版本就不会出现了</p></li><li><p>POST请求解决方案是:设置输入流的编码</p><pre class="line-numbers language-none"><code class="language-none">request.setCharacterEncoding("UTF-8");注意:设置的字符集要和页面保持一致</code></pre></li><li><p>通用方式（GET/POST）：需要先解码，再编码</p><pre class="line-numbers language-none"><code class="language-none">new String(username.getBytes("ISO-8859-1"),"UTF-8");</code></pre></li></ul><ol start="2"><li>URL编码实现方式:</li></ol><ul><li><p>编码:</p><pre class="line-numbers language-none"><code class="language-none">URLEncoder.encode(str,"UTF-8");</code></pre></li><li><p>解码:</p><pre class="line-numbers language-none"><code class="language-none">URLDecoder.decode(s,"ISO-8859-1");</code></pre></li></ul><h4 id="2-5-Request请求转发"><a href="#2-5-Request请求转发" class="headerlink" title="2.5 Request请求转发"></a>2.5 Request请求转发</h4><ol><li>==请求转发(forward):一种在服务器内部的资源跳转方式。==</li></ol><p><img src="1628851404283.png" alt="1628851404283"></p><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p><p>(2)资源A处理完请求后将请求发给资源B</p><p>(3)资源B处理完后将结果响应给浏览器</p><p>(4)请求从资源A到资源B的过程就叫==请求转发==</p><ol start="2"><li>请求转发的实现方式:</li></ol><pre class="line-numbers language-none"><code class="language-none">req.getRequestDispatcher("资源B路径").forward(req,resp);</code></pre><p>具体如何来使用，我们先来看下需求:</p><p><img src="1628854783523.png" alt="1628854783523"></p><p>针对上述需求，具体的实现步骤为:</p><blockquote><p>1.创建一个RequestDemo5类，接收/req5的请求，在doGet方法中打印<code>demo5</code></p><p>2.创建一个RequestDemo6类，接收/req6的请求，在doGet方法中打印<code>demo6</code></p><p>3.在RequestDemo5的方法中使用</p><p>​req.getRequestDispatcher(“/req6”).forward(req,resp)进行请求转发</p><p>4.启动测试</p></blockquote><p>(1)创建RequestDemo5类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 请求转发 */@WebServlet("/req5")public class RequestDemo5 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("demo5...");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)创建RequestDemo6类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 请求转发 */@WebServlet("/req6")public class RequestDemo6 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("demo6...");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)在RequestDemo5的doGet方法中进行请求转发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 请求转发 */@WebServlet("/req5")public class RequestDemo5 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("demo5...");        //请求转发        request.getRequestDispatcher("/req6").forward(request,response);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(4)启动测试</p><p>访问<code>http://localhost:8080/request-demo/req5</code>,就可以在控制台看到如下内容:</p><p><img src="1628855192876.png" alt="1628855192876"></p><p>说明请求已经转发到了<code>/req6</code></p><ol start="3"><li>请求转发资源间共享数据:使用Request对象</li></ol><p>此处主要解决的问题是把请求从<code>/req5</code>转发到<code>/req6</code>的时候，如何传递数据给<code>/req6</code>。</p><p>需要使用request对象提供的三个方法:</p><ul><li>存储数据到request域[范围,数据是存储在request对象]中</li></ul><pre class="line-numbers language-none"><code class="language-none">void setAttribute(String name,Object o);</code></pre><ul><li>根据key获取值</li></ul><pre class="line-numbers language-none"><code class="language-none">Object getAttribute(String name);</code></pre><ul><li>根据key删除该键值对</li></ul><pre class="line-numbers language-none"><code class="language-none">void removeAttribute(String name);</code></pre><p>接着上个需求来:</p><p><img src="1628856995417.png" alt="1628856995417"></p><blockquote><p>1.在RequestDemo5的doGet方法中转发请求之前，将数据存入request域对象中</p><p>2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台</p><p>3.启动访问测试</p></blockquote><p>(1)修改RequestDemo5中的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/req5")public class RequestDemo5 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("demo5...");        //存储数据        request.setAttribute("msg","hello");        //请求转发        request.getRequestDispatcher("/req6").forward(request,response);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)修改RequestDemo6中的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 请求转发 */@WebServlet("/req6")public class RequestDemo6 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("demo6...");        //获取数据        Object msg = request.getAttribute("msg");        System.out.println(msg);    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)启动测试</p><p>访问<code>http://localhost:8080/request-demo/req5</code>,就可以在控制台看到如下内容:</p><p><img src="1628857213364.png" alt="1628857213364"></p><p>此时就可以实现在转发多个资源之间共享数据。</p><ol start="4"><li>请求转发的特点</li></ol><ul><li><p>浏览器地址栏路径不发生变化</p><p>虽然后台从<code>/req5</code>转发到<code>/req6</code>,但是浏览器的地址一直是<code>/req5</code>,未发生变化</p><p><img src="1628857365153.png" alt="1628857365153"></p></li><li><p>只能转发到当前服务器的内部资源</p><p>不能从一个服务器通过转发访问另一台服务器</p></li><li><p>一次请求，可以在转发资源间使用request共享数据</p><p>虽然后台从<code>/req5</code>转发到<code>/req6</code>，但是这个==只有一次请求==</p></li></ul><h3 id="3-Response对象"><a href="#3-Response对象" class="headerlink" title="3. Response对象"></a>3. Response对象</h3><p>前面讲解完Request对象，接下来我们回到刚开始的那张图:</p><p><img src="1628857632899.png" alt="1628857632899"></p><ul><li>Request:使用request对象来==获取==请求数据</li><li>Response:使用response对象来==设置==响应数据</li></ul><p>Reponse的继承体系和Request的继承体系也非常相似:</p><p><img src="1628857761317.png" alt="1628857761317"></p><p> 介绍完Response的相关体系结构后，接下来对于Response我们需要学习如下内容:</p><ul><li>Response设置响应数据的功能介绍</li><li>Response完成重定向</li><li>Response响应字符数据</li><li>Response响应字节数据</li></ul><h4 id="3-1-Response设置响应数据功能介绍"><a href="#3-1-Response设置响应数据功能介绍" class="headerlink" title="3.1 Response设置响应数据功能介绍"></a>3.1 Response设置响应数据功能介绍</h4><p>HTTP响应数据总共分为三部分内容，分别是==响应行、响应头、响应体==，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置?</p><ol><li>响应行</li></ol><p><img src="1628858926498.png" alt="1628858926498"></p><p>对于响应头，比较常用的就是设置响应状态码:</p><pre class="line-numbers language-none"><code class="language-none">void setStatus(int sc);</code></pre><ol start="2"><li>响应头</li></ol><p><img src="1628859051368.png" alt="1628859051368"></p><p>设置响应头键值对：</p><pre class="line-numbers language-none"><code class="language-none">void setHeader(String name,String value);</code></pre><ol start="3"><li>响应体</li></ol><p><img src="1628859268095.png" alt="1628859268095"></p><p>对于响应体，是通过字符、字节输出流的方式往浏览器写，</p><p>获取字符输出流:</p><pre class="line-numbers language-none"><code class="language-none">PrintWriter getWriter();</code></pre><p>获取字节输出流</p><pre class="line-numbers language-none"><code class="language-none">ServletOutputStream getOutputStream();</code></pre><p>介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。</p><h4 id="3-2-Response请求重定向"><a href="#3-2-Response请求重定向" class="headerlink" title="3.2 Response请求重定向"></a>3.2 Response请求重定向</h4><ol><li>==Response重定向(redirect):一种资源跳转方式。==</li></ol><p><img src="1628859860279.png" alt="1628859860279"></p><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p><p>(2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径</p><p>(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B</p><p>(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫==重定向==</p><ol start="2"><li>重定向的实现方式:</li></ol><pre class="line-numbers language-none"><code class="language-none">resp.setStatus(302);resp.setHeader("location","资源B的访问路径");</code></pre><p>具体如何来使用，我们先来看下需求:</p><p><img src="1628861030429.png" alt="1628861030429"></p><p>针对上述需求，具体的实现步骤为:</p><blockquote><p>1.创建一个ResponseDemo1类，接收/resp1的请求，在doGet方法中打印<code>resp1....</code></p><p>2.创建一个ResponseDemo2类，接收/resp2的请求，在doGet方法中打印<code>resp2....</code></p><p>3.在ResponseDemo1的方法中使用</p><p>​response.setStatus(302);</p><p>​response.setHeader(“Location”,”/request-demo/resp2”) 来给前端响应结果数据</p><p>4.启动测试</p></blockquote><p>(1)创建ResponseDemo1类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/resp1")public class ResponseDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("resp1....");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(2)创建ResponseDemo2类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/resp2")public class ResponseDemo2 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("resp2....");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(3)在ResponseDemo1的doGet方法中给前端响应数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/resp1")public class ResponseDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("resp1....");        //重定向        //1.设置响应状态码 302        response.setStatus(302);        //2. 设置响应头 Location        response.setHeader("Location","/request-demo/resp2");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>(4)启动测试</p><p>访问<code>http://localhost:8080/request-demo/resp1</code>,就可以在控制台看到如下内容:</p><p><img src="1628861404699.png" alt="1628861404699"></p><p>说明<code>/resp1</code>和<code>/resp2</code>都被访问到了。到这重定向就已经完成了。</p><p>虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为:</p><pre class="line-numbers language-none"><code class="language-none">resposne.sendRedirect("/request-demo/resp2")</code></pre><p>所以第3步中的代码就可以简化为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/resp1")public class ResponseDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("resp1....");        //重定向        resposne.sendRedirect("/request-demo/resp2")；    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><ol start="3"><li>重定向的特点</li></ol><ul><li><p>浏览器地址栏路径发送变化</p><p>当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化</p><p><img src="1628861893130.png" alt="1628861893130"></p></li><li><p>可以重定向到任何位置的资源(服务内容、外部均可)</p><p>因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p></li><li><p>两次请求，不能在多个资源使用request共享数据</p><p>因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据</p></li></ul><p>介绍完==请求重定向==和==请求转发==以后，接下来需要把这两个放在一块对比下:</p><p><img src="1628862170296.png" alt="1628862170296"></p><p>以后到底用哪个，还是需要根据具体的业务来决定。</p><h4 id="3-3-路径问题"><a href="#3-3-路径问题" class="headerlink" title="3.3 路径问题"></a>3.3 路径问题</h4><ol><li>问题1：转发的时候路径上没有加<code>/request-demo</code>而重定向加了，那么到底什么时候需要加，什么时候不需要加呢?</li></ol><p><img src="1628862652700.png" alt="1628862652700"></p><p>其实判断的依据很简单，只需要记住下面的规则即可:</p><ul><li>浏览器使用:需要加虚拟目录(项目访问路径)</li><li>服务端使用:不需要加虚拟目录</li></ul><p>对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录</p><p>对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p><p>掌握了这个规则，接下来就通过一些练习来强化下知识的学习:</p><ul><li><code>&lt;a href='路劲'&gt;</code></li><li><code>&lt;form action='路径'&gt;</code></li><li>req.getRequestDispatcher(“路径”)</li><li>resp.sendRedirect(“路径”)</li></ul><p>答案:</p><pre class="line-numbers language-none"><code class="language-none">1.超链接，从浏览器发送，需要加2.表单，从浏览器发送，需要加3.转发，是从服务器内部跳转，不需要加4.重定向，是由浏览器进行跳转，需要加。</code></pre><ol start="2"><li>问题2：在重定向的代码中，<code>/request-demo</code>是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?</li></ol><p><img src="1628863270545.png" alt="1628863270545"></p><p>答案也比较简单，我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/resp1")public class ResponseDemo1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println("resp1....");        //简化方式完成重定向        //动态获取虚拟目录        String contextPath = request.getContextPath();        response.sendRedirect(contextPath+"/resp2");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p>重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。</p><h4 id="3-4-Response响应字符数据"><a href="#3-4-Response响应字符数据" class="headerlink" title="3.4 Response响应字符数据"></a>3.4 Response响应字符数据</h4><p>要想将字符数据写回到浏览器，我们需要两个步骤:</p><ul><li><p>通过Response对象获取字符输出流： PrintWriter writer = resp.getWriter();</p></li><li><p>通过字符输出流写数据: writer.write(“aaa”);</p></li></ul><p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p><ol><li>返回一个简单的字符串<code>aaa</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 响应字符数据：设置字符数据的响应体 */@WebServlet("/resp3")public class ResponseDemo3 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.setContentType("text/html;charset=utf-8");        //1. 获取字符输出流        PrintWriter writer = response.getWriter(); writer.write("aaa");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p><img src="1628863905362.png" alt="1628863905362"></p><ol start="2"><li>返回一串html字符串，并且能被浏览器解析</li></ol><pre class="line-numbers language-none"><code class="language-none">PrintWriter writer = response.getWriter();//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签response.setHeader("content-type","text/html");writer.write("&lt;h1&gt;aaa&lt;/h1&gt;");</code></pre><p><img src="1628864140820.png" alt="1628864140820"></p><p>==注意:==一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。</p><ol start="3"><li>返回一个中文的字符串<code>你好</code>，需要注意设置响应数据的编码为<code>utf-8</code></li></ol><pre class="line-numbers language-none"><code class="language-none">//设置响应的数据格式及数据的编码response.setContentType("text/html;charset=utf-8");writer.write("你好");</code></pre><p><img src="1628864390263.png" alt="1628864390263"></p><h4 id="3-5-Response响应字节数据"><a href="#3-5-Response响应字节数据" class="headerlink" title="3.5 Response响应字节数据"></a>3.5 Response响应字节数据</h4><p>要想将字节数据写回到浏览器，我们需要两个步骤:</p><ul><li><p>通过Response对象获取字节输出流：ServletOutputStream outputStream = resp.getOutputStream();</p></li><li><p>通过字节输出流写数据: outputStream.write(字节数据);</p></li></ul><p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p><ol><li>返回一个图片文件到浏览器</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet("/resp4")public class ResponseDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 读取文件        FileInputStream fis = new FileInputStream("d://a.jpg");        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy        byte[] buff = new byte[1024];        int len = 0;        while ((len = fis.read(buff))!= -1){            os.write(buff,0,len);        }        fis.close();    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><p><img src="1628864883564.png" alt="1628864883564"></p><p>上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是:</p><p>(1)pom.xml添加依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>(2)调用工具类方法</p><pre class="line-numbers language-none"><code class="language-none">//fis:输入流//os:输出流IOUtils.copy(fis,os);</code></pre><p>优化后的代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet("/resp4")public class ResponseDemo4 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 读取文件        FileInputStream fis = new FileInputStream("d://a.jpg");        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy      IOUtils.copy(fis,os);        fis.close();    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><h3 id="4-用户注册登录案例"><a href="#4-用户注册登录案例" class="headerlink" title="4. 用户注册登录案例"></a>4. 用户注册登录案例</h3><p>接下来我们通过两个比较常见的案例，一个是==注册==，一个是==登录==来对今天学习的内容进行一个实战演练，首先来实现用户登录。</p><h4 id="4-1-用户登录"><a href="#4-1-用户登录" class="headerlink" title="4.1 用户登录"></a>4.1 用户登录</h4><h5 id="4-1-1-需求分析"><a href="#4-1-1-需求分析" class="headerlink" title="4.1.1 需求分析"></a>4.1.1 需求分析</h5><p><img src="1628865728305.png" alt="1628865728305"></p><ol><li>用户在登录页面输入用户名和密码，提交请求给LoginServlet</li><li>在LoginServlet中接收请求和数据[用户名和密码]</li><li>在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表</li><li>将查询的结果封装到User对象中进行返回</li><li>在LoginServlet中判断返回的User对象是否为null</li><li>如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回”登录失败”数据给前端</li><li>如果不为null,则说明用户存在并且密码正确，则登录成功，返回”登录成功”数据给前端</li></ol><h5 id="4-1-2-环境准备"><a href="#4-1-2-环境准备" class="headerlink" title="4.1.2 环境准备"></a>4.1.2 环境准备</h5><ol><li>复制资料中的静态页面到项目的webapp目录下</li></ol><p>参考<code>资料\1. 登陆注册案例\1. 静态页面</code>,拷贝完效果如下:</p><p><img src="1628866248169.png" alt="1628866248169"></p><ol start="2"><li>创建db1数据库，创建tb_user表，创建User实体类</li></ol><p>2.1 将<code>资料\1. 登陆注册案例\2. MyBatis环境\tb_user.sql</code>中的sql语句执行下:</p><p><img src="1628866403891.png" alt="1628866403891"></p><p> 2.2 将<code>资料\1. 登陆注册案例\2. MyBatis环境\User.java</code>拷贝到com.itheima.pojo</p><p><img src="1628866560738.png" alt="1628866560738"></p><ol start="3"><li>在项目的pom.xml导入Mybatis和Mysql驱动坐标</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.34&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="4"><li>创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口</li></ol><p>4.1  将<code>资料\1. 登陆注册案例\2. MyBatis环境\mybatis-config.xml</code>拷贝到resources目录下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!--起别名--&gt;    &lt;typeAliases&gt;        &lt;package name="com.itheima.pojo"/&gt;    &lt;/typeAliases&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;                &lt;!--                    useSSL:关闭SSL安全连接 性能更高                    useServerPrepStmts:开启预编译功能                    &amp; 等同于 &amp; ,xml配置文件中不能直接写 &amp;符号                --&gt;                &lt;property name="url" value="jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="1234"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!--扫描mapper--&gt;        &lt;package name="com.itheima.mapper"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>4.2 在com.itheima.mapper包下创建UserMapper接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserMapper {}</code></pre><p>4.3 将<code>资料\1. 登陆注册案例\2. MyBatis环境\UserMapper.xml</code>拷贝到resources目录下</p><p>==注意：在resources下创建UserMapper.xml的目录时，要使用/分割==</p><p><img src="1628867237329.png" alt="1628867237329"></p><p>至此我们所需要的环境就都已经准备好了，具体该如何实现?</p><h5 id="4-1-3-代码实现"><a href="#4-1-3-代码实现" class="headerlink" title="4.1.3 代码实现"></a>4.1.3 代码实现</h5><ol><li>在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * 根据用户名和密码查询用户对象     * @param username     * @param password     * @return     */    @Select("select * from tb_user where username = #{username} and password = #{password}")    User select(@Param("username") String username,@Param("password")  String password);</code></pre><p><strong>说明</strong></p><p>@Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。</p><ol start="2"><li>修改loign.html</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;login&lt;/title&gt;    &lt;link href="css/login.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="loginDiv"&gt;    &lt;form action="/request-demo/loginServlet" method="post" id="form"&gt;        &lt;h1 id="loginMsg"&gt;LOGIN IN&lt;/h1&gt;        &lt;p&gt;Username:&lt;input id="username" name="username" type="text"&gt;&lt;/p&gt;        &lt;p&gt;Password:&lt;input id="password" name="password" type="password"&gt;&lt;/p&gt;        &lt;div id="subDiv"&gt;            &lt;input type="submit" class="button" value="login up"&gt;            &lt;input type="reset" class="button" value="reset"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;            &lt;a href="register.html"&gt;没有账号？点击注册&lt;/a&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="3"><li>编写LoginServlet</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/loginServlet")public class LoginServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 接收用户名和密码        String username = request.getParameter("username");        String password = request.getParameter("password");        //2. 调用MyBatis完成查询        //2.1 获取SqlSessionFactory对象        String resource = "mybatis-config.xml";        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2.2 获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //2.3 获取Mapper        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //2.4 调用方法        User user = userMapper.select(username, password);        //2.5 释放资源        sqlSession.close();        //获取字符输出流，并设置content type        response.setContentType("text/html;charset=utf-8");        PrintWriter writer = response.getWriter();        //3. 判断user释放为null        if(user != null){            // 登陆成功            writer.write("登陆成功");        }else {            // 登陆失败            writer.write("登陆失败");        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><ol start="4"><li>启动服务器测试</li></ol><p>4.1 如果用户名和密码输入错误，则</p><p><img src="1628867761245.png" alt="1628867761245"></p><p>4.2 如果用户名和密码输入正确，则</p><p><img src="1628867801708.png" alt="1628867801708"></p><p>至此用户的登录功能就已经完成了~</p><h4 id="4-2-用户注册"><a href="#4-2-用户注册" class="headerlink" title="4.2 用户注册"></a>4.2 用户注册</h4><h5 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1 需求分析"></a>4.2.1 需求分析</h5><p><img src="1628867904783.png" alt="1628867904783"></p><ol><li>用户在注册页面输入用户名和密码，提交请求给RegisterServlet</li><li>在RegisterServlet中接收请求和数据[用户名和密码]</li><li>在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表</li><li>将查询的结果封装到User对象中进行返回</li><li>在RegisterServlet中判断返回的User对象是否为null</li><li>如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户</li><li>如果不为null,则说明用户不可以，返回”用户名已存在”数据给前端</li></ol><h5 id="4-2-2-代码编写"><a href="#4-2-2-代码编写" class="headerlink" title="4.2.2 代码编写"></a>4.2.2 代码编写</h5><ol><li>编写UserMapper提供根据用户名查询用户数据方法和添加用户方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** 根据用户名查询用户对象* @param username* @return*/@Select("select * from tb_user where username = #{username}")User selectByUsername(String username);/*** 添加用户* @param user*/@Insert("insert into tb_user values(null,#{username},#{password})")void add(User user);</code></pre><ol start="2"><li>修改register.html</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;欢迎注册&lt;/title&gt;    &lt;link href="css/register.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="form-div"&gt;    &lt;div class="reg-content"&gt;        &lt;h1&gt;欢迎注册&lt;/h1&gt;        &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href="login.html"&gt;登录&lt;/a&gt;    &lt;/div&gt;    &lt;form id="reg-form" action="/request-demo/registerServlet" method="post"&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名&lt;/td&gt;                &lt;td class="inputs"&gt;                    &lt;input name="username" type="text" id="username"&gt;                    &lt;br&gt;                    &lt;span id="username_err" class="err_msg" style="display: none"&gt;用户名不太受欢迎&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码&lt;/td&gt;                &lt;td class="inputs"&gt;                    &lt;input name="password" type="password" id="password"&gt;                    &lt;br&gt;                    &lt;span id="password_err" class="err_msg" style="display: none"&gt;密码格式有误&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;div class="buttons"&gt;            &lt;input value="注 册" type="submit" id="reg_btn"&gt;        &lt;/div&gt;        &lt;br class="clear"&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="3"><li>创建RegisterServlet类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet("/registerServlet")public class RegisterServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //1. 接收用户数据        String username = request.getParameter("username");        String password = request.getParameter("password");        //封装用户对象        User user = new User();        user.setUsername(username);        user.setPassword(password);        //2. 调用mapper 根据用户名查询用户对象        //2.1 获取SqlSessionFactory对象        String resource = "mybatis-config.xml";        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2.2 获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //2.3 获取Mapper        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //2.4 调用方法        User u = userMapper.selectByUsername(username);        //3. 判断用户对象释放为null        if( u == null){            // 用户名不存在，添加用户            userMapper.add(user);            // 提交事务            sqlSession.commit();            // 释放资源            sqlSession.close();        }else {            // 用户名存在，给出提示信息            response.setContentType("text/html;charset=utf-8");            response.getWriter().write("用户名已存在");        }    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doGet(request, response);    }}</code></pre><ol start="4"><li>启动服务器进行测试</li></ol><p>4.1 如果测试成功，则在数据库中就能查看到新注册的数据</p><p>4.2 如果用户已经存在，则在页面上展示 <code>用户名已存在</code> 的提示信息</p><h4 id="4-3-SqlSessionFactory工具类抽取"><a href="#4-3-SqlSessionFactory工具类抽取" class="headerlink" title="4.3 SqlSessionFactory工具类抽取"></a>4.3 SqlSessionFactory工具类抽取</h4><p>上面两个功能已经实现，但是在写Servlet的时候，因为需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String resource = "mybatis-config.xml";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>有了这些重复代码就会造成一些问题:</p><ul><li>重复代码不利于后期的维护</li><li>SqlSessionFactory工厂类进行重复创建<ul><li>就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。</li></ul></li></ul><p>那如何来优化呢？</p><ul><li>代码重复可以抽取工具类</li><li>对指定代码只需要执行一次可以使用静态代码块</li></ul><p>有了这两个方向后，代码具体该如何编写?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SqlSessionFactoryUtils {    private static SqlSessionFactory sqlSessionFactory;    static {        //静态代码块会随着类的加载而自动执行，且只执行一次        try {            String resource = "mybatis-config.xml";            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        } catch (IOException e) {            e.printStackTrace();        }    }    public static SqlSessionFactory getSqlSessionFactory(){        return sqlSessionFactory;    }}</code></pre><p>工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory();</code></pre><p>这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> servlet </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/05/20/Maven/"/>
      <url>/2023/05/20/Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p></li><li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）</p></li><li><p>提供了一套依赖管理机制</p></li></ul><p><strong>标准化的项目结构：</strong></p><p>项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具</p><img src="image-20210726153521381.png" alt="image-20210726153521381" style="zoom:80%;"><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。</p><img src="image-20210726153815028.png" alt="image-20210726153815028" style="zoom:80%;"><p><strong>标准化的构建流程：</strong></p><img src="image-20210726154144488.png" alt="image-20210726154144488" style="zoom:80%;"><p>如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><strong>依赖管理：</strong></p><p>依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包（当前之前是老师已经下载好提供给大家了），复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示</p><img src="image-20210726154753631.png" alt="image-20210726154753631" style="zoom:80%;"><p>而Maven使用标准的 ==坐标== 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><img src="image-20210726154922337.png" alt="image-20210726154922337" style="zoom:80%;"><p>如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。</p><p>市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比</p><p><img src="image-20210726155212733.png" alt="image-20210726155212733"></p><h3 id="1-1-Maven简介"><a href="#1-1-Maven简介" class="headerlink" title="1.1  Maven简介"></a>1.1  Maven简介</h3><blockquote><p>==Apache Maven== 是一个项目管理和构建==工具==，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网 ：<a href="http://maven.apache.org/">http://maven.apache.org/</a> </p></blockquote><p>通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。</p><h4 id="1-1-1-Maven模型"><a href="#1-1-1-Maven模型" class="headerlink" title="1.1.1  Maven模型"></a>1.1.1  Maven模型</h4><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><img src="image-20210726155759621.png" alt="image-20210726155759621" style="zoom:80%;"><p>如上图所示就是Maven的模型，而我们先看紫色框框起来的部分，他就是用来完成 <code>标准化构建流程</code> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p><img src="image-20210726160928515.png" alt="image-20210726160928515" style="zoom:80%;"><p>上图中紫色框起来的部分，项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p><img src="image-20210726161340796.png" alt="image-20210726161340796" style="zoom:80%;"><p>依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，如下图所示</p><p><img src="image-20210726161616034.png" alt="image-20210726161616034"></p><p>上述Maven模型图中还有一部分是仓库。如何理解仓库呢？</p><h4 id="1-1-2-仓库"><a href="#1-1-2-仓库" class="headerlink" title="1.1.2  仓库"></a>1.1.2  仓库</h4><p>大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p><p><strong>仓库分类：</strong></p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p><p>今天我们只学习远程仓库的使用，并不会搭建。</p></li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li><p>如果有，则在项目直接引用;</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p></li></ul><img src="image-20210726162605394.png" alt="image-20210726162605394" style="zoom:70%;"><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p></blockquote><img src="image-20210726162815045.png" alt="image-20210726162815045" style="zoom:70%;"><h3 id="1-2-Maven安装配置"><a href="#1-2-Maven安装配置" class="headerlink" title="1.2  Maven安装配置"></a>1.2  Maven安装配置</h3><ul><li><p>解压 apache-maven-3.6.1.rar 既安装完成</p><img src="image-20210726163219682.png" alt="image-20210726163219682" style="zoom:90%;"><blockquote><p>建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 <code>D:\software</code> 下。</p></blockquote><p>解压缩后的目录结构如下：</p><img src="image-20210726163518885.png" alt="image-20210726163518885" style="zoom:80%;"><ul><li>bin目录 ： 存放的是可执行命令。mvn 命令重点关注。</li><li>conf目录 ：存放Maven的配置文件。<code>settings.xml</code> 配置文件后期需要修改。</li><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul></li><li><p>配置环境变量 MAVEN_HOME 为安装路径的bin目录</p><p><code>此电脑</code> 右键  –&gt;  <code>高级系统设置</code>  –&gt;  <code>高级</code>  –&gt;  <code>环境变量</code></p><p>在系统变量处新建一个变量 <code>MAVEN_HOME</code></p><img src="image-20210726164058589.png" alt="image-20210726164058589" style="zoom:80%;"><p>在 <code>Path</code> 中进行配置</p><img src="image-20210726164146832.png" alt="image-20210726164146832" style="zoom:80%;"><p>打开命令提示符进行验证，出现如图所示表示安装成功</p><img src="image-20210726164306480.png" alt="image-20210726164306480" style="zoom:80%;"></li><li><p>配置本地仓库</p><p>修改 conf/settings.xml 中的 <localrepository> 为一个指定目录作为本地仓库，用来存储jar包。</localrepository></p><img src="image-20210726164348048.png" alt="image-20210726164348048" style="zoom:60%;"></li><li><p>配置阿里云私服</p><p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>修改 conf/settings.xml 中的 <mirrors>标签，为其添加如下子标签：</mirrors></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mirror&gt;      &lt;id&gt;alimaven&lt;/id&gt;      &lt;name&gt;aliyun maven&lt;/name&gt;      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          &lt;/mirror&gt;</code></pre></li></ul><h3 id="1-3-Maven基本使用"><a href="#1-3-Maven基本使用" class="headerlink" title="1.3  Maven基本使用"></a>1.3  Maven基本使用</h3><h4 id="1-3-1-Maven-常用命令"><a href="#1-3-1-Maven-常用命令" class="headerlink" title="1.3.1  Maven 常用命令"></a>1.3.1  Maven 常用命令</h4><blockquote><ul><li><p>compile ：编译</p></li><li><p>clean：清理</p></li><li><p>test：测试</p></li><li><p>package：打包</p></li><li><p>install：安装</p></li></ul></blockquote><p><strong>命令演示：</strong></p><p>在 <code>资料\代码\maven-project</code> 提供了一个使用Maven构建的项目，项目结构如下：</p><img src="image-20210726170404545.png" alt="image-20210726170404545" style="zoom:70%;"><p>而我们使用上面命令需要在磁盘上进入到项目的 <code>pom.xml</code> 目录下，打开命令提示符</p><img src="image-20210726170549907.png" alt="image-20210726170549907" style="zoom:70%;"><p><strong>编译命令演示：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">compile ：编译</code></pre><p>执行上述命令可以看到：</p><ul><li>从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件</li><li>在项目下会生成一个 <code>target</code> 目录</li></ul><img src="image-20210726171047324.png" alt="image-20210726171047324" style="zoom:80%;"><p>同时在项目下会出现一个 <code>target</code> 目录，编译后的字节码文件就放在该目录下</p><img src="image-20210726171346824.png" alt="image-20210726171346824" style="zoom:80%;"><p><strong>清理命令演示：</strong></p><pre class="line-numbers language-none"><code class="language-none">mvn clean</code></pre><p>执行上述命令可以看到</p><ul><li>从阿里云下载清理需要的插件jar包</li><li>删除项目下的 <code>target</code> 目录</li></ul><img src="image-20210726171558786.png" alt="image-20210726171558786" style="zoom:80%;"><p><strong>打包命令演示：</strong></p><pre class="line-numbers language-none"><code class="language-none">mvn package</code></pre><p>执行上述命令可以看到：</p><ul><li>从阿里云下载打包需要的插件jar包</li><li>在项目的 <code>terget</code> 目录下有一个jar包（将当前项目打成的jar包）</li></ul><img src="image-20210726171747125.png" alt="image-20210726171747125" style="zoom:80%;"><p><strong>测试命令演示：</strong></p><pre class="line-numbers language-none"><code class="language-none">mvn test  </code></pre><p>该命令会执行所有的测试代码。执行上述命令效果如下</p><img src="image-20210726172343933.png" alt="image-20210726172343933" style="zoom:80%;"><p><strong>安装命令演示：</strong></p><pre class="line-numbers language-none"><code class="language-none">mvn install</code></pre><p>该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下：</p><img src="image-20210726172709112.png" alt="image-20210726172709112" style="zoom:80%;"><h4 id="1-3-2-Maven-生命周期"><a href="#1-3-2-Maven-生命周期" class="headerlink" title="1.3.2  Maven 生命周期"></a>1.3.2  Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li>clean ：清理工作。</li><li>default ：核心工作，例如编译，测试，打包，安装等。</li><li>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：</p><img src="image-20210726173153576.png" alt="image-20210726173153576" style="zoom:80%;"><p>当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test </code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令。</p><p>当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><p>默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的：</p><img src="image-20210726173619353.png" alt="image-20210726173619353" style="zoom:80%;"><h3 id="1-4-IDEA使用Maven"><a href="#1-4-IDEA使用Maven" class="headerlink" title="1.4  IDEA使用Maven"></a>1.4  IDEA使用Maven</h3><p>以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。</p><h4 id="1-4-1-IDEA配置Maven环境"><a href="#1-4-1-IDEA配置Maven环境" class="headerlink" title="1.4.1  IDEA配置Maven环境"></a>1.4.1  IDEA配置Maven环境</h4><p>我们需要先在IDEA中配置Maven环境：</p><ul><li><p>选择 IDEA中 File –&gt; Settings</p><img src="image-20210726174202898.png" alt="image-20210726174202898" style="zoom:80%;"></li><li><p>搜索 maven </p><img src="image-20210726174229396.png" alt="image-20210726174229396" style="zoom:80%;"></li><li><p>设置 IDEA 使用本地安装的 Maven，并修改配置文件路径</p><img src="image-20210726174248050.png" alt="image-20210726174248050" style="zoom:70%;"></li></ul><h4 id="1-4-2-Maven-坐标详解"><a href="#1-4-2-Maven-坐标详解" class="headerlink" title="1.4.2  Maven 坐标详解"></a>1.4.2  Maven 坐标详解</h4><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是==资源的唯一标识==</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p>如下图就是使用坐标表示一个项目：</p><p><img src="image-20210726174718176.png" alt="image-20210726174718176"></p><blockquote><p>==注意：==</p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h4 id="1-4-3-IDEA-创建-Maven项目"><a href="#1-4-3-IDEA-创建-Maven项目" class="headerlink" title="1.4.3  IDEA 创建 Maven项目"></a>1.4.3  IDEA 创建 Maven项目</h4><ul><li><p>创建模块，选择Maven，点击Next</p><img src="image-20210726175049876.png" alt="image-20210726175049876" style="zoom:90%;"></li><li><p>填写模块名称，坐标信息，点击finish，创建完成</p><img src="image-20210726175109822.png" alt="image-20210726175109822" style="zoom:80%;"><p>创建好的项目目录结构如下：</p><p><img src="image-20210726175244826.png" alt="image-20210726175244826"></p></li><li><p>编写 HelloWorld，并运行</p></li></ul><h4 id="1-4-4-IDEA-导入-Maven项目"><a href="#1-4-4-IDEA-导入-Maven项目" class="headerlink" title="1.4.4  IDEA 导入 Maven项目"></a>1.4.4  IDEA 导入 Maven项目</h4><p>大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入：</p><ul><li><p>选择右侧Maven面板，点击 + 号</p><img src="image-20210726182702336.png" alt="image-20210726182702336" style="zoom:70%;"></li><li><p>选中对应项目的pom.xml文件，双击即可</p><img src="image-20210726182648891.png" alt="image-20210726182648891" style="zoom:70%;"></li><li><p>如果没有Maven面板，选择</p><p>View –&gt; Appearance –&gt; Tool Window Bars</p><img src="image-20210726182634466.png" alt="image-20210726182634466" style="zoom:80%;"></li></ul><p>可以通过下图所示进行命令的操作：</p><img src="image-20210726182902961.png" alt="image-20210726182902961" style="zoom:80%;"><p><strong>配置 Maven-Helper 插件</strong> </p><ul><li><p>选择 IDEA中 File –&gt; Settings</p><img src="image-20210726192212026.png" alt="image-20210726192212026" style="zoom:80%;"></li><li><p>选择 Plugins</p><img src="image-20210726192224914.png" alt="image-20210726192224914" style="zoom:80%;"></li><li><p>搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept</p><img src="image-20210726192244567.png" alt="image-20210726192244567" style="zoom:80%;"></li><li><p>重启 IDEA</p></li></ul><p>安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示：</p><img src="image-20210726192430371.png" alt="image-20210726192430371" style="zoom:80%;"><h3 id="1-5-依赖管理"><a href="#1-5-依赖管理" class="headerlink" title="1.5  依赖管理"></a>1.5  依赖管理</h3><h4 id="1-5-1-使用坐标引入jar包"><a href="#1-5-1-使用坐标引入jar包" class="headerlink" title="1.5.1  使用坐标引入jar包"></a>1.5.1  使用坐标引入jar包</h4><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li><p>在项目的 pom.xml 中编写 <dependencies> 标签</dependencies></p></li><li><p>在 <dependencies> 标签中 使用 <dependency> 引入坐标</dependency></dependencies></p></li><li><p>定义坐标的 groupId，artifactId，version</p><img src="image-20210726193105765.png" alt="image-20210726193105765" style="zoom:70%;"></li><li><p>点击刷新按钮，使坐标生效</p><img src="image-20210726193121384.png" alt="image-20210726193121384" style="zoom:60%;"></li></ul><blockquote><p> 注意：</p><ul><li>具体的坐标我们可以到如下网站进行搜索</li><li><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li></ul></blockquote><p><strong>快捷方式导入jar包的坐标：</strong></p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式</p><ul><li><p>在 pom.xml 中 按 alt + insert，选择 Dependency</p><img src="image-20210726193603724.png" alt="image-20210726193603724" style="zoom:60%;"></li><li><p>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</p><img src="image-20210726193625229.png" alt="image-20210726193625229" style="zoom:60%;"></li><li><p>点击刷新按钮，使坐标生效</p><img src="image-20210726193121384.png" alt="image-20210726193121384" style="zoom:60%;"></li></ul><p><strong>自动导入设置：</strong></p><p>上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成</p><ul><li><p>选择 IDEA中 File –&gt; Settings</p><img src="image-20210726193854438.png" alt="image-20210726193854438" style="zoom:60%;"></li><li><p>在弹出的面板中找到 Build Tools</p><img src="image-20210726193909276.png" alt="image-20210726193909276" style="zoom:80%;"></li><li><p>选择 Any changes，点击 ok 即可生效</p></li></ul><h4 id="1-5-2-依赖范围"><a href="#1-5-2-依赖范围" class="headerlink" title="1.5.2  依赖范围"></a>1.5.2  依赖范围</h4><p>通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><img src="image-20210726194703845.png" alt="image-20210726194703845" style="zoom:70%;"><p>那么 <code>scope</code> 都可以有哪些取值呢？</p><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table><ul><li>compile ：作用于编译环境、测试环境、运行环境。</li><li>test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值</li><li>provided ：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错</li><li>runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题</li></ul><blockquote><p>注意：</p><ul><li>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/05/11/JDBC/"/>
      <url>/2023/05/11/JDBC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-jdbc-技术组成和核心api概述"><a href="#1-jdbc-技术组成和核心api概述" class="headerlink" title="1. jdbc 技术组成和核心api概述"></a>1. jdbc 技术组成和核心api概述</h3><p><img src="image-20230710154044309.png" alt="image-20230710154044309"></p><p><img src="image-20230710154130908.png" alt="image-20230710154130908"></p><p><img src="image-20230710154215703.png" alt="image-20230710154215703"></p><h3 id="2-jdbc基本使用步骤"><a href="#2-jdbc基本使用步骤" class="headerlink" title="2. jdbc基本使用步骤"></a>2. jdbc基本使用步骤</h3><p><img src="image-20230710154913782.png" alt="image-20230710154913782"></p><h3 id="3-Statement和PreparedStatement"><a href="#3-Statement和PreparedStatement" class="headerlink" title="3. Statement和PreparedStatement"></a>3. Statement和PreparedStatement</h3><p><img src="image-20230710204159269.png" alt="image-20230710204159269"></p><p><img src="image-20230710211858357.png" alt="image-20230710211858357"></p><p>使用api总结：</p><p><img src="image-20230710212043115.png" alt="image-20230710212043115"></p><h3 id="4-Druid连接池技术使用"><a href="#4-Druid连接池技术使用" class="headerlink" title="4. Druid连接池技术使用"></a>4. Druid连接池技术使用</h3><p>数据库连接池作用：</p><p><img src="image-20230710213041636.png" alt="image-20230710213041636"></p><p><img src="image-20230710214938169.png" alt="image-20230710214938169"></p><h3 id="5-jdbc连接池类封装"><a href="#5-jdbc连接池类封装" class="headerlink" title="5. jdbc连接池类封装"></a>5. jdbc连接池类封装</h3><p><img src="image-20230710220523380.png" alt="image-20230710220523380"></p><h3 id="6-高级应用层封装BaseDao"><a href="#6-高级应用层封装BaseDao" class="headerlink" title="6. 高级应用层封装BaseDao"></a>6. 高级应用层封装BaseDao</h3><p><img src="image-20230710220938159.png" alt="image-20230710220938159"></p><p><strong>非DQL方法的封装：</strong></p><p><img src="image-20230710221326697.png" alt="image-20230710221326697"></p><p><strong>DQL方法的封装：</strong></p><blockquote><p>表 -&gt; Java中的一个类</p><p>一行 -&gt; 类中的一个对象   列名+数据 -&gt; 对象名+值</p><p>多行 -&gt; List&lt;Java实体类&gt; list</p></blockquote><p><img src="image-20230710223915943.png" alt="image-20230710223915943"></p><p><img src="image-20230710224504782.png" alt="image-20230710224504782"></p><p><img src="image-20230710224541456.png" alt="image-20230710224541456"></p><p><img src="image-20230710224622439.png" alt="image-20230710224622439"></p>]]></content>
      
      
      <categories>
          
          <category> Javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js报错The “chunk“ argument must be of type string or an instance of Buffer or Uint8Array.</title>
      <link href="/2023/02/19/node-js%E6%8A%A5%E9%94%99The-%E2%80%9Cchunk%E2%80%9C-argument-must-be-of-type-string-or-an-instance-of-Buffer-or-Uint8Array/"/>
      <url>/2023/02/19/node-js%E6%8A%A5%E9%94%99The-%E2%80%9Cchunk%E2%80%9C-argument-must-be-of-type-string-or-an-instance-of-Buffer-or-Uint8Array/</url>
      
        <content type="html"><![CDATA[<p>如题，在使用node.js进行http请求时，出现如下报错：</p><p>The “chunk” argument must be of type string or an instance of Buffer or Uint8Array. Received an instance of Object</p><p><img src="2e4f0fd84a0043bbb03129482c312540.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>原代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const http = require("http");const querystring = require("querystring");const server = http.createServer((req, res) =&gt; {  const method = req.method;  const url = req.url;  const path = req.url.split("?")[0];  const query = req.url.split("?")[1];  // 设置返回数据格式  res.setHeader("Content-type", "application/json");  const resData = {    method,    url,    path,    query,  };  if (method === "GET") {    res.end(resData); // 这里数据类型为Object类型  }});server.listen(8000);console.log("OK");</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>而<strong>response.end()方法接收的参数类型只能是字符串或Buffer</strong></p><p><strong>修改办法：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const http = require("http");const querystring = require("querystring");const server = http.createServer((req, res) =&gt; {  const method = req.method;  const url = req.url;  const path = req.url.split("?")[0];  const query = req.url.split("?")[1];  // 设置返回数据格式  res.setHeader("Content-type", "application/json");  const resData = {    method,    url,    path,    query,  };  if (method === "GET") {    res.end(JSON.stringify(resData)); // 这里转换为字符串类型  }});server.listen(8000);console.log("OK");</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>问题就解决啦~</p><p><strong>总结： response.end()方法接收的参数类型只能是字符串或Buffer</strong></p>]]></content>
      
      
      <categories>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解vue中的slot-scope与scope.row</title>
      <link href="/2023/02/13/%E7%90%86%E8%A7%A3vue%E4%B8%AD%E7%9A%84slot-scope%E4%B8%8Escope-row/"/>
      <url>/2023/02/13/%E7%90%86%E8%A7%A3vue%E4%B8%AD%E7%9A%84slot-scope%E4%B8%8Escope-row/</url>
      
        <content type="html"><![CDATA[<blockquote><p> slot-scope 是vue2中的作用域插槽</p></blockquote><p>在父组件 <code>&lt;template&gt;</code> 上使用特殊的 <code>slot-scope</code> attribute，可以接收子组件传递给插槽的 prop</p><p>父组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;template&gt;  &lt;div class="father"&gt;    &lt;h3&gt;这里是父组件&lt;/h3&gt;    &lt;child&gt;      &lt;template slot-scope="user"&gt;       {{user.data}}      &lt;/template&gt;    &lt;/child&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>子组件：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;template&gt;  &lt;div class="child"&gt;    &lt;h3&gt;这里是子组件&lt;/h3&gt;    // 作用域插槽    &lt;slot :data="data"&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default {    data: function() {      return {        data: ['john','lisa','amy','mike']      }    }}&lt;/script&gt;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>使用vue中的<a href="https://so.csdn.net/so/search?q=ele&amp;spm=1001.2101.3001.7020">ele</a>-ui组件的时候，我们经常使用template插槽，slot-<a href="https://so.csdn.net/so/search?q=scope&amp;spm=1001.2101.3001.7020">scope</a>可以获取当前所在元素的数据</p></blockquote><p><img src="f82cb4890ea046eaa42b6155eb0c7fd8.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;el-table :data="computeData" border style="width: 100%"&gt;      &lt;el-table-column prop="name" label="姓名" align="center"&gt;      &lt;/el-table-column&gt;      &lt;el-table-column prop="age" label="年龄" align="center"&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label="操作" align="center"&gt;        &lt;template slot-scope="scope"&gt; // 此处获取点击的该行的数据          &lt;el-button            type="danger"            size="mini"            icon="el-icon-delete"            @click="del(scope.row)"          &gt;&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;&lt;/el-table&gt;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>scope.row 中存储着该行的数据：</p><p><img src="017f6187d61d4a62a061df4c92db6e5e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 工具介绍及使用</title>
      <link href="/2023/02/03/git-%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/03/git-%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>git add . git commit -m “提交信息” / git commit -a -m “提交信息”</p><p>git remote add 远程仓库别名 url</p><p>git branch –set-upstream-to=origin/main(远程) 本地分支名 (本地分支关联远程分支)</p><p>git pull 远程仓库别名 远程仓库分支</p><p>git push 远程仓库别名 本地当前分支 (git push = git push origin master)</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css布局中使用min-width: 0的作用</title>
      <link href="/2023/02/01/css%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8min-width-0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/02/01/css%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8min-width-0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>父元素存在flex布局，由于flex布局的特性，如果不设置宽度，父元素可以被子节点无限撑开</p><p>min-width是最小宽度的意思，在存在flex布局的父元素中使用min-width: 0，可以使父元素中的子元素内容不超出父元素容器。</p><p>作用：让包裹的盒子宽度不会因为内容的新增而增加，与使用<code>overflow hidden</code>的效果一样</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 知识大总结（四）Vue3 全家桶 router、vuex、pinia、axios</title>
      <link href="/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89Vue3-%E5%85%A8%E5%AE%B6%E6%A1%B6-router%E3%80%81vuex%E3%80%81pinia%E3%80%81axios/"/>
      <url>/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89Vue3-%E5%85%A8%E5%AE%B6%E6%A1%B6-router%E3%80%81vuex%E3%80%81pinia%E3%80%81axios/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Vue-Router"><a href="#一、Vue-Router" class="headerlink" title="一、Vue-Router"></a>一、Vue-Router</h1><h2 id="1-前端路由发展历程"><a href="#1-前端路由发展历程" class="headerlink" title="1. 前端路由发展历程"></a>1. 前端路由发展历程</h2><p>==发展历程：==</p><ul><li>后端路由：当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, <strong>服务器渲染好整个页面, 并且将页面返回</strong>给客户端。</li><li>前后端分离：<strong>后端只提供API</strong>来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</li><li>单页面富应用：<ul><li>SPA：single page web application<ul><li>SPA最主要的特点就是<strong>在前后端分离的基础上加了一层前端路由</strong>。</li></ul></li><li><em><strong>前端路由</strong></em><ul><li>由前端来维护映射关系，在不同的URL显示不同的组件</li><li>核心：<strong>监听URL的改变，URL和内容进行映射</strong></li></ul></li></ul></li></ul><h3 id="1-1-两种模式"><a href="#1-1-两种模式" class="headerlink" title="1.1 两种模式"></a>1.1 两种模式</h3><ul><li><p>hash模式：URL的hash也就是<strong>锚点(#)</strong>, 本质上是改变window.location的href属性</p></li><li><p>history模式：history接口是HTML5新增的，通过一些模式函数来改变URL但不刷新页面</p></li></ul><table><thead><tr><th>hash</th><th>history</th></tr></thead><tbody><tr><td>有 # 号</td><td>没有 # 号</td></tr><tr><td>能够兼容到IE8</td><td>只能兼容到IE10</td></tr><tr><td>实际的url之前使用哈希字符，这部分url不会发送到服务器，不需要在服务器层面上进行任何处理</td><td>每访问一个页面都需要服务器进行路由匹配生成 html 文件再发送响应给浏览器，消耗服务器大量资源</td></tr><tr><td>刷新不会存在 404 问题</td><td>浏览器直接访问嵌套路由时，会报 404 问题。</td></tr><tr><td>不需要服务器任何配置</td><td>需要在服务器配置一个回调路由</td></tr></tbody></table><h2 id="2-vue-router-的使用过程"><a href="#2-vue-router-的使用过程" class="headerlink" title="2. vue-router 的使用过程"></a>2. vue-router 的使用过程</h2><p>路由用于设定访问路径，<strong>将路径和组件映射起来</strong></p><ul><li>安装：<code>npm install vue-router</code></li></ul><p>使用vue-router的步骤：</p><ul><li>第一步：创建路由需要映射的组件（<strong>打算显示的页面</strong>）</li><li>第二步：通过<strong>createRouter创建路由对象</strong>，并且<strong>传入routes和history模式</strong><ul><li><p>routes：配置路由映射，组件和路径映射关系的routes数组</p></li><li><p>history：创建基于hash或者history的模式</p><ul><li>hash模式  :  <code>history: createWebHashHistory()</code></li></ul><ul><li>history模式:    <code>history: createWebHistory()</code></li></ul></li></ul></li><li>第三步：使用<strong>app注册路由对象</strong>（use方法）</li><li>第四步：<strong>使用路径</strong><ul><li>router-view: 占位</li><li>router-link  进行路由的切换<ul><li>编程式导航</li><li>to 属性, 跳转到哪一个路由</li></ul></li></ul></li></ul><p><img src="6f86f3c449dc4c41814ba59d8b74347a.png" alt="在这里插入图片描述"></p><h3 id="2-1-vue-router-知识点补充"><a href="#2-1-vue-router-知识点补充" class="headerlink" title="2.1 vue-router 知识点补充"></a>2.1 vue-router 知识点补充</h3><h4 id="2-1-1-路由的默认路径"><a href="#2-1-1-路由的默认路径" class="headerlink" title="2.1.1 路由的默认路径"></a>2.1.1 路由的默认路径</h4><p>让路径<strong>默认跳到到首页</strong></p><ul><li>path：配置的是根路径: /</li><li>redirect：重定向，将根路径重定向到/home的路径下</li></ul><p><img src="5dff00e5cd32470287119c07a2144cf8.png" alt="在这里插入图片描述"></p><h4 id="2-1-2-router-link-其他属性"><a href="#2-1-2-router-link-其他属性" class="headerlink" title="2.1.2 router-link 其他属性"></a>2.1.2 router-link 其他属性</h4><ul><li>to属性：指定<strong>跳转到哪个路由</strong>。是一个字符串，或者是一个对象</li><li>replace属性： 设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()。导航后<strong>不会留下history记录</strong>，也就是不能回退到上一个页面</li><li>active-class属性：设置激活a元素后应用的<strong>class名称</strong>，默认是router-link-active</li><li>exact-active-class属性：链接<strong>精准激活</strong>时，应用于渲染的 的 class，默认是router-link-exact-active</li></ul><h4 id="2-1-3-路由懒加载-分包处理"><a href="#2-1-3-路由懒加载-分包处理" class="headerlink" title="2.1.3 路由懒加载-分包处理"></a>2.1.3 路由懒加载-分包处理</h4><p>把<strong>不同路由对应的组件分割</strong>成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">{ path: "/home", component: () =&gt; import(/* webpackChunkName: 'home' */"../Views/Home.vue") }// webpackChunkName 规定分包后的文件名称</code></pre><h4 id="2-1-4-其他属性"><a href="#2-1-4-其他属性" class="headerlink" title="2.1.4 其他属性"></a>2.1.4 其他属性</h4><ul><li>name：路由记录独一无二的名称</li><li>meta：自定义数据</li></ul><p><img src="df608049783b4da49b52093d5c27a18a.png" alt="在这里插入图片描述"></p><h2 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3. 动态路由"></a>3. 动态路由</h2><p>如果需要将<strong>给定匹配模式的路由</strong>映射到<strong>同一个</strong>组件：可以<strong>在路径中使用一个动态字段</strong>来实现，我们称之为路径参数</p><p><img src="1203c38349694cdd9334f51e57615d15.png" alt="在这里插入图片描述"></p><p>在router-link中进行如下跳转：</p><p><img src="e5fd8ea9245b4a04a96580c6c5d99901.png" alt="在这里插入图片描述"></p><p>获取动态路由中对应的值：</p><ul><li>在template中，直接通过 <code>$route.params</code>获取值</li><li>在created中，通过 <code>this.$route.param</code>s获取值</li><li>在setup中，我们要使用 vue-router库给我们提供的一个hook，useRoute</li></ul><p><img src="abc9d88f1bc74c16972ffeaeb6a37877.png" alt="在这里插入图片描述"></p><h3 id="3-1-NotFound-页面匹配"><a href="#3-1-NotFound-页面匹配" class="headerlink" title="3.1 NotFound 页面匹配"></a>3.1 NotFound 页面匹配</h3><p>没有匹配到的路由，我们通常会<strong>匹配到固定的某个页面</strong>：编写一个动态路由用于匹配所有页面<br><img src="212dc44a971f474c81367a43a7526655.png" alt="在这里插入图片描述"></p><p>通过 $route.params.pathMatch获取到传入的参数：<br><img src="90582ec43b154e9da347a5f80134ef6c.png" alt="在这里插入图片描述"></p><p>ps：另一种写法<br><img src="9877478a6b3443528488f2ac1bd563c2.png" alt="在这里插入图片描述"></p><h2 id="4-路由的嵌套"><a href="#4-路由的嵌套" class="headerlink" title="4. 路由的嵌套"></a>4. 路由的嵌套</h2><p>会出现多层路由嵌套的情况：</p><ol><li>在一层路由Home中<strong>添加 children属性</strong>：</li><li>在Home组件中添加 <code>&lt;router-view&gt;</code></li><li>路径跳转 <code>&lt;router-link&gt;</code></li></ol><p><img src="f47256289fb44f5ebc003cb5801e7084.png" alt="在这里插入图片描述"></p><p><img src="e16a478a66f344c292ee1bf2a6fd013d.png" alt="在这里插入图片描述"></p><h2 id="5-路由的编程式导航"><a href="#5-路由的编程式导航" class="headerlink" title="5. 路由的编程式导航"></a>5. 路由的编程式导航</h2><h3 id="5-1-代码的页面跳转"><a href="#5-1-代码的页面跳转" class="headerlink" title="5.1 代码的页面跳转"></a>5.1 代码的页面跳转</h3><p>希望实现<strong>其他元素（按钮、span等）的跳转</strong>，可以通过 useRouter 来获取<br>通过query的方式来<strong>传递参数</strong>，在界面中通过 $route.query 来获取参数</p><p>// App.vue<br><img src="61ad60b220554d5ca8b2087f6b64fbcf.png" alt="在这里插入图片描述"></p><p>router.push({}) 中可传递参数<br><img src="1a0e1da1c1284aab9fd08d9cc57d61ca.png" alt="在这里插入图片描述"><br><img src="e47eafd1ea354bc28fca7b42d5729c8b.png" alt="在这里插入图片描述"></p><h3 id="5-2-页面的前进后退"><a href="#5-2-页面的前进后退" class="headerlink" title="5.2 页面的前进后退"></a>5.2 页面的前进后退</h3><ul><li>back()：回溯历史，相当于 router.go(-1)</li><li>forward()：在历史中前进，相当于 router.go(1)</li><li>go(number)</li></ul><p><img src="6393c39f0de04027924301bdb9299b7e.png" alt="在这里插入图片描述"></p><h2 id="6-动态管理路由对象"><a href="#6-动态管理路由对象" class="headerlink" title="6. 动态管理路由对象"></a>6. 动态管理路由对象</h2><p>某些情况下我们可能需要动态的来添加路由：</p><ul><li>比如根据<strong>用户不同的权限，注册不同的路由</strong>（后台管理系统）</li></ul><p><img src="2532224ca0fa4005a7c3942929d8f09b.png" alt="在这里插入图片描述"></p><h3 id="6-1-动态添加路由"><a href="#6-1-动态添加路由" class="headerlink" title="6.1 动态添加路由"></a>6.1 动态添加路由</h3><ul><li>我们可以使用一个方法 addRoute</li><li>如果我们是为route<strong>添加一个children路由</strong>，那么可以传入对应的name</li></ul><p><img src="c2f6b8451507400fbd1e2dd60e1321c3.png" alt="在这里插入图片描述"></p><h4 id="6-1-1-管理路由的其他方法（了解）"><a href="#6-1-1-管理路由的其他方法（了解）" class="headerlink" title="6.1.1 管理路由的其他方法（了解）"></a>6.1.1 管理路由的其他方法（了解）</h4><ul><li><p>删除路由有以下三种方式：</p><ul><li>方式一：添加一个name相同的路由</li><li>方式二：通过removeRoute方法，传入路由的名称</li><li>方式三：通过addRoute方法的返回值回调<br><img src="f6bec5cdbf3f4d30bc15c7bd0ba8ae34.png" alt="在这里插入图片描述"></li></ul></li><li><p>路由的其他方法补充：</p><ul><li>router.hasRoute()：检查<strong>路由是否存在</strong>。</li><li>router.getRoutes()：<strong>获取一个包含所有路由记录</strong>的数组</li></ul></li></ul><h2 id="7-路由导航守卫"><a href="#7-路由导航守卫" class="headerlink" title="7. 路由导航守卫"></a>7. 路由导航守卫</h2><p>导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong></p><h3 id="7-1-beforeEach"><a href="#7-1-beforeEach" class="headerlink" title="7.1 beforeEach"></a>7.1 beforeEach</h3><p>全局的前置守卫beforeEach<strong>在导航触发时被回调</strong>：</p><ul><li>它有<strong>两个参数</strong>：<ul><li>to：即将进入的路由Route对象</li><li>from：即将离开的路由Route对象</li></ul></li><li>它有<strong>返回值</strong>：<ul><li>false：取消当前导航</li><li>不返回或者undefined：进行<strong>默认导航</strong></li><li>返回一个路由地址：<ul><li>可以是一个string类型的路径</li><li>可以是一个对象，对象中包含path、query、params等信息</li></ul></li></ul></li><li>可选的第三个参数：next（不推荐使用）<ul><li>在Vue2中我们是通过next函数来决定如何进行跳转的</li><li>但是在Vue3中我们是通过返回值来控制的，不再推荐使用next函数，这是因为开发中很容易调用多次next</li></ul></li></ul><h3 id="7-2-登录守卫功能"><a href="#7-2-登录守卫功能" class="headerlink" title="7.2 登录守卫功能"></a>7.2 登录守卫功能</h3><ul><li>跳转order组件时, 判断用户是否登录<ul><li>没有登录：<ul><li>跳到登录页面</li><li>进行登录的操作</li><li>在浏览器localStorage保存token</li></ul></li><li>已登录/登录成功：<ul><li>跳到order页面</li></ul></li></ul></li></ul><p><img src="5cb0bf206bbb49c4ba9091cdcf08a05a.png" alt="在这里插入图片描述"></p><p><img src="616e68cc640240b1831b77eeec9614e7.png" alt="在这里插入图片描述"></p><h3 id="7-3-路由导航的流程解析（了解）"><a href="#7-3-路由导航的流程解析（了解）" class="headerlink" title="7.3 路由导航的流程解析（了解）"></a>7.3 路由导航的流程解析（了解）</h3><p>完整的导航解析流程： </p><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ul><h1 id="二、Vuex-状态管理"><a href="#二、Vuex-状态管理" class="headerlink" title="二、Vuex 状态管理"></a>二、Vuex 状态管理</h1><h2 id="1-理解状态管理"><a href="#1-理解状态管理" class="headerlink" title="1. 理解状态管理"></a>1. 理解状态管理</h2><p>在开发中，应用程序需要<strong>处理各种各样的数据</strong>，这些数据需要保存在应用程序中的某一个位置。对于这些数据的管理我们就 称之为是状态管理。</p><p>随着发展，JavaScript需要管理的状态越来越多，越来越复杂</p><ul><li>这些状态包括<strong>服务器返回的数据、缓存数据、用户操作产生的数据等等</strong></li><li>也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页</li><li>多个组件还会共享状态</li></ul><p>此时我们==将组件的内部状态抽离出来==，以一个全局单例的方式来管理</p><ul><li>在这种模式下，我们的组件树构成了一个巨大的 “试图View”</li><li>不管在树的哪个位置，<strong>任何组件都能获取状态或者触发行为</strong></li><li>通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码会变得更加结构化和易于维护、跟踪</li></ul><p><img src="5726e4d23e2141afa018bf226c14c779.png" alt="在这里插入图片描述"></p><h2 id="2-Vuex-基本使用"><a href="#2-Vuex-基本使用" class="headerlink" title="2. Vuex 基本使用"></a>2. Vuex 基本使用</h2><ul><li>安装vuex：<code>npm install vuex</code></li></ul><h3 id="2-1-创建-store"><a href="#2-1-创建-store" class="headerlink" title="2.1 创建 store"></a>2.1 创建 store</h3><p>Vuex应用的核心就是store（仓库）：包含着应用中大部分的状态（state）</p><ul><li>第一：Vuex的<strong>状态存储是响应式的</strong><ul><li>当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会被更新</li></ul></li><li>第二：你<strong>不能直接改变store中的状态</strong><ul><li>改变store中的状态的唯一途径就<strong>显式提交</strong> (commit) 至mutation</li><li>这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态</li></ul></li></ul><p><img src="d37c3ed9c9464e90a3c86dda6f124aaf.png" alt="在这里插入图片描述"></p><p><img src="ef4aa145fd974724b472a770e1c0d08a.png" alt="在这里插入图片描述"></p><h3 id="2-2-组件中使用-store"><a href="#2-2-组件中使用-store" class="headerlink" title="2.2 组件中使用 store"></a>2.2 组件中使用 store</h3><p>在组件中使用store，有三种方式： </p><ul><li>在模板中使用</li><li>在options api中使用，比如computed</li><li>在setup中使用</li></ul><p><img src="c2ad8dcfad35407d8202b8e6f3e58536.png" alt="在这里插入图片描述"></p><h2 id="3-核心概念一：state"><a href="#3-核心概念一：state" class="headerlink" title="3. 核心概念一：state"></a>3. 核心概念一：state</h2><p>Vuex 使用单一状态树，便于维护：</p><ul><li>用一个对象就包含了全部的应用层级的状态</li><li>这也意味着，<strong>每个应用将仅仅包含一个 store 实例</strong></li></ul><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><p>见 2.2 </p><h3 id="3-2-映射使用"><a href="#3-2-映射使用" class="headerlink" title="3.2 映射使用"></a>3.2 映射使用</h3><p>如果我们有<strong>很多个状态都需要获取</strong>，可以使用mapState的辅助函数：</p><ul><li>mapState的方式一：对象类型</li><li>mapState的方式二：数组类型</li><li>也可以使用展开运算符和原有的computed混合在一起</li></ul><p>分为在options api中使用 &amp; 在setup中使用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="app"&gt;&lt;button @click="incrementLevel"&gt;修改level&lt;/button&gt;&lt;!-- 1.在模板中直接使用多个状态 --&gt;&lt;!-- &lt;h2&gt;name: {{ $store.state.name }}&lt;/h2&gt;&lt;h2&gt;level: {{ $store.state.level }}&lt;/h2&gt;&lt;h2&gt;avatar: {{ $store.state.avatarURL }}&lt;/h2&gt; --&gt;&lt;!-- 2.计算属性(映射状态: 数组语法) --&gt;&lt;h2&gt;name: {{ name() }}&lt;/h2&gt;&lt;h2&gt;level: {{ level() }}&lt;/h2&gt;&lt;!-- 3.计算属性(映射状态: 对象语法) --&gt;&lt;h2&gt;name: {{ sName }}&lt;/h2&gt;&lt;h2&gt;level: {{ sLevel }}&lt;/h2&gt;&lt;!-- 4.setup计算属性(映射状态: 对象语法) --&gt;&lt;h2&gt;name: {{ cName }}&lt;/h2&gt;&lt;h2&gt;level: {{ cLevel }}&lt;/h2&gt;&lt;!-- 5.setup计算属性(映射状态: 对象语法) --&gt;&lt;h2&gt;name: {{ name }}&lt;/h2&gt;&lt;h2&gt;level: {{ level }}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState } from "vuex";export default {computed: {fullname() {return "xxx";},...mapState(["name", "level", "avatarURL"]),...mapState({sName: (state) =&gt; state.name,sLevel: (state) =&gt; state.level,}),},};&lt;/script&gt;&lt;script setup&gt;import { computed, toRefs } from "vue";import { mapState, useStore } from "vuex";import useState from "../hooks/useState";// 1.一步步完成// const { name, level } = mapState(["name", "level"])// const store = useStore()// const cName = computed(name.bind({ $store: store }))// const cLevel = computed(level.bind({ $store: store }))// 2.使用useState// const { name, level } = useState(["name", "level"]) // 3.直接对store.state进行解构(推荐)const store = useStore();const { name, level } = toRefs(store.state);function incrementLevel() {store.state.level++;}&lt;/script&gt;</code></pre><h2 id="4-核心概念二：getter"><a href="#4-核心概念二：getter" class="headerlink" title="4. 核心概念二：getter"></a>4. 核心概念二：getter</h2><h3 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1 基本使用"></a>4.1 基本使用</h3><p>某些属性我们可能需要<strong>经过变化后来使用</strong>，这个时候可以使用getters</p><ul><li>第一个参数：state</li><li>第二个参数：getter</li><li>返回值：可以返回一个函数，在使用的地方相当于可以调用这个函数</li></ul><p><img src="790c0ec1d6c6497d9bfe731f47cf7dde.png" alt="在这里插入图片描述"></p><p><img src="fa4482cfdf4c47588727f615bab747c6.png" alt="在这里插入图片描述"></p><h3 id="4-2-映射使用"><a href="#4-2-映射使用" class="headerlink" title="4.2 映射使用"></a>4.2 映射使用</h3><p>如果有多个getter中的函数需要获取，可以使用mapGetters的辅助函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="app"&gt;&lt;button @click="changeAge"&gt;修改name&lt;/button&gt;&lt;h2&gt;doubleCounter: {{ doubleCounter }}&lt;/h2&gt;&lt;h2&gt;friendsTotalAge: {{ totalAge }}&lt;/h2&gt;&lt;h2&gt;message: {{ message }}&lt;/h2&gt;&lt;!-- 根据id获取某一个朋友的信息 --&gt;&lt;h2&gt;id-111的朋友信息: {{ getFriendById(111) }}&lt;/h2&gt;&lt;h2&gt;id-112的朋友信息: {{ getFriendById(112) }}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters } from 'vuex'export default {computed: {...mapGetters(["doubleCounter", "totalAge", "getFriendById"])}}&lt;/script&gt;&lt;script setup&gt;import { computed, toRefs } from 'vue';import { mapGetters, useStore } from 'vuex'const store = useStore()// 1.使用mapGetters// const { message: messageFn } = mapGetters(["message"])// const message = computed(messageFn.bind({ $store: store }))// 2.直接解构, 并且包裹成ref(会报警告)// const { message } = toRefs(store.getters)// 3.针对某一个getters属性使用computed（推荐）const message = computed(() =&gt; store.getters.message)function changeAge() {store.state.name = "kobe"}&lt;/script&gt;</code></pre><h2 id="5-核心概念三：mutations"><a href="#5-核心概念三：mutations" class="headerlink" title="5. 核心概念三：mutations"></a>5. 核心概念三：mutations</h2><p><strong>更改 Vuex 的 store 中的状态</strong>的==唯一方法==是提交 mutation</p><h3 id="5-1-基本使用"><a href="#5-1-基本使用" class="headerlink" title="5.1 基本使用"></a>5.1 基本使用</h3><ul><li>支持传入参数</li><li>Mutation常量类型：为防止在两个文件中的Mutation名称拼写错误，可以将名称定义为一个常量，存入一个mutation-type.js文件中</li></ul><p><img src="11da06fd431644be84137c83fc898d4d.png" alt="在这里插入图片描述"></p><p><img src="32efbfdb3fa240cf9deb1c660d667e1c.png" alt="在这里插入图片描述"></p><p><img src="a08a328e0bc4464dbf216651740eecc7.png" alt="在这里插入图片描述"></p><h3 id="5-2-映射使用"><a href="#5-2-映射使用" class="headerlink" title="5.2 映射使用"></a>5.2 映射使用</h3><p>如果有多个mutation中的函数需要获取，可以使用mapMutations的辅助函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="app"&gt;&lt;button @click="changeName('王小波')"&gt;修改name&lt;/button&gt;&lt;button @click="incrementLevel"&gt;递增level&lt;/button&gt;&lt;button @click="changeInfo({ name: '王二', level: 200 })"&gt;修改info&lt;/button&gt;&lt;h2&gt;Store Name: {{ $store.state.name }}&lt;/h2&gt;&lt;h2&gt;Store Level: {{ $store.state.level }}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapMutations } from "vuex";import { CHANGE_INFO } from "@/store/mutation_types";export default {computed: {},methods: {btnClick() {console.log("btnClick");},...mapMutations(["changeName", "incrementLevel", CHANGE_INFO]),},};&lt;/script&gt;&lt;script setup&gt;import { mapMutations, useStore } from "vuex";import { CHANGE_INFO } from "@/store/mutation_types";const store = useStore();// 1.手动的映射和绑定const mutations = mapMutations(["changeName", "incrementLevel", CHANGE_INFO]);const newMutations = {};Object.keys(mutations).forEach((key) =&gt; {newMutations[key] = mutations[key].bind({ $store: store });});const { changeName, incrementLevel, changeInfo } = newMutations;&lt;/script&gt;</code></pre><h3 id="5-3-重要原则"><a href="#5-3-重要原则" class="headerlink" title="5.3 重要原则"></a>5.3 重要原则</h3><p>一条重要的原则就是要记住 mutation <strong>必须是同步函数</strong></p><ul><li>这是因为devtool工具会记录mutation的日记</li><li>每一条mutation被记录，devtools都需要<strong>捕捉到前一状态和后一状态的快照</strong></li><li>但是在mutation中执行异步操作，就无法追踪到数据的变化</li></ul><h2 id="6-核心概念四：actions"><a href="#6-核心概念四：actions" class="headerlink" title="6. 核心概念四：actions"></a>6. 核心概念四：actions</h2><h3 id="6-1-基本使用"><a href="#6-1-基本使用" class="headerlink" title="6.1 基本使用"></a>6.1 基本使用</h3><p>Action类似于mutation，不同在于：</p><ul><li>Action<strong>提交的是mutation</strong>，而不是直接变更状态</li><li>Action可以<strong>包含任意异步操作</strong></li></ul><p>参数context：</p><ul><li>context是一个对象，<strong>和store实例有相同方法和属性</strong></li><li>所以我们可以从其中获取到commit方法来提交一个mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</li></ul><p><img src="a245708bf9d84573bebdf8ce412d15f6.png" alt="在这里插入图片描述"></p><p><img src="52bab9847829473c99474dc8ea1e4536.png" alt="在这里插入图片描述"></p><h3 id="6-2-映射使用"><a href="#6-2-映射使用" class="headerlink" title="6.2 映射使用"></a>6.2 映射使用</h3><p><img src="16ea5b388e824ed2b09b65fb933d9568.png" alt="在这里插入图片描述"></p><h3 id="6-3-actions-的异步操作"><a href="#6-3-actions-的异步操作" class="headerlink" title="6.3 actions 的异步操作"></a>6.3 actions 的异步操作</h3><p>通常应用于发送网络请求：<br><img src="778f0d8be1564c67aff25774969e9ef2.png" alt="在这里插入图片描述"></p><p>实例：渲染页面banner</p><ul><li>home.vue -&gt; home.js -&gt; actions发送请求</li></ul><p><img src="778f7da245514d8f8ee417a0e07dda53.png" alt="在这里插入图片描述"></p><p><img src="319ec58e2d6a44148c3200ce695c87dd.png" alt="在这里插入图片描述"></p><h2 id="7-核心概念五：modules"><a href="#7-核心概念五：modules" class="headerlink" title="7. 核心概念五：modules"></a>7. 核心概念五：modules</h2><ul><li>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store 对象就有可能变得相当臃肿</li><li>为了解决以上问题，Vuex 允许我们<strong>将 store 分割成模块</strong>（module）</li><li>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</li></ul><h3 id="7-1-module-的基本使用"><a href="#7-1-module-的基本使用" class="headerlink" title="7.1 module 的基本使用"></a>7.1 module 的基本使用</h3><ul><li>抽取到独立对象counter.js：<ul><li>state</li><li>mutations</li><li>getters</li><li>action</li><li>modules: { home: 对象 }</li></ul></li></ul><ul><li>在根文件index.js中引用</li></ul><p><img src="98c7f601961b436ebd863986070e6ad5.png" alt="在这里插入图片描述"></p><p><img src="e188cadff0bb42d98c145a4e309556ed.png" alt="在这里插入图片描述"></p><p><img src="c6667b4b2f2f4ec0aed316067b020f56.png" alt="在这里插入图片描述"></p><ul><li>使用state时，需要指明模块</li><li>使用getters时，不需要</li><li>使用commit时，不需要</li><li>使用dispatch时，不需要</li></ul><h3 id="7-2-module-的命名空间"><a href="#7-2-module-的命名空间" class="headerlink" title="7.2 module 的命名空间"></a>7.2 module 的命名空间</h3><p>默认情况下，模块内部的action和mutation仍然是<strong>注册在全局的命名空间</strong>中的，这样使得多个模块能够对同一个 action 或 mutation 作出响应。==此时需要注意，模块中定义的名称<strong>不要和根模块进行重复</strong>==</p><p>如果我们希望模块具有更高的封装度和复用性，可以添加 <code>namespaced: true</code> 的方式使其成为<strong>带命名空间的模块</strong></p><ul><li>getters[“home/xxx”]</li><li>commit(“home/xxx”)</li><li>dispatch(“home/xxx”)</li></ul><p><img src="9b3d65cf79e74b378caa074b7a44372b.png" alt="在这里插入图片描述"></p><p><img src="a1c659587c7c4970ad3e48cc3b7da8a7.png" alt="在这里插入图片描述"></p><h1 id="三、Pinia-的使用"><a href="#三、Pinia-的使用" class="headerlink" title="三、Pinia 的使用"></a>三、Pinia 的使用</h1><h2 id="1-Pinia-的介绍和-Vuex-的区别（面试）"><a href="#1-Pinia-的介绍和-Vuex-的区别（面试）" class="headerlink" title="1. Pinia 的介绍和 Vuex 的区别（面试）"></a>1. Pinia 的介绍和 Vuex 的区别（面试）</h2><ul><li>pinia是一个用于对状态进行管理的库，跨组件跨页面对状态进行共享<ul><li>与vuex和redux在作用上并无区别</li></ul></li><li><strong>核心区别</strong><ul><li>pinia<strong>没有mutations选项</strong>，因为mutations的出现解决的问题是让devtools进行状态追踪<ul><li>我们可以在任意组件中拿到store然后直接修改state中的任意值</li></ul></li><li>不再需要modules这样的嵌套结构，取而代之的是<strong>可以创建一个个store</strong><ul><li>可以在一个组件中拿任意数量的store</li><li>除此之外你还可以在某个store中拿另外的store，然后使用store中的任何东西</li></ul></li></ul></li><li><strong>使用上的区别</strong><ul><li>使用state<ul><li>在vuex中使用某个state时，需要$store.state.xxx</li><li>在pinia中直接拿到store之后store.xxx即可</li></ul></li><li>使用getter<ul><li>在vuex中使用某个getter函数时，需要$store.getters.xxx</li><li>在pinia中拿到store后，store.xxx即可</li></ul></li><li>使用action<ul><li>在vuex中进行异步请求需要派发action函数</li><li>在pinia中拿到store后，直接调用action函数即可</li></ul></li></ul></li></ul><h2 id="2-Pinia-的安装和基本使用"><a href="#2-Pinia-的安装和基本使用" class="headerlink" title="2. Pinia 的安装和基本使用"></a>2. Pinia 的安装和基本使用</h2><ul><li>安装：<code>npm install pinia</code></li></ul><ul><li>在根文件中createPinia</li><li>app.use</li></ul><p><img src="182ac9b2d70b43e69cd2c4f1ecfbac1e.png" alt="在这里插入图片描述"></p><p><img src="dc8f1de4fe8b48fb9e854b577b1b81b6.png" alt="在这里插入图片描述"></p><h3 id="2-1-定义一个-store"><a href="#2-1-定义一个-store" class="headerlink" title="2.1 定义一个 store"></a>2.1 定义一个 store</h3><ul><li>store 是<strong>使用 defineStore()</strong> 定义的</li><li>并且它需要一个<strong>唯一名称</strong>，作为第一个参数传递</li></ul><p><img src="cb9d8d2e81174930b9d56d9df3c9981b.png" alt="在这里插入图片描述"></p><h3 id="2-2-使用定义的-store"><a href="#2-2-使用定义的-store" class="headerlink" title="2.2 使用定义的 store"></a>2.2 使用定义的 store</h3><ul><li>可以通过<strong>调用use函数</strong>来使用store</li><li>为了从 Store 中提取属性<strong>同时保持响应式</strong>，您需要使用storeToRefs()</li></ul><p><img src="f9081fd301f04a59bf572353df45573e.png" alt="在这里插入图片描述"></p><h2 id="3-Pinia-核心一：state"><a href="#3-Pinia-核心一：state" class="headerlink" title="3. Pinia 核心一：state"></a>3. Pinia 核心一：state</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="home"&gt;&lt;h2&gt;Home View&lt;/h2&gt;&lt;h2&gt;name: {{ name }}&lt;/h2&gt;&lt;h2&gt;age: {{ age }}&lt;/h2&gt;&lt;h2&gt;level: {{ level }}&lt;/h2&gt;&lt;button @click="changeState"&gt;修改state&lt;/button&gt;&lt;button @click="resetState"&gt;重置state&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import useUser from "@/stores/user";import { storeToRefs } from "pinia";const userStore = useUser();const { name, age, level } = storeToRefs(userStore);function changeState() {// 1.一个个修改状态userStore.name = "kobe";userStore.age = 20;userStore.level = 200;// 2.一次性修改多个状态// userStore.$patch({//   name: "james",//   age: 35// })// 3.替换state为新的对象// const oldState = userStore.$state// userStore.$state = {//   name: "curry",//   level: 200// }// console.log(oldState === userStore.$state) // true}function resetState() {userStore.$reset();}&lt;/script&gt;</code></pre><h2 id="4-Pinia-核心二：getters"><a href="#4-Pinia-核心二：getters" class="headerlink" title="4. Pinia 核心二：getters"></a>4. Pinia 核心二：getters</h2><ul><li>getters中可以定义接受一个state作为参数的函数</li><li>getters访问自己的其他getters：通过==this来访问到当前store实例的所有其他属性==（this是store实例）</li><li>getters中可以<strong>访问其他store的getter</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 定义关于counter的storeimport { defineStore } from "pinia";// 引入其他moduleimport useUser from "./user";const useCounter = defineStore("counter", {state: () =&gt; ({count: 99,friends: [{ id: 111, name: "why" },{ id: 112, name: "kobe" },{ id: 113, name: "james" },],}),getters: {// 1.基本使用doubleCount(state) {return state.count * 2;},// 2.一个getter引入另外一个getterdoubleCountAddOne() {// this是store实例return this.doubleCount + 1;},// 3.getters也支持返回一个函数getFriendById(state) {return function (id) {for (let i = 0; i &lt; state.friends.length; i++) {const friend = state.friends[i];if (friend.id === id) {return friend;}}};},// 4.getters中用到别的store中的数据showMessage(state) {// 1.获取user信息const userStore = useUser();// 2.拼接信息return `name:${userStore.name}-count:${state.count}`;},},actions: {increment() {this.count++;},incrementNum(num) {this.count += num;},},});export default useCounter;</code></pre><p><img src="c1ccb550dd1e4f9380a60035635c4809.png" alt="在这里插入图片描述"></p><h2 id="5-Pinia-核心三：actions"><a href="#5-Pinia-核心三：actions" class="headerlink" title="5. Pinia 核心三：actions"></a>5. Pinia 核心三：actions</h2><h3 id="5-1-基本使用-1"><a href="#5-1-基本使用-1" class="headerlink" title="5.1 基本使用"></a>5.1 基本使用</h3><p>在action中可以<strong>通过this访问整个store实例的所有操作</strong></p><p><img src="c8e02c004d6347ee8634f709be337f8c.png" alt="在这里插入图片描述"></p><h3 id="5-2-执行异步操作"><a href="#5-2-执行异步操作" class="headerlink" title="5.2 执行异步操作"></a>5.2 执行异步操作</h3><p><img src="4a0f09cfa5ea47908c897394c37be424.png" alt="在这里插入图片描述"></p><h1 id="四、axios-库"><a href="#四、axios-库" class="headerlink" title="四、axios 库"></a>四、axios 库</h1><p>功能特点: </p><ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据等等</li></ul><p>相比与原生fetch，axios自动适配浏览器和node.js，同时还提供多种附加功能（拦截请求等）</p><h2 id="1-axios-发送请求"><a href="#1-axios-发送请求" class="headerlink" title="1. axios 发送请求"></a>1. axios 发送请求</h2><p><img src="d2943269f55c4891a0c18241676e0e94.png" alt="在这里插入图片描述"></p><p><img src="e82b64b4b9d64db0acb4ff6fdc5f2acf.png" alt="在这里插入图片描述"></p><p><img src="1a04b982e6e740ce9bba8421e82b89af.png" alt="在这里插入图片描述"></p><h3 id="1-1-axios-额外补充"><a href="#1-1-axios-额外补充" class="headerlink" title="1.1 axios 额外补充"></a>1.1 axios 额外补充</h3><ul><li>axios.defaults.baseURL</li><li>axios.defaults.timeout/headers</li><li>axios.all -&gt; Promise.all</li></ul><p><img src="c4d62dfa598348f1bcb04f3dd62c174b.png" alt="在这里插入图片描述"></p><h2 id="2-axios-创建实例"><a href="#2-axios-创建实例" class="headerlink" title="2. axios 创建实例"></a>2. axios 创建实例</h2><ul><li><p>为什么需要创建实例</p><ul><li>当我们从axios模块中导入对象时, 使用的实例是<strong>默认的实例</strong><ul><li>当给该实例设置一些默认配置时, <strong>这些配置就被固定下来</strong>了。</li><li>但是后续开发中, 某些配置可能会不太一样。比如某些请求需要使用特定的baseURL或者timeout等.</li></ul></li><li>这个时候, 我们就可以<strong>创建新的实例</strong>, 并且传入属于该实例的配置信息</li></ul></li><li><p>axios.create()</p></li></ul><p><img src="1c45e79085a446e9b0a5baafa9dd8568.png" alt="在这里插入图片描述"></p><h2 id="3-axios-的拦截器"><a href="#3-axios-的拦截器" class="headerlink" title="3. axios 的拦截器"></a>3. axios 的拦截器</h2><p>axios的也可以设置拦截器：<strong>拦截每次请求和响应</strong></p><ul><li>axios.interceptors.request.use(请求成功拦截, 请求失败拦截)</li><li>axios.interceptors.response.use(响应成功拦截, 响应失败拦截)</li></ul><p><img src="d5c1b01c500945398f21911ff8572f3f.png" alt="在这里插入图片描述"></p><h2 id="4-axios-的简洁封装"><a href="#4-axios-的简洁封装" class="headerlink" title="4. axios 的简洁封装"></a>4. axios 的简洁封装</h2><p>在项目中，我们会在多个地方使用到axios进行网络请求。但如果axios库发生停止维护的情况时，需要利用别的库进行替代。<br>此时一一替换非常不方便，因此我们事先对axios进行封装。</p><p>在service文件夹中index.js进行封装</p><p><img src="18ff03bf918a4da495c9c012b380e211.png" alt="在这里插入图片描述"></p><p>使用时引入该文件即可：</p><p><img src="6b0468bb16684ea6b264acb81c519007.png" alt="在这里插入图片描述"></p><h1 id="五、项目实战"><a href="#五、项目实战" class="headerlink" title="五、项目实战"></a>五、项目实战</h1><h2 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1. 项目准备"></a>1. 项目准备</h2><h3 id="1-1-项目目录结构划分"><a href="#1-1-项目目录结构划分" class="headerlink" title="1.1 项目目录结构划分"></a>1.1 项目目录结构划分</h3><p><img src="264846b3f3df4501be041eaa86e346b3.png" alt="在这里插入图片描述"></p><h3 id="1-2-CSS样式的重置"><a href="#1-2-CSS样式的重置" class="headerlink" title="1.2 CSS样式的重置"></a>1.2 CSS样式的重置</h3><p>对默认CSS样式进行重置: </p><ul><li>common.css</li><li>reset.css</li><li>index.css：所有css文件的接口</li></ul><p><img src="d284e927cb4047f08baf08ed5af5e23b.png" alt="在这里插入图片描述"></p><h3 id="1-3-路由配置和状态管理"><a href="#1-3-路由配置和状态管理" class="headerlink" title="1.3 路由配置和状态管理"></a>1.3 路由配置和状态管理</h3><p><img src="68ee3e1233ea4c0396c7cb4ac8c7cc20.png" alt="在这里插入图片描述"></p><p><img src="c35b3176e3b040c99c8bf1a323aa3996.png" alt="在这里插入图片描述"></p><h2 id="2-Tips"><a href="#2-Tips" class="headerlink" title="2. Tips"></a>2. Tips</h2><ol><li>动态绑定图片的相对路径，需要使用getAssetURL()</li></ol><p><img src="13ebd4f08d964e37ba8c703c8abb99f2.png" alt="在这里插入图片描述"></p><p>封装一个工具utils：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// load_assets.jsexport const getAssetURL = (image) =&gt; {// 参数一: 相对路径// 参数二: 当前路径的URLreturn new URL(`../assets/img/${image}`, import.meta.url).href}</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;img :src="getAssetURL(item.image)" alt="" /&gt;&lt;/template&gt;&lt;script setup&gt;import { getAssetURL } from "@/utils/load_assets.js";&lt;/script&gt;</code></pre><hr><ol start="2"><li>善用组件库</li></ol><p><a href="http://vant-contrib.gitee.io/vant/v3/#/zh-CN/quickstart">http://vant-contrib.gitee.io/vant/v3/#/zh-CN/quickstart</a></p><hr><ol start="3"><li>使一整页（city模块）覆盖掉底部的tab-bar：</li></ol><p>封装一个class到common.css中</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.top-page {position: relative;z-index: 9;height: 100vh;background-color: #fff;overflow-y: auto;}</code></pre><p>使用时直接添加top-page即可<br><img src="8f8170459d6f478daa2b8154675e1687.png" alt="在这里插入图片描述"></p><hr><ol start="4"><li>滑动city模块中的content，固定top组件</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css">.city {// 布局滚动.content {height: calc(100vh - 98px); // 98px为top的高度overflow-y: auto;}}</code></pre><hr><ol start="5"><li>请求数据</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!-- city.vue --&gt;// 从Store中获取数据const cityStore = useCityStore()cityStore.fetchAllCitiesData()const { allCities } = storeToRefs(cityStore)&lt;!--  store-&gt;modules-&gt;city.js  --&gt;import { getCityAll } from "@/services";import { defineStore } from "pinia";const useCityStore = defineStore("city", {state: () =&gt; ({allCities: {},currentCity: {cityName: "广州"}}),// 通过axios发送数据请求，得到的数据存储在store中actions: {async fetchAllCitiesData() {const res = await getCityAll()this.allCities = res.data}}})export default useCityStore&lt;!--  services-&gt;modules-&gt;city.js  --&gt;// 通过axios发送数据请求import hyRequest from '../request' // 对axios组件的再封装export function getCityAll() {return hyRequest.get({url: "/city/all"})}</code></pre><ol start="5"><li><p>格式化日期：npm install dayjs</p></li><li><p>防抖/节流函数：npm install underscore</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 知识大总结（三）Composition API</title>
      <link href="/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89Composition-API/"/>
      <url>/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89Composition-API/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Composition-API（一）"><a href="#一、Composition-API（一）" class="headerlink" title="一、Composition API（一）"></a>一、Composition API（一）</h1><h2 id="1-认识组合-API"><a href="#1-认识组合-API" class="headerlink" title="1. 认识组合 API"></a>1. 认识组合 API</h2><ul><li>==Composition API==：组件根据逻辑功能来组织的，<strong>一个功能所定义的所有 API 会放在一起</strong>（更加的高内聚，低耦合）</li><li>==Options API==：在对应的属性中编写对应的功能模块,  比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子<ul><li>弊端:  当我们实现某一个功能时，这个功能<strong>对应的代码逻辑会被拆分到各个属性中</strong>。当组件变得复杂，对应属性的列表也会增长，这可能会导致组件难以阅读和理解</li></ul></li><li>==两者区别==：<ul><li>在逻辑组织和逻辑复用方面，Composition API是优于Options API<ul><li>因为Composition API几乎是函数，会有更好的类型推断。</li><li>Composition API对 tree-shaking 友好，代码也更容易压缩</li><li>Composition API中见不到this的使用，减少了this指向不明的情况</li></ul></li></ul></li></ul><h2 id="2-setup-函数"><a href="#2-setup-函数" class="headerlink" title="2. setup 函数"></a>2. setup 函数</h2><p>setup 函数可以替代之前所编写的大部分其他选项：比如methods、computed、watch、data、生命周期等等</p><h3 id="2-1-setup-函数的参数"><a href="#2-1-setup-函数的参数" class="headerlink" title="2.1 setup 函数的参数"></a>2.1 setup 函数的参数</h3><ul><li>setup函数的参数：<ul><li><code>props</code>：<strong>父组件传递过来的属性</strong>会被放到props对象中，我们在setup中如果需要使用，那么就可以直接 通过props参数获取<ul><li>对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义</li><li>在template中依然是可以正常去使用props中的属性，比如message</li><li>如果我们在setup函数中想要使用props，那么<strong>不可以通过 this 去获取</strong></li><li>因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可</li></ul></li><li><code>context</code>：里面包含三个属性<ul><li>attrs：所有的非prop的attribute</li><li>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）</li><li>emit：当我们组件内部需要<strong>发出事件</strong>时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）</li></ul></li></ul></li></ul><h3 id="2-2-setup-函数的返回值"><a href="#2-2-setup-函数的返回值" class="headerlink" title="2.2 setup 函数的返回值"></a>2.2 setup 函数的返回值</h3><p>setup的返回值可以在模板template中被使用</p><ul><li>可以通过setup的返回值来<strong>替代data选项</strong></li><li>可以返回一个执行函数来<strong>代替在methods</strong>中定义的方法<br>注意：</li><li>对于定义的变量，默认情况下，Vue并<strong>不会跟踪它的变化，来引起界面的响应式操作</strong></li></ul><h3 id="2-3-setup-不可以使用-this"><a href="#2-3-setup-不可以使用-this" class="headerlink" title="2.3 setup 不可以使用 this"></a>2.3 setup 不可以使用 this</h3><p>在setup被调用之前，data、computed、methods等都没有被解析，<strong>this并没有指向当前组件实例</strong></p><h2 id="3-setup-中数据的响应式"><a href="#3-setup-中数据的响应式" class="headerlink" title="3. setup 中数据的响应式"></a>3. setup 中数据的响应式</h2><h3 id="3-1-reactive-定义响应式数据"><a href="#3-1-reactive-定义响应式数据" class="headerlink" title="3.1 reactive 定义响应式数据"></a>3.1 reactive 定义响应式数据</h3><p><strong>使用reactive的函数，可以使setup中定义的数据（多为复杂类型）提供响应式的特性。</strong></p><ul><li>这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集</li><li>当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）</li><li>事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程响应式对象的</li></ul><p>reactive API对<strong>传入的类型</strong>是有限制的，它要求我们必须传入的是一个<strong>对象或者数组类型</strong></p><h4 id="3-1-1-reactive-判断的-API"><a href="#3-1-1-reactive-判断的-API" class="headerlink" title="3.1.1 reactive 判断的 API"></a>3.1.1 reactive 判断的 API</h4><p><img src="add4f17428a34dfc937c55e393c44e94.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-toRefs"><a href="#3-1-2-toRefs" class="headerlink" title="3.1.2 toRefs"></a>3.1.2 toRefs</h4><p>对reactive<strong>返回的对象进行解构</strong>获取值，那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，<strong>数据都不再是响应式</strong>的：</p><ul><li>使用toRefs的函数，可以将reactive返回的对象中的属性都转成ref</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;h2&gt;info: {{ name }} - {{ age }} - {{ height }}&lt;/h2&gt;&lt;button @click="age++"&gt;修改age&lt;/button&gt;&lt;button @click="height = 1.89"&gt;修改height&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, toRefs, toRef } from 'vue'export default {setup() {const info = reactive({name: "why",age: 18,height: 1.88})// reactive被解构后会变成普通的值, 失去响应式，需要使用toRef(s)const { name, age } = toRefs(info)const height = toRef(info, "height")return {name,age,height}}}&lt;/script&gt;</code></pre><h3 id="3-2-ref-定义响应式数据"><a href="#3-2-ref-定义响应式数据" class="headerlink" title="3.2 ref 定义响应式数据"></a>3.2 ref 定义响应式数据</h3><p>ref 会<strong>返回一个可变的响应式对象</strong>，该对象作为一个响应式的引用维护着它内部的值，这就是ref名称的来源</p><p>注意：</p><ul><li><strong>在模板中</strong>引入ref的值时，Vue会<strong>自动进行解包</strong>（浅层解包）操作，所以我们并不需要在模板中通过 ref.value 的方式来使用</li><li>如果将ref放到一个reactive的属性当中，那么在<strong>模板中</strong>使用时，它会<strong>自动解包</strong></li><li>但是在 <strong>setup 函数内部</strong>，它依然是一个 ref引用， 所以对其进行操作时，我们依然需要<strong>使用 ref.value</strong>的方式</li></ul><h4 id="3-2-1-ref-判断的-API"><a href="#3-2-1-ref-判断的-API" class="headerlink" title="3.2.1 ref 判断的 API"></a>3.2.1 ref 判断的 API</h4><p><img src="2e70ed67607741f585fc9cca9e4715ef.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;h2&gt;message: {{ message }}&lt;/h2&gt;&lt;button @click="changeMessage"&gt;修改message&lt;/button&gt;&lt;hr&gt;&lt;h2&gt;账号: {{ account.username }}&lt;/h2&gt;&lt;h2&gt;密码: {{ account.password }}&lt;/h2&gt;&lt;button @click="changeAccount"&gt;修改账号&lt;/button&gt;&lt;hr&gt;&lt;!-- 默认情况下在template中使用ref时, vue会自动对其进行解包(取出其中value) --&gt;&lt;h2&gt;当前计数: {{ counter }}&lt;/h2&gt;&lt;button @click="increment"&gt;+1&lt;/button&gt;&lt;button @click="counter++"&gt;+1&lt;/button&gt;&lt;hr&gt;&lt;!-- 使用的时候需要写.value --&gt;&lt;h2&gt;当前计数: {{ info.counter.value }}&lt;/h2&gt;&lt;!-- 修改的时候不需要写.value --&gt;&lt;h2&gt;当前计数: {{ info1.counter }}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref } from 'vue'export default {setup() {// 1.定义普通的数据: 可以正常的被使用// 缺点: 数据不是响应式的let message = "Hello World"function changeMessage() {message = "你好啊,李银河!" // 页面上的 message 不会更改console.log(message)}// 2.定义响应式数据// 2.1.reactive函数: 定义复杂类型的数据const account = reactive({username: "coderwhy",password: "123456"})function changeAccount() {account.username = "kobe"}// 2.2.ref函数: 定义简单类型的数据(也可以定义复杂类型的数据)// counter定义响应式数据const counter = ref(0)function increment() {counter.value++}// 3.ref是浅层解包const info = {counter}const info1 = reactive({counter})return {message,changeMessage,account,changeAccount,counter,increment,info}}}&lt;/script&gt;</code></pre><h3 id="3-3-开发中选择-reactive-ref"><a href="#3-3-开发中选择-reactive-ref" class="headerlink" title="3.3 开发中选择 reactive/ref"></a>3.3 开发中选择 reactive/ref</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;form&gt;账号: &lt;input type="text" v-model="account.username"&gt;密码: &lt;input type="password" v-model="account.password"&gt;&lt;/form&gt;&lt;show-info :name="name" :age="age"&gt;&lt;/show-info&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { onMounted, reactive, ref } from 'vue'import ShowInfo from './ShowInfo.vue'export default {components: {ShowInfo},data() {return {message: "Hello World"}},setup() {// 定义响应式数据: reactive/ref// 强调: ref也可以定义复杂的数据const info = ref({})console.log(info.value)// 1.reactive的应用场景// 1.1.条件一: reactive应用于本地的数据// 1.2.条件二: 多个数据之间是有关系/联系(聚合的数据, 组织在一起会有特定的作用)const account = reactive({username: "coderwhy",password: "1234567"})// 2.ref的应用场景: 其他的场景基本都用ref(computed)// 2.1.定义本地的一些简单数据const name = ref("why")const age = ref(18)// 2.定义从网络中获取的数据也是使用ref// const musics = reactive([])const musics = ref([])onMounted(() =&gt; {const serverMusics = ["海阔天空", "小苹果", "野狼"]musics.value = serverMusics})return {account,name,age}}}&lt;/script&gt;</code></pre><h3 id="3-4-readonly-的使用"><a href="#3-4-readonly-的使用" class="headerlink" title="3.4 readonly 的使用"></a>3.4 readonly 的使用</h3><h4 id="3-4-1-单项数据流"><a href="#3-4-1-单项数据流" class="headerlink" title="3.4.1 单项数据流"></a>3.4.1 单项数据流</h4><p>我们传入给其他地方（组件）的这个响应式对象希望<strong>在另外一个地方（组件）被使用，但是不能被修改</strong></p><h4 id="3-4-2-readonly"><a href="#3-4-2-readonly" class="headerlink" title="3.4.2 readonly"></a>3.4.2 readonly</h4><p>常见的readonly方法会<strong>传入三个类型的参数</strong>：</p><ul><li>类型一：普通对象</li><li>类型二：reactive返回的对象</li><li>类型三：ref的对象</li></ul><p>规则：</p><ul><li>readonly<strong>返回的对象都是不允许修改</strong>的</li><li>但是经过readonly处理的<strong>原来的对象允许修改</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;h2&gt;App: {{ info }}&lt;/h2&gt;&lt;show-info:roInfo="roInfo"@changeRoInfoName="changeRoInfoName"&gt;&lt;/show-info&gt;&lt;/template&gt;&lt;script&gt;import { reactive, readonly } from 'vue'import ShowInfo from './ShowInfo.vue'export default {components: {ShowInfo},setup() {// 本地定义多个数据, 都需要传递给子组件// name/age/heightconst info = reactive({name: "why",age: 18,height: 1.88})// 使用readOnly包裹infoconst roInfo = readonly(info)function changeRoInfoName(payload) {info.name = payload}return {roInfo,changeRoInfoName}}}&lt;/script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// ShowInfo.vue&lt;template&gt;&lt;div&gt;&lt;!-- 想修改info中内容的正确做法: 符合单项数据流--&gt;&lt;!-- 使用readonly的数据 --&gt;&lt;h2&gt;ShowInfo: {{ roInfo }}&lt;/h2&gt;&lt;!-- 代码就会无效(报警告) --&gt;&lt;!-- &lt;button @click="roInfo.name = 'james'"&gt;ShowInfo按钮&lt;/button&gt; --&gt;&lt;button @click="roInfoBtnClick"&gt;roInfo按钮&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {props: {// reactive数据info: {type: Object,default: () =&gt; ({})},// readonly数据roInfo: {type: Object,default: () =&gt; ({})}},emits: ["changeRoInfoName"],setup(props, context) {function roInfoBtnClick() {context.emit("changeRoInfoName", "james")}return {roInfoBtnClick}}}&lt;/script&gt;</code></pre><h1 id="二、Composition-API（二）"><a href="#二、Composition-API（二）" class="headerlink" title="二、Composition API（二）"></a>二、Composition API（二）</h1><h2 id="1-computed-函数使用（重要）"><a href="#1-computed-函数使用（重要）" class="headerlink" title="1. computed 函数使用（重要）"></a>1. computed 函数使用（重要）</h2><p>可以在 setup 函数中使用 computed 方法来编写一个计算属性：</p><ul><li><strong>接收一个getter函数</strong>，返回一个不变的 ref 对象</li><li><strong>接收一个具有 get 和 set 的对象</strong>，返回一个可变的（可读写）ref 对象</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;button @click="setFullname"&gt;设置fullname&lt;/button&gt;&lt;h2&gt;{{ scoreLevel }}&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;import { reactive, computed, ref } from "vue";export default {// 原Options API写法// computed: {//   fullname() {//     return this.firstName + this.lastName;//   },// },setup() {// 1.定义fullnameconst names = reactive({firstName: "kobe",lastName: "bryant",});// 方法一// const fullname = computed(() =&gt; {//   return names.firstName + " " + names.lastName// })// 方法二const fullname = computed({set: function (newValue) {const tempNames = newValue.split(" ");names.firstName = tempNames[0];names.lastName = tempNames[1];},get: function () {return names.firstName + " " + names.lastName;},});function setFullname() {fullname.value = "coder why";console.log(names);} // 此时可以更改数据// 2.定义scoreconst score = ref(89);const scoreLevel = computed(() =&gt; {return score.value &gt;= 60 ? "及格" : "不及格"});return {names,fullname,setFullname,scoreLevel,};},};&lt;/script&gt;</code></pre><h2 id="2-ref-获取元素-组件（半重要）"><a href="#2-ref-获取元素-组件（半重要）" class="headerlink" title="2. ref 获取元素/组件（半重要）"></a>2. ref 获取元素/组件（半重要）</h2><p>定义一个ref对象，绑定到元素或者组件的ref属性上即可</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;!-- 1.获取元素 --&gt;&lt;h2 ref="titleRef"&gt;我是标题&lt;/h2&gt;&lt;button ref="btnRef"&gt;按钮&lt;/button&gt;&lt;!-- 2.获取组件实例 --&gt;&lt;show-info ref="showInfoRef"&gt;&lt;/show-info&gt;&lt;/template&gt;&lt;script&gt;import { ref, onMounted } from 'vue'import ShowInfo from './ShowInfo.vue'export default {components: {ShowInfo},setup() {const titleRef = ref()const btnRef = ref()const showInfoRef = ref()// mounted的生命周期函数onMounted(() =&gt; {console.log(titleRef.value)console.log(btnRef.value)console.log(showInfoRef.value)// 取ShowInfo.vue中的函数 showInfoRef.value.showInfoFoo()})return {titleRef,btnRef,showInfoRef}}}&lt;/script&gt;</code></pre><h2 id="3-生命周期注册函数（重要）"><a href="#3-生命周期注册函数（重要）" class="headerlink" title="3. 生命周期注册函数（重要）"></a>3. 生命周期注册函数（重要）</h2><p>使用<strong>直接导入的 onX 函数</strong>注册生命周期钩子，<code>beforeCreate</code>、<code>created</code>不再需要了</p><p><img src="a48f18fd7c434aceab0c0e1b28558afd.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;AppContent&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { onMounted, onUpdated, onUnmounted } from 'vue'export default {// beforeCreate() {// },// created() {// },// beforeMount() {// },// mounted() {// },// beforeUpdate() {// },// updated() {// }setup() {// 在执行setup函数的过程中, 你需要注册别的生命周期函数onMounted(() =&gt; {console.log("onmounted")})}}&lt;/script&gt;</code></pre><h2 id="4-provide-inject-函数"><a href="#4-provide-inject-函数" class="headerlink" title="4. provide/inject 函数"></a>4. provide/inject 函数</h2><p>通过 provide 方法来定义每个 Property，可以传<strong>入两个参数</strong>：</p><ul><li>name：提供的属性名称</li><li>value：提供的属性值</li></ul><p>通过 inject 来注入需要的属性和对应的值，可以<strong>传入两个参数</strong>：</p><ul><li>要 inject 的 property 的 name</li><li>默认值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div&gt;AppContent: {{ name }}&lt;/div&gt;&lt;button @click="name = 'kobe'"&gt;app btn&lt;/button&gt;&lt;show-info&gt;&lt;/show-info&gt;&lt;/template&gt;&lt;script&gt;import { provide, ref } from 'vue'import ShowInfo from './ShowInfo.vue'export default {components: {ShowInfo},setup() {const name = ref("why")provide("name", name)provide("age", 18)return {name}}}&lt;/script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// ShowInfo.vue&lt;template&gt;&lt;div&gt;ShowInfo: {{ name }}-{{ age }}-{{ height }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { inject } from 'vue'export default {// inject的options api注入, 那么依然需要手动来解包// inject: ["name", "age"],setup() {const name = inject("name")const age = inject("age")const height = inject("height", 1.88)return {name,age,height}}}&lt;/script&gt;</code></pre><h2 id="5-watch-watchEffect（半重要）"><a href="#5-watch-watchEffect（半重要）" class="headerlink" title="5. watch/watchEffect（半重要）"></a>5. watch/watchEffect（半重要）</h2><p>可以通过watch选项来<strong>侦听data或者props的数据变化</strong>，当数据变化时执行某一些操作</p><ul><li>watchEffect：用于自动收集响应式数据的依赖</li><li>watch：需要手动指定侦听的数据源</li><li><strong>区别</strong>：<ol><li>watch监听到改变, 可以<strong>拿到改变前后value</strong></li><li>watchEffect<strong>默认直接执行一次</strong>, watch在不设置immediate第一次是不执行</li></ol></li></ul><h3 id="5-1-watch-的使用"><a href="#5-1-watch-的使用" class="headerlink" title="5.1 watch 的使用"></a>5.1 watch 的使用</h3><ul><li>watch需要<strong>侦听特定的数据源</strong>，并且执行其回调函数</li><li>默认情况下它是<strong>惰性</strong>的，只有当被侦听的源发生变化时才会执行回调</li><li>侦听器还可以使用数组<strong>同时侦听多个源</strong></li><li>可以设置选项：deep、immediate</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;AppContent&lt;/div&gt;&lt;button @click="message = '你好啊,李银河!'"&gt;修改message&lt;/button&gt;&lt;button @click="info.friend.name = 'james'"&gt;修改info&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref, watch } from 'vue'export default {setup() {// 1.定义数据const message = ref("Hello World")const message2 = ref("Hello World2")const info = reactive({name: "why",age: 18,friend: {name: "kobe"}})// 2.侦听数据的变化watch(message, (newValue, oldValue) =&gt; {console.log(newValue, oldValue)})watch(info, (newValue, oldValue) =&gt; {console.log(newValue, oldValue)console.log(newValue === oldValue)}, {immediate: true})// 3.监听reactive数据变化后, 获取普通对象watch(() =&gt; ({ ...info }), (newValue, oldValue) =&gt; {console.log(newValue, oldValue)}, {immediate: true,deep: true})// 侦听多个数据源watch([message, message2], (newValue, oldValue) =&gt; {console.log(newValue, oldValue)})return {message,message2,info}}}&lt;/script&gt;</code></pre><h3 id="5-2-watchEffect-的使用"><a href="#5-2-watchEffect-的使用" class="headerlink" title="5.2 watchEffect 的使用"></a>5.2 watchEffect 的使用</h3><ul><li>首先，watchEffect传入的函数会<strong>被立即执行一次</strong>，并且在执行的过程中会收集依赖</li><li>其次，只有收集的依赖发生变化时，watchEffect传入的函数才会<strong>再次执行</strong></li><li>希望停止侦听，获取watchEffect的<strong>返回值函数，调用该函数</strong>即可</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;h2&gt;当前计数: {{ counter }}&lt;/h2&gt;&lt;button @click="counter++"&gt;+1&lt;/button&gt;&lt;button @click="name = 'kobe'"&gt;修改name&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { watchEffect, watch, ref } from 'vue'export default {setup() {const counter = ref(0)const name = ref("why")// watch(counter, (newValue, oldValue) =&gt; {})// 1.watchEffect传入的函数默认会直接被执行// 2.在执行的过程中, 会自动的收集依赖(依赖哪些响应式的数据)const stopWatch = watchEffect(() =&gt; {console.log("-------", counter.value, name.value)// 判断counter.value &gt; 10，停止侦听if (counter.value &gt;= 10) {stopWatch()}})return {counter,name}}}&lt;/script&gt;</code></pre><h2 id="6-自定义-Hook-的练习-思想"><a href="#6-自定义-Hook-的练习-思想" class="headerlink" title="6. 自定义 Hook 的练习(思想)"></a>6. 自定义 Hook 的练习(思想)</h2><h3 id="6-1-useCounter"><a href="#6-1-useCounter" class="headerlink" title="6.1 useCounter"></a>6.1 useCounter</h3><p>对counter逻辑进行抽取：</p><p><img src="fafbdf3529c446a4ac77fcc9c5327338.png" alt="在这里插入图片描述"></p><h3 id="6-2-useTitle"><a href="#6-2-useTitle" class="headerlink" title="6.2 useTitle"></a>6.2 useTitle</h3><p>修改title的Hook：</p><p><img src="c1e3764e6849475797e8c46de73c0eee.png" alt="在这里插入图片描述"></p><h3 id="6-3-useScrollPosition"><a href="#6-3-useScrollPosition" class="headerlink" title="6.3 useScrollPosition"></a>6.3 useScrollPosition</h3><p>监听界面滚动位置的Hook：</p><p><img src="5098051e350c4effbf3f051aa581ae92.png" alt="在这里插入图片描述"></p><h2 id="7-setup-语法糖（重要）"><a href="#7-setup-语法糖（重要）" class="headerlink" title="7. setup 语法糖（重要）"></a>7. setup 语法糖（重要）</h2><ul><li>当使用<code>&lt;script setup&gt;</code> 的时候，任何在 <code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 都能<strong>在模板template中直接使用</strong></li><li>import 导入的组件可以直接使用，不需要引入</li><li>在<strong>声明 props 和 emits 选项</strong>时获得完整的类型推断支持，可以使用 <code>defineProps</code> 和 <code>defineEmits</code> API</li><li>通过<strong>模板 ref 或者 $parent 链获取到的组件</strong>的公开实例，不会暴露在任何<code>&lt;script setup&gt;</code>中。通过<code>defineExpose</code>解决</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div&gt;AppContent: {{ message }}&lt;/div&gt;&lt;button @click="changeMessage"&gt;修改message&lt;/button&gt;&lt;show-info name="why":age="18"@info-btn-click="infoBtnClick"ref="showInfoRef"&gt;&lt;/show-info&gt;&lt;/template&gt;&lt;script setup&gt;// 1.所有编写在顶层中的代码, 都是默认暴露给template可以使用import { ref, onMounted } from 'vue'import ShowInfo from './ShowInfo.vue'// 2.定义响应式数据const message = ref("Hello World")console.log(message.value)// 3.定义绑定的函数function changeMessage() {message.value = "你好啊, 李银河!"}function infoBtnClick(payload) {console.log("监听到showInfo内部的点击:", payload)}// 4.获取组件实例const showInfoRef = ref()onMounted(() =&gt; {showInfoRef.value.foo()})&lt;/script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// ShowInfo.vue&lt;template&gt;&lt;div&gt;ShowInfo: {{ name }}-{{ age }}&lt;/div&gt;&lt;button @click="showInfoBtnClick"&gt;showInfoButton&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;// 定义propsconst props = defineProps({name: {type: String,default: "默认值"},age: {type: Number,default: 0}})// 绑定函数, 并且发出事件const emits = defineEmits(["infoBtnClick"])function showInfoBtnClick() {emits("infoBtnClick", "showInfo内部发生了点击")}// 定义foo的函数function foo() {console.log("foo function")}// 函数可公开defineExpose({foo})&lt;/script&gt;</code></pre><h2 id="8-案例实战"><a href="#8-案例实战" class="headerlink" title="8. 案例实战"></a>8. 案例实战</h2><p><img src="29671096df8f4c199b5ed85a7fbd0d5b.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 知识大总结（二）组件化基础</title>
      <link href="/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、组件化开发思想"><a href="#一、组件化开发思想" class="headerlink" title="一、组件化开发思想"></a>一、组件化开发思想</h1><p>组件化是Vue、React、Angular的核心思想：</p><ul><li>前面我们的createApp函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的<strong>根组件</strong></li><li>组件化提供了一种抽象，让我们可以开发出一个个<strong>独立可复用的小组件</strong>来构造我们的应用</li><li>任何的应用都会被抽象成一颗<strong>组件树</strong></li></ul><h2 id="1-注册全局组件"><a href="#1-注册全局组件" class="headerlink" title="1. 注册全局组件"></a>1. 注册全局组件</h2><ul><li>全局组件：在任何其他的组件中都可以使用的组件</li><li>通过<strong>component方法</strong>传入组件名称、组件对象即可注册一个全局组件了</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;HomeNav&gt;&lt;/HomeNav&gt;&lt;home-nav&gt;&lt;/home-nav&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;/div&gt;&lt;template id="nav"&gt;&lt;h2&gt;我是应用程序的导航&lt;/h2&gt;&lt;/template&gt;&lt;template id="product"&gt;&lt;div class="product"&gt;&lt;h2&gt;{{title}}&lt;/h2&gt;&lt;p&gt;商品描述, 限时折扣, 赶紧抢购&lt;/p&gt;&lt;p&gt;价格: {{price}}&lt;/p&gt;&lt;button @click="favarItem"&gt;收藏&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {}},})// 2.注册全局组件app.component("product-item", {template: "#product",data() {return {title: "我是商品Item",price: 9.9}},methods: {favarItem() {console.log("收藏了当前的item")}}})app.component("HomeNav", {template: "#nav"})// 3.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h2 id="2-注册局部组件"><a href="#2-注册局部组件" class="headerlink" title="2. 注册局部组件"></a>2. 注册局部组件</h2><ul><li>局部组件：只有在<strong>注册的组件中</strong>才能使用的组件（常用）</li><li>通过<strong>components属性</strong>选项来进行注册</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;home-nav&gt;&lt;/home-nav&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;/div&gt;&lt;template id="product"&gt;&lt;div class="product"&gt;&lt;h2&gt;{{title}}&lt;/h2&gt;&lt;p&gt;商品描述, 限时折扣, 赶紧抢购&lt;/p&gt;&lt;p&gt;价格: {{price}}&lt;/p&gt;&lt;button&gt;收藏&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;template id="nav"&gt;&lt;div&gt;-------------------- nav start ---------------&lt;/div&gt;&lt;h1&gt;我是home-nav的组件&lt;/h1&gt;&lt;product-item&gt;&lt;/product-item&gt; // 在此组件中加components属性才可使用&lt;div&gt;-------------------- nav end ---------------&lt;/div&gt;&lt;/template&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;const ProductItem = {template: "#product",data() {return {title: "我是product的title",price: 9.9}}}// 1.创建局部组件const app = Vue.createApp({// components: option apicomponents: {ProductItem,HomeNav: {template: "#nav",components: {ProductItem}}},// data: option apidata() {return {message: "Hello Vue"}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h1 id="二、Vue-脚手架"><a href="#二、Vue-脚手架" class="headerlink" title="二、Vue 脚手架"></a>二、Vue 脚手架</h1><p>在真实开发中，我们可以通过一个<strong>后缀名为 .vue</strong> 的single-file components (单文件组件) 来解决，并且可以<strong>使用 webpack或者vite或者rollup等构建工具</strong>来对其进行处理</p><p>想要使用这一的SFC的.vue文件，比较常见的是两种方式：</p><ul><li>方式一：使用<strong>Vue CLI来创建项目</strong>，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件</li><li>方式二：自己使用webpack或rollup或vite这类打包工具，对其进行打包处理</li></ul><h2 id="1-Vue-CLI-安装和使用"><a href="#1-Vue-CLI-安装和使用" class="headerlink" title="1. Vue CLI 安装和使用"></a>1. Vue CLI 安装和使用</h2><p>Vue的脚手架就是Vue CLI：</p><ul><li>CLI是Command-Line Interface, 翻译为<strong>命令行界面</strong></li><li>我们可以通过CLI选择项目的配置和创建出我们的项目</li><li>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置</li></ul><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ul><li>安装Vue CLI：<code>npm install @vue/cli -g</code></li><li>升级Vue CLI：<code>npm update @vue/cli -g</code></li></ul><h3 id="1-2-vue-create-项目的过程"><a href="#1-2-vue-create-项目的过程" class="headerlink" title="1.2 vue create 项目的过程"></a>1.2 vue create 项目的过程</h3><ul><li>通过Vue的命令来创建项目：<code>Vue create 项目的名称</code></li></ul><p><img src="17da786379754ac1a7192141351c4b7b.png" alt="在这里插入图片描述"></p><h2 id="2-Vue-项目目录结构"><a href="#2-Vue-项目目录结构" class="headerlink" title="2. Vue 项目目录结构"></a>2. Vue 项目目录结构</h2><pre class="line-numbers language-node" data-language="node"><code class="language-node">node_modules:  安装的所有依赖包public： public目录存放的是一些公用文件   ---favicon.ico  图标   ---index.html   打包webpack时所需要的的HTML 模板src： 存放vue项目的源代码   --assets: 资源文件,比如存放css,图片等资源   --components: 组件文件夹   --APP.vue   根组件   --main.js  项目的入口文件.browserslistrc：  设置目标浏览器,进行浏览器适配.gitignore：  git的忽略文件babel.config.js：  babel的配置jsconfig.json：  给vscode进行读取,vscode在读取到其中的内容时,给我们代码更加友好的提示package-lock.json：   项目包的锁定文件,npm install 可以通过package-lock文件来检测lock中包的版本是否和package.json中一致 ---一致,会优先查找缓存,不一致,就会重新构建依赖关系package.json：  npm配置文件,记录这你项目的名称,版本号,项目描述,也记录项目所依赖的其他库的信息和依赖库的版本号README.md：  项目说明(描述)vue.config.js：  vue 的配置文件</code></pre><p><img src="edc7a4c51fd744049fe6bc8c3c06b97e.png" alt="在这里插入图片描述"></p><h2 id="3-vue-初步使用"><a href="#3-vue-初步使用" class="headerlink" title="3. vue 初步使用"></a>3. vue 初步使用</h2><ul><li>main.js</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import { createApp } from "vue";import App from "./components/App.vue";// import ProductItem from "./components/ProductItem.vue";const app = createApp(App);// 全局注册// app.component("product-item", ProductItem);app.mount("#app");</code></pre><ul><li>App.vue</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;h2&gt;{{ title }}&lt;/h2&gt;&lt;h2&gt;当前计数：{{ counter }}&lt;/h2&gt;&lt;button @click="decrement"&gt;-&lt;/button&gt;&lt;button @click="increment"&gt;+&lt;/button&gt;&lt;product-item&gt;&lt;/product-item&gt;&lt;/template&gt;&lt;script&gt;// 局部注册import ProductItem from "./ProductItem.vue"export default {components: {ProductItem,},data() {return {title: "我还是标题",counter: 0,};},methods: {decrement() {this.counter--;},increment() {this.counter++;},},}&lt;/script&gt;&lt;style&gt;h2 {color: red;}&lt;/style&gt;</code></pre><ul><li>ProductItem.vue</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="product"&gt;&lt;h2&gt;我是商品&lt;/h2&gt;&lt;div&gt;商品图片&lt;/div&gt;&lt;div&gt;商品价格: &lt;span&gt;¥{{ price }}&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {data() {return {price: 9.9,count: 0,};},}&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h2 id="4-知识补充"><a href="#4-知识补充" class="headerlink" title="4. 知识补充"></a>4. 知识补充</h2><h3 id="4-1-jsconfig-文件的作用"><a href="#4-1-jsconfig-文件的作用" class="headerlink" title="4.1 jsconfig 文件的作用"></a>4.1 jsconfig 文件的作用</h3><p>给vscode进行读取,vscode在读取到其中的内容时,给我们代码<strong>更加友好的提示</strong></p><p>jsconfig 文件<br><img src="2f7217460c7d4dccadd6b52c9a9aff86.png" alt="在这里插入图片描述"></p><p>vue.config.js 文件<br><img src="94f00413f1d5426f8e9ee88acfe13445.png" alt="在这里插入图片描述"></p><h3 id="4-2-vue-不同版本的作用"><a href="#4-2-vue-不同版本的作用" class="headerlink" title="4.2 vue 不同版本的作用"></a>4.2 vue 不同版本的作用</h3><ul><li>runtime版本：没有对模板的编译，需要自己写对应的render函数(返回h函数)或者setup返回一个函数，函数的返回值是h函数<ul><li>没有将模板转成vnode节点这一过程</li></ul></li><li>runtime+comiple 版本：可以将template模板通过compile转换成对应的vnode节点</li></ul><h3 id="4-3-css-的-scoped-作用域"><a href="#4-3-css-的-scoped-作用域" class="headerlink" title="4.3 css 的 scoped 作用域"></a>4.3 css 的 scoped 作用域</h3><p>每个vue文件中的css：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style scoped&gt;.title {color: red;}&lt;/style&gt;</code></pre><p>此时对title的样式只对此vue文件中的.title适用，其他vue文件中不适用</p><h3 id="4-4-npm-init-vue-latest创建项目"><a href="#4-4-npm-init-vue-latest创建项目" class="headerlink" title="4.4 npm init vue@latest创建项目"></a>4.4 npm init vue@latest创建项目</h3><ul><li>vite打包：<code>npm init vue@latest</code></li></ul><p><img src="ba8169979e394e3a8c5e08bc414c0fff.png" alt="在这里插入图片描述"></p><h1 id="三、组件间的通信"><a href="#三、组件间的通信" class="headerlink" title="三、组件间的通信"></a>三、组件间的通信</h1><h2 id="1-组件的嵌套关系"><a href="#1-组件的嵌套关系" class="headerlink" title="1. 组件的嵌套关系"></a>1. 组件的嵌套关系</h2><p>对组件进行拆分，拆分成一个个功能的小组件：</p><p><img src="935053d43ec34f57af2776bf161422d0.png" alt="在这里插入图片描述"></p><ul><li><p>上面的嵌套逻辑如下，它们存在如下<strong>关系</strong>：</p><ul><li>App组件是Header、Main、Footer组件的父组件</li><li>Main组件是Banner、ProductList组件的父组件</li></ul></li><li><p>在开发过程中，我们会经常遇到需要<strong>组件之间相互进行通信</strong>：</p><ul><li>父组件传递给子组件：<strong>通过props属性</strong></li><li>子组件传递给父组件：<strong>通过$emit触发事件</strong></li></ul></li></ul><h2 id="2-父传子-props（重要）"><a href="#2-父传子-props（重要）" class="headerlink" title="2. 父传子 - props（重要）"></a>2. 父传子 - props（重要）</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p>父子组件之间通信，比如<strong>父组件有一些数据</strong>，需要子组件来进行展示：</p><p>Props有两种常见的用法：</p><ul><li>方式一：==字符串数组==，数组中的字符串就是attribute的名称<ul><li>只能说明传入的attribute的名称，并<strong>不能对其进行任何形式的限制</strong></li></ul></li><li>方式二：==对象类型==，可以在指定attribute名称的同时，传入更多内容<ul><li>指定传入的attribute的类型 <code>type</code><ul><li>指定类型的最好在父组件传值时使用 <code>:age="18"</code></li></ul></li><li>指定传入的attribute是否是必传的 <code>required</code></li><li>指定没有传入时，attribute的默认值 <code>default</code></li></ul></li></ul><h3 id="2-2-更多细节"><a href="#2-2-更多细节" class="headerlink" title="2.2 更多细节"></a>2.2 更多细节</h3><ol><li><p>type 的类型</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul></li><li><p>Prop 的大小写命名</p><ul><li>使用 DOM 中的模板时，<strong>camelCase</strong> (驼峰命名法) 的 prop 名需要使用其==等价==的 <strong>kebab-case</strong> (短横线分隔命名) 命名</li></ul></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;!-- 1.展示why的个人信息 --&gt;&lt;!-- 如果当前的属性是一个非prop的attribute, 那么该属性会默认添加到子组件的根元素上 --&gt;&lt;show-info name="why" :age="18" :height="1.88"address="广州市" abc="cba" class="active" /&gt;&lt;!-- 2.展示kobe的个人信息 --&gt;&lt;show-info name="kobe" :age="30" :height="1.87" /&gt;&lt;!-- 3.展示默认的个人信息 --&gt;&lt;show-info :age="100" show-message="哈哈哈哈"/&gt;&lt;/template&gt;&lt;script&gt;import ShowInfo from './ShowInfo.vue'export default {components: {ShowInfo}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// ShowInfo.vue&lt;template&gt;&lt;div class="infos"&gt;&lt;h2 :class="$attrs.class"&gt;姓名: {{ name }}&lt;/h2&gt;&lt;h2&gt;年龄: {{ age }}&lt;/h2&gt;&lt;h2&gt;身高: {{ height }}&lt;/h2&gt;&lt;h2&gt;Message: {{ showMessage }}&lt;/h2&gt;&lt;/div&gt;&lt;div class="others" v-bind="$attrs"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {// inheritAttrs: false,// 作用: 接收父组件传递过来的属性// 1.props数组语法// 弊端: 1&gt; 不能对类型进行验证 2.没有默认值的// props: ["name", "age", "height"]// 2.props对象语法(必须掌握)props: {name: {type: String,default: "我是默认name"},age: {type: Number,required: true,default: 0},height: {type: Number,default: 2},// 重要的原则: 对象类型写默认值时, 需要编写default的函数, 函数返回默认值friend: {type: Object,default() {return { name: "james" }}},hobbies: {type: Array,default: () =&gt; ["篮球", "rap", "唱跳"]},showMessage: {type: String,default: "我是showMessage"}}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h3 id="2-3-非-prop-的-attribute"><a href="#2-3-非-prop-的-attribute" class="headerlink" title="2.3 非 prop 的 attribute"></a>2.3 非 prop 的 attribute</h3><ul><li>当我们传递给一个组件某个属性，但是<strong>该属性并没有定义对应的props或者emits</strong>时，就称之为 <strong>非Prop的Attribute</strong></li><li>当组件有单个根节点时，非Prop的Attribute将<strong>自动添加到根节点</strong>的Attribute中</li></ul><p><img src="395952595ed147c1a412b4c841659dd0.png" alt="在这里插入图片描述"></p><h3 id="2-4-禁用Attribute继承和多根节点"><a href="#2-4-禁用Attribute继承和多根节点" class="headerlink" title="2.4 禁用Attribute继承和多根节点"></a>2.4 禁用Attribute继承和多根节点</h3><ul><li>如果我们不希望组件的根元素继承attribute，可以在组件中设置 <code>inheritAttrs: false</code></li><li>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须<strong>手动的指定要绑定</strong>到哪一个属性上 <code>v-bind="$attrs"</code>、<code>:class="$attrs.address"</code></li></ul><h2 id="3-子传父-emit（重要）"><a href="#3-子传父-emit（重要）" class="headerlink" title="3. 子传父 - $emit（重要）"></a>3. 子传父 - $emit（重要）</h2><p>当<strong>子组件有一些事件发生</strong>的时候，比如在组件中发生了点击，父组件需要切换内容； 子组件<strong>有一些内容想要传递</strong>给父组件：</p><ul><li>首先，我们需要在子组件中<strong>定义好</strong>在某些情况下触发的事件名称，之后<strong>通过this.$emit</strong>的方式发出去事件</li><li>其次，在父组件中<strong>以v-on的方式传入</strong>要监听的事件名称，并且绑定到对应的方法中</li><li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// AddCounter.vue&lt;template&gt;&lt;div class="add"&gt;&lt;button @click="btnClick(1)"&gt;+1&lt;/button&gt;&lt;button @click="btnClick(5)"&gt;+5&lt;/button&gt;&lt;button @click="btnClick(10)"&gt;+10&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {// 1.emits数组语法emits: ["add"],// 2.emmits对象语法(了解)// emits: {//   add: function(count) {//     if (count &lt;= 10) {//       return true//     }//     return false//   }// },methods: {btnClick(count) {// 让子组件发出去一个自定义事件// 第一个参数自定义的事件名称// 第二个参数是传递的参数this.$emit("add", 100)}}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="app"&gt;&lt;h2&gt;当前计数: {{ counter }}&lt;/h2&gt;&lt;!-- 1.自定义add-counter, 并且监听内部的add事件 --&gt;&lt;add-counter @add="addBtnClick"&gt;&lt;/add-counter&gt;&lt;!-- 2.自定义sub-counter, 并且监听内部的sub事件 --&gt;&lt;sub-counter @sub="subBtnClick"&gt;&lt;/sub-counter&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import AddCounter from './AddCounter.vue'import SubCounter from './SubCounter.vue'export default {components: {AddCounter,SubCounter},data() {return {counter: 0}},methods: {addBtnClick(count) {this.counter += count},subBtnClick(count) {this.counter -= count}}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="4-阶段案例练习-TabControl的封装"><a href="#4-阶段案例练习-TabControl的封装" class="headerlink" title="4. 阶段案例练习 - TabControl的封装"></a>4. 阶段案例练习 - TabControl的封装</h2><ul><li>父组件将列表选项中的内容传给子组件</li><li>子组件将点击选项的事件传给父组件，使父组件下面的页面内容随之改变<br><img src="f49dbf73367244e4b8b729fe6bf0cb97.png" alt="在这里插入图片描述"></li></ul><h1 id="四、组件的插槽-Slot"><a href="#四、组件的插槽-Slot" class="headerlink" title="四、组件的插槽 Slot"></a>四、组件的插槽 Slot</h1><h2 id="1-认识-Slot-的作用"><a href="#1-认识-Slot-的作用" class="headerlink" title="1. 认识 Slot 的作用"></a>1. 认识 Slot 的作用</h2><p>假如我们定制一个通用的导航组件 - NavBar</p><ul><li>这个组件分成三块区域：<strong>左边-中间-右边</strong>，每块区域的内容是不固定</li><li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示</li><li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等</li><li>右边可能是一个文字，也可能是一个图标，也可能什么都不显示</li></ul><p>定义插槽slot：</p><ul><li>插槽的使用过程其实是<strong>抽取共性、预留不同</strong></li><li>我们会将共同的元素、内容依然在组件内进行封装</li><li>同时会将<strong>不同的元素使用slot作为占位</strong>，让<strong>外部决定</strong>到底显示什么样的元素</li></ul><h2 id="2-Slot-的基本使用和默认值（重要）"><a href="#2-Slot-的基本使用和默认值（重要）" class="headerlink" title="2. Slot 的基本使用和默认值（重要）"></a>2. Slot 的基本使用和默认值（重要）</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;!-- 1.内容是button --&gt;&lt;show-message&gt;&lt;button&gt;我是按钮元素&lt;/button&gt;&lt;/show-message&gt;&lt;!-- 2.内容是超链接 --&gt;&lt;show-message&gt;&lt;a href="#"&gt;百度一下&lt;/a&gt;&lt;/show-message&gt;&lt;!-- 3.内容是一张图片 --&gt;&lt;show-message&gt;&lt;img src="@/img/kobe02.png" alt=""&gt;&lt;/show-message&gt;&lt;!-- 4.内容没有传递 --&gt;&lt;show-message&gt;&lt;/show-message&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ShowMessage from './ShowMessage.vue'export default {components: {ShowMessage}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// ShowMessage.vue&lt;template&gt;&lt;h2&gt;哈哈哈哈哈&lt;/h2&gt;&lt;div class="content"&gt;&lt;slot&gt;&lt;p&gt;我是默认内容, 哈哈哈&lt;/p&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="3-Slot-的具名插槽（重要）"><a href="#3-Slot-的具名插槽（重要）" class="headerlink" title="3. Slot 的具名插槽（重要）"></a>3. Slot 的具名插槽（重要）</h2><p>当有多个插槽时，默认情况下每个插槽都会获取到我们插入的内容来显示。希望达到的效果是<strong>插槽对应的显示</strong>，这个时候我们就可以使用 具名插槽：</p><ul><li>具名插槽顾名思义就是给<strong>插槽起一个名字</strong>， 元素有一个特殊的 attribute：name</li><li>一个不带 name 的slot，会带有隐含的名字 default</li></ul><p><img src="472601b17a5f4d109996cf9f1c823b46.png" alt="在这里插入图片描述"></p><h3 id="3-1-动态插槽名（了解）"><a href="#3-1-动态插槽名（了解）" class="headerlink" title="3.1 动态插槽名（了解）"></a>3.1 动态插槽名（了解）</h3><p>可以通过 <code>v-slot:[dynamicSlotName]</code>方式动态绑定一个名称</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;nav-bar&gt;&lt;template v-slot:left&gt;&lt;button&gt;{{ leftText }}&lt;/button&gt;&lt;/template&gt;// 语法糖写法&lt;template #center&gt;&lt;span&gt;内容&lt;/span&gt;&lt;/template&gt;&lt;template #right&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/template&gt;&lt;/nav-bar&gt;&lt;!-- nav-bar只给一个插槽传入数据 --&gt;&lt;nav-bar&gt;&lt;template v-slot:[position]&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/template&gt;&lt;/nav-bar&gt;&lt;button @click=" position = 'left' "&gt;左边&lt;/button&gt;&lt;button @click=" position = 'center' "&gt;中间&lt;/button&gt;&lt;button @click=" position = 'right' "&gt;右边&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import NavBar from './NavBar.vue'export default {components: {NavBar},data() {return {position: "center",leftText: "返回"}}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// NavBar.vue&lt;template&gt;&lt;div class="nav-bar"&gt;&lt;div class="left"&gt;&lt;slot name="left"&gt;left&lt;/slot&gt;&lt;/div&gt;&lt;div class="center"&gt;&lt;slot name="center"&gt;center&lt;/slot&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;slot name="right"&gt;right&lt;/slot&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="other"&gt;&lt;slot name="default"&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style scoped&gt;.nav-bar {display: flex;height: 44px;line-height: 44px;text-align: center;}.left {width: 80px;background-color: orange;}.center {flex: 1;background-color: skyblue;}.right {width: 80px;background-color: aquamarine;}&lt;/style&gt;</code></pre><h2 id="4-作用域插槽"><a href="#4-作用域插槽" class="headerlink" title="4. 作用域插槽"></a>4. 作用域插槽</h2><h3 id="4-1-渲染作用域"><a href="#4-1-渲染作用域" class="headerlink" title="4.1 渲染作用域"></a>4.1 渲染作用域</h3><p>在Vue中有渲染作用域的概念：</p><ul><li>父级模板里的所有内容都是在父级作用域中编译的</li><li>子模板里的所有内容都是在子作用域中编译的</li></ul><p><img src="87733bd3c9404c5598ee10b38b98fa53.png" alt="在这里插入图片描述"></p><h3 id="4-2-作用域插槽使用"><a href="#4-2-作用域插槽使用" class="headerlink" title="4.2 作用域插槽使用"></a>4.2 作用域插槽使用</h3><ul><li>核心：希望父组件可以访问到<strong>slot传入的子组件的内容</strong></li></ul><p>阶段案例练习改进版：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// TabControl.vue&lt;template&gt;&lt;div class="tab-control"&gt;&lt;template v-for="(item, index) in titles" :key="item"&gt;&lt;div class="tab-control-item":class="{ active: index === currentIndex }"@click="itemClick(index)"&gt;// 选项列表中的内容形式span希望可以在外部更改为其他形式(如button)，故引入slot插槽// 将子组件的内容item、abc通过slot传至父组件&lt;slot :item="item" abc="cba"&gt;&lt;span&gt;{{ item }}&lt;/span&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {props: {titles: {type: Array,default: () =&gt; [],},},data() {return {currentIndex: 0,};},emits: ["tabItemClick"],methods: {itemClick(index) {this.currentIndex = index;this.$emit("tabItemClick", index);},},};&lt;/script&gt;&lt;style scoped&gt;.tab-control {display: flex;height: 44px;line-height: 44px;text-align: center;}.tab-control-item {flex: 1;}.tab-control-item.active {color: red;font-weight: 700;}.tab-control-item.active span {border-bottom: 3px solid red;padding: 8px;}&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;!-- 1.tab-control --&gt;&lt;tab-control :titles="['衣服', '鞋子', '裤子']"@tab-item-click="tabItemClick"/&gt;&lt;!-- 2.展示内容 --&gt;&lt;h1&gt;{{ pageContents[currentIndex] }}&lt;/h1&gt;&lt;!-- 1.tab-control: button --&gt;&lt;tab-control :titles="['衣服', '鞋子', '裤子']"@tab-item-click="tabItemClick"&gt;// 从子组件中接收到内容放入props中&lt;template v-slot:default="props"&gt;&lt;button&gt;{{ props.item }}&lt;/button&gt;&lt;/template&gt;&lt;/tab-control&gt;&lt;!-- 2.tab-control: a元素(重要) --&gt;&lt;tab-control :titles="['衣服', '鞋子', '裤子']"@tab-item-click="tabItemClick"&gt;// 从子组件中接收到内容放入props中&lt;template #default="props"&gt;&lt;a href="#"&gt;{{ props.item }}&lt;/a&gt;&lt;/template&gt;&lt;/tab-control&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TabControl from './TabControl.vue'export default {components: {TabControl},data() {return {pageContents: [ "衣服列表", "鞋子列表", "裤子列表" ],currentIndex: 0}},methods: {tabItemClick(index) {this.currentIndex = index}}}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h1 id="五、非父子组件的通信"><a href="#五、非父子组件的通信" class="headerlink" title="五、非父子组件的通信"></a>五、非父子组件的通信</h1><p>主要有两种方式： </p><ul><li>全局事件总线</li><li>Provide/Inject</li></ul><h2 id="1-Provide-Inject"><a href="#1-Provide-Inject" class="headerlink" title="1. Provide / Inject"></a>1. Provide / Inject</h2><p>一些<strong>深度嵌套的组件</strong>，子组件想要获取父组件的部分内容，可以使用 Provide 和 Inject ：</p><ul><li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者</li><li>父组件有<strong>一个 provide 选项</strong>来提供数据</li><li>子组件有<strong>一个 inject 选项</strong>来开始使用这些数据</li></ul><p><img src="6660587239d04352b9415e0946447164.png" alt="在这里插入图片描述"></p><h3 id="1-1-函数写法"><a href="#1-1-函数写法" class="headerlink" title="1.1 函数写法"></a>1.1 函数写法</h3><p>如果Provide中提供的一些数据是来自data，那么我们可能会想要通过this来获取：</p><ul><li>此时使用对象写法会报错</li><li><strong>在日常使用中我们一般采用函数写法</strong><br><img src="13022d03f7e54a838228526c1f9f9bb1.png" alt="在这里插入图片描述"></li></ul><h3 id="1-2-数据的响应式"><a href="#1-2-数据的响应式" class="headerlink" title="1.2 数据的响应式"></a>1.2 数据的响应式</h3><p>如果修改了names之后，之前在provide中引入的 this.names.length 本身并不是响应式的：</p><ul><li>可以使用响应式的一些API来完成这些功能，比如说<strong>computed函数</strong></li><li>因为computed返回的是<strong>一个ref对象</strong>，需要取出其中的<strong>value</strong>来使用<br><img src="93522a580b7149188b35a8388abda454.png" alt="在这里插入图片描述"></li></ul><h2 id="2-事件总线-hy-event-store"><a href="#2-事件总线-hy-event-store" class="headerlink" title="2. 事件总线 hy-event-store"></a>2. 事件总线 hy-event-store</h2><ol><li><p>封装一个工具eventbus.js：<br><code>npm install hy-event-store</code><br><img src="57ad4f3054ed43afa78b6bcf156e8711.png" alt="在这里插入图片描述"></p></li><li><p>在Banner.vue中触发事件：<code>eventBus.emit("事件名"，参数)</code></p></li><li><p>在App.vue中监听事件：<code>eventBus.on("事件名"，回调函数)</code></p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// HomeBanner.vue&lt;template&gt;&lt;div class="banner"&gt;&lt;button @click="bannerBtnClick"&gt;banner按钮&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from './utils/event-bus'export default {methods: {bannerBtnClick() {console.log("bannerBtnClick")eventBus.emit("whyEvent", "why", 18, 1.88)}}}&lt;/script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;h2&gt;App Message: {{ message }}&lt;/h2&gt;&lt;home&gt;&lt;/home&gt;&lt;button @click="isShowCategory = false"&gt;是否显示category&lt;/button&gt;&lt;category v-if="isShowCategory"&gt;&lt;/category&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from './utils/event-bus'import Home from './Home.vue'import Category from './Category.vue'export default {components: {Home,Category},data() {return {message: "Hello App",isShowCategory: true}},created() {// fetch()// 事件监听eventBus.on("whyEvent", (name, age, height) =&gt; {console.log("whyEvent事件在app中监听", name, age, height)this.message = `name:${name}, age:${age}, height:${height}`})}}&lt;/script&gt;</code></pre><h3 id="2-1-取消事件"><a href="#2-1-取消事件" class="headerlink" title="2.1 取消事件"></a>2.1 取消事件</h3><p>某些情况下我们希望<strong>取消掉之前注册的函数监听</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// Category.vue&lt;template&gt;&lt;div&gt;&lt;h2&gt;Category&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from './utils/event-bus'export default {methods: {whyEventHandler() {console.log("whyEvent在category中监听")}},created() {eventBus.on("whyEvent", this.whyEventHandler)},unmounted() {console.log("category unmounted")&lt;!-- 取消事件 --&gt;eventBus.off("whyEvent", this.whyEventHandler)}}&lt;/script&gt;</code></pre><h1 id="六、组件化-额外知识补充"><a href="#六、组件化-额外知识补充" class="headerlink" title="六、组件化-额外知识补充"></a>六、组件化-额外知识补充</h1><h2 id="1-组件的生命周期（重要）"><a href="#1-组件的生命周期（重要）" class="headerlink" title="1. 组件的生命周期（重要）"></a>1. 组件的生命周期（重要）</h2><ul><li>生命周期函数是<strong>一些钩子函数（回调函数）</strong>，在某个时间会<strong>被Vue源码内部进行回调</strong></li><li>通过对生命周期函数的回调，我们可以知道目前<strong>组件正在经历什么阶段</strong></li><li>那么我们就可以在该生命周期中编写属于自己的逻辑代码了</li></ul><p><img src="6ff80aa869ae439994360b1692c2989e.png" alt="在这里插入图片描述"></p><h2 id="2-refs引入元素-组件（重要）"><a href="#2-refs引入元素-组件（重要）" class="headerlink" title="2. refs引入元素/组件（重要）"></a>2. refs引入元素/组件（重要）</h2><p>某些情况下，我们在组件中想要<strong>直接获取到元素对象或者子组件实例</strong>：</p><ul><li>在Vue开发中我们是<strong>不推荐进行DOM操作</strong>的</li><li>这个时候，我们可以给元素或者组件<strong>绑定一个ref的attribute属性</strong></li><li>通过$parent来访问父元素</li><li>通过$root来访问根组件</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;!-- 绑定ref属性 --&gt;&lt;h2 ref="title" class="title" :style="{ color: titleColor }"&gt;{{ message }}&lt;/h2&gt;&lt;button ref="btn" @click="changeTitle"&gt;修改title&lt;/button&gt;&lt;banner ref="banner" /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Banner from "./Banner.vue";export default {components: {Banner,},data() {return {message: "Hello World",titleColor: "red",};},methods: {changeTitle() {// 1.获取h2/button元素console.log(this.$refs.title);console.log(this.$refs.btn);// 2.获取banner组件: 组件实例console.log(this.$refs.banner); // Proxy(Object) {bannerClick: ƒ, …}// 2.1.在父组件中可以主动的调用子组件的对象方法this.$refs.banner.bannerClick();// 2.2.获取banner组件实例, 获取banner template中的所有元素(单根)console.log(this.$refs.banner.$el);// 2.3.如果banner template是多个根, 拿到的是第一个node节点// 注意: 开发中不推荐一个组件的template中有多个根元素// console.log(this.$refs.banner.$el.nextElementSibling)// 3.组件实例还有两个属性(了解):console.log(this.$parent); // 获取父组件 nullconsole.log(this.$root); // 获取根组件 Proxy(Object) {changeTitle: ƒ, …}},},};&lt;/script&gt;</code></pre><h2 id="3-动态组件的使用"><a href="#3-动态组件的使用" class="headerlink" title="3. 动态组件的使用"></a>3. 动态组件的使用</h2><p>想要实现了一个功能：点击一个tab-bar，切换不同的内容显示<br>可以使用动态组件的方式实现</p><ul><li>动态组件是<strong>使用 component 组件</strong>，通过一个特殊的attribute <strong>is 来实现</strong>：</li><li>动态组件的<strong>传值</strong>：将属性和监听事件放到component上来使用</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;div class="tabs"&gt;&lt;template v-for="item in tabs" :key="item"&gt;&lt;button :class="{ active: currentTab === item }"@click="itemClick(item)"&gt;{{ item }}&lt;/button&gt;&lt;/template&gt;&lt;/div&gt;&lt;div class="view"&gt;&lt;!-- 做法: 动态组件 component --&gt;&lt;!-- is中的组件需要来自两个地方: 1.全局注册的组件 2.局部注册的组件 --&gt;&lt;!-- 传值 --&gt;&lt;component :is="currentTab"name="why":age="18"@homeClick="homeClick"&gt;&lt;/component&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Home from './views/Home.vue'import About from './views/About.vue'import Category from './views/Category.vue'export default {components: {Home,About,Category},data() {return {tabs: ["home", "about", "category"],currentTab: "home"}},methods: {itemClick(tab) {this.currentTab = tab},homeClick(payload) {console.log("homeClick:", payload)}}}&lt;/script&gt;&lt;style scoped&gt;.active {color: red;}&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// Home.vue&lt;template&gt;&lt;div&gt;&lt;h2&gt;Home组件: {{ name }} - {{ age }}&lt;/h2&gt;&lt;button @click="homeBtnClick"&gt;homeBtn&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {// 与父组件进行传值props: {name: {type: String,default: ""},age: {type: Number,default: 0}},emits: ["homeClick"],methods: {homeBtnClick() {this.$emit("homeClick", "home")}}}&lt;/script&gt;</code></pre><h2 id="4-keep-alive"><a href="#4-keep-alive" class="headerlink" title="4. keep-alive"></a>4. keep-alive</h2><ul><li>默认情况下，我们在切换组件后，<strong>原组件会被销毁掉，再次回来时会重新创建组件</strong></li><li>在开发中某些情况我们希望<strong>继续保持组件的状态，而不是销毁掉</strong>，这个时候我们就可以使用一个内置组件：keep-alive</li></ul><h3 id="4-1-keep-alive-属性"><a href="#4-1-keep-alive-属性" class="headerlink" title="4.1 keep-alive 属性"></a>4.1 keep-alive 属性</h3><p>keep-alive有一些属性：</p><ul><li>include - string | RegExp | Array。只有名称匹配的组件会被缓存</li><li>exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存</li><li>max - number | string。最多可以缓存多少组件实例，一旦达到这个数 字，那么缓存组件中最近没有被访问的实例会被销毁</li></ul><p>include 和 exclude prop 允许组件有条件地缓存：</p><ul><li>二者都可以用<strong>逗号分隔字符串、正则表达式或一个数组</strong>来表示</li><li>匹配首先<strong>检查组件自身的 <code>name</code> 选项</strong></li></ul><h3 id="4-2-缓存组件的生命周期"><a href="#4-2-缓存组件的生命周期" class="headerlink" title="4.2 缓存组件的生命周期"></a>4.2 缓存组件的生命周期</h3><p>对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的：</p><ul><li>可以使用<strong>activated 监听到何时重新进入到了组件</strong></li><li>可以使用 <strong>deactivated 监听到何时离开了组件</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// App.vue&lt;template&gt;&lt;div class="app"&gt;&lt;div class="tabs"&gt;&lt;template v-for="item in tabs" :key="item"&gt;&lt;button :class="{ active: currentTab === item }"@click="itemClick(item)"&gt;{{ item }}&lt;/button&gt;&lt;/template&gt;&lt;/div&gt;&lt;div class="view"&gt;&lt;!-- include: 组件的名称来自于组件定义时 name 选项  --&gt;&lt;keep-alive include="home,about"&gt;&lt;component :is="currentTab"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Home from './views/Home.vue'import About from './views/About.vue'import Category from './views/Category.vue'export default {components: {Home,About,Category},data() {return {tabs: ["home", "about", "category"],currentTab: "home"}},methods: {itemClick(tab) {this.currentTab = tab},homeClick(payload) {console.log("homeClick:", payload)}}}&lt;/script&gt;&lt;style scoped&gt;.active {color: red;}&lt;/style&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// Home.vue&lt;template&gt;&lt;div&gt;&lt;h2&gt;Home组件&lt;/h2&gt;&lt;h2&gt;当前计数: {{ counter }}&lt;/h2&gt;&lt;button @click="counter++"&gt;+1&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {// 需有name，与include配对name: "home",data() {return {counter: 0}},created() {console.log("home created")},unmounted() {console.log("home unmounted")},// 对于保持keep-alive组件, 监听有没有进行切换// keep-alive组件进入活跃状态activated() {console.log("home activated")},deactivated() {console.log("home deactivated")}}&lt;/script&gt;</code></pre><h2 id="5-异步组件的使用"><a href="#5-异步组件的使用" class="headerlink" title="5. 异步组件的使用"></a>5. 异步组件的使用</h2><h3 id="5-1-webpack-分包处理"><a href="#5-1-webpack-分包处理" class="headerlink" title="5.1 webpack 分包处理"></a>5.1 webpack 分包处理</h3><ul><li><strong>默认的打包过程</strong>：<ul><li>默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会<strong>将组件模块打包到一起</strong>（比如一个app.js文件中）</li><li>随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢</li></ul></li><li>打包时，<strong>代码的分包</strong>：<ul><li>所以，对于一些不需要立即使用的组件，我们可以<strong>单独对它们进行拆分，拆分成一些小的代码块chunk.js</strong></li><li>这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容</li></ul></li></ul><p><img src="3fb03dadfac94889b3cefe1b9d7926e8.png" alt="在这里插入图片描述"></p><h3 id="5-2-Vue-中实现异步组件"><a href="#5-2-Vue-中实现异步组件" class="headerlink" title="5.2 Vue 中实现异步组件"></a>5.2 Vue 中实现异步组件</h3><p>提供了一个函数：defineAsyncComponent</p><p><img src="4e6dcebdc5a04ec0b7d45ef84ff6dec9.png" alt="在这里插入图片描述"></p><h2 id="6-组件的-v-model"><a href="#6-组件的-v-model" class="headerlink" title="6. 组件的 v-model"></a>6. 组件的 v-model</h2><p>vue也支持在组件上使用v-model</p><p>// App.vue<br><img src="17cac1dfdbc34734b89a76be8e24b51e.png" alt="在这里插入图片描述"></p><p>为了我们的MyInput组件可以正常的工作，这个组件内的<code>&lt;input&gt;</code>必须：</p><ul><li>将其 value attribute 绑定到一个<strong>名叫 modelValue 的 prop 上</strong></li><li>在其 input 事件被触发时，将新的值<strong>通过自定义的 update:modelValue 事件抛出</strong></li></ul><p>// MyInput.vue<br><img src="7b6ec92af02140ada23898549a426576.png" alt="在这里插入图片描述"></p><h3 id="6-1-绑定多个自定义名称属性"><a href="#6-1-绑定多个自定义名称属性" class="headerlink" title="6.1 绑定多个自定义名称属性"></a>6.1 绑定多个自定义名称属性</h3><ul><li><strong>默认情况下</strong>的v-model其实是绑定了 modelValue 属性和 @update:modelValue的事件</li><li>如果我们希望绑定更多，可以<strong>给v-model传入一个参数</strong>，那么这个参数的名称就是我们绑定属性的名称；</li></ul><p>// App.vue<br><img src="42cbecf97a9240349d6cf4f196785069.png" alt="在这里插入图片描述"></p><p>// MyInput.vue<br><img src="75e065a401d749b4b73d522dc60e43b3.png" alt="在这里插入图片描述"></p><h2 id="7-混入-Mixin"><a href="#7-混入-Mixin" class="headerlink" title="7. 混入 Mixin"></a>7. 混入 Mixin</h2><p>组件和组件之间有时候会<strong>存在相同的代码逻辑</strong>，我们希望对相同的代码逻辑进行抽取</p><h3 id="7-1-Mixin-的基本使用"><a href="#7-1-Mixin-的基本使用" class="headerlink" title="7.1 Mixin 的基本使用"></a>7.1 Mixin 的基本使用</h3><p><img src="0f5d3d4f1b5a4d48af1aa623aa962a94.png" alt="在这里插入图片描述"></p><p>如果<strong>Mixin对象中的选项和组件对象中的选项</strong>发生了冲突，合并规则：（以组件对象为优先）</p><ul><li>==情况一：如果是data函数的返回值对象==<ul><li>返回值对象默认情况下会进行合并</li><li>如果data返回值对象的属性发生了冲突，那么会<strong>保留组件自身的数据</strong></li></ul></li><li>==情况二：生命周期钩子函数==<ul><li>生命周期的钩子函数会被合并到数组中，<strong>都会被调用</strong></li></ul></li><li>==情况三：值为对象的选项==，例如 methods、components 和 directives，将被合并为同一个对象。<ul><li>比如都有methods选项，并且都定义了方法，那么它们<strong>都会生效</strong></li><li>但是如果对象的key相同，那么会取<strong>组件对象</strong>的键值对</li></ul></li></ul><h3 id="7-2-全局混入-Mixin"><a href="#7-2-全局混入-Mixin" class="headerlink" title="7.2 全局混入 Mixin"></a>7.2 全局混入 Mixin</h3><p>如果组件中的某些选项，是<strong>所有的组件都需要拥有的</strong>，那么这个时候我们可以使用<strong>全局的mixin</strong>：</p><ul><li>全局的Mixin可以使用 应用app的方法 mixin 来完成注册</li><li>一旦注册，那么全局混入的选项将会影响每一个组件</li></ul><p><img src="1f1a245baceb4c958ba974747db15970.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 知识大总结（一）基础语法</title>
      <link href="/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/20/Vue3-%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-初识-Vue-js-开发"><a href="#一-初识-Vue-js-开发" class="headerlink" title="一. 初识 Vue.js 开发"></a>一. 初识 Vue.js 开发</h1><p>Vue 是一套用于构建用户界面的<strong>渐进式 JavaScript框架</strong>，它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型。</p><h2 id="1-Vue-下载和使用"><a href="#1-Vue-下载和使用" class="headerlink" title="1. Vue 下载和使用"></a>1. Vue 下载和使用</h2><p>安装和使用Vue这个JavaScript库有一些方式： </p><ul><li>方式一：在页面中通过CDN的方式来引入</li><li>方式二：下载Vue的JavaScript文件，并且自己手动引入</li><li>方式三：通过npm包管理工具安装使用它（webpack再讲）</li><li>方式四：直接通过Vue CLI创建项目，并且使用它</li></ul><h3 id="1-1-方式一：CDN引入"><a href="#1-1-方式一：CDN引入" class="headerlink" title="1.1 方式一：CDN引入"></a>1.1 方式一：CDN引入</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;/div&gt;&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt;&lt;script&gt;// 使用Vueconst app = Vue.createApp({template: `&lt;h2&gt;Hello world&lt;/h2&gt;&lt;span&gt;哈哈哈&lt;/span&gt;`,});// 挂载app.mount("#app");&lt;/script&gt;</code></pre><h3 id="1-2-方式二：下载和引入"><a href="#1-2-方式二：下载和引入" class="headerlink" title="1.2 方式二：下载和引入"></a>1.2 方式二：下载和引入</h3><p>下载Vue的源码（<a href="https://unpkg.com/vue@next%EF%BC%89%E5%88%B0vue.js%E6%96%87%E4%BB%B6%E4%B8%AD">https://unpkg.com/vue@next）到vue.js文件中</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({template: `&lt;h1&gt;Hello world&lt;/h1&gt;&lt;span&gt;哈哈哈&lt;/span&gt;`});// 2.挂载appapp.mount("#app");&lt;/script&gt;</code></pre><h2 id="2-Vue-初体验之三个案例"><a href="#2-Vue-初体验之三个案例" class="headerlink" title="2. Vue 初体验之三个案例"></a>2. Vue 初体验之三个案例</h2><h3 id="2-1-动态数据展示"><a href="#2-1-动态数据展示" class="headerlink" title="2.1 动态数据展示"></a>2.1 动态数据展示</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;const app = Vue.createApp({template: `&lt;h2&gt;{{message}}&lt;/h2&gt;`,data: function () {return {title: "Hello World",message: "你好呀，Vue3",};},});app.mount("#app");&lt;/script&gt;</code></pre><h3 id="2-2-动态展示列表"><a href="#2-2-动态展示列表" class="headerlink" title="2.2 动态展示列表"></a>2.2 动态展示列表</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;const app = Vue.createApp({template: `&lt;h2&gt;电影列表&lt;/h2&gt;&lt;ul&gt;&lt;li v-for="item in movies"&gt;{{item}}&lt;/li&gt;   &lt;/ul&gt;`,data: function () {return {movies: ["情书", "怦然心动", "傲慢与偏见"],};},});app.mount("#app");&lt;/script&gt;</code></pre><h3 id="2-3-计数器案例"><a href="#2-3-计数器案例" class="headerlink" title="2.3 计数器案例"></a>2.3 计数器案例</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt; &lt;script&gt;const app = Vue.createApp({template: `&lt;h2&gt;当前计数: {{counter}}&lt;/h2&gt;&lt;button @click="increment"&gt;+1&lt;/button&gt;&lt;button @click="decrement"&gt;-1&lt;/button&gt;`,data: function () {return {counter: 0,};},methods: {increment: function () {this.counter++;},decrement: function () {this.counter--;},},}); app.mount("#app");&lt;/script&gt;</code></pre><h2 id="3-命令式和声明式编程"><a href="#3-命令式和声明式编程" class="headerlink" title="3. 命令式和声明式编程"></a>3. 命令式和声明式编程</h2><p>原生开发和Vue开发的模式和特点涉及到两种不同的编程范式：</p><ul><li><strong>命令式编程和声明式编程</strong></li></ul><ul><li><p>==声明式编程==</p><ul><li>声明式编程关注的是 “<strong>what to do</strong>”，由框架(机器)完成 “how”的过程</li><li>我们会在createApp传入的对象中<strong>声明需要的内容，模板template、数据data、方法methods</strong></li><li>目前Vue、React、Angular、小程序的编程模式，我们称之为声明式编程</li></ul></li><li><p>==命令式编程==</p><ul><li>命令式编程关注的是 “<strong>how to do</strong>”，自己完成整个how的过程</li><li>我们<strong>每完成一个操作，都需要通过JavaScript编写一条代码</strong>，来给浏览器一个指令</li><li>在早期的原生JavaScript和jQuery开发的过程中，我们都是通过这种命令式的方式在编写代码的</li></ul></li></ul><p><img src="58a7809ba50d45089265b97d27bf08c1.png" alt="在这里插入图片描述"></p><h3 id="3-1-MVVM-模型"><a href="#3-1-MVVM-模型" class="headerlink" title="3.1 MVVM 模型"></a>3.1 MVVM 模型</h3><p>MVC和MVVM都是一种软件的体系结构 </p><ul><li>MVC是Model – View –Controller的简称，是在前期被使用非常框架的架构模式，比如iOS、前端</li><li>MVVM是Model-View-ViewModel的简称，是目前非常流行的架构模式</li></ul><p>通常情况下，我们也经常称Vue是一个MVVM的框架</p><p><img src="383792ec45ff4055be72317a67dd29b9.png" alt="在这里插入图片描述"></p><h2 id="4-data-属性"><a href="#4-data-属性" class="headerlink" title="4. data 属性"></a>4. data 属性</h2><ul><li>data属性必须是<strong>一个函数</strong>，并且该函数需要返回一个对象：</li></ul><ul><li>data中返回的对象会被<strong>Vue的响应式系统劫持</strong>，之后对该<strong>对象的修改或者访问</strong>都会在劫持中被处理：<ul><li>所以我们在template或者app中通过  访问counter，可以从对象中获取到数据</li><li>所以我们修改counter的值时，app中的 也会发生改变</li></ul></li></ul><h2 id="5-methods-属性"><a href="#5-methods-属性" class="headerlink" title="5. methods 属性"></a>5. methods 属性</h2><ul><li>methods属性是<strong>一个对象</strong>，通常我们会在这个对象中定义很多的方法<ul><li>这些方法可以被绑定到模板中</li><li>在该方法中，我们可以<strong>使用this关键字</strong>来直接<strong>访问到data中</strong>返回的对象的属性</li></ul></li><li>方法不能使用箭头函数，否则this就会是window了</li></ul><h1 id="二、Vue基础-模板语法"><a href="#二、Vue基础-模板语法" class="headerlink" title="二、Vue基础 - 模板语法"></a>二、Vue基础 - 模板语法</h1><h2 id="1-Mustache-语法（插值语法）"><a href="#1-Mustache-语法（插值语法）" class="headerlink" title="1. Mustache 语法（插值语法）"></a>1. Mustache 语法（插值语法）</h2><ul><li>如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值</li><li>Mustache中不仅仅可以是data中的属性，也<strong>可以是一个JavaScript的表达式</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.基本使用 --&gt;&lt;h2&gt;{{ message }}&lt;/h2&gt;&lt;h2&gt;当前计数: {{ counter }}&lt;/h2&gt;&lt;!-- 2.表达式 --&gt;&lt;h2&gt;计数双倍: {{ counter * 2 }}&lt;/h2&gt;&lt;h2&gt;展示的信息: {{ info.split(" ") }}&lt;/h2&gt;&lt;!-- 3.三元运算符 --&gt;&lt;h2&gt;{{ age &gt;= 18 ? "成年人" : "未成年人" }}&lt;/h2&gt;&lt;!-- 4.调用methods中函数 --&gt;&lt;h2&gt;{{ formatDate(time) }}&lt;/h2&gt;&lt;!-- 5.注意: 这里不能定义语句 --&gt;&lt;!-- &lt;h2&gt;{{ const name = "why" }}&lt;/h2&gt; --&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function () {return {message: "Hello Vue",counter: 100,info: "my name is why",age: 22,time: 123,};},methods: {formatDate: function (date) {return "2022-10-10-" + date;},},});// 2.挂载appapp.mount("#app");&lt;/script&gt;</code></pre><h2 id="2-基本指令"><a href="#2-基本指令" class="headerlink" title="2. 基本指令"></a>2. 基本指令</h2><h3 id="2-1-不常见的指令"><a href="#2-1-不常见的指令" class="headerlink" title="2.1 不常见的指令"></a>2.1 不常见的指令</h3><ul><li>v-once 用于指定元素或者组件<strong>只渲染一次</strong>：<ul><li>当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;div id="app"&gt;&lt;!-- 指令: v-once --&gt;&lt;h2 v-once&gt;{{ message }}&lt;span&gt;数字: {{counter}}&lt;/span&gt;&lt;/h2&gt; // 此中内容，点击按钮后均不变&lt;h1&gt;{{message}}&lt;/h1&gt;&lt;button @click="changeMessage"&gt;改变message&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {message: "Hello Vue",counter: 100}},methods: {changeMessage: function() {this.message = "你好啊, 李银河"this.counter += 100console.log(this.message, this.counter)}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><ul><li>v-text 用于<strong>更新元素的 textContent</strong>：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;// 展示出的内容：aaHello Worldbbb&lt;h2&gt; aa {{message}} bbb&lt;/h2&gt;// 展示出的内容：Hello World,覆盖aaa&lt;h2 v-text="message"&gt;aaa&lt;/h2&gt;&lt;span v-text="msg"&gt;&lt;/span&gt;&lt;!-- 等价于 --&gt;&lt;span&gt;{{msg}}&lt;/span&gt;&lt;/div&gt;</code></pre><ul><li>v-html 使 html 的内容可以被Vue解析出来</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h2&gt;{{ content }}&lt;/h2&gt;&lt;h2 v-html="content"&gt;&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {content: `&lt;span style="color: red; font-size: 30px;"&gt;哈哈哈&lt;/span&gt;`}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><ul><li>v-pre 用于跳过元素和它的子元素的编译过程，<strong>显示原始的Mustache标签</strong>：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;div v-pre&gt;&lt;h2&gt;{{ message }}&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;// 浏览器界面中展示：{{ message }}</code></pre><ul><li>v-cloak 保持在元素上直到关联组件实例结束编译<br> 可以<strong>隐藏未编译的 Mustache 标签直到组件实例准备完毕</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;style&gt;[v-cloak] {display: none;}&lt;/style&gt;&lt;div id="app"&gt;&lt;h2 v-cloak&gt;{{message}}&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;setTimeout(() =&gt; {// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {message: "Hello Vue"}},})// 2.挂载appapp.mount("#app")}, 3000)&lt;/script&gt;</code></pre><h3 id="2-2-新的指令-v-memo"><a href="#2-2-新的指令-v-memo" class="headerlink" title="2.2 新的指令 v-memo"></a>2.2 新的指令 v-memo</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;div v-memo="[name, age]"&gt;&lt;h2&gt;姓名: {{ name }}&lt;/h2&gt;&lt;h2&gt;年龄: {{ age }}&lt;/h2&gt;&lt;h2&gt;身高: {{ height }}&lt;/h2&gt;&lt;/div&gt;&lt;button @click="updateInfo"&gt;改变信息&lt;/button&gt;&lt;/div&gt;</code></pre><ul><li>若name和age都保持不变，这个div及其子项的所有更新都将被跳过</li><li>优化性能</li></ul><h2 id="3-v-bind-绑定属性"><a href="#3-v-bind-绑定属性" class="headerlink" title="3. v-bind 绑定属性"></a>3. v-bind 绑定属性</h2><p>除了内容需要动态来决定外，我们也希望<strong>动态绑定某些属性</strong></p><h3 id="3-1-v-bind-绑定基本属性"><a href="#3-1-v-bind-绑定基本属性" class="headerlink" title="3.1 v-bind 绑定基本属性"></a>3.1 v-bind 绑定基本属性</h3><ul><li>v-bind用于<strong>绑定一个或多个属性值</strong>，或者向另一个组件传递props值（这个学到组件时再介绍）</li><li>可以绑定图片的链接src、网站的链接href、动态绑定一些类、样式等等</li><li>v-bind有一个对应的<strong>语法糖</strong>，也就是简写方式：<code>:</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;button @click="switchImg"&gt;切换图片&lt;/button&gt;&lt;img v-bind:src="showImgUrl" alt="" /&gt;&lt;!-- 语法糖写法 --&gt;&lt;a :href="href"&gt;百度一下&lt;/a&gt;&lt;/div&gt;&lt;script src="./lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function () {return {imgUrl1:"http://p1.music.126.net/P89nasGuX_gjdBe_2PpQuw==/109951168455849588.jpg",imgUrl2: "http://p1.music.126.net/zLNyOeVM5CVdx0OQ9TU11A==/109951168454700007.jpg",showImgUrl: "http://p1.music.126.net/P89nasGuX_gjdBe_2PpQuw==/109951168455849588.jpg",href: "http://www.baidu.com",};},methods: {switchImg: function () {this.showImgUrl = this.showImgUrl === this.imgUrl1 ? this.imgUrl2 : this.imgUrl1;},},});// 2.挂载appapp.mount("#app");&lt;/script&gt;</code></pre><h3 id="3-2-v-bind-绑定-class"><a href="#3-2-v-bind-绑定-class" class="headerlink" title="3.2 v-bind 绑定 class"></a>3.2 v-bind 绑定 class</h3><ul><li>基本绑定</li><li><strong>对象语法</strong>:  我们可以传给 :class (v-bind:class 的简写) 一个对象（<code>{ className: Boolean }</code>），以<strong>动态地切换</strong> class<ul><li>若为false，则不会加载该class</li></ul></li><li><strong>数组语法</strong>:  我们可以把一个数组传给 :class，以应用一个 class 列表</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;style&gt;.active {color: red;}&lt;/style&gt;&lt;div id="app"&gt;&lt;!-- 1.基本绑定class --&gt;&lt;h2 :class="classes"&gt;Hello World&lt;/h2&gt;&lt;!-- 2.动态class可以写对象语法 --&gt;&lt;!-- 2.1.对象语法的基本使用(掌握) --&gt;&lt;button :class="{ active: isActive, why: true, kobe: false }" @click="btnClick"&gt;我是按钮&lt;/button&gt;&lt;!-- 2.2.动态绑定的class是可以和普通的class同时的使用 --&gt;&lt;button class="abc cba" :class="{ active: isActive, why: true, kobe: false }" @click="btnClick"&gt;我是按钮&lt;/button&gt;&lt;!-- 2.3.动态绑定的class是可以从methods获取 --&gt;&lt;button class="abc cba" :class="getDynamicClasses()" @click="btnClick"&gt;我是按钮&lt;/button&gt;&lt;!-- 3.动态class可以写数组语法(了解) --&gt;&lt;h2 :class="['abc', 'cba']"&gt;Hello Array&lt;/h2&gt;&lt;h2 :class="['abc', className]"&gt;Hello Array&lt;/h2&gt;&lt;h2 :class="['abc', className, isActive? 'active': '']"&gt;Hello Array&lt;/h2&gt;&lt;h2 :class="['abc', className, { active: isActive }]"&gt;Hello Array&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {classes: "abc cba nba",isActive: false,className: "why"}},methods: {btnClick: function() {this.isActive = !this.isActive},getDynamicClasses: function() {return { active: this.isActive, why: true, kobe: false }}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="3-3-v-bind-绑定-style"><a href="#3-3-v-bind-绑定-style" class="headerlink" title="3.3 v-bind 绑定 style"></a>3.3 v-bind 绑定 style</h3><p>可以利用v-bind:style来<strong>绑定一些CSS内联样式</strong></p><p>CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</p><ul><li>对象语法：<code>{ cssname: cssvalue }</code></li><li>数组语法：<code>[obj1, obj2]</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.普通的html写法 --&gt;&lt;h2 style="color: red; font-size: 30px;"&gt;哈哈哈哈&lt;/h2&gt;&lt;!-- 2.style中的某些值, 来自data中 --&gt;&lt;!-- 2.1.动态绑定style, 在后面跟上对象类型 (重要)--&gt;&lt;h2 :style="{ color: fontColor, fontSize: fontSize }"&gt;哈哈哈哈&lt;/h2&gt;&lt;!-- 2.2.动态的绑定属性, 这个属性是一个对象 --&gt;&lt;h2 :style="objStyle"&gt;呵呵呵呵&lt;/h2&gt;&lt;!-- 3.style的数组语法 --&gt;&lt;h2 :style="[objStyle, { backgroundColor: 'purple' }]"&gt;嘿嘿嘿嘿&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {fontColor: "blue",fontSize: '30px',objStyle: {fontSize: '50px',color: "green"}}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="3-4-动态绑定属性名"><a href="#3-4-动态绑定属性名" class="headerlink" title="3.4 动态绑定属性名"></a>3.4 动态绑定属性名</h3><ul><li>如果<strong>属性名称不是固定</strong>的，我们可以使用 :[属性名]=“值” 的格式来定义</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!-- 动态绑定属性:属性名称不是固定的, --&gt;&lt;div id="app"&gt;&lt;h2 :[name]="value"&gt;Hello World&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {name: "class"}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="3-5-v-bind-绑定对象"><a href="#3-5-v-bind-绑定对象" class="headerlink" title="3.5 v-bind 绑定对象"></a>3.5 v-bind 绑定对象</h3><p>可以直接使用 v-bind 绑定一个对象，将<strong>一个对象的所有属性</strong>，绑定到元素上</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h2 :name="name" :age="age" :height="height"&gt;Hello World&lt;/h2&gt;&lt;!-- v-bind绑定对象: 给组件传递参数 --&gt;&lt;h2 v-bind="infos"&gt;Hello Bind&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {infos: { name: "why", age: 18, height: 1.88, address: "广州市" },name: "why",age: 18,height: 1.88}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h2 id="4-事件绑定-v-on"><a href="#4-事件绑定-v-on" class="headerlink" title="4. 事件绑定 v-on"></a>4. 事件绑定 v-on</h2><p>在前端开发中，我们需要经常和用户进行各种各样的交互。<strong>使用v-on指令监听</strong>用户发生的事件，比如点击、拖拽、键盘事件等等</p><h3 id="4-1-v-on-的基本使用"><a href="#4-1-v-on-的基本使用" class="headerlink" title="4.1 v-on 的基本使用"></a>4.1 v-on 的基本使用</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.基本的写法 --&gt;&lt;div class="box" v-on:click="divClick"&gt;&lt;/div&gt;&lt;!-- 2.语法糖写法(重点掌握) --&gt;&lt;div class="box" @click="divClick"&gt;&lt;/div&gt;&lt;!-- 3.绑定的方法位置, 也可以写成一个表达式(不常用, 不推荐) --&gt;&lt;h2&gt;{{ counter }}&lt;/h2&gt;&lt;button @click="counter++"&gt;+1&lt;/button&gt;&lt;!-- 4.绑定其他方法(掌握) --&gt;&lt;div class="box" @mousemove="divMousemove"&gt;&lt;/div&gt;&lt;!-- 5.元素绑定多个事件(掌握) --&gt;&lt;div class="box" @click="divClick" @mousemove="divMousemove"&gt;&lt;/div&gt;&lt;!-- &lt;div class="box" v-on="{ click: divClick, mousemove: divMousemove }"&gt;&lt;/div&gt; --&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {counter: 0}},methods: {divClick() {console.log("divClick")},divMousemove() {console.log("divMousemove")}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="4-2-v-on-参数传递"><a href="#4-2-v-on-参数传递" class="headerlink" title="4.2 v-on 参数传递"></a>4.2 v-on 参数传递</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.默认传递event对象 --&gt;&lt;button @click="btn1Click"&gt;按钮1&lt;/button&gt;&lt;!-- 2.只有自己的参数 --&gt;&lt;button @click="btn2Click('why', age)"&gt;按钮2&lt;/button&gt;&lt;!-- 3.自己的参数和event对象 --&gt;&lt;!-- 在模板中想要明确的获取event对象: $event --&gt;&lt;button @click="btn3Click('why', age, $event)"&gt;按钮3&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {message: "Hello Vue",age: 18}},methods: {// 1.默认参数: event对象// 总结: 如果在绑定事件的时候, 没有传递任何的参数, 那么event对象会被默认传递进来btn1Click(event) {console.log("btn1Click:", event)},// 2.明确参数:btn2Click(name, age) {console.log("btn2Click:", name, age)},// 3.明确参数+event对象btn3Click(name, age, event) {console.log("btn3Click:", name, age, event)}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="4-3-v-on-的修饰符"><a href="#4-3-v-on-的修饰符" class="headerlink" title="4.3 v-on 的修饰符"></a>4.3 v-on 的修饰符</h3><p>v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;// 此时点击button按钮不会冒泡到输出divClick&lt;div class="box" @click="divClick"&gt;&lt;button @click.stop="btnClick"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata: function() {return {}},methods: {btnClick() {console.log("btnClick")},divClick() {console.log("divClick")}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><p><img src="8f64843973d1488baa9d4f17522122a0.png" alt="在这里插入图片描述"></p><h2 id="5-条件渲染"><a href="#5-条件渲染" class="headerlink" title="5. 条件渲染"></a>5. 条件渲染</h2><p>在某些情况下，我们需要根据当前的条件<strong>决定某些元素或组件是否渲染</strong>，这个时候我们就需要进行条件判断</p><h3 id="5-1-v-if-else-else-if"><a href="#5-1-v-if-else-else-if" class="headerlink" title="5.1 v-if/else/else-if"></a>5.1 v-if/else/else-if</h3><p>v-if的渲染原理：</p><ul><li>v-if是<strong>惰性</strong>的</li><li>当条件为false时，其判断的内容<strong>完全不会被渲染或者会被销毁掉</strong></li><li>当条件为true时，才会真正渲染条件块中的内容</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- v-if="条件" --&gt;&lt;div class="info" v-if="Object.keys(info).length"&gt;&lt;h2&gt;个人信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;姓名: {{info.name}}&lt;/li&gt;&lt;li&gt;年龄: {{info.age}}&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;!-- v-else --&gt;&lt;div v-else&gt;&lt;h2&gt;没有输入个人信息&lt;/h2&gt;&lt;p&gt;请输入个人信息后, 再进行展示~&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {info: { name: "why", age: 18 }}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h1 v-if="score &gt; 90"&gt;优秀&lt;/h1&gt;&lt;h2 v-else-if="score &gt; 80"&gt;良好&lt;/h2&gt;&lt;h3 v-else-if="score &gt;= 60"&gt;及格&lt;/h3&gt;&lt;h4 v-else&gt;不及格&lt;/h4&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {score: 40}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h4 id="5-1-1-template-元素"><a href="#5-1-1-template-元素" class="headerlink" title="5.1.1 template 元素"></a>5.1.1 template 元素</h4><p>v-if是一个指令，所以必须将其添加到一个元素上：</p><ul><li>如果需要切换多个元素，此时我们将元素放进一个div，但是我们并<strong>不希望div这种元素被渲染</strong></li><li>这个时候，我们可以选择使用template</li><li><strong>template元素可以当做不可见的包裹元素</strong>，并且在v-if上使用，但是最终template<strong>不会被渲染出来</strong></li></ul><p><em><strong>v-for 指令处也可使用template</strong></em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- v-if="条件" --&gt;&lt;template class="info" v-if="Object.keys(info).length"&gt;&lt;h2&gt;个人信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;姓名: {{info.name}}&lt;/li&gt;&lt;li&gt;年龄: {{info.age}}&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;&lt;!-- v-else --&gt;&lt;template v-else&gt;&lt;h2&gt;没有输入个人信息&lt;/h2&gt;&lt;p&gt;请输入个人信息后, 再进行展示~&lt;/p&gt;&lt;/template&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {info: { name: "why", age: 18 }}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="5-2-v-show"><a href="#5-2-v-show" class="headerlink" title="5.2 v-show"></a>5.2 v-show</h3><p>v-show和v-if的用法看起来是一致的，也是根据一个条件<strong>决定是否显示元素或者组件</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;div&gt;&lt;button @click="toggle"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;div v-show="isShowCode"&gt;&lt;img src="[https://game.gtimg.cn/images/yxzj/web201706/images/comm/floatwindow/wzry_qrcode.jpg](https://game.gtimg.cn/images/yxzj/web201706/images/comm/floatwindow/wzry_qrcode.jpg)" alt=""&gt;&lt;/div&gt;&lt;div v-if="isShowCode"&gt;&lt;img src="[https://game.gtimg.cn/images/yxzj/web201706/images/comm/floatwindow/wzry_qrcode.jpg](https://game.gtimg.cn/images/yxzj/web201706/images/comm/floatwindow/wzry_qrcode.jpg)" alt=""&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {isShowCode: true}},methods: {toggle() {this.isShowCode = !this.isShowCode}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><ul><li><p>与v-if用法区别：</p><ul><li>v-show是<strong>不支持template</strong></li><li>v-show<strong>不可以和v-else一起使用</strong></li></ul></li><li><p>与v-if的本质区别:</p><ul><li>v-show元素无论是否需要显示到浏览器上，<strong>它的DOM实际都是有存在的</strong>，只是通过CSS的display属性来进行切换</li><li>v-if当条件为false时，其对应的原生压根<strong>不会被渲染到DOM中</strong></li></ul></li><li><p>开发中如何进行选择：</p><ul><li>如果我们的原生需要在显示和隐藏之间<strong>频繁的切换</strong>，那么使用v-show</li><li>不频繁使用 v-if</li></ul></li></ul><h2 id="6-v-for-列表渲染"><a href="#6-v-for-列表渲染" class="headerlink" title="6. v-for 列表渲染"></a>6. v-for 列表渲染</h2><h3 id="6-1-v-for-的基本使用"><a href="#6-1-v-for-的基本使用" class="headerlink" title="6.1 v-for 的基本使用"></a>6.1 v-for 的基本使用</h3><ul><li>v-for的基本格式是 <strong>“item in 数组</strong>“：数组通常是来自data或者prop，也可以是其他方式</li><li>同时可以拿到<strong>数组的索引</strong>：**”(item, index) in 数组”**，需按顺序</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.电影列表进行渲染 --&gt;&lt;h2&gt;电影列表&lt;/h2&gt;&lt;ul&gt;&lt;li v-for="movie in movies"&gt;{{ movie }}&lt;/li&gt;&lt;/ul&gt;&lt;!-- 2.电影列表同时有索引 --&gt;&lt;ul&gt;&lt;li v-for="(movie, index) in movies"&gt;{{index + 1}} - {{ movie }}&lt;/li&gt;&lt;/ul&gt;&lt;!-- 3.遍历数组复杂数据 --&gt;&lt;h2&gt;商品列表&lt;/h2&gt;&lt;div class="item" v-for="item in products"&gt;&lt;h3 class="title"&gt;商品: {{item.name}}&lt;/h3&gt;&lt;span&gt;价格: {{item.price}}&lt;/span&gt;&lt;p&gt;秒杀: {{item.desc}}&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {// 1.moviesmovies: ["星际穿越", "少年派", "大话西游", "哆啦A梦"],// 2.数组: 存放的是对象products: [{ id: 110, name: "Macbook", price: 9.9, desc: "9.9秒杀, 快来抢购!" },{ id: 111, name: "iPhone", price: 8.8, desc: "9.9秒杀, 快来抢购!" },{ id: 112, name: "小米电脑", price: 9.9, desc: "9.9秒杀, 快来抢购!" },]}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="6-2-v-for-其他的类型"><a href="#6-2-v-for-其他的类型" class="headerlink" title="6.2 v-for 其他的类型"></a>6.2 v-for 其他的类型</h3><ul><li>v-for也支持<strong>遍历对象</strong>，并且支持有一二三个参数：<ul><li>一个参数： “value in object”</li><li>二个参数： “(value, key) in object”</li><li>三个参数： “(value, key, index) in object”</li></ul></li><li>v-for同时也支持<strong>数字的遍历</strong>：<ul><li>每一个item都是一个数字</li></ul></li><li>v-for也可以<strong>遍历其他可迭代对象</strong>(Iterable)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.遍历数组 --&gt;&lt;!-- 2.遍历对象 --&gt;&lt;ul&gt;&lt;li v-for="(value, key, index) in info"&gt;{{value}}-{{key}}-{{index}}&lt;/li&gt;&lt;/ul&gt;&lt;!-- 3.遍历字符串(iterable) --&gt;&lt;ul&gt;&lt;li v-for="item in message"&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;!-- 4.遍历数字 --&gt;&lt;ul&gt;&lt;li v-for="item in 100"&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {message: "Hello Vue",info: { name: "why", age: 18, height: 1.88 }}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="6-3-数组更新检测"><a href="#6-3-数组更新检测" class="headerlink" title="6.3 数组更新检测"></a>6.3 数组更新检测</h3><p>被侦听的数组发生变更，也会触发视图更新</p><p>直接修改原来数组的方法：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;ul&gt;&lt;li v-for="item in names"&gt;{{ item }}&lt;/li&gt;&lt;/ul&gt;&lt;button @click="changeArray"&gt;修改数组&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {names: ["abc", "cba", "nba", "aaa", "ccc"]}},methods: {changeArray() {// 1.直接将数组修改为一个新的数组this.names = ["why", "kobe"]// 2.通过一些数组的方法, 修改数组中的元素this.names.push("why")this.names.pop()this.names.splice(2, 1, "why")this.names.sort()this.names.reverse()// 3.不修改原数组的方法不能侦听(watch)const newNames = this.names.map(item =&gt; item + "why")this.names = newNames}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="6-4-v-for-绑定-key-属性"><a href="#6-4-v-for-绑定-key-属性" class="headerlink" title="6.4 v-for 绑定 key 属性"></a>6.4 v-for 绑定 key 属性</h3><p>在使用v-for进行列表渲染时，我们通常会<strong>给元素或者组件绑定一个key属性</strong>，<strong>key要求是唯一: id</strong></p><h4 id="6-4-1-VNode-虚拟-DOM"><a href="#6-4-1-VNode-虚拟-DOM" class="headerlink" title="6.4.1 VNode &amp; 虚拟 DOM"></a>6.4.1 VNode &amp; 虚拟 DOM</h4><ul><li>VNode的全称是Virtual Node，也就是虚拟节点</li><li>事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode</li><li><strong>VNode的本质是一个JavaScript的对象</strong></li><li>template元素 -&gt;解析成 VNode—&gt;转换为真实DOM元素</li></ul><p><img src="4602df0f56d748098782fd208a5b9500.png" alt="在这里插入图片描述"></p><ul><li>如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个VNode Tree</li><li>template元素—&gt;一个个VNode虚拟节点—&gt;VNode Tree –&gt;虚拟DOM—&gt;真实DOM</li></ul><p><img src="72d7dcb2110e445cb61d4ef36db0fe0c.png" alt="在这里插入图片描述"></p><p>虚拟DOM的一大作用：方便代码<strong>跨平台</strong>运行</p><p><img src="e31f88e7bd524c719b765b61d42a2a8b.png" alt="在这里插入图片描述"></p><h4 id="6-4-2-key-的作用"><a href="#6-4-2-key-的作用" class="headerlink" title="6.4.2 key 的作用"></a>6.4.2 key 的作用</h4><p>案例：点击按钮插入f</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;button @click="insertF"&gt;插入f&lt;/button&gt;&lt;ul&gt;&lt;!-- key要求是唯一: id --&gt;&lt;li v-for="item in letters" :key="item"&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; &lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {letters: ["a", "b", "c", "d", "e"]}},methods: {insertF() {this.letters.splice(2, 0, "f")}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><ul><li>没有key的操作:<ul><li>diff算法, 后续VNode复用性不强</li></ul></li></ul><p><img src="f74bcb9969db4dc6b96f53f955d296a3.png" alt="在这里插入图片描述"></p><ul><li>有key的操作:<ul><li>根据key找到之前的VNode进行复用;</li><li>没有VNode可以复用, 再创建新的VNode</li></ul></li></ul><p><img src="d6e79ff91701489fab90e9fb03058b13.png" alt="在这里插入图片描述"><br><img src="965272747ed0418ea7670e26eaa518e9.png" alt="在这里插入图片描述"></p><h1 id="三、Options-API"><a href="#三、Options-API" class="headerlink" title="三、Options API"></a>三、Options API</h1><h2 id="1-计算属性-computed"><a href="#1-计算属性-computed" class="headerlink" title="1. 计算属性 computed"></a>1. 计算属性 computed</h2><h3 id="1-1-复杂数据的处理方式"><a href="#1-1-复杂数据的处理方式" class="headerlink" title="1.1 复杂数据的处理方式"></a>1.1 复杂数据的处理方式</h3><p>在某些情况，我们可能需要<strong>对数据进行一些转化</strong>后再显示，或者需要将<strong>多个数据结合起来</strong>进行显示</p><ul><li>mustache插值语法自己写逻辑：在模板中放入太多的逻辑会让<strong>模板过重和难以维护</strong></li><li>methods完成逻辑：所有的data使用过程都会变成了<strong>一个方法的调用</strong></li></ul><h3 id="1-2-computed-用法"><a href="#1-2-computed-用法" class="headerlink" title="1.2 computed 用法"></a>1.2 computed 用法</h3><p>对于任何<strong>包含响应式数据的复杂逻辑</strong>，都应该使用计算属性</p><ul><li><code>computed: { fullname() {} }</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 插值语法表达式直接进行拼接 --&gt;&lt;!-- 1.拼接名字 --&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;!-- 2.显示分数等级 --&gt;&lt;h2&gt;{{ scoreLevel }}&lt;/h2&gt;&lt;!-- 3.反转单词显示文本 --&gt;&lt;h2&gt;{{ reverseMessage }}&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {// 1.姓名firstName: "kobe",lastName: "bryant",// 2.分数: 及格/不及格score: 80,// 3.一串文本: 对文本中的单词进行反转显示message: "my name is why"}},computed: {// 1.计算属性默认对应的是一个函数fullname() {return this.firstName + " " + this.lastName},scoreLevel() {return this.score &gt;= 60 ? "及格": "不及格"},reverseMessage() {return this.message.split(" ").reverse().join(" ")}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="1-3-computed-和-methods-区别"><a href="#1-3-computed-和-methods-区别" class="headerlink" title="1.3 computed 和 methods 区别"></a>1.3 computed 和 methods 区别</h3><ul><li>computed<strong>底层会缓存, 性能更高</strong><ul><li>计算属性会基于它们的依赖关系进行缓存;</li><li>在数据不发生变化时，计算属性是不需要重新计算的</li><li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;div id="app"&gt;&lt;!-- 1.methods --&gt;&lt;h2&gt;{{ getFullname() }}&lt;/h2&gt;&lt;h2&gt;{{ getFullname() }}&lt;/h2&gt;&lt;h2&gt;{{ getFullname() }}&lt;/h2&gt;&lt;!-- 2.computed --&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;!-- 修改name值 --&gt;&lt;button @click="changeLastname"&gt;修改lastname&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {firstName: "kobe",lastName: "bryant"}},methods: {getFullname() {console.log("getFullname-----")return this.firstName + " " + this.lastName},changeLastname() {this.lastName = "why"}},computed: {fullname() {console.log("computed fullname-----")return this.firstName + " " + this.lastName}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><p><img src="e848a126cda7417aa4ea6c78e09cdfe0.png" alt="在这里插入图片描述"></p><h3 id="1-4-计算属性的-setter-和-getter-了解"><a href="#1-4-计算属性的-setter-和-getter-了解" class="headerlink" title="1.4 计算属性的 setter 和 getter (了解)"></a>1.4 计算属性的 setter 和 getter (了解)</h3><p>计算属性在大多数情况下，<strong>只需要一个getter方法</strong>即可，所以我们会将计算属性直接写成一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h2&gt;{{ fullname }}&lt;/h2&gt;&lt;button @click="setFullname"&gt;设置fullname&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {firstname: "coder",lastname: "why"}},computed: {// 语法糖的写法// fullname() {// return this.firstname + " " + this.lastname// },// 完整的写法:fullname: {get: function() {return this.firstname + " " + this.lastname},set: function(value) {const names = value.split(" ")this.firstname = names[0]this.lastname = names[1]}}},methods: {setFullname() {this.fullname = "kobe bryant"}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h2 id="2-侦听器-watch"><a href="#2-侦听器-watch" class="headerlink" title="2. 侦听器 watch"></a>2. 侦听器 watch</h2><p>希望在代码逻辑中<strong>监听某个数据的变化</strong>，这个时候就需要用侦听器watch来完成</p><h3 id="2-1-基本侦听-watch"><a href="#2-1-基本侦听-watch" class="headerlink" title="2.1 基本侦听 watch"></a>2.1 基本侦听 watch</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h2&gt;{{message}}&lt;/h2&gt;&lt;button @click="changeMessage"&gt;修改message&lt;/button&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {message: "Hello Vue",info: { name: "why", age: 18 }}},methods: {changeMessage() {this.message = "你好啊, 李银河!"this.info = { name: "kobe" }}},watch: {// 1.默认有两个参数: newValue/oldValuemessage(newValue, oldValue) {console.log("message数据发生了变化:", newValue, oldValue)},info(newValue, oldValue) {// 2.如果是对象类型, 那么拿到的是代理对象 Proxyconsole.log("info数据发生了变化:", newValue, oldValue)console.log(newValue.name, oldValue.name)// 3.获取原生对象console.log(Vue.toRaw(newValue))}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="2-2-侦听器-watch-的配置选项"><a href="#2-2-侦听器-watch-的配置选项" class="headerlink" title="2.2 侦听器 watch 的配置选项"></a>2.2 侦听器 watch 的配置选项</h3><p>若修改info.name，用watch侦听info，无法侦听到</p><ul><li>watch<strong>只侦听info的引用变化</strong>，对于内部属性的变化是不会做出响应的</li><li>这个时候我们可以使用一个选项<strong>deep进行更深层的侦听</strong></li><li>还有另外一个属性，是希望<strong>一开始就会立即执行一次</strong><ul><li>使用immediate选项</li><li>无论后面数据是否有变化，侦听的函数都会有限执行一次</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;div id="app"&gt;&lt;h2&gt;{{ info.name }}&lt;/h2&gt;&lt;button @click="changeInfo"&gt;修改info&lt;/button&gt;&lt;/div&gt;&lt;script src="[../lib/vue.js](../lib/vue.js)"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {info: { name: "why", age: 18 }}},methods: {changeInfo() {// 创建一个新对象, 赋值给info// this.info = { name: "kobe" }// 直接修改原对象某一个属性this.info.name = "kobe"}},watch: {// 默认watch监听不会进行深度监听// info(newValue, oldValue) {// console.log("侦听到info改变:", newValue, oldValue)// }// 进行深度监听info: {handler(newValue, oldValue) {console.log("侦听到info改变:", newValue, oldValue) // 侦听到info改变: Proxy {name: 'kobe', age: 18} Proxy {name: 'kobe', age: 18}console.log(newValue === oldValue)}, // true// 1.info进行深度监听deep: true,// 2.第一次渲染直接执行一次监听器immediate: true},"info.name": function(newValue, oldValue) {console.log("name发生改变:", newValue, oldValue) // name发生改变: kobe why}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="2-3-其他的写法"><a href="#2-3-其他的写法" class="headerlink" title="2.3 其他的写法"></a>2.3 其他的写法</h3><p>在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听</p><ul><li>第一个参数是要侦听的源</li><li>第二个参数是侦听的回调函数callback</li><li>第三个参数是额外的其他选项，比如deep、immediate</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;h2&gt;{{message}}&lt;/h2&gt;&lt;button @click="changeMessage"&gt;修改message&lt;/button&gt;&lt;/div&gt;&lt;script src="[../lib/vue.js](../lib/vue.js)"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {message: "Hello Vue"}},methods: {changeMessage() {this.message = "你好啊, 李银河!"}},// 生命周期回调函数: 当前的组件被创建时自动执行// 一般在该函数中, 会进行网络请求created() {// ajax/fetch/axiosconsole.log("created")this.$watch("message", (newValue, oldValue) =&gt; {console.log("message数据变化:", newValue, oldValue)}, { deep: true })}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h1 id="四、v-model-双向绑定"><a href="#四、v-model-双向绑定" class="headerlink" title="四、v-model 双向绑定"></a>四、v-model 双向绑定</h1><h2 id="1-v-model-基本使用"><a href="#1-v-model-基本使用" class="headerlink" title="1. v-model 基本使用"></a>1. v-model 基本使用</h2><p>表单提交是开发中非常常见的功能，也是和用户交互的重要手段</p><ul><li>这要求我们可以在代码逻辑中<strong>获取到用户提交的数据</strong>，我们通常会使用v-model指令来完成<ul><li>v-model指令可以在表单 input、textarea以及select元素上创建<strong>双向数据绑定</strong></li><li>v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理</li></ul></li></ul><ul><li><strong>v-model的原理</strong>是背后有两个操作：<ul><li>v-bind绑定value属性的值</li><li>v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;input type="text" :value="message" @input="inputChange"&gt;等价于&lt;input type="text" v-model="message"&gt;</code></pre><h2 id="2-v-model-绑定其他类型"><a href="#2-v-model-绑定其他类型" class="headerlink" title="2. v-model 绑定其他类型"></a>2. v-model 绑定其他类型</h2><h3 id="2-1-textarea"><a href="#2-1-textarea" class="headerlink" title="2.1 textarea"></a>2.1 textarea</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;textarea cols="30" rows="10" v-model="content"&gt;&lt;/textarea&gt;&lt;p&gt;输入的内容: {{content}}&lt;/p&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {content: ""}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="2-2-checkbox"><a href="#2-2-checkbox" class="headerlink" title="2.2 checkbox"></a>2.2 checkbox</h3><ul><li>单个勾选框：<ul><li>v-model即为<strong>布尔值</strong>。</li><li>此时input的value属性并不影响v-model的值。</li></ul></li><li>多个复选框：<ul><li>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个<strong>数组</strong>。</li><li>当选中某一个时，就会将input的value添加到数组中</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;div id="app"&gt;&lt;!-- 1.checkbox单选框: 绑定到属性中的值是一个Boolean --&gt;&lt;label for="agree"&gt;&lt;input id="agree" type="checkbox" v-model="isAgree"&gt; 同意协议&lt;/label&gt;&lt;h2&gt;单选框: {{isAgree}}&lt;/h2&gt;&lt;hr&gt;&lt;!-- 2.checkbox多选框: 绑定到属性中的值是一个Array --&gt;&lt;!-- 注意: 多选框当中, 必须明确的绑定一个value值 --&gt;&lt;div class="hobbies"&gt;&lt;h2&gt;请选择你的爱好:&lt;/h2&gt;&lt;label for="sing"&gt;&lt;input id="sing" type="checkbox" v-model="hobbies" value="sing"&gt; 唱&lt;/label&gt;&lt;label for="jump"&gt;&lt;input id="jump" type="checkbox" v-model="hobbies" value="jump"&gt; 跳&lt;/label&gt;&lt;h2&gt;爱好: {{hobbies}}&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {isAgree: false,hobbies: []}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="2-3-radio"><a href="#2-3-radio" class="headerlink" title="2.3 radio"></a>2.3 radio</h3><p>此时不需要通过添加name属性使两选项排他，添加v-model可以自动排他</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;div class="gender"&gt;&lt;label for="male"&gt;&lt;input id="male" type="radio" v-model="gender" value="male"&gt; 男&lt;/label&gt;&lt;label for="female"&gt;&lt;input id="female" type="radio" v-model="gender" value="female"&gt; 女&lt;/label&gt;&lt;h2&gt;性别: {{gender}}&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {gender: "female" // 默认选女}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h3 id="2-4-select"><a href="#2-4-select" class="headerlink" title="2.4 select"></a>2.4 select</h3><ul><li>单选：只能选中一个值<ul><li>v-model绑定的是一个<strong>值</strong></li><li>当我们选中option中的一个时，会将它对应的value赋值到fruit中</li></ul></li><li>多选：可以选中多个值 <ul><li>v-model绑定的是一个<strong>数组</strong></li><li>当选中多个值时，就会将选中的option对应的value添加到数组fruit中</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js&lt;div id="app"&gt;&lt;!-- select的单选 --&gt;&lt;select v-model="fruit"&gt;&lt;option value="apple"&gt;苹果&lt;/option&gt;&lt;option value="orange"&gt;橘子&lt;/option&gt;&lt;option value="banana"&gt;香蕉&lt;/option&gt;&lt;/select&gt;&lt;h2&gt;单选: {{fruit}}&lt;/h2&gt;&lt;hr&gt;&lt;!-- select的多选 --&gt;&lt;select multiple size="3" v-model="fruits"&gt;&lt;option value="apple"&gt;苹果&lt;/option&gt;&lt;option value="orange"&gt;橘子&lt;/option&gt;&lt;option value="banana"&gt;香蕉&lt;/option&gt;&lt;/select&gt;&lt;h2&gt;多选: {{fruits}}&lt;/h2&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {fruit: "orange",fruits: []}},})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h2 id="3-v-model-值绑定"><a href="#3-v-model-值绑定" class="headerlink" title="3. v-model 值绑定"></a>3. v-model 值绑定</h2><p>在真实开发中，我们的<strong>数据可能是来自服务器</strong>的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div id="app"&gt;&lt;!-- 1.select的值绑定 --&gt;&lt;select multiple size="3" v-model="fruits"&gt;&lt;option v-for="item in allFruits":key="item.value":value="item.value"&gt;{{item.text}}&lt;/option&gt;&lt;/select&gt;&lt;h2&gt;多选: {{fruits}}&lt;/h2&gt;&lt;hr&gt;&lt;!-- 2.checkbox的值绑定 --&gt;&lt;div class="hobbies"&gt;&lt;h2&gt;请选择你的爱好:&lt;/h2&gt;&lt;template v-for="item in allHobbies" :key="item.value"&gt;&lt;label :for="item.value"&gt;&lt;input :id="item.value" type="checkbox" v-model="hobbies" :value="item.value"&gt; {{item.text}}&lt;/label&gt;&lt;/template&gt;&lt;h2&gt;爱好: {{hobbies}}&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../lib/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.创建appconst app = Vue.createApp({// data: option apidata() {return {// 水果allFruits: [{ value: "apple", text: "苹果" },{ value: "orange", text: "橘子" },{ value: "banana", text: "香蕉" },],fruits: [],// 爱好allHobbies: [{ value: "sing", text: "唱" },{ value: "jump", text: "跳" },],hobbies: []}}})// 2.挂载appapp.mount("#app")&lt;/script&gt;</code></pre><h2 id="4-v-model-修饰符"><a href="#4-v-model-修饰符" class="headerlink" title="4. v-model 修饰符"></a>4. v-model 修饰符</h2><h3 id="4-1-lazy"><a href="#4-1-lazy" class="headerlink" title="4.1 lazy"></a>4.1 lazy</h3><ul><li>默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在<strong>每次内容输入后</strong>就将最新的值和绑定的属性进行<strong>同步</strong></li><li>如果我们在v-model后跟上lazy修饰符(<code>v-model.lazy</code>)，那么会将绑定的事件切换为 change 事件，只有<strong>在提交时（比如回车）才会触发</strong></li></ul><h3 id="4-2-number"><a href="#4-2-number" class="headerlink" title="4.2 number"></a>4.2 number</h3><ul><li>v-model绑定后的值总是string类型，即使在我们设置input的type为number也是string类型；</li><li>如果我们希望<strong>转换为数字类型</strong>，那么可以使用 .number 修饰符</li></ul><h3 id="4-3-trim"><a href="#4-3-trim" class="headerlink" title="4.3 trim"></a>4.3 trim</h3><p>如果要自动<strong>过滤用户输入的空白字符</strong>，可以给v-model添加 trim 修饰符</p><p><em><strong>这些修饰符可以叠加使用：<code>v-model.lazy.trim</code></strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（六）网络请求和响应</title>
      <link href="/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/"/>
      <url>/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="一、服务端渲染和前后端分离"><a href="#一、服务端渲染和前后端分离" class="headerlink" title="一、服务端渲染和前后端分离"></a>一、服务端渲染和前后端分离</h1><h2 id="1-服务器端渲染"><a href="#1-服务器端渲染" class="headerlink" title="1. 服务器端渲染"></a>1. 服务器端渲染</h2><p>早期的网页都是通过后端渲染来完成的：服务器端渲染：</p><ul><li>客户端发出请求 -&gt; 服务端接收请求并返回相应HTML文档 -&gt; 页面刷新，客户端加载新的HTML文档；<br>==服务器端渲染的缺点：==</li><li>当用户点击页面中的某个按钮向服务器发送请求时，页面本质上只是<strong>一些数据发生了变化</strong>，而此时服务器却要将<strong>重绘的整个页面</strong>再返回给浏览器加载，这显然有悖于程序员的“DRY（ Don‘t repeat yourself ）”原则</li><li>而且明明只是一些数据的变化却迫使服务器要返回整个HTML文档，这本身也会给网络带宽带来不必要的开销</li></ul><p><img src="27b4b3f41c7e487485d2ac991d9a269a.png" alt="在这里插入图片描述"></p><h2 id="2-前后端分离"><a href="#2-前后端分离" class="headerlink" title="2. 前后端分离"></a>2. 前后端分离</h2><p>AJAX是“Asynchronous JavaScript And XML”的缩写(异步的JavaScript和XML)，是一种实现<strong>无页面刷新、获取服务器数据</strong>的技术。<br>AJAX最吸引人的就是它的“异步”特性，也就是说它可以==在不重新刷新页面的情况下**与服务器通信，交换数据，或更新页面==**。</p><p>你可以使用AJAX最主要的两个特性做下列事：</p><ul><li>在不重新加载页面的情况下发送请求给服务器；</li><li>接受并使用从服务器发来的数据。<br><img src="410e8fbd46784970bf41f564d1d2a55d.png" alt="在这里插入图片描述"></li></ul><h1 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h1><h2 id="1-HTTP-的介绍"><a href="#1-HTTP-的介绍" class="headerlink" title="1. HTTP 的介绍"></a>1. HTTP 的介绍</h2><p>HTTP是一个<strong>客户端（用户）和服务端（网站）之间请求和响应</strong>的标准。</p><ul><li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个<strong>HTTP请求</strong>到服务器上指定<strong>端口</strong>（默认端口为80）； <ul><li>我们称这个客户端为用户代理程序（user agent）</li></ul></li><li>响应的服务器上<strong>存储着一些资源</strong>，比如HTML文件和图像。<ul><li>我们称这个响应服务器为源服务器（origin server）</li></ul></li></ul><p>我们网页中的资源通常是被放在Web资源服务器中，由浏览器自动发送HTTP请求来获取、解析、展示的。</p><h2 id="2-HTTP-的组成"><a href="#2-HTTP-的组成" class="headerlink" title="2. HTTP 的组成"></a>2. HTTP 的组成</h2><p>一次HTTP请求主要包括：</p><ul><li><p>==请求request==</p><ul><li>请求行</li><li>请求头</li><li>请求体</li></ul></li><li><p>==响应response==</p><ul><li>响应行</li><li>响应头</li><li>响应体</li></ul></li></ul><p><img src="6ccf088e804b42c2b0b2378162421f8f.png" alt="在这里插入图片描述"></p><h3 id="2-1-HTTP-版本"><a href="#2-1-HTTP-版本" class="headerlink" title="2.1 HTTP 版本"></a>2.1 HTTP 版本</h3><p><img src="2204379de97849279190741304fe9873.png" alt="在这里插入图片描述"></p><h3 id="2-2-HTTP-请求方式"><a href="#2-2-HTTP-请求方式" class="headerlink" title="2.2 HTTP 请求方式"></a>2.2 HTTP 请求方式</h3><p>在RFC中定义了一组请求方式，来表示要对给定资源执行的操作： </p><ul><li>==<strong>GET</strong>==：GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于<strong>获取数据</strong>。</li><li>==<strong>HEAD</strong>==：HEAD 方法请求一个与 GET 请求的响应相同的响应，但<strong>没有响应体</strong>。<ul><li>比如在准备下载一个文件前，先获取文件的大小，再决定是否进行下载；</li></ul></li><li>==<strong>POST</strong>==：POST 方法用于将实体<strong>提交</strong>到指定的资源。</li><li>==<strong>PUT</strong>==：PUT 方法用请求有效载荷（payload）<strong>替换</strong>目标资源的所有当前表示；</li><li>==<strong>DELETE</strong>==：DELETE 方法<strong>删除</strong>指定的资源；</li><li>==<strong>PATCH</strong>==：PATCH 方法用于对应资源部分<strong>修改</strong>； </li><li>==<strong>CONNECT</strong>==：CONNECT 方法建立一个到目标资源标识的服务器的隧道，通常用在代理服务器，网页开发很少用到。</li><li>==<strong>TRACE</strong>==：TRACE 方法沿着到目标资源的路径执行一个消息环回测试。</li></ul><p>在开发中使用最多的是GET、POST请求；在后续的后台管理项目中，我们也会使用PATCH、DELETE请求</p><h3 id="2-3-HTTP-请求-header-相关"><a href="#2-3-HTTP-请求-header-相关" class="headerlink" title="2.3 HTTP 请求 header 相关"></a>2.3 HTTP 请求 header 相关</h3><p><strong>Content-type</strong> 是这次请求携带的数据的类型：</p><ul><li><code>application/x-www-form-urlencoded</code>：表示数据被编码成以 ‘&amp;’ 分隔的键 - 值对，同时以 ‘=’ 分隔键和值</li><li><code>application/json</code>：表示是一个<strong>json类型</strong></li><li><code>text/plain</code>：表示是<strong>文本</strong>类型</li><li><code>application/xml</code>：表示是<strong>xml</strong>类型</li><li><code>multipart/form-data</code>：表示是上传<strong>文件</strong></li></ul><p><strong>Content-length</strong>：文件的大小长度</p><p><strong>keep-alive</strong>： </p><ul><li>http是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断</li><li><strong>在http1.0中</strong>，如果想要继续保持连接：<ul><li>浏览器需要在请求头中添加 connection: keep-alive； </li><li>服务器需要在响应头中添加 connection:keey-alive； </li><li>当客户端再次放请求时，就会使用同一个连接，直接一方中断连接</li></ul></li><li><strong>在http1.1中</strong>，所有连接默认是 connection: keep-alive的； <ul><li>不同的Web服务器会有不同的保持 keep-alive的时间； </li><li>Node中默认是5s中</li></ul></li></ul><p><strong>accept-encoding</strong>：告知服务器，<strong>客户端支持的文件==压缩==格式</strong>，比如js文件可以使用gzip编码，对应 .gz文件</p><p><strong>accept</strong>：告知服务器，<strong>客户端可接受文件的格式</strong>类型</p><p><strong>user-agent</strong>：客户端相关的信息</p><h3 id="2-4-HTTP-响应状态码"><a href="#2-4-HTTP-响应状态码" class="headerlink" title="2.4 HTTP 响应状态码"></a>2.4 HTTP 响应状态码</h3><p>Http状态码（Http Status Code）是用来表示<strong>Http响应状态</strong>的数字代码：</p><table><thead><tr><th>常见HTTP状态码</th><th>状态描述</th><th>信息说明</th></tr></thead><tbody><tr><td><strong>200</strong></td><td>OK</td><td>客户端请求成功</td></tr><tr><td>201</td><td>Created</td><td>POST请求，创建新的资源</td></tr><tr><td>301</td><td>Moved Permanently</td><td>请求资源的URL已经修改，响应中会给出新的URL</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端的错误，服务器无法或者不进行处理</td></tr><tr><td>401</td><td>Unauthorized</td><td><strong>未授权</strong>的错误，必须携带请求的身份信息</td></tr><tr><td>403</td><td>Forbidden</td><td>客户端<strong>没有权限访问</strong>，被拒接</td></tr><tr><td><strong>404</strong></td><td>Not Found</td><td>服务器找不到请求的资源。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到了不知道如何处理的情况。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器不可用，可能处理维护或者重载状态，暂时无法访问</td></tr></tbody></table><h1 id="三、XMLHttpRequest"><a href="#三、XMLHttpRequest" class="headerlink" title="三、XMLHttpRequest"></a>三、XMLHttpRequest</h1><h2 id="1-XHR-发送请求的基本过程"><a href="#1-XHR-发送请求的基本过程" class="headerlink" title="1. XHR 发送请求的基本过程"></a>1. XHR 发送请求的基本过程</h2><p>第一步：<strong>创建</strong>网络请求的AJAX对象（使用XMLHttpRequest）<br>第二步：<strong>监听</strong>XMLHttpRequest对象状态的变化，或者监听onload事件（请求完成时触发）<br>第三步：配置网络请求（通过<strong>open</strong>方法）<br>第四步：发送<strong>send</strong>网络请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.创建XMLHttpRequest对象const xhr = new XMLHttpRequest()// 2.监听状态的改变(宏任务)xhr.onreadystatechange = function () {if (xhr.readyState !== XMLHttpRequest.DONE) returnconst resJSON = JSON.parse(xhr.response)console.log(resJSON);}// 3.配置请求open// method: 请求的方式(get/post/delete/put/patch...)// url: 请求的地址xhr.open('get', "http://123.207.32.32:8000/home/multidata")// 4.发送请求(浏览器帮助发送对应请求)xhr.send()</code></pre><h2 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a>2. 事件监听</h2><h3 id="2-1-事件监听-onreadystatechange"><a href="#2-1-事件监听-onreadystatechange" class="headerlink" title="2.1 事件监听 onreadystatechange"></a>2.1 事件监听 onreadystatechange</h3><p>我们在一次网络请求中看到状态发生了很多次变化，这是因为对于一次请求来说包括如下的状态：<br>注意（这个状态并非是HTTP的相应状态，而是<strong>记录的XMLHttpRequest对象的状态</strong>变化。）</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>UNSENT</td><td>代理被创建，但尚未调用 open() 方法。</td></tr><tr><td>1</td><td>OPENED</td><td>open() 方法已经被调用。</td></tr><tr><td>2</td><td>HEADERS_RECEIVED</td><td>send() 方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td>3</td><td>LOADING</td><td>下载中；responseText 属性已经包含部分数据。</td></tr><tr><td>4</td><td>DONE</td><td>下载操作已完成。</td></tr></tbody></table><p>若想发送同步请求：将open的第三个参数设置为false</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const xhr = new XMLHttpRequest()xhr.open('get', "http://123.207.32.32:8000/home/multidata", false)xhr.send()console.log(xhr.response)console.log('-----------');console.log('+++++++++++'); // 这两个输出在xhr.response打印之后再打印，不会提前打印</code></pre><h3 id="2-2-其他事件监听"><a href="#2-2-其他事件监听" class="headerlink" title="2.2 其他事件监听"></a>2.2 其他事件监听</h3><p>除了onreadystatechange还有其他的事件可以监听 </p><ul><li>loadstart：请求开始。</li><li>progress： 一个响应数据包到达，此时整个 response body 都在 response 中。</li><li>abort：调用 xhr.abort() 取消了请求。</li><li>error：发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。</li><li><strong>load</strong>：请求成功完成。</li><li>timeout：由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。</li><li>loadend：在 load，error，timeout 或 abort 之后触发。</li></ul><h2 id="3-响应阶段"><a href="#3-响应阶段" class="headerlink" title="3. 响应阶段"></a>3. 响应阶段</h2><h3 id="3-1-响应数据和响应类型"><a href="#3-1-响应数据和响应类型" class="headerlink" title="3.1 响应数据和响应类型"></a>3.1 响应数据和响应类型</h3><p>发送了请求后，我们需要<strong>获取对应的结果</strong>：response属性</p><p>通过responseType可以<strong>设置获取数据的类型</strong> </p><ul><li>如果将 responseType 的值设置为空字符串，则会使用 <strong>text 作为默认值</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.const xhr = new XMLHttpRequest()// 2.onload监听数据加载完成xhr.onload = function () {console.log(xhr.response)// 早期通常服务器返回的数据是普通的文本和XML，所以我们通常会通过responseText、 responseXML来获取响应结果；之后将它们转化成JavaScript对象形式；// console.log(xhr.responseText)// console.log(xhr.responseXML)}// 3.告知xhr获取到的数据的类型// 目前服务器基本返回的都是json数据，直接设置为json即可xhr.responseType = "json"// xhr.responseType = "xml"// 4.配置网络请求// 4.1.json类型的接口xhr.open("get", "http://123.207.32.32:1888/01_basic/hello_json")// 4.2.text类型的接口xhr.open("get", "http://123.207.32.32:1888/01_basic/hello_text")// 4.3.xml类型的接口xhr.open("get", "http://123.207.32.32:1888/01_basic/hello_xml")// 5.发送网络请求xhr.send()</code></pre><h3 id="3-2-获取响应码"><a href="#3-2-获取响应码" class="headerlink" title="3.2 获取响应码"></a>3.2 获取响应码</h3><p>获取<strong>HTTP响应的网络状态</strong>，可以通过status和statusText来获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const xhr = new XMLHttpRequest()// onload监听数据加载完成xhr.onload = function () {if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {console.log(xhr.response);} else {console.log(xhr.status, xhr.statusText);}}xhr.responseType = "json"// xhr.open("get", "http://123.207.32.32:8000/home/multidata")xhr.open("get", "http://123.207.32.32:8000/aaa/bbb")xhr.send()</code></pre><h2 id="4-服务器传递参数"><a href="#4-服务器传递参数" class="headerlink" title="4. 服务器传递参数"></a>4. 服务器传递参数</h2><p>常见的传递给服务器数据的方式有如下几种：</p><ul><li>方式一: GET请求的query参数</li><li>方式二: POST请求 x-www-form-urlencoded 格式</li><li>方式三: POST请求 FormData 格式</li><li>方式四: POST请求 JSON 格式</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;form class="info"&gt;&lt;input type="text" name="username"&gt;&lt;input type="password" name="password"&gt;&lt;/form&gt;&lt;button class="send"&gt;发送请求&lt;/button&gt;&lt;script&gt;const formEl = document.querySelector(".info")const sendBtn = document.querySelector(".send")sendBtn.onclick = function() {// 创建xhr对象const xhr = new XMLHttpRequest()// 监听数据响应xhr.onload = function() {console.log(xhr.response)}// 配置请求xhr.responseType = "json"// 1.传递参数方式一: get -&gt; queryxhr.open("get", "http://123.207.32.32:1888/02_param/get?name=why&amp;age=18&amp;address=广州市")// 2.传递参数方式二: post -&gt; urlencodedxhr.open("post", "http://123.207.32.32:1888/02_param/posturl")// 发送请求(请求体body)xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")xhr.send("name=why&amp;age=18&amp;address=广州市")// 3.传递参数方式三: post -&gt; formdata// 发送参数默认是FormData格式，所以不用声明Content-typexhr.open("post", "http://123.207.32.32:1888/02_param/postform")// formElement对象转成FormData对象const formData = new FormData(formEl)xhr.send(formData)// 4.传递参数方式四: post -&gt; jsonxhr.open("post", "http://123.207.32.32:1888/02_param/postjson")xhr.setRequestHeader("Content-type", "application/json")xhr.send(JSON.stringify({name: "why", age: 18, height: 1.88}))}&lt;/script&gt;</code></pre><h2 id="5-ajax-的封装"><a href="#5-ajax-的封装" class="headerlink" title="5. ajax 的封装"></a>5. ajax 的封装</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function hyajax({url,method = "get",data = {},timeout = 10000,headers = {}, // token} = {}) {// 1.创建对象const xhr = new XMLHttpRequest()// 2.创建Promiseconst promise = new Promise((resolve, reject) =&gt; {    // 2.监听数据    xhr.onload = function() {    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {    resolve(xhr.response)    } else {        reject({ status: xhr.status, message: xhr.statusText })    }    }        // 3.设置类型    xhr.responseType = "json"    xhr.timeout = timeout        // 4.open方法    if (method.toUpperCase() === "GET") {    const queryStrings = []    for (const key in data) {    queryStrings.push(`${key}=${data[key]}`)    }    url = url + "?" + queryStrings.join("&amp;")    xhr.open(method, url)    xhr.send()    } else {    xhr.open(method, url)    xhr.setRequestHeader("Content-type", "application/json")    xhr.send(JSON.stringify(data))}})promise.xhr = xhrreturn promise}const promise = hyajax({url: "http://123.207.32.32:1888/02_param/get",data: {username: "coderwhy",password: "123456"}})promise.then(res =&gt; {console.log("res:", res)}).catch(err =&gt; {console.log("err:", err)})</code></pre><h2 id="6-延迟时间-timeout-和取消请求"><a href="#6-延迟时间-timeout-和取消请求" class="headerlink" title="6. 延迟时间 timeout 和取消请求"></a>6. 延迟时间 timeout 和取消请求</h2><p>在网络请求的过程中，为了避免过长的时间服务器无法返回数据，通常我们会为请求<strong>设置一个超时时间</strong>：timeout。 </p><ul><li>当达到超时时间后依然没有获取到数据，那么这个请求会自动被取消掉</li><li>默认值为0，表示没有设置超时时间</li></ul><p>我们也可以通过<strong>abort方法</strong>强制取消请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;button&gt;取消请求&lt;/button&gt;&lt;script&gt;const xhr = new XMLHttpRequest()xhr.onload = function () {console.log(xhr.response)}xhr.responseType = "json"// 1.超时时间的设置xhr.ontimeout = function () {console.log("请求过期: timeout")}// timeout: 浏览器达到过期时间还没有获取到对应的结果时, 取消本次请求xhr.timeout = 3000xhr.open("get", "http://123.207.32.32:1888/01_basic/timeout")xhr.send()// 2.手动取消结果xhr.onabort = function () {console.log("请求被取消");}const cancelBtn = document.querySelector("button")cancelBtn.onclick = function () {xhr.abort()}&lt;/script&gt;</code></pre><h1 id="四、Fetch"><a href="#四、Fetch" class="headerlink" title="四、Fetch"></a>四、Fetch</h1><h2 id="1-Fetch-基本使用"><a href="#1-Fetch-基本使用" class="headerlink" title="1. Fetch 基本使用"></a>1. Fetch 基本使用</h2><p>Fetch可以看做是早期的XMLHttpRequest的替代方案，它提供了一种更加现代的处理方案：</p><ul><li>比如<strong>返回值是一个Promise</strong>，提供了一种更加优雅的处理结果方式<ul><li>在请求发送成功时，调用resolve回调then；</li><li>在请求发送失败时，调用reject回调catch</li></ul></li><li>不像XMLHttpRequest一样，所有的操作都在一个对象上</li></ul><p>fetch函数的使用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fetch(input, {method, headers, body})</code></pre><ul><li>input：定义要获取的<strong>资源地址</strong>，可以是一个URL字符串，也可以使用一个Request对象（实验性特性）类型</li><li>init：其他初始化参数 <ul><li>method: <strong>请求使用的方法</strong>，如 GET、POST</li><li>headers: 请求的头信息</li><li>body: 请求的 <strong>body 信息</strong></li></ul></li></ul><h2 id="2-Fetch-数据的响应"><a href="#2-Fetch-数据的响应" class="headerlink" title="2. Fetch 数据的响应"></a>2. Fetch 数据的响应</h2><p>Fetch的数据响应主要分为==两个阶段==：</p><p>阶段一：当服务器<strong>返回了响应</strong>（response）</p><ul><li>fetch 返回的 promise 就使用内建的 Response class 对象来对响应头进行解析；</li><li>在这个阶段，我们可以通过检查响应头，来检查 HTTP 状态以确定请求是否成功；</li><li>如果 fetch 无法建立一个 HTTP 请求，例如网络问题，亦或是请求的网址不存在，那么 promise 就会 reject； </li><li>异常的 HTTP 状态，例如 404 或 500，不会导致出现 error<br>我们可以<strong>在 response 的属性中</strong>看到 HTTP 状态：</li><li>status：HTTP 状态码，例如 200</li><li>ok：布尔值，如果 HTTP 状态码为 200-299，则为 true</li></ul><p>第二阶段，为了<strong>获取 response body</strong>，我们需要使用一个其他的方法调用。</p><ul><li>response.text() —— 读取 response，并以文本形式返回 response</li><li>response.json() —— 将 response 解析为 JSON</li></ul><h2 id="3-Fetch-GET-POST-请求"><a href="#3-Fetch-GET-POST-请求" class="headerlink" title="3. Fetch GET/POST 请求"></a>3. Fetch GET/POST 请求</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.fetch发送get请求// 1.1.未优化的代码fetch("http://123.207.32.32:8000/home/multidata").then(res =&gt; {// 1.获取到responseconst response = res// 2.获取具体的结果response.json().then(res =&gt; {console.log("res:", res)})}).catch(err =&gt; {console.log("err:", err)})// 1.2. 优化方式一:fetch("http://123.207.32.32:8000/home/multidata").then(res =&gt; {// 1.获取到responseconst response = res// 2.获取具体的结果return response.json()}).then(res =&gt; {console.log("res:", res)}).catch(err =&gt; {console.log("err:", err)})// 1.3. 优化方式二:async function getData() {const response = await fetch("http://123.207.32.32:8000/home/multidata")const res = await response.json()console.log("res:", res)}getData()</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 2.post请求并且有参数async function getData() {// 1.常用内容传递const response = await fetch("http://123.207.32.32:1888/02_param/postjson", {method: "post",headers: {"Content-type": "application/json"},body: JSON.stringify({name: "why",age: 18})})// 2.formData类型内容传递const formData = new FormData()formData.append("name", "why")formData.append("age", 18)const response = await fetch("http://123.207.32.32:1888/02_param/postform", {method: "post",body: formData})// 获取response状态console.log(response.ok, response.status, response.statusText)const res = await response.json()console.log("res:", res)}getData()</code></pre><h2 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4. 文件上传"></a>4. 文件上传</h2><h3 id="4-1-XMLHttpRequest-的文件上传"><a href="#4-1-XMLHttpRequest-的文件上传" class="headerlink" title="4.1 XMLHttpRequest 的文件上传"></a>4.1 XMLHttpRequest 的文件上传</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input class="file" type="file"&gt;&lt;button class="upload"&gt;上传文件&lt;/button&gt;&lt;script&gt;const uploadBtn = document.querySelector(".upload")const fileEl = document.querySelector(".file")uploadBtn.onclick = function () {// 1.创建对象const xhr = new XMLHttpRequest()// 2.监听结果xhr.onload = function () {console.log(xhr.response)}xhr.onprogress = function (event) {console.log(event)}xhr.responseType = "json"xhr.open("post", "http://123.207.32.32:1888/02_param/upload")//表单const file = fileEl.files[0]const formdata = new FormData()formdata.append('avatar', file)xhr.send(formdata)}&lt;/script&gt;</code></pre><h3 id="4-2-Fetch-的文件上传"><a href="#4-2-Fetch-的文件上传" class="headerlink" title="4.2 Fetch 的文件上传"></a>4.2 Fetch 的文件上传</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input class="file" type="file"&gt;&lt;button class="upload"&gt;上传文件&lt;/button&gt;&lt;script&gt;const uploadBtn = document.querySelector(".upload")const fileEl = document.querySelector(".file")uploadBtn.onclick = async function() {// 表单const file = fileEl.files[0]const formData = new FormData()formData.append("avatar", file)// 发送fetch请求const response = await fetch("http://123.207.32.32:1888/02_param/upload", {method: "post",body: formData})const res = await response.json()console.log("res:", res)}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（五）Promise、异步async await、防抖节流等</title>
      <link href="/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%94%EF%BC%89Promise%E3%80%81%E5%BC%82%E6%AD%A5async-await%E3%80%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%AD%89/"/>
      <url>/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%94%EF%BC%89Promise%E3%80%81%E5%BC%82%E6%AD%A5async-await%E3%80%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Promise-使用"><a href="#一、Promise-使用" class="headerlink" title="一、Promise 使用"></a>一、Promise 使用</h1><h2 id="1-异步代码存在困境"><a href="#1-异步代码存在困境" class="headerlink" title="1. 异步代码存在困境"></a>1. 异步代码存在困境</h2><p>调用一个函数，这个函数中发送网络请求（我们可以用定时器来模拟）</p><ul><li>如果发送网络请求成功了，那么告知调用者发送成功，并且将相关数据返回过去</li><li>如果发送网络请求失败了，那么告知调用者发送失败，并且告知错误信息；<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.设计这样的一个函数function execCode(counter, successCallback, failureCallback) {// 异步任务setTimeout(() =&gt; {if (counter &gt; 0) { // counter可以计算的情况let total = 0for (let i = 0; i &lt; counter; i++) {total += i}// 成功情况，在某一个时刻只需要回调传入的函数successCallback(total)} else { // 失败情况, counter有问题failureCallback(`${counter}值有问题`)}}, 3000)}// 2.ES5之前,处理异步的代码都是这样封装execCode(100, (value) =&gt; {console.log("本次执行成功了:", value)}, (err) =&gt; {console.log("本次执行失败了:", err)})</code></pre></li></ul><p>缺点：</p><ul><li>需要自己来设计回调函数、回调函数的名称、回调函数的使用等</li><li>对于不同的人、不同的框架设计出来的方案是不同的，那么我们必须耐心去看别人的源码或者文档，以便可以理解这个函数到底怎么用</li></ul><h2 id="2-Promise-的代码结构"><a href="#2-Promise-的代码结构" class="headerlink" title="2. Promise 的代码结构"></a>2. Promise 的代码结构</h2><ul><li>Promise是一个<strong>类</strong></li><li>当我们需要的时候，给予调用者一个承诺：<strong>待会儿我会给你回调数据</strong>时，就可以创建一个Promise的对象</li><li>在通过new创建Promise对象时，我们需要==传入一个回调函数==，我们称之为executor<ul><li>这个回调函数会被<strong>立即执行</strong>，并且给传入另外两个回调函数<code>resolve、reject</code><ul><li>当我们调用resolve回调函数时，会执行Promise对象的<code>then</code>方法传入的回调函数</li><li>当我们调用reject回调函数时，会执行Promise对象的<code>catch</code>方法传入的回调函数</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````jsfunction execode(count) {const promise = new Promise((resolve, reject) =&gt; { // 此处函数为立即执行函数setTimeout(() =&gt; {if (count &gt; 0) {let total = 0for (let i = 0; i &lt;= count; i++) {total += i}// 成功的回调resolve(total)} else {// 失败的回调reject(`${count}错误`)}}, 3000);})return promise}execode(100).then((value) =&gt; {console.log('成功，有了结果：', value);}).catch((err) =&gt; {console.log('失败，有了错误：', err);})</code></pre><h2 id="3-Promise-状态变化"><a href="#3-Promise-状态变化" class="headerlink" title="3. Promise 状态变化"></a>3. Promise 状态变化</h2><p>Promise使用过程，我们可以将它划分成三个状态： </p><ul><li><strong>待定（pending）:</strong> 初始状态，既没有被兑现，也没有被拒绝<ul><li>当执行executor中的代码时，处于该状态</li></ul></li><li><strong>已兑现（fulfilled）</strong>: 意味着操作成功完成<ul><li>执行了resolve时，处于该状态，Promise已经被兑现</li></ul></li><li><strong>已拒绝（rejected）</strong>: 意味着操作失败<ul><li>执行了reject时，处于该状态，Promise已经被拒绝</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {// 1.待定状态console.log('111111');console.log('222222');// 状态一旦确定，不会更改，不能再执行别的回调函数来改变状态// 2.兑现状态resolve()// 3.拒绝状态reject()})promise.then((value) =&gt; {console.log('成功的回调');}).catch((err) =&gt; {console.log('失败的回调');})</code></pre><h3 id="3-1-resolve不同的值"><a href="#3-1-resolve不同的值" class="headerlink" title="3.1 resolve不同的值"></a>3.1 resolve不同的值</h3><ul><li>情况一：如果resolve传入<strong>一个普通的值或者对象</strong>，那么这个值会作为then回调的参数</li><li>情况二：如果resolve中传入的是<strong>另外一个Promise</strong>，那么这个新Promise会决定原Promise的状态</li><li>情况三：如果resolve中传入的是一个对象，并且这个<strong>对象有实现then方法</strong>，那么会执行该then方法，并且根据then方法的结果来决定Promise的状态</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p = new Promise((resolve) =&gt; {setTimeout(() =&gt; {resolve("p的resolve")}, 2000)})const promise = new Promise((resolve, reject) =&gt; {//1.普通值resolve({ name: 'why', age: 18 })//2.promiseresolve(p)//3.thenableresolve({then: function (resolve) {resolve(1111)}})})promise.then(res =&gt; {console.log("then中拿到结果:", res)})</code></pre><h2 id="4-Promise-实例方法"><a href="#4-Promise-实例方法" class="headerlink" title="4. Promise 实例方法"></a>4. Promise 实例方法</h2><h3 id="4-1-then-和-catch-方法"><a href="#4-1-then-和-catch-方法" class="headerlink" title="4.1 then 和 catch 方法"></a>4.1 then 和 catch 方法</h3><p>then方法是Promise对象上的一个方法（实例方法）</p><ul><li>放在Promise的原型上的 <code>Promise.prototype.then</code></li></ul><p>then方法<strong>接受两个参数</strong>：</p><ul><li>resolve的回调函数：当状态变成resolve时会回调的函数</li><li>reject的回调函数：当状态变成reject时会回调的函数</li></ul><p>一个Promise的then方法是可以<strong>被多次调用</strong>的：</p><ul><li>每次调用我们都可以传入对应的resolve回调</li><li>当Promise的状态变成resolve的时候，这些回调函数<strong>都会被执行</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {resolve('success')// reject('failure')})// promise.then(res =&gt; {//     console.log('成功回调', res);// }, err =&gt; {//     console.log('失败回调', err);// })promise.then(res =&gt; {console.log('成功回调', res);})promise.then(res =&gt; {console.log('成功回调', res);})promise.then(res =&gt; {console.log('成功回调', res);})promise.then(res =&gt; {console.log('成功回调', res);})</code></pre><p><em><strong>then 的返回值</strong></em><br>then方法本身是有<strong>返回值</strong>的，它的返回值是<strong>一个Promise</strong><br>当then方法中的回调函数<strong>返回一个结果</strong>时，那么它处于resolve状态，并且会将结果作为resolve的参数</p><ul><li>返回一个普通的值</li><li>返回一个Promise</li><li>返回一个thenable值<br>当then方法抛出一个异常时，那么它处于reject状态</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {resolve('aaaaa')// reject('failure')})promise.then(res =&gt; {  // 返回新的promiseconsole.log('第一个then', res); //aaaaareturn 'bbbbb'}).then(res =&gt; {console.log('第二个then', res);//bbbbbreturn 'ccccc'}).then(res =&gt; {console.log('第三个then', res);//ccccc})promise.then(res =&gt; {console.log('添加第二个then', res);//aaaaa})</code></pre><p>then返回一个Promise，return中的值传入resolve的result中作为下一次执行的参数<br><img src="e0365588857c4a078c318e388f0dfa8a.png" alt="在这里插入图片描述"></p><hr><p>catch方法也是Promise对象上的一个方法（<strong>实例方法</strong>）</p><p>一个Promise的catch方法是可以被<strong>多次调用</strong>的</p><p>catch方法也是会<strong>返回一个Promise对象</strong>的，所以catch方法后面我们可以继续调用then方法或者catch方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {// resolve('success')reject('failure')})promise.catch(err =&gt; {console.log('失败回调', err);}).then(res =&gt; {console.log('成功回调', res);}) // 输出：失败回调failure  成功回调undefined// 因为catch传入的回调在执行完后，默认状态依然会是resolve的</code></pre><p><strong>需要catch() 方法兜底，处理异常情况</strong><br>中断函数继续执行:<br>方式一: return<br>方式二: throw new Error()<br>方式三: yield 暂停(暂时性的中断)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {resolve("aaaaaa")})promise.then(res =&gt; {console.log("then第一次回调:", res)// throw new Error("第二个Promise的异常error")return "bbbbbb"}).then(res =&gt; {console.log("then第二次回调:", res)throw new Error("第三个Promise的异常error")}).then(res =&gt; {console.log("then第三次回调:", res)}).catch(err =&gt; {console.log("catch回调被执行:", err)})// then第一次回调: aaaaaa// then第二次回调: bbbbbb// catch回调被执行: Error: 第三个Promise的异常error</code></pre><h3 id="4-2-finally-方法"><a href="#4-2-finally-方法" class="headerlink" title="4.2 finally 方法"></a>4.2 finally 方法</h3><p>finally方法<strong>不接收参数</strong>，无论Promise对象无论变成fulfilled还是rejected状态，最终<strong>都会被执行</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {resolve('aaaaa')//reject('bbbbb')})promise.then(res =&gt; {console.log('then', res);//执行}).catch(err =&gt; {console.log('catch', err);}).finally(() =&gt; {console.log('hhhhhhh');//执行})</code></pre><h2 id="5-Promise-类方法"><a href="#5-Promise-类方法" class="headerlink" title="5. Promise 类方法"></a>5. Promise 类方法</h2><h3 id="5-1-resolve-和-reject-方法"><a href="#5-1-resolve-和-reject-方法" class="headerlink" title="5.1 resolve 和 reject 方法"></a>5.1 resolve 和 reject 方法</h3><p><code>Promise.resolve()</code> 相当于new Promise，并且执行resolve操作<br><code>Promise.reject()</code> 相当于new Promise，只是会调用reject</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const studentList = ['abc', 'nab']const promise = Promise.resolve(studentList)const promise1 = Promise.reject('error')promise.then(res =&gt; {console.log(res);})promise1.catch(err =&gt; {console.log(err);})</code></pre><h3 id="5-2-all-和-allSettled-方法"><a href="#5-2-all-和-allSettled-方法" class="headerlink" title="5.2 all 和 allSettled 方法"></a>5.2 all 和 allSettled 方法</h3><p><code>Promise.all</code>：</p><ul><li>将多个Promise包裹在一起<strong>形成一个新的Promise</strong></li><li>新的Promise状态由包裹的所有Promise共同决定：<ul><li>当<strong>所有的Promise状态变成fulfilled状态</strong>时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组</li><li>当<strong>有一个Promise状态为reject</strong>时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数</li></ul></li></ul><p><code>Promise.allSettled</code>：</p><ul><li>在<strong>所有的Promise都有结果</strong>（settled），无论是fulfilled，还是rejected时，都会有最终的状态； </li><li>并且这个Promise的结果一定是fulfilled的</li><li>结果：一个数组，数组中每一个值都是对象。对象中包含<strong>status状态，以及对应的value值</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p1 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {// resolve("p1 resolve")reject("p1 reject error")}, 3000)})const p2 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {resolve("p2 resolve")}, 2000)})const p3 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {resolve("p3 resolve")}, 5000)})// allPromise.all([p1, p2, p3]).then(res =&gt; {console.log(res);}).catch(err =&gt; {console.log(err);})// allSettledPromise.allSettled([p1, p2, p3]).then(res =&gt; {console.log(res);}).catch(err =&gt; {console.log(err);})</code></pre><h3 id="5-3-race-和-any-方法"><a href="#5-3-race-和-any-方法" class="headerlink" title="5.3 race 和 any 方法"></a>5.3 race 和 any 方法</h3><p>race 表示<strong>多个Promise相互竞争</strong>，谁先有结果，那么就使用谁的结果</p><ul><li>any 会<strong>等到一个fulfilled状态</strong>，才会决定新Promise的状态，此时输出该返回值</li><li>如果<strong>所有的Promise都是reject</strong>，会等到所有的Promise都变成rejected状态，报一个AggregateError的错误</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p1 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {// resolve("p1 resolve")reject("p1 reject error")}, 3000)})const p2 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {resolve("p2 resolve")}, 2000)})const p3 = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {resolve("p3 resolve")}, 5000)})// anyPromise.any([p1, p2, p3]).then(res =&gt; {console.log("any promise res:", res)}).catch(err =&gt; {console.log("any promise err:", err)})// p2 resolve</code></pre><h1 id="二、迭代器和生成器"><a href="#二、迭代器和生成器" class="headerlink" title="二、迭代器和生成器"></a>二、迭代器和生成器</h1><h2 id="1-迭代器-Iterator"><a href="#1-迭代器-Iterator" class="headerlink" title="1. 迭代器 Iterator"></a>1. 迭代器 Iterator</h2><p>迭代器是帮助我们<strong>对某个数据结构进行遍历</strong>的对象</p><p>实现：next方法</p><ul><li>一个<strong>无参数或者一个参数的函数</strong></li><li><strong>返回</strong>一个应当拥有以下两个属性的对象<ul><li>==done（boolean）==<ul><li>如果迭代器可以产生序列中的下一个值，则为 false。</li><li>如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</li></ul></li><li>==value==<ul><li>迭代器返回的任何 JavaScript 值。done 为 true 时可省略</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````js// 为数组创建迭代器const names = ["abc", "cba", "nba"]const nums = [100, 24, 55, 66, 86]// 封装一个函数function createArrayIterator(arr) {let index = 0return {next: function () {if (index &lt; arr.length) {return { done: false, value: arr[index++] }} else {return { done: true }}}}}const namesIterator = createArrayIterator(names)console.log(namesIterator.next());console.log(namesIterator.next());console.log(namesIterator.next());console.log(namesIterator.next());</code></pre><h3 id="1-1-可迭代对象"><a href="#1-1-可迭代对象" class="headerlink" title="1.1 可迭代对象"></a>1.1 可迭代对象</h3><p>但是上面的代码需要再创建一个迭代器对象，可以对代码进一步封装，让其变成一个可迭代对象</p><p>使用 <code>[Symbol.iterator]</code> 访问该属性<br>需要返回一个: 迭代器</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 将infos变成一个可迭代对象/*1.必须实现一个特定的函数: [Symbol.iterator]2.这个函数需要返回一个迭代器(这个迭代器用于迭代当前的对象)*/const infos = {friends: ["kobe", "james", "curry"],[Symbol.iterator]: function() {let index = 0const infosIterator = {next: () =&gt; {if (index &lt; this.friends.length) {return { done: false, value: this.friends[index++] }} else {return { done: true }}}}return infosIterator}}const iterator = infos[Symbol.iterator]()console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());// 可迭代对象可以进行for of 操作for (const item of infos) {console.log(item);}</code></pre><h4 id="1-1-1-原生迭代器对象"><a href="#1-1-1-原生迭代器对象" class="headerlink" title="1.1.1 原生迭代器对象"></a>1.1.1 原生迭代器对象</h4><p>平时创建的很多原生对象已经实现了可迭代协议，会生成一个迭代器对象</p><p><strong>String、Array、Map、Set、arguments对象、NodeList集合</strong></p><p>这些对象中必然有一个<code>[Symbol.iterator]</code>函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.数组const names = ["abc", "cba", "nba"]// for (const name of names) {//console.log(name)// }console.log(names[Symbol.iterator]())// 2.Setconst set = new Set(["abc", "cba", "nba"])// for (const item of set) {// console.log(item)// }const setIterator = set[Symbol.iterator]()console.log(setIterator.next())console.log(setIterator.next())console.log(setIterator.next())console.log(setIterator.next())</code></pre><h4 id="1-1-2-可迭代对象的应用"><a href="#1-1-2-可迭代对象的应用" class="headerlink" title="1.1.2 可迭代对象的应用"></a>1.1.2 可迭代对象的应用</h4><ul><li>用在特定的语法上：for …of、展开语法、yield*、解构赋值</li><li>创建一些对象时：<code>new Map([Iterable])</code>、<code>new WeakMap([iterable])</code>、<code>new Set([iterable])</code>、<code>new WeakSet([iterable])</code></li><li>一些方法的调用：Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.用在特定的语法上(比如展开语法)const info = {name: "why",age: 18,height: 1.88,[Symbol.iterator]: function() {const values = Object.values(this)let index = 0const iterator = {next: function() {if (index &lt; values.length) {return { done: false, value: values[index++] }} else {return { done: true }}}}return iterator}}function foo(arg1, arg2, arg3) {console.log(arg1, arg2, arg3)}foo(...info)// 2.一些类的构造方法中, 也是传入的可迭代对象const names = ["abc", "cba", "nba"]const set = new Set(names)console.log(set);const set1 = new Set(infos)console.log(set1);// 3.一些常用的方法const p1 = Promise.resolve("aaaa")const p2 = Promise.resolve("aaaa")const p3 = Promise.resolve("aaaa")const pSet = new Set()pSet.add(p1)pSet.add(p2)pSet.add(p3)Promise.all(pSet).then(res =&gt; {console.log("res:", res)})// ['aaaa', 'aaaa', 'aaaa']function bar() {// 将arguments转成Array类型const arr = Array.from(arguments)console.log(arr)}bar(111, 222, 333)</code></pre><h3 id="1-2-自定义类的迭代"><a href="#1-2-自定义类的迭代" class="headerlink" title="1.2 自定义类的迭代"></a>1.2 自定义类的迭代</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {constructor(name, age, height, friends) {this.name = namethis.age = agethis.height = heightthis.friends = friends}// 实例方法[Symbol.iterator]() {let index = 0return {next: () =&gt; {if (index &lt; this.friend.length) {return { done: false, value: this.friend[index++] }} else {return { done: true }}},return: () =&gt; {console.log('监听到迭代器中断了');return { done: true }}}}}const p = new Person("why", 18, 1.88, ["curry", "kobe", "james", "tatumu"])for (const item of p) {console.log(item)if (item === 'curry') {break}}// james curry 监听到迭代器中断了</code></pre><h3 id="1-3-迭代器的中断-了解"><a href="#1-3-迭代器的中断-了解" class="headerlink" title="1.3 迭代器的中断(了解)"></a>1.3 迭代器的中断(了解)</h3><ul><li>迭代器在某些情况下会在没有完全迭代的情况下中断：<ul><li>比如<strong>遍历的过程中</strong>通过break、return、throw中断了循环操作</li><li>比如在解构的时候，没有解构所有的值</li></ul></li><li>那么这个时候我们<strong>想要监听中断</strong>的话，可以<strong>添加return方法</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 见上面代码</code></pre><h2 id="2-生成器-Generator"><a href="#2-生成器-Generator" class="headerlink" title="2. 生成器 Generator"></a>2. 生成器 Generator</h2><p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的<strong>控制函数什么时候继续执行、暂停执行</strong>等</p><h3 id="2-1-生成器函数"><a href="#2-1-生成器函数" class="headerlink" title="2.1. 生成器函数"></a>2.1. 生成器函数</h3><p>生成器函数也是一个函数，但是和普通的函数有一些区别：</p><ul><li>首先，生成器函数需要在function的后面加一个符号：<code>*</code></li><li>其次，生成器函数可以<strong>通过yield关键字来控制函数</strong>的执行流程。<strong>调用生成器不会执行里面的函数</strong></li><li>最后，生成器函数的返回值是一个Generator（生成器）：<ul><li><strong>生成器事实上是一种特殊的迭代器</strong></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````jsfunction* foo(name1) {console.log('1111', name1);console.log('2222', name1);const name2 = yield 'aaa'console.log('3333', name2);console.log('4444', name2);const name3 = yield 'bbb'// return 'bbb'console.log('5555', name3);console.log('6666', name3);yield 'ccc'return undefined}const generator = foo('next1')// 第一段代码的参数在这里传// 1.普通执行时console.log(generator.next());// {value: 'aaa', done: false}console.log(generator.next());// {value: 'bbb', done: false}console.log(generator.next());// {value: 'ccc', done: false}console.log(generator.next());// {value: undefined, done: true}// 2.中间有return语句时console.log(generator.next());// {value: 'aaa', done: false}console.log(generator.next());// {value: 'bbb', done: true}console.log(generator.next());// {value: undefined, done: true}// 3.给函数每次执行时，传入参数console.log(generator.next());console.log(generator.next('next2'));console.log(generator.next('next3'));</code></pre><p>next函数：</p><ul><li>调用next函数的时候，可以给它传递参数</li></ul><p>return函数：</p><ul><li>return传值后这个生成器函数就会结束，之后调用next不会继续生成值了</li></ul><h3 id="2-2-提前结束return-throw-了解"><a href="#2-2-提前结束return-throw-了解" class="headerlink" title="2.2 提前结束return/throw(了解)"></a>2.2 提前结束return/throw(了解)</h3><p>除了return语句之外，也可以给生成器函数<strong>内部抛出异常</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function* foo(name1) {console.log('1111', name1);console.log('2222', name1);const name2 = yield 'aaa'console.log('3333', name2);console.log('4444', name2);const name3 = yield 'bbb'console.log('5555', name3);console.log('6666', name3);yield 'ccc'console.log('last');return undefined}const generator = foo('next1')console.log(generator.next());// console.log(generator.return('next2'));console.log(generator.throw('next2 throw Error'));console.log('----------------');console.log(generator.next('next3'));console.log(generator.next('next4'));// 1111 next1     2222 next1    {value: 'aaa', done: false}// return语句生效的情况：// 1111 next1// 2222 next1// {value: 'aaa', done: false}// {value: 'next2', done: true}// ----------------// {value: undefined, done: true}// {value: undefined, done: true}</code></pre><h3 id="2-3-generator-替代-iterator"><a href="#2-3-generator-替代-iterator" class="headerlink" title="2.3 generator 替代 iterator"></a>2.3 generator 替代 iterator</h3><p>生成器是一种<strong>特殊的迭代器</strong>，那么在某些情况下我们可以使用生成器来替代迭代器（更简便）</p><ul><li>不需要写next等复杂的结构，只需要写实现迭代功能的主体代码</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const names = ['abc', 'bac', 'nba']const nums = [100, 22, 66, 88, 55]function* createArrayIterator(arr) {//yield* arrfor (let i = 0; i &lt; arr.length; i++) {yield arr[i]}}const iterator = createArrayIterator(names)console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())</code></pre><p>改进版：使用 <code>yield*</code> 再生产一个可迭代对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 自定义类迭代class Person {constructor(name, age, height, friends) { this.name = namethis.age = agethis.height = heightthis.friends = friends}*[Symbol.iterator]() {yield* this.friends}}const p = new Person('why', 18, 1.8, ['kobe', 'james', 'curry'])for (const item of p) {console.log(item);}</code></pre><h3 id="2-4-异步处理方案"><a href="#2-4-异步处理方案" class="headerlink" title="2.4 异步处理方案"></a>2.4 异步处理方案</h3><p>案例需求：</p><ul><li>我们需要向服务器隔两秒发送网络请求获取数据，一共需要发送三次请求</li><li>第二次的请求url依赖于第一次的结果</li><li>第三次的请求url依赖于第二次的结果</li><li>依次类推</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 因为是隔2秒后传值，不能直接用returnfunction requestData(url) {return new Promise((resolve) =&gt; {setTimeout(() =&gt; {resolve(url)}, 2000)})}</code></pre><h4 id="2-4-1-处理一-回调地狱"><a href="#2-4-1-处理一-回调地狱" class="headerlink" title="2.4.1 处理一 - 回调地狱"></a>2.4.1 处理一 - 回调地狱</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 方式一: 层层嵌套(回调地狱 callback hell)function getData() {// 1.第一次请求requestData("why").then(res1 =&gt; {console.log("第一次结果:", res1)// 2.第二次请求requestData(res1 + "kobe").then(res2 =&gt; {console.log("第二次结果:", res2)// 3.第三次请求requestData(res2 + "james").then(res3 =&gt; {console.log("第三次结果:", res3)})})})}getData()</code></pre><h4 id="2-4-2-处理二-Promise-链式"><a href="#2-4-2-处理二-Promise-链式" class="headerlink" title="2.4.2 处理二 - Promise 链式"></a>2.4.2 处理二 - Promise 链式</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 方式二: 使用Promise进行重构(解决回调地狱)// 链式调用function getData() {requestData('why').then(res1 =&gt; {console.log(res1);return requestData(res1 + 'kobe')}).then(res2 =&gt; {console.log(res2);return requestData(res2 + 'james')}).then(res3 =&gt; {console.log(res3);})}getData()</code></pre><h4 id="2-4-3-处理三-generator-yield"><a href="#2-4-3-处理三-generator-yield" class="headerlink" title="2.4.3 处理三 - generator+yield"></a>2.4.3 处理三 - generator+yield</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function* getData() {const res11 = yield requestData('why')console.log(res11);const res22 = yield requestData(res11 + 'kobe')console.log(res22);const res33 = yield requestData(res22 + 'james')console.log(res33);}// 调用方法一const generator = getData()// 生成器函数调用时不立即执行，先返回一个生成器generator.next().value.then(res1 =&gt; { //res1从promise函数中拿的whygenerator.next(res1).value.then(res2 =&gt; { //res2从promise函数中拿的res11 + 'kobe'generator.next(res2).value.then(res3 =&gt; {generator.next(res3)})})})// generator.next(res1)是将参数'why'传给生成器getData的res11// generator.next(res1)执行结果为{value: requestData(res11 + 'kobe'), done: false}// generator.next(res1).value得到一个promise// 调用方法二：自动化执行生成器函数(了解)function execGenFn(genFn) {// 1.获取对应函数的generatorconst generator = genFn()// 2.定义一个递归函数function exec(res) {// result -&gt; { done: true/false, value: 值/undefined }const result = generator.next(res)if (result.done) returnresult.value.then(res =&gt; {exec(res)})}// 3.执行递归函数exec()}execGenFn(getData)</code></pre><h4 id="2-4-4-处理四-await-async"><a href="#2-4-4-处理四-await-async" class="headerlink" title="2.4.4 处理四 - await/async"></a>2.4.4 处理四 - await/async</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 方式四: async/await的解决方案async function getData() {const res1 = await requestData("why")console.log("res1:", res1)const res2 = await requestData(res1 + "kobe")console.log("res2:", res2)const res3 = await requestData(res2 + "james")console.log("res3:", res3)}const generator = getData()</code></pre><h2 id="3-异步-async、await"><a href="#3-异步-async、await" class="headerlink" title="3. 异步 async、await"></a>3. 异步 async、await</h2><h3 id="3-1-异步函数-async"><a href="#3-1-异步函数-async" class="headerlink" title="3.1 异步函数 async"></a>3.1 异步函数 async</h3><p>异步函数的内部<strong>代码执行过程和普通的函数是一致</strong>的，默认情况下也是会被同步执行</p><p><strong>异步函数有返回值</strong>时，和普通函数会有区别： </p><ul><li>情况一：异步函数返回值是普通值时，返回值<strong>相当于被包裹到Promise.resolve中</strong></li><li>情况二：如果我们的异步函数的返回值是Promise，状态由会由Promise决定</li><li>情况三：如果我们的异步函数的返回值是一个对象并且实现了thenable，那么会由对象的then方法来决定</li></ul><p>如果我们在async中<strong>抛出异常</strong>，那么程序它并不会像普通函数一样报错，而是会<strong>作为Promise的reject来传递</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function foo() {console.log('---------1');'abc'.filter()console.log('---------2');// --&gt; Promise.resolve(123)return 123}foo().then(res =&gt; {console.log('res:', res);}).catch(err =&gt; {console.log('err', err);})</code></pre><h3 id="3-2-await-关键字"><a href="#3-2-await-关键字" class="headerlink" title="3.2 await 关键字"></a>3.2 await 关键字</h3><p>async函数另外一个特殊之处就是可以在它内部<strong>使用await关键字</strong>，而普通函数中是不可以的</p><p>通常使用await是后面会跟上一个表达式，这个表达式会返回一个Promise</p><ul><li><p>那么await会==等到Promise的状态变成fulfilled状态==，之后继续执行异步函数</p></li><li><p>如果await后面是一个<strong>普通的值</strong>，那么会直接返回这个值</p></li><li><p>如果await后面是一个<strong>thenable的对象</strong>，那么会根据对象的then方法调用来决定后续的值</p></li><li><p>如果await后面的表达式，<strong>返回的Promise是reject的状态</strong>，那么会将这个reject结果直接作为函数的Promise的reject值</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function requestData(url) {return new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {// resolve(url)reject('Error message')}, 2000)})}async function getData() {const res1 = await requestData('why')console.log(res1);const res2 = await requestData(res1 + 'kobe')console.log(res2);}getData().catch(err =&gt; {console.log(err);}) // reject需要.catch()兜底</code></pre><h1 id="四、事件循环-队列"><a href="#四、事件循环-队列" class="headerlink" title="四、事件循环/队列"></a>四、事件循环/队列</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ul><li>==进程==：我们可以认为，<strong>启动一个应用程序，就会默认启动一个进程</strong>（也可能是多个进程）</li><li>==线程==：每一个进程中，都会启动<strong>至少一个线程用来执行程序中的代码</strong>，这个线程被称之为主线程</li></ul><p><img src="32c621c589774e9da02e594774fad97e.png" alt="在这里插入图片描述"></p><p>操作系统如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作：</p><ul><li>这是因为<strong>CPU的运算速度非常快</strong>，它可以快速的在多个进程之间迅速的切换</li><li>当我们进程中的线程<strong>获取到时间片</strong>时，就可以快速执行我们编写的代码</li><li>对于用户来说是感受不到这种快速的切换的</li></ul><h3 id="1-2-JavaScript-单线程"><a href="#1-2-JavaScript-单线程" class="headerlink" title="1.2 JavaScript 单线程"></a>1.2 JavaScript 单线程</h3><p>多数的浏览器都是多进程的</p><ul><li>当我们<strong>打开一个tab页面时就会开启一个新的进程</strong>，这是为了防止一个页面卡死而造成 所有页面无法响应，整个浏览器需要强制退出</li><li>每个进程中又有很多的线程，其中包括执行JavaScript代码的线程</li></ul><p>JavaScript的代码执行是在<strong>一个单独的线程</strong>中执行的：</p><ul><li>这就意味着JavaScript的代码，在<strong>同一个时刻只能做一件事</strong></li><li>如果这件事是非常耗时的，就意味着当前的线程就会被阻塞</li></ul><h2 id="2-事件队列-循环"><a href="#2-事件队列-循环" class="headerlink" title="2. 事件队列/循环"></a>2. 事件队列/循环</h2><p><img src="d2c26d477b324f1f90a33e68096e51e3.png" alt="在这里插入图片描述"></p><h3 id="2-1-宏任务-微任务"><a href="#2-1-宏任务-微任务" class="headerlink" title="2.1 宏任务/微任务"></a>2.1 宏任务/微任务</h3><p>事件循环中并非只维护着一个队列，事实上是有两个队列：</p><ul><li><strong>宏任务队列</strong>（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等</li><li><strong>微任务队列</strong>（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等</li></ul><p>执行顺序：</p><ol><li><strong>main script中的代码优先</strong>执行（编写的顶层script代码）</li><li>在执行任何一个宏任务之前（不是队列，是一个宏任务），都会<strong>先查看微任务队列中是否有任务</strong>需要执行 <ol><li>也就是宏任务执行之前，必须保证微任务队列是空的；</li><li>如果不为空，那么就优先执行微任务队列中的任务（回调）</li></ol></li></ol><h3 id="2-2-面试题：Promise-async-await"><a href="#2-2-面试题：Promise-async-await" class="headerlink" title="2.2 面试题：Promise/async/await"></a>2.2 面试题：Promise/async/await</h3><p>面试题一</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log("script start")setTimeout(function () {console.log("setTimeout1");new Promise(function (resolve) {resolve();}).then(function () {new Promise(function (resolve) {resolve();}).then(function () {console.log("then4");});console.log("then2");});});new Promise(function (resolve) {console.log("promise1");resolve();}).then(function () {console.log("then1");});setTimeout(function () {console.log("setTimeout2");});console.log(2);queueMicrotask(() =&gt; {console.log("queueMicrotask1")});new Promise(function (resolve) {resolve();}).then(function () {console.log("then3");});console.log("script end")/* 结果：script startpromise12script endthen1queueMicrotask1then3setTimeout1then2then4setTimeout2 */</code></pre><p><img src="eff350715078431f93eab5125ed0538f.png" alt="在这里插入图片描述"></p><p>面试题二</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log("script start")function requestData(url) {console.log("requestData")return new Promise((resolve) =&gt; {setTimeout(() =&gt; {console.log("setTimeout")resolve(url)}, 2000);})}// await/asyncasync function getData() {console.log("getData start") //和普通函数一样立即执行const res = await requestData("why") // 需要等待requestData()返回结果才执行函数中剩下的部分console.log("then1-res:", res)console.log("getData end")}getData()console.log("script end")/* 结果：script startgetData startrequestData//setTimeout()需要等两秒，因此此时还不能加入队列中，先往后执行script endsetTimeout//resolve(url)调用时，将29-31行代码加入微任务，相当于then(...代码)then1-res: whygetData end */</code></pre><p><img src="400eac8abe374370885fd8d311d66536.png" alt="在这里插入图片描述"></p><p>面试题三</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function async1() {console.log('async1 start')await async2();console.log('async1 end') // 这部分代码相当于then(undefined =&gt; {console.log('async1 end')}),会加入微任务}async function async2() {console.log('async2')} // return undefined --&gt; return Promise.resolve(undefined)console.log('script start')setTimeout(function () {console.log('setTimeout')}, 0)async1();new Promise(function (resolve) {console.log('promise1')resolve();}).then(function () {console.log('promise2')})console.log('script end')/* 结果：script startasync1 startasync2promise1script endasync1 endpromise2setTimeout */</code></pre><h1 id="五、其他知识补充"><a href="#五、其他知识补充" class="headerlink" title="五、其他知识补充"></a>五、其他知识补充</h1><h2 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1. 异常处理"></a>1. 异常处理</h2><p>很多时候我们可能验证到不是希望得到的参数时，就会直接return：</p><ul><li>但是return存在很大的弊端：调用者<strong>不知道是因为函数内部没有正常执行，还是执行结果就是一个undefined</strong></li><li>事实上，正确的做法应该是如果没有通过某些验证，那么应该<strong>让外界知道函数内部报错</strong>了</li></ul><p>此时<strong>通过throw关键字</strong>，抛出一个异常</p><h3 id="1-1-throw-关键字"><a href="#1-1-throw-关键字" class="headerlink" title="1.1 throw 关键字"></a>1.1 throw 关键字</h3><ul><li>throw语句用于<strong>抛出一个用户自定义的异常</strong></li><li>当遇到throw语句时，当前的函数<strong>执行会被停止</strong></li></ul><p>throw关键字后的类型</p><ul><li>number/string/boolean</li><li>自定义对象</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class HYError {constructor(message, code) {this.errMessage = messagethis.errCode = code}}function foo() {console.log('foo function1');throw new HYError('err', -1001)// throw new Error('错误信息')console.log('foo function2');console.log('foo function3');}foo()</code></pre><h3 id="1-2-Error-类型"><a href="#1-2-Error-类型" class="headerlink" title="1.2 Error 类型"></a>1.2 Error 类型</h3><p>JavaScript已经给我们<strong>提供了一个Error类</strong>，我们可以直接创建这个类的对象</p><p>Error包含<strong>三个属性</strong>：</p><ul><li><code>messsage</code>：创建Error对象时<strong>传入</strong>的message</li><li><code>name</code>：Error的名称，通常和<strong>类的名称</strong>一致</li><li><code>stack</code>：整个Error的错误信息，包括函数的调用栈，当我们直接打印Error对象时，打印的就是stack</li></ul><p>Error有一些自己的<strong>子类</strong>：</p><ul><li>RangeError：下标值越界时使用的错误类型</li><li>SyntaxError：解析语法错误时使用的错误类型</li><li>TypeError：出现类型错误时，使用的错误类型；</li></ul><h3 id="1-3-捕获异常"><a href="#1-3-捕获异常" class="headerlink" title="1.3 捕获异常"></a>1.3 捕获异常</h3><p>一个函数抛出了异常，但是我们并没有对这个异常进行处理，那么这个<strong>异常会继续传递</strong>到上一个函数调用中；<br>而如果<strong>到了最顶层（全局）的代码</strong>中依然没有对这个异常的处理代码，这个时候就会<strong>报错并且终止程序的运行</strong></p><p>但是很多情况下当出现异常时，我们并不希望程序直接推出，而是希望可以正确的处理异常：</p><ul><li>这个时候我们就可以使用<code>try catch</code></li><li>如果有一些<strong>必须要执行的代码</strong>，我们可以使用<code>finally</code>来执行<ul><li>注意：如果try和finally中都有返回值，那么会使用finally当中的返回值</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````jsfunction foo() {console.log('foo function1');throw new Error('错误信息')console.log('foo function2');console.log('foo function3');}function test() {try {foo()} catch (error) {console.log(error.message, error.name, error.stack);} finally {console.log('finally');}}function bar() {test()}bar()</code></pre><h2 id="2-Storage"><a href="#2-Storage" class="headerlink" title="2. Storage"></a>2. Storage</h2><p>见 JavaScript 基础（六）笔记</p><p>封装 Cache</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Cache {constructor(isLocal = true) {this.storage = isLocal ? localStorage: sessionStorage}setCache(key, value) {if (!value) {throw new Error("value error: value必须有值!")}if (value) {this.storage.setItem(key, JSON.stringify(value))}}getCache(key) {const result = this.storage.getItem(key)if (result) {return JSON.parse(result)}}removeCache(key) {this.storage.removeItem(key)}clear() {this.storage.clear()}}const localCache = new Cache()const sessionCache = new Cache(false)// 应用localCache.setCache("sno", 111)const userInfo = {name: "why",nickname: "coderwhy",level: 100,imgURL: "http://github.com/coderwhy.png"}// storage本身是不能直接存储对象类型的sessionCache.setCache("userInfo", userInfo)</code></pre><h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3. 正则表达式"></a>3. 正则表达式</h2><p>正则表达式是一种字符串匹配利器，可以帮助我们<strong>搜索、获取、替代字符串</strong></p><h3 id="3-1-正则的创建"><a href="#3-1-正则的创建" class="headerlink" title="3.1 正则的创建"></a>3.1 正则的创建</h3><p>创建方法：</p><ul><li>new</li><li>字面量</li></ul><p>正则表达式主要由两部分组成：<strong>模式</strong>（patterns）和<strong>修饰符</strong>（flags）</p><ul><li>修饰符：<code>g</code>（匹配全部的）、<code>i</code>（忽略大小写）、<code>m</code>（多行匹配）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const re1 = new RegExp('abc', 'ig')const re1 = /abc/igconst message = "fdabc123 faBC323 dfABC222 A2324aaBc"// 需求: 将所有的abc(忽略大小写)换成cbaconst newMessage1 = message.replaceAll(/abc/ig, 'cba')console.log(newMessage1);// 需求：将所有的数字删除const newMessage2 = message.replaceAll(/\d+/ig, '')console.log(newMessage2);</code></pre><h3 id="3-2-正则常见的方法"><a href="#3-2-正则常见的方法" class="headerlink" title="3.2 正则常见的方法"></a>3.2 正则常见的方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>exec</td><td>在字符串中执行<strong>查找匹配</strong>的 RegExp 方法，它<strong>返回一个数组</strong>（未匹配到则返回 null）。</td></tr><tr><td>test</td><td>在字符串中<strong>测试是否匹配</strong>的 RegExp 方法，它<strong>返回 true 或 false</strong>。</td></tr><tr><td>match</td><td>在字符串中执行<strong>查找匹配</strong>的 String 方法，它<strong>返回一个数组</strong>（在未匹配到时会返回 null）。</td></tr><tr><td>matchAll</td><td>在字符串中执行<strong>查找所有匹配</strong>的 String 方法，它<strong>返回一个迭代器</strong>（iterator）。修饰符必须加g</td></tr><tr><td>search</td><td>在字符串中<strong>测试匹配</strong>的 String 方法，它返回匹配到的位置<strong>索引</strong>，或者在失败时返回-1。</td></tr><tr><td>replace</td><td>在字符串中执行查找匹配的 String 方法，并且使用替换字符串<strong>替换掉</strong>匹配到的子字符串。</td></tr><tr><td>split</td><td>使用正则表达式或者一个固定字符串<strong>分隔</strong>一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">输入账号: &lt;input type="text"&gt;&lt;p class="tip"&gt;请输入账号&lt;/p&gt;const re1 = /abc/igconst message = "fdabc123 faBC323 dfABC222 A2324aaBc"// 1.test方法if (re1.test(message)) {console.log('message符合规则');} else {console.log('message不符合规则');}// 案例: 让用户输入的账号必须是aaaaaconst inputEl = document.querySelector("input")const tipEl = document.querySelector(".tip")inputEl.oninput = function () {const value = inputEl.valueif (/^aaaaa$/.test(value)) {tipEl.textContent = '符合要求'} else {tipEl.textContent = '不符合要求'}}// 2.exec方法const res1 = re1.exec(message)console.log(res1);//['abc', index: 2, input: 'fdabc123 faBC323 dfABC222 A2324aaBc', groups: undefined]// 3.match方法const res2 = message.match(re1)console.log(res2);//['abc', 'aBC', 'ABC', 'aBc']// 3.matchAll方法 修饰符必须加gconst res3 = message.matchAll(re1)console.log(res3);//RegExpStringIterator {}for (const item of res3) {console.log(item);}// 多个exec的结果// 4.split方法const res4 = message.split(re1)console.log(res4);// 5.search方法const res5 = message.search(re1)console.log(res5); // 2</code></pre><h3 id="3-3-正则规则"><a href="#3-3-正则规则" class="headerlink" title="3.3 正则规则"></a>3.3 正则规则</h3><h4 id="3-3-1-字符类"><a href="#3-3-1-字符类" class="headerlink" title="3.3.1 字符类"></a>3.3.1 字符类</h4><p>字符类是一个特殊的符号，匹配特定集中的任何符号</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\d</code>（digit）</td><td>数字：从 0 到 9 的字符。</td></tr><tr><td><code>\s</code>（space）</td><td>空格符号：包括空格，制表符 <code>\t</code>，换行符 <code>\n</code> 和其他少数稀有字符，例如 <code>\v</code>，<code>\f</code> 和 <code>\r</code>。</td></tr><tr><td><code>\w</code>（word）</td><td>“单字”字符：大小写字母或数字或下划线 。</td></tr><tr><td><code>.</code>（点）</td><td>点 . 是一种特殊字符类，它与 “除换行符之外的任何字符” 匹配</td></tr><tr><td>反向类</td><td></td></tr></tbody></table><ul><li><code> \D</code> 非数字：除 <code>\d</code> 以外的任何字符，例如字母。</li><li><code>\S</code> 非空格符号：除 <code>\s</code> 以外的任何字符，例如字母。</li><li><code>\W</code> 非单字字符：除 <code>\w</code> 以外的任何字符，例如非拉丁字母或空格</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const message = "fdaa4 22242asfasdf2242"const re = /\d+/igconsole.log(message.match(re))</code></pre><h4 id="3-3-2-锚点、词边界与转义"><a href="#3-3-2-锚点、词边界与转义" class="headerlink" title="3.3.2 锚点、词边界与转义"></a>3.3.2 锚点、词边界与转义</h4><p>锚点：</p><ul><li>符号 ^ 匹配文本<strong>开头</strong>；</li><li>符号 $ 匹配文本<strong>末尾</strong></li></ul><p>词边界：</p><ul><li>词边界 <code>\b</code> 是一种检查，就像 ^ 和 $ 一样，它会检查字符串中的位置是否是词边界。</li><li>词边界测试 <code>\b</code> 检查位置的一侧是否匹配 <code>\w</code></li></ul><p>要把特殊字符作为常规字符来使用，需要对其进行转义：</p><ul><li>常见的需要转义的字符：<code>[] \ / ^ $ . | ? * + ( )</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 锚点const message = "My name is WHY."if (/why\.$/i.test(message)) {console.log("以why结尾")}// 词边界的应用const infos = "now time is 11:56, 12:00 eat food, number is 123:456"const timeRe = /\b\d\d:\d\d\b/ig;console.log(infos.match(timeRe));// 获取到.js/.jsx的文件名const fileNames = ["abc.html", "Home.jsx", "index.html", "index.js", "util.js", "format.js"]const jsfileRe = /\.jsx?$/const newFileNames = fileNames.filter(filename =&gt; jsfileRe.test(filename))console.log(newFileNames);</code></pre><h4 id="3-3-3-集合和范围"><a href="#3-3-3-集合和范围" class="headerlink" title="3.3.3 集合和范围"></a>3.3.3 集合和范围</h4><p>集合（Sets）</p><ul><li>比如说，<code>[eao]</code> 意味着查找在 3 个字符 ‘a’、‘e’ 或者 ‘o’ 中的任意一个；</li></ul><p>范围（Ranges） </p><ul><li>方括号也可以包含字符范围</li><li>比如说，<code>[0-9A-F]</code> 表示两个范围：它搜索一个字符，满足数字 0 到 9 或字母 A 到 F</li><li><code>\d</code> —— 和 <code>[0-9]</code> 相同；<code>\D</code> -&gt; <code>[^0-9]</code></li><li><code>\w</code> —— 和 <code>[a-zA-Z0-9_]</code> 相同</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const phoneNum = '185025510280'const phoneRe = /^1[3-9]\d{9}$/console.log(phoneRe.test(phoneNum));</code></pre><h4 id="3-3-4-量词"><a href="#3-3-4-量词" class="headerlink" title="3.3.4 量词"></a>3.3.4 量词</h4><p>量词用来<strong>形容我们所需要的数量</strong>的词</p><p>数量 {n} </p><ul><li>确切的位数：{5} </li><li>某个范围的位数：{3,5}</li></ul><p>缩写：</p><ul><li><code>+</code>：代表“一个或多个”，相当于 {1, } </li><li><code>?</code>：代表“零个或一个”，相当于 {0,1}。换句话说，它使得符号变得可选；</li><li><code>*</code>：代表“零个或多个”，相当于 {0, }。也就是说，这个字符可以多次出现或不出现</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 案例: 字符串的html元素, 匹配出来里面所有的标签const htmlElement = "&lt;div&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;h2&gt;我是标题&lt;/h2&gt;&lt;/div&gt;"const tagRe = /&lt;\/?[a-z][a-z0-9]*&gt;/igconst results2 = htmlElement.match(tagRe)console.log(results2)</code></pre><h4 id="3-3-5-贪婪和惰性"><a href="#3-3-5-贪婪和惰性" class="headerlink" title="3.3.5 贪婪和惰性"></a>3.3.5 贪婪和惰性</h4><p><strong>默认</strong>情况下的匹配规则是<strong>查找到匹配的内容后，会继续向后查找</strong>，一直找到最后一个匹配的内容 </p><ul><li>这种匹配的方式，我们称之为贪婪模式（Greedy）</li></ul><p>懒惰模式中的量词与贪婪模式中的是相反的。</p><ul><li>只要获取到对应的内容后，就不再继续向后匹配</li><li>我们可以<strong>在量词后面再加一个问号</strong> ‘?’ 来启用它</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const message = "我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》"// 默认.+采用贪婪模式const nameRe = /《.+》/igconst result1 = message.match(nameRe)console.log(result1)// 使用惰性模式const nameRe = /《.+?》/igconst result1 = message.match(nameRe)console.log(result1)</code></pre><h4 id="3-3-6-捕获组"><a href="#3-3-6-捕获组" class="headerlink" title="3.3.6 捕获组"></a>3.3.6 捕获组</h4><p>模式的<strong>一部分可以用括号括起来</strong> (…)，这称为“捕获组</p><ul><li>它允许将匹配的一部分作为结果数组中的单独项</li><li>它将括号视为一个整体</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.打印书名，不要《》const message = "我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》"const nameRe = /《(?&lt;why&gt;.+?)》/igconst iterator = message.matchAll(nameRe)for (const item of iterator) {console.log(item[1]);}// 2.将捕获组作为整体const info = "dfabcabcfabcdfdabcabcabcljll;jk;j"const abcRe = /(abc){2,}/igconsole.log(info.match(abcRe));// ['abcabc', 'abcabcabc']</code></pre><p>捕获组的补充：<br><img src="a2174ea65d4e4e258f2533b28df65b22.png" alt="在这里插入图片描述"></p><h3 id="3-4-练习案例"><a href="#3-4-练习案例" class="headerlink" title="3.4 练习案例"></a>3.4 练习案例</h3><h4 id="3-4-1-歌词解析-重要"><a href="#3-4-1-歌词解析-重要" class="headerlink" title="3.4.1 歌词解析(重要)"></a>3.4.1 歌词解析(重要)</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const lyricString = "[00:00.000] 作词 : 许嵩\n[00:01.000] 作曲 : 许嵩\n[00:02.000] 编曲 : 许嵩\n[00:22.240]天空好想下雨\n[00:24.380]我好想住你隔壁\n[00:26.810]傻站在你家楼下\n[00:29.500]抬起头数乌云\n[00:31.160]如果场景里出现一架钢琴\n[00:33.640]我会唱歌给你听\n[00:35.900]哪怕好多盆水往下淋\n"// 封装function parseLyric(lyricString) {// 1.根据\n切割字符串const lyricLineStrings = lyricString.split('\n')// 2.针对每一行歌词时间进行解析const timeRe = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/iconst lyricInfos = []// [01:22.550]夏末秋凉里带一点温热有换季的颜色for (const lineString of lyricLineStrings) {// 1.获取时间const result = lineString.match(timeRe)if (!result) continueconst minuteTime = result[1] * 60 * 1000const secondTime = result[2] * 1000const mSecondTime = result[3].length === 3 ? result[3] * 1 : result[3] * 10// 考虑毫秒有2位的情况[01:22.550]const time = minuteTime + secondTime + mSecondTime// 2.获取内容const content = lineString.replace(timeRe, '').trim()// 3.将对象放到数组中lyricInfos.push({ time, content })}return lyricInfos}const lyricInfos = parseLyric(lyricString)console.log(lyricInfos)</code></pre><h4 id="3-4-2-时间格式化"><a href="#3-4-2-时间格式化" class="headerlink" title="3.4.2 时间格式化"></a>3.4.2 时间格式化</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function formatTime(timestamp, fmtString) {// 1.将时间戳转成Dateconst date = new Date(timestamp)// // 2.获取到值// const year = date.getFullYear()// const month = date.getMonth() + 1// const day = date.getDate()// const hour = date.getHours()// const minute = date.getMinutes()// const second = date.getSeconds()// // 3.创建正则// const yearRe = /y+/// const monthRe = /M+/// 2.正则和值匹配起来const dateO = {'y+': date.getFullYear(),'M+': date.getMonth() + 1,"d+": date.getDate(),"h+": date.getHours(),"m+": date.getMinutes(),"s+": date.getSeconds()}for (const key in dateO) {if (new RegExp(key).test(fmtString)) {const value = (dateO[key] + '').padStart(2, '0')fmtString = fmtString.replace(new RegExp(key), value)}}return fmtString}// 某一个商品上架时间, 活动的结束时间const timeEl = document.querySelector(".time")const productJSON = {name: "iPhone",newPrice: 4999,oldPrice: 5999,endTime: 1659252301637}timeEl.textContent = formatTime(productJSON.endTime, 'yyyy/MM/dd hh:mm:ss')</code></pre><h1 id="六、防抖和节流"><a href="#六、防抖和节流" class="headerlink" title="六、防抖和节流"></a>六、防抖和节流</h1><ul><li>JavaScript是事件驱动的，大量的操作会触发事件，加入到事件队列中处理。</li><li>而对于某些频繁的事件处理会造成性能的损耗，我们就可以通过防抖和节流来限制事件频繁的发生</li></ul><h2 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a>1. 防抖</h2><h3 id="1-1-认识防抖函数-debounce"><a href="#1-1-认识防抖函数-debounce" class="headerlink" title="1.1 认识防抖函数 debounce"></a>1.1 认识防抖函数 debounce</h3><p>==过程：==</p><ul><li>当事件触发时，相应的函数并<strong>不会立即触发，而是会等待一定的时间</strong>； </li><li>当事件密集触发时，函数的触发会被频繁的推迟；</li><li>只有等待了一段时间也没有事件触发，才会真正的执行响应函数</li></ul><p>==应用场景：==</p><ul><li>输入框中频繁的输入内容，搜索或者提交信息</li><li>频繁的点击按钮，触发某个事件</li><li>监听浏览器滚动事件，完成某些特定操作</li><li>用户缩放浏览器的resize事件</li></ul><p>==应用案例：==<br>搜索联想，这些联想内容通常是保存在服务器的，所以需要一次网络请求</p><ul><li>在合适的情况下发送网络请求</li><li>比如如果用户快速的输入一个macbook，那么只是发送一次网络请求</li><li>比如如果用户是输入一个m想了一会儿，这个时候m确实应该发送一次网络请求</li><li>也就是我们应该<strong>监听用户在某个时间，比如3000ms内，没有再次触发时间时，再发送网络请求</strong></li></ul><h3 id="1-2-自定义防抖函数"><a href="#1-2-自定义防抖函数" class="headerlink" title="1.2 自定义防抖函数"></a>1.2 自定义防抖函数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="text"&gt;&lt;script&gt;function hydebounce(fn, delay) {// 1.记录上一次事件触发的timerlet timer = null// 2.触发事件时执行的函数const _debounce = function (...args) {// console.log('_debounce的this,', this);// inputEl// 2.1 如果有再次(更多次)触发事件，清除上一次的timerif (timer) clearTimeout(timer)// 2.2 延迟去执行对应的fntimer = setTimeout(() =&gt; {fn.apply(this, args)timer = null}, delay);}// 返回一个新的函数return _debounce}&lt;/script&gt;&lt;script&gt;// 1.获取input元素const inputEl = document.querySelector("input")// 2.防抖处理代码let counter = 1inputEl.oninput = hydebounce(function (e) {console.log(`发送网络请求${counter++}:`, this.value, e)}, 3000)&lt;/script&gt;</code></pre><h4 id="优化（了解）"><a href="#优化（了解）" class="headerlink" title="优化（了解）"></a>优化（了解）</h4><p>优化一：优化取消操作（增加取消功能）<br>优化二：优化立即执行效果：第一次输入时立即执行，后面每次输入触发流程结束后，重新输入都立即执行<br>优化三：优化返回值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="text"&gt;&lt;button class="cancel"&gt;取消&lt;/button&gt;&lt;script&gt;function hydebounce(fn, delay, immediate = false, resultCallback) {// 1.记录上一次事件触发的timerlet timer = nulllet isInvoke = false// 2.触发事件时执行的函数const _debounce = function (...args) {return new Promise((resolve, reject) =&gt; {try {// 2.1 如果有再次(更多次)触发事件，清除上一次的timerif (timer) clearTimeout(timer)let res = undefinedif (immediate &amp;&amp; !isInvoke) {res = fn.apply(this, args)if (resultCallback) resultCallback(res)resolve(res)isInvoke = truereturn}// 2.2 延迟去执行对应的fntimer = setTimeout(() =&gt; {res = fn.apply(this, args)if (resultCallback) resultCallback(res)resolve(res)timer = nullisInvoke = false // 保证延迟执行后，再次输入时可以立即执行}, delay);} catch {reject(error)}})}// 3.给_debounce绑定一个取消的函数_debounce.cancel = function () {if (timer) clearTimeout(timer)timer = nullisInvoke = false}// 返回一个新的函数return _debounce}&lt;/script&gt;&lt;script&gt;// 1.获取input元素const inputEl = document.querySelector("input")const cancelBtn = document.querySelector(".cancel")// 2.防抖处理代码let counter = 1const debounceFn = hydebounce(function (e) {console.log(`发送网络请求${counter++}:`, this.value, e)}, 3000, true)inputEl.oninput = debounceFncancelBtn.onclick = function () {debounceFn.cancel()}// 优化返回值const myDebounceFn = hydebounce(function (name, age, height) {console.log("----------", name, age, height)return "coderwhy 哈哈哈哈"}, 1000, false)myDebounceFn("why", 18, 1.88).then(res =&gt; {console.log("拿到执行结果:", res) //coderwhy 哈哈哈哈})&lt;/script&gt;</code></pre><h2 id="2-节流"><a href="#2-节流" class="headerlink" title="2. 节流"></a>2. 节流</h2><h3 id="2-1-认识节流函数-throttle"><a href="#2-1-认识节流函数-throttle" class="headerlink" title="2.1 认识节流函数 throttle"></a>2.1 认识节流函数 throttle</h3><p>==过程：==</p><ul><li>当事件触发时，会执行这个事件的响应函数</li><li>如果这个事件会被频繁触发，那么节流函数会<strong>按照一定的频率来执行</strong>函数</li><li>不管在这个中间有多少次触发这个事件，执行函数的频繁总是固定的</li></ul><p>==应用场景：==</p><ul><li>监听页面的滚动事件</li><li>鼠标移动事件</li><li>用户频繁点击按钮操作</li><li>游戏中的一些设计</li></ul><p>==应用案例：==<br>搜索联想，这些联想内容通常是保存在服务器的，所以需要一次网络请求</p><ul><li>监听input的输入，前后输入时间间隔超过一定时间（10s）后，对后面输入的发送请求</li><li>若未超过，则不发送请求。此时过一段时间输入时，若与初次时间间隔超过10s则立即执行，startTime刷新</li><li><strong>发送请求的间隔只会等于或大于10s</strong></li></ul><h3 id="2-2-自定义节流函数"><a href="#2-2-自定义节流函数" class="headerlink" title="2.2 自定义节流函数"></a>2.2 自定义节流函数</h3><p><img src="8d9d9e99ac6246bf9774a6cb3545aa79.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="text"&gt;&lt;script&gt;function hythrottle(fn, interval) {let startTime = 0const _throttle = function (...args) {const nowTime = new Date().getTime()const waitTime = interval - (nowTime - startTime)if (waitTime &lt;= 0) {fn.apply(this, args)startTime = nowTime}}return _throttle}&lt;/script&gt;&lt;script&gt;// 1.获取input元素const inputEl = document.querySelector("input")// 2.节流处理代码let counter = 1inputEl.oninput = hythrottle(function (e) {console.log(`发送网络请求${counter++}:`, this.value, e)}, 10000)</code></pre><h4 id="优化（了解）-1"><a href="#优化（了解）-1" class="headerlink" title="优化（了解）"></a>优化（了解）</h4><p>优化一：节流最后一次也可以执行<br><img src="555c1de7589a4fe4bf9c60644bfb26fc.png" alt="在这里插入图片描述"></p><p>优化二：优化添加取消功能<br>优化三：优化返回值问题</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="text"&gt;&lt;button class="cancel"&gt;取消&lt;/button&gt;&lt;script&gt;function hythrottle(fn, interval, leading = true, trailing = false) {let startTime = 0let timer = nullconst _throttle = function (...args) {return new Promise((resolve, reject) =&gt; {try {// 1.获取当前时间const nowTime = new Date().getTime()// 使函数在最开始不立即执行if (!leading &amp;&amp; startTime === 0) {startTime = nowTime}// 2.计算需要等待的时间执行函数const waitTime = interval - (nowTime - startTime)if (waitTime &lt;= 0) {if (timer) clearTimeout(timer)const res = fn.apply(this, args)resolve(res)startTime = nowTimetimer = nullreturn}// 3.使节流最后一次也可以执行if (trailing &amp;&amp; !timer) {timer = setTimeout(() =&gt; {const res = fn.apply(this, args)resolve(res)startTime = new Date().getTime() // 最后一次没有触发_throttle函数，无法使用nowTimetimer = null}, waitTime);}} catch (error) {reject(error)}})_throttle.cancel = function() {if (timer) clearTimeout(timer)startTime = 0timer = null}return _throttle}&lt;/script&gt;&lt;script&gt;// 1.获取input元素const inputEl = document.querySelector("input")const cancelBtn = document.querySelector(".cancel")// 2.节流处理代码let counter = 1inputEl.oninput = hythrottle(function (e) {console.log(`发送网络请求${counter++}:`, this.value, e)}, 1000, false, true)// 3.获取返回值const throttleFn = hythrottle(function(event) {console.log(`发送网络请求${counter++}:`, this.value, event)return "throttle return value"}, 3000, { trailing: true })throttleFn("aaaa").then(res =&gt; {console.log("res:", res)})&lt;/script&gt;</code></pre><h2 id="3-underscore-库实现防抖和节流"><a href="#3-underscore-库实现防抖和节流" class="headerlink" title="3. underscore 库实现防抖和节流"></a>3. underscore 库实现防抖和节流</h2><p>underscore的官网： <a href="https://underscorejs.org/">https://underscorejs.org/</a></p><p>里面有两个函数：<br>防抖函数：<code>_debounce(fn, ms)</code><br>节流函数：<code>_throttle(fn, ms)</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="text"&gt;&lt;script src="./js/underscore.js"&gt;&lt;/script&gt;&lt;script&gt;// 1.获取input元素const inputEl = document.querySelector("input")// 2.防抖处理代码let counter = 1inputEl.oninput = _.debounce(function () {console.log(`发送网络请求${counter++}:`, this.value)}, 3000)// 3.节流处理代码inputEl.oninput = _.throttle(function () {console.log(`发送网络请求${counter++}:`, this.value)}, 3000)</code></pre><h1 id="七、深拷贝和事件总线"><a href="#七、深拷贝和事件总线" class="headerlink" title="七、深拷贝和事件总线"></a>七、深拷贝和事件总线</h1><h2 id="1-深拷贝"><a href="#1-深拷贝" class="headerlink" title="1. 深拷贝"></a>1. 深拷贝</h2><p>前面我们已经可以通过一种方法来实现深拷贝了：<code>JSON.parse</code> </p><ul><li>这种深拷贝的方式其实对于<strong>函数、Symbol</strong>等是无法处理的</li><li>并且如果存在对象的<strong>循环引用</strong>，也会报错的</li></ul><p>自定义深拷贝函数：</p><ol><li>自定义深拷贝的基本功能</li><li>对Symbol的key进行处理</li><li>其他数据类型的值进程处理：数组、函数、Symbol、Set、Map</li><li>对循环引用的处理</li></ol><h3 id="1-1-自定义深拷贝的基本功能"><a href="#1-1-自定义深拷贝的基本功能" class="headerlink" title="1.1 自定义深拷贝的基本功能"></a>1.1 自定义深拷贝的基本功能</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isObject(value) {const valueType = typeof value// null -&gt; object// function -&gt; function// object/arr -&gt; objectreturn (value !== null) &amp;&amp; (valueType === 'object' || valueType === 'function')}function deepCopy(originValue) {// 如果是原始类型，直接返回if (!isObject(originValue)) {return originValue}// 如果是对象类型，需要创建对象const newObj = {}for (const key in originValue) {newObj[key] = deepCopy(originValue[key])}}const info = {name: "why",age: 18,friend: {name: "kobe",address: {name: "洛杉矶",detail: "斯坦普斯中心"}}}const newObj = deepCopy(info)console.log(newObj);</code></pre><h3 id="1-2-优化（了解）"><a href="#1-2-优化（了解）" class="headerlink" title="1.2 优化（了解）"></a>1.2 优化（了解）</h3><ul><li>数组类型</li><li>其他类型处理<ul><li>Set</li><li>函数</li><li>Symbol key</li><li>Symbol value</li></ul></li><li>循环引用<ul><li>WeakMap<pre class="line-numbers language-none"><code class="language-none">``````jsfunction deepCopy(originValue, map = new WeakMap()) {// 0.如果值是Symbol的类型if (typeof originValue === "symbol") {return Symbol(originValue.description)}// 1.如果是原始类型, 直接返回if (!isObject(originValue)) {return originValue}// 2.如果是set类型if (originValue instanceof Set) {const newSet = new Set()for (const setItem of originValue) {newSet.add(deepCopy(setItem))}return newSet}// 3.如果是函数function类型, 不需要进行深拷贝if (typeof originValue === "function") {return originValue}// 4.如果是对象类型, 才需要创建对象if (map.get(originValue)) {return map.get(originValue)}const newObj = Array.isArray(originValue) ? []: {} // 区分数组类型和对象类型map.set(originValue, newObj)// 遍历普通的keyfor (const key in originValue) {newObj[key] = deepCopy(originValue[key], map);}// 单独遍历Symbol keyconst symbolKeys = Object.getOwnPropertySymbols(originValue)for (const symbolKey of symbolKeys) {newObj[Symbol(symbolKey.description)] = deepCopy(originValue[symbolKey], map)}return newObj}const s1 = Symbol("s1")const s2 = Symbol("s2")const info = {name: "why",age: 18,friend: {name: "kobe",address: {name: "洛杉矶",detail: "斯坦普斯中心"}},// 1.特殊类型: Setset: new Set(['abc', 'cba', 'nba']),// 2.特性类型: functionrunning: function () {console.log('running~');},// 3.值的特殊类型: SymbolsymbolKey: Symbol("abc"),// 4.key是symbol时[s1]: "aaaa",[s2]: "bbbb"}info.self = infolet newObj = deepCopy(info)console.log(newObj)console.log(newObj.self === newObj)</code></pre></li></ul></li></ul><h2 id="2-事件总线"><a href="#2-事件总线" class="headerlink" title="2. 事件总线"></a>2. 事件总线</h2><p>自定义事件总线属于一种观察者模式，其中包括三个角色：</p><ul><li>发布者（Publisher）：发出事件（Event）</li><li>订阅者（Subscriber）：订阅事件（Event），并且会进行响应（Handler）</li><li>事件总线（EventBus）：无论是发布者还是订阅者都是通过事件总线作为中台的</li></ul><p>实现自己的事件总线：</p><ul><li>事件的监听方法on</li><li>事件的发射方法emit</li><li>事件的取消监听off；</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;button class="nav-btn"&gt;nav button&lt;/button&gt;&lt;script&gt;class HYEventBus {constructor() {this.eventMap = {}}on(eventName, eventFn) {let eventFns = this.eventMap[eventName] // 找到eventMap对象中eventName属性对应的值if (!eventFns) {eventFns = [] // 创建为一个数组this.eventMap[eventName] = eventFns // 加入eventMap对象中}eventFns.push(eventFn)}off(eventName, eventFn) {let eventFns = this.eventMap[eventName]if (!eventFns) returnfor (let i = 0; i &lt; eventFns.length; i++) {const fn = eventFns[i]if (fn === eventFn) {eventFns.splice(i, 1)break}}// 如果eventFns已经清空了if (eventFns.length === 0) {delete this.eventMap[eventName]}}emit(eventName, ...args) {let eventFns = this.eventMap[eventName]if (!eventFns) return// 遍历所有的函数，依次执行eventFns.forEach(fn =&gt; {fn(...args)});}}const eventBus = new HYEventBus()// aside.vue组件中监听事件eventBus.on('navclick', (name, age, height) =&gt; {console.log('navclick listener 01', name, age, height);})const click = () =&gt; {console.log("navclick listener 02")}eventBus.on("navclick", click) // 一个事件名称"navclick"可以绑定多个不同的函数setTimeout(() =&gt; {eventBus.off("navclick", click)}, 5000);// eventBus.on('asideclick', () =&gt; {//console.log('asideclick listener');// })// nav.vueconst navBtnEl = document.querySelector(".nav-btn")navBtnEl.onclick = function () {console.log("自己监听到")eventBus.emit("navclick", "why", 18, 1.88)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（四）E6 ~E13 新特性</title>
      <link href="/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E5%9B%9B%EF%BC%89E6-E13-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E5%9B%9B%EF%BC%89E6-E13-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、E6-新特性"><a href="#一、E6-新特性" class="headerlink" title="一、E6 新特性"></a>一、E6 新特性</h1><h2 id="1-ECMA-新描述概念"><a href="#1-ECMA-新描述概念" class="headerlink" title="1. ECMA 新描述概念"></a>1. ECMA 新描述概念</h2><h3 id="1-1-词法环境"><a href="#1-1-词法环境" class="headerlink" title="1.1 词法环境"></a>1.1 词法环境</h3><p>词法环境（Lexical Environments）是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符：</p><ul><li>一个词法环境是由<strong>环境记录</strong>（Environment Record）和一个<strong>外部</strong>词法环境（outer Lexical Environment）组成；</li><li>一个词法环境经常用于关联一个函数声明、代码块语句、try-catch语句，当它们的<strong>代码被执行时</strong>，词法环境被<strong>创建</strong>出来</li></ul><p><strong>在ES5之后，执行一个代码，通常会关联对应的词法环境</strong><br>执行上下文会关联两种词法环境：</p><ul><li>LexicalEnvironment用于处理let、const声明的标识符</li><li>VariableEnvironment用于处理var和function声明的标识符</li></ul><h3 id="1-2-环境记录"><a href="#1-2-环境记录" class="headerlink" title="1.2 环境记录"></a>1.2 环境记录</h3><p>环境记录分为<strong>声明式环境记录</strong>和<strong>对象式环境记录</strong></p><ul><li>声明式环境记录：声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句 </li><li>对象式环境记录：对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属性关联起来</li></ul><h3 id="1-3-新-ECMA-描述内存图"><a href="#1-3-新-ECMA-描述内存图" class="headerlink" title="1.3 新 ECMA 描述内存图"></a>1.3 新 ECMA 描述内存图</h3><p><img src="3644fc0128e44141a8228eba14efead5.png" alt="在这里插入图片描述"></p><h2 id="2-let、const-用法"><a href="#2-let、const-用法" class="headerlink" title="2. let、const 用法"></a>2. let、const 用法</h2><h3 id="2-1-let、const-的基本使用"><a href="#2-1-let、const-的基本使用" class="headerlink" title="2.1 let、const 的基本使用"></a>2.1 let、const 的基本使用</h3><p>◼ let关键字：从直观的角度来说，let和var是没有太大的区别的，都是用于<strong>声明一个变量</strong></p><p>◼ const关键字：表示保存的数据一旦被赋值，就<strong>不能被修改</strong>；但是如果赋值的是<strong>引用类型</strong>，那么可以通过引用找到对应的对象，修改对象的内容</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const info = {name: 'why',age: 18} // 引用类型// info = {}info.name = 'kobe'console.log(info);</code></pre><p>==注意：let、const 不允许<strong>重复</strong>声明变量==</p><h3 id="2-2-let、const-没有作用域提升"><a href="#2-2-let、const-没有作用域提升" class="headerlink" title="2.2 let、const 没有作用域提升"></a>2.2 let、const 没有作用域提升</h3><p>let、const 变量会在<strong>执行上下文的词法环境创建出来的时候</strong>被创建，但是是<strong>不可以访问</strong>它们的，直到词法绑定被求值<br>(虽然被创建出来，但不能被访问，所以可以理解为作用域没有提升)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(address);const address = '广州'</code></pre><h4 id="2-2-1-暂时性死区-TDZ"><a href="#2-2-1-暂时性死区-TDZ" class="headerlink" title="2.2.1 暂时性死区 TDZ"></a>2.2.1 暂时性死区 TDZ</h4><p>在let、const定义的标识符真正执行到声明的代码之前，是不能被访问的</p><p>从<strong>块作用域的顶部一直到变量声明完成</strong>之前，这个变量处在<strong>暂时性死区</strong>（TDZ，temporal dead zone）</p><p>ps：取决于执行顺序，不是编写代码的位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo() {console.log(message)}let message = 'hello'foo() // 可以访问</code></pre><h3 id="2-3-不会在-window-对象上添加属性"><a href="#2-3-不会在-window-对象上添加属性" class="headerlink" title="2.3 不会在 window 对象上添加属性"></a>2.3 不会在 window 对象上添加属性</h3><p>在全局通过var来声明一个变量，事实上会在window上添加一个属性；<br>但是let、const是不会给window上添加任何属性的</p><ul><li>Global environment record:<ul><li>合成的record</li><li>window</li><li>声明式环境记录对象</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var message = '广州'// console.log(window.message);let name = 'why'console.log(window.name);// 报错</code></pre><p><code>name = 'why'</code> 存储在Script中，<code>message = '广州'</code> 存储在Global中<br><img src="c73c8c054e45448baab09c8116450ac2.png" alt="在这里插入图片描述"></p><h3 id="2-4-块级作用域和应用"><a href="#2-4-块级作用域和应用" class="headerlink" title="2.4 块级作用域和应用"></a>2.4 块级作用域和应用</h3><p>ES5 中，JavaScript只会形成两个作用域：<strong>全局作用域和函数作用域</strong></p><p>ES6 中，通过<code>let、const、function、class声明</code>的标识符是具备<strong>块级作用域</strong>的限制的</p><blockquote><p>函数拥有块级作用域，但是外面依然是可以访问</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">{let age = 18const height = 1.88class Person {}function foo() {console.log('foo function');}}// console.log(age); 报错// console.log(height); 报错// const p = new Person() 报错foo() // 可以调用</code></pre><h4 id="2-4-1-应用"><a href="#2-4-1-应用" class="headerlink" title="2.4.1 应用"></a>2.4.1 应用</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var message = "Hello World"var age = 18function foo() {}let address = "广州市"{var height = 1.88let title = "教师"let info = "了解真相~"}...剩余代码</code></pre><p><img src="2df91f194ddd43beb34e9f60b4605aed.png" alt="在这里插入图片描述"></p><p>跳出代码块，执行剩余代码<br><img src="5a42f356bbc2414f87afc7648f55e97d.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;button&gt;按钮0&lt;/button&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;const btnEls = document.querySelectorAll('button')for (let i = 0; i &lt; btnEls.length; i++) { // 此时for{}形成一个新的词法环境const btnEl = btnEls[i];btnEl.onclick = function () {console.log(`点击了${i}按钮`);}}</code></pre><p><img src="1552e90589564193954d1fb5413d5ecf.png" alt="在这里插入图片描述"></p><h2 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h2><p>使用字符串模板来嵌入JS的变量或者表达式来进行<strong>拼接</strong>：</p><ul><li>使用``符号来编写字符串，称之为模板字符串</li><li>通过 ${expression} 来嵌入动态的内容</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const name = 'why'const age = 18const info = `My name is ${name}`console.log(info);function foo(...args) {console.log('参数：', args);}foo`my name is ${name}, my age is ${age}, my height is ${1.88}`</code></pre><h2 id="4-ES6-函数的增强用法"><a href="#4-ES6-函数的增强用法" class="headerlink" title="4. ES6 函数的增强用法"></a>4. ES6 函数的增强用法</h2><h3 id="4-1-函数的默认参数"><a href="#4-1-函数的默认参数" class="headerlink" title="4.1 函数的默认参数"></a>4.1 函数的默认参数</h3><p>在编写函数时，若没有传入参数，可以<strong>给函数一个默认值</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo1(age, name = 'why', ...arg) {console.log(name, age);}foo1(18)console.log(foo1.length);//1</code></pre><ul><li>参数的默认值我们通常会将其<strong>放到后面</strong>，剩余参数放在最后</li><li><strong>默认值以及后面的参数</strong>都不计算在函数的 length 之内</li></ul><h3 id="4-2-默认参数解构"><a href="#4-2-默认参数解构" class="headerlink" title="4.2 默认参数解构"></a>4.2 默认参数解构</h3><p>默认值也可以和解构一起来使用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 原始做法function foo(obj = { name: 'why', age: 18 }) {console.log(obj.name, obj.age);}// 解构版function foo({ name, age } = { name: 'why', age: 18 }) {console.log(name, age);}// 解构改进版function foo({ name = 'why', age = 18 } = {}) {console.log(name, age);}foo()</code></pre><h3 id="4-3-箭头函数的补充"><a href="#4-3-箭头函数的补充" class="headerlink" title="4.3 箭头函数的补充"></a>4.3 箭头函数的补充</h3><ul><li>箭头函数是没有显式原型prototype的，所以<strong>不能作为构造函数</strong>，使用new来创建对象；</li><li>箭头函数也<strong>不绑定</strong>this、arguments、super参数</li></ul><h2 id="5-展开语法"><a href="#5-展开语法" class="headerlink" title="5. 展开语法"></a>5. 展开语法</h2><p>展开语法的场景：</p><ul><li>在<strong>函数调用/数组构造</strong>时，将数组表达式或者string在语法层面展开；</li><li>在<strong>构造字面量对象</strong>时, 将对象表达式按key-value的方式展开</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const names = ["abc", "cba", "nba", "mba"]const str = "Hello"// 数组构造const newNames = [...names, "aaa", "bbb"]console.log(newNames)// 函数调用function foo(name1, name2, ...args) {console.log(name1, name2, args);}foo(...names)foo(...str)// 对象构造var obj = {name: 'why',age: 18}var bar = {...obj,height: 1.88}console.log(bar);</code></pre><h3 id="5-1-引用赋值-浅拷贝-深拷贝-重要"><a href="#5-1-引用赋值-浅拷贝-深拷贝-重要" class="headerlink" title="5.1 引用赋值/浅拷贝/深拷贝(重要)"></a>5.1 引用赋值/浅拷贝/深拷贝(重要)</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',age: 18,friend: {name: 'curry'}}//1.引用赋值const info1 = obj//2.浅拷贝const info2 = {...obj}info2.name = 'kobe'console.log(obj.name, info2.name);//why kobeinfo2.friend.name = 'james'console.log(obj.friend.name)//james//3.深拷贝//1.第三方库//2.手写//3.利用现有JS机制const info3 = JSON.parse(JSON.stringify(obj))info3.friend.name = 'james'console.log(info3.friend.name);console.log(obj.friend.name);//curry</code></pre><ol><li><p>引用赋值：直接将内存地址传给新变量（在新变量上修改会影响原变量）<br><img src="d74d73df86d4464e84f4088a65de4fea.png" alt="在这里插入图片描述"></p></li><li><p>浅拷贝：新创建一个对象将原对象中内容拷贝过来，但只拷贝一层<br><img src="db41f55eece54be6910085bbe44e2e6d.png" alt="在这里插入图片描述"></p></li><li><p>深拷贝：全部重新创建对象<br><img src="6f31df3c8ed84a59aa36749ab0deecd2.png" alt="在这里插入图片描述"></p></li></ol><h2 id="6-数值的表示"><a href="#6-数值的表示" class="headerlink" title="6. 数值的表示"></a>6. 数值的表示</h2><ol><li>规范二进制和八进制写法</li><li>数字过长时，可以使用_作为连接符</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.进制console.log(100)//十进制console.log(0b100)//二进制console.log(0o100)//八进制console.log(0x100)//十六进制// 2.长数字的表示const money = 100_00_00_0000_00_00</code></pre><h2 id="7-Symbol-符号使用"><a href="#7-Symbol-符号使用" class="headerlink" title="7. Symbol 符号使用"></a>7. Symbol 符号使用</h2><p>一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易<strong>造成冲突</strong>，从而<strong>覆盖掉它内部的某个属性</strong></p><p>Symbol就是为了解决上面的问题，用来<strong>生成一个独一无二的属性</strong></p><ul><li>Symbol即使<strong>多次创建值</strong>，它们也是不同的：函数执行后每次创建出来的值都是独一无二的</li><li><code>Object.keys()</code>得到的值不包含Symbol<ul><li>利用<code>Object.getOwnPropertySymbols()</code>得到只含有Symbol的数组</li><li>在创建Symbol值的时候传入一个描述description</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const s1 = Symbol()const s2 = Symbol()const obj = {name: 'why',[s1]: 'aaa',}obj[s2] = 'bbb'console.log(Object.keys(obj));//不包含Symbolconst symbolKeys = Object.getOwnPropertySymbols(obj)for (const key of symbolKeys) {// console.log(key);// 得到symbolKeys中的所有值（分开）console.log(obj[key]);}// Symbol函数直接生成的值, 都是独一无二const s3 = Symbol('ccc')console.log(s3.description);//cccconst s4 = Symbol(s3.description)console.log(s3 === s4)//false</code></pre><p>如果我们想创建相同的Symbol：</p><ul><li>使用<code>Symbol.for</code>方法来做到这一点</li><li>通过<code>Symbol.keyFor</code>方法来获取对应的值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const s3 = Symbol('ccc')const s5 = Symbol.for(s3.description)console.log(s5);// Symbol(ccc)console.log(Symbol.keyFor(s5));//cccconst s6 = Symbol.for(s3.description)console.log(s5 === s6)//true</code></pre><h2 id="8-新增数据结构"><a href="#8-新增数据结构" class="headerlink" title="8. 新增数据结构"></a>8. 新增数据结构</h2><p>在ES6之前，我们存储数据的结构主要有两种：数组、对象。<br>在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap</p><h3 id="8-1-Set、WeakSet"><a href="#8-1-Set、WeakSet" class="headerlink" title="8.1 Set、WeakSet"></a>8.1 Set、WeakSet</h3><p>Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是<strong>元素不能重复</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const set = new Set()//需通过Set构造函数，无字面量创建方式set.add(12)set.add(22)set.add(35)set.add(22)console.log(set);set.forEach(item =&gt; console.log(item))// 应用场景：数组去重const names = ['abc', 'cba', 'nba', 'cba']const newNameSet = new Set(names)const newName = Array.from(newNameSet)console.log(newName);</code></pre><p>Set常见的<strong>属性</strong>：</p><ul><li><code>size</code>：返回Set中元素的个数<br>Set常用的<strong>方法</strong>：</li><li><code>add(value)</code>：添加某个元素，返回Set对象本身</li><li><code>delete(value)</code>：从set中删除和这个值相等的元素，返回boolean类型 </li><li><code>has(value)</code>：判断set中是否存在某个元素，返回boolean类型</li><li><code>clear()</code>：清空set中所有的元素，没有返回值</li><li><code>forEach(callback, [, thisArg])</code>：通过forEach遍历set</li><li>支持for of的遍历的。</li></ul><p>WeakSet也是<strong>内部元素不能重复</strong>的数据结构</p><p>与Set的区别：</p><ul><li>WeakSet中<strong>只能存放对象类型</strong>，不能存放基本数据类型</li><li>WeakSet对元素的引用是<strong>弱引用</strong>，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收</li></ul><p>WeakSet常见的方法：</p><ul><li><code>add(value)</code>：添加某个元素，返回WeakSet对象本身</li><li><code>delete(value)</code>：从WeakSet中删除和这个值相等的元素，返回boolean类型</li><li><code>has(value)</code>：判断WeakSet中是否存在某个元素，返回boolean类型</li><li>WeakSet不能遍历（只是对对象的弱引用，存储到WeakSet中的对象是没办法获取的）</li></ul><h3 id="8-2-Map、WeakMap"><a href="#8-2-Map、WeakMap" class="headerlink" title="8.2 Map、WeakMap"></a>8.2 Map、WeakMap</h3><p>Map，用于<strong>存储映射关系</strong></p><p>在之前使用<strong>对象来存储映射关系</strong>，他们有什么区别呢？</p><ul><li>对象存储映射关系只能用<strong>字符串</strong>（ES6新增了Symbol）作为属性名（key）</li><li>某些情况下我们可能希望通过==<strong>其他类型==作为key</strong>（比如对象）这个时候会自动将对象转成字符串来作为key</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const info1 = { name: 'why' }const info2 = { age: 18 }const map = new Map()map.set(info1, 'aaa')map.set(info2, 'bbb')console.log(map);map.forEach(item =&gt; console.log(item))// 得到key对应的valuefor (const item of map) {const [key, value] = itemconsole.log(key, value);}</code></pre><p>Map常见的属性：</p><ul><li><code>size</code>：返回Map中元素的个数<br>Map常见的方法：</li><li><code>set(key, value)</code>：在Map中添加key、value，并且返回整个Map对象</li><li><code>get(key)</code>：根据key获取Map中的value</li><li><code>has(key)</code>：判断是否包括某一个key，返回Boolean类型</li><li><code>delete(key)</code>：根据key删除一个键值对，返回Boolean类型</li><li><code>clear()</code>：清空所有的元素</li><li><code>forEach(callback, [, thisArg])</code>：通过forEach遍历Map</li><li>Map可以通过for of进行遍历</li></ul><p>WeakMap，也是以<strong>键值对的形式</strong>存在的</p><p>和Map的区别：</p><ul><li>WeakMap的key<strong>只能使用对象</strong>，不接受其他的类型作为key</li><li>key对象的引用是<strong>弱引用</strong>，如果没有其他引用引用这个对象，那么GC可以回收该对象</li></ul><p>WeakMap常见的方法：</p><ul><li><code>set(key, value)</code>：在Map中添加key、value，并且返回整个Map对象</li><li><code>get(key)</code>：根据key获取Map中的value</li><li><code>has(key)</code>：判断是否包括某一个key，返回Boolean类型</li><li><code>delete(key)</code>：根据key删除一个键值对，返回Boolean类型</li><li>不能遍历</li></ul><h1 id="二、ES7-ES13-知识点"><a href="#二、ES7-ES13-知识点" class="headerlink" title="二、ES7~ES13 知识点"></a>二、ES7~ES13 知识点</h1><h2 id="1-ES7-知识点"><a href="#1-ES7-知识点" class="headerlink" title="1. ES7 知识点"></a>1. ES7 知识点</h2><p>判断一个数组中是否包含一个指定的元素</p><ul><li><code>arry.includes('why', fromIndex) //true</code></li></ul><p>指数运算符：<code>**</code></p><h2 id="2-ES8-知识点"><a href="#2-ES8-知识点" class="headerlink" title="2. ES8 知识点"></a>2. ES8 知识点</h2><h3 id="2-1-对象相关属性"><a href="#2-1-对象相关属性" class="headerlink" title="2.1 对象相关属性"></a>2.1 对象相关属性</h3><ul><li><p>通过<code>Object.values()</code>来获取所有的value值</p></li><li><p>通过<code>Object.entries()</code>获取到一个数组，数组中会存放可枚举属性的键值对数组</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',age: 18,height: 1.88,}const keys = Object.keys(obj)console.log(keys);const values = Object.values(obj)console.log(values);const entries = Object.entries(obj)// [['name', 'why'], ['age', 18], ['height', 1.88]]for (const entry of entries) {const [key, value] = entryconsole.log(key, value);}console.log(Object.entries(['abc', 'nba']));// [['0', 'abc'], ['1', 'nba']]console.log(Object.entries('Hi'));// [['0', H], ['1', i]]</code></pre><h3 id="2-2-字符串填充方法"><a href="#2-2-字符串填充方法" class="headerlink" title="2.2 字符串填充方法"></a>2.2 字符串填充方法</h3><p>padStart/padEnd 分别对字符串的<strong>首尾进行填充</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//应用：时间格式化const min = '15'.padStart(2, '0')const sec = '6'.padStart(2, '0')console.log(`${min}:${sec}`);//15:06//应用：敏感数据格式化let cardNum = '342601199910274626'const sliceNum = cardNum.slice(-4)cardNum = sliceNum.padStart(cardNum.length, '*')const card = document.querySelector('h1')card.innerHTML = cardNum //**************4626</code></pre><h2 id="3-ES10-知识点"><a href="#3-ES10-知识点" class="headerlink" title="3. ES10 知识点"></a>3. ES10 知识点</h2><h3 id="3-1-flat、flatMap"><a href="#3-1-flat、flatMap" class="headerlink" title="3.1 flat、flatMap"></a>3.1 flat、flatMap</h3><p>flat() 方法会按照一个<strong>可指定的深度</strong>递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个<strong>新数组</strong>返回</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const nums = [10, 20, [111, 222], [[123, 321], [231, 312]]]const newNums1 = nums.flat(1)console.log(newNums1);// [10, 20, 111, 222, [123, 321], [231,312]]const newNums2 = nums.flat(2)console.log(newNums2);</code></pre><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。</p><ul><li>flatMap是先进行map操作，再做flat的操作；</li><li>flatMap中的flat相当于<strong>深度为1</strong>；</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const messages = ["Hello World aaaaa","Hello Coderwhy","你好啊 李银河"]//先map 再flatconst newMessage = messages.map(item =&gt; item.split(' '))console.log(newMessage);// [['Hello', 'World', 'aaaaa'],['Hello', 'Coderwhy'],['你好啊', '李银河']]const finaMessage = newMessage.flat(1)console.log(finaMessage);//flatmapconst finaMessages = messages.flatMap(item =&gt; item.split(' '))console.log(finaMessages);</code></pre><h3 id="3-2-Object-fromEntries"><a href="#3-2-Object-fromEntries" class="headerlink" title="3.2 Object.fromEntries"></a>3.2 Object.fromEntries</h3><p>Object.entries 将一个对象转换成 entries，Object.formEntries将 entries 转换成对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//应用const searchString = '?name=why&amp;age=18&amp;height=1.88'const params = new URLSearchParams(searchString)console.log(params.get('name'));console.log(params.get('age'));for (const item of params) { //相当于params.entriesconsole.log(item);}const paramObj = Object.fromEntries(params)console.log(paramObj.name);console.log(paramObj.age);</code></pre><h3 id="3-3-清除字符串首尾空格"><a href="#3-3-清除字符串首尾空格" class="headerlink" title="3.3 清除字符串首尾空格"></a>3.3 清除字符串首尾空格</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const message = " Hello World "console.log(message.trim())console.log(message.trimStart())console.log(message.trimEnd())</code></pre><h2 id="4-ES11-知识点"><a href="#4-ES11-知识点" class="headerlink" title="4. ES11 知识点"></a>4. ES11 知识点</h2><h3 id="4-1-BigInt"><a href="#4-1-BigInt" class="headerlink" title="4.1 BigInt"></a>4.1 BigInt</h3><p>过大的数字，在其后加上<code>n</code></p><h3 id="4-2-空值合并运算符"><a href="#4-2-空值合并运算符" class="headerlink" title="4.2 空值合并运算符"></a>4.2 空值合并运算符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> function foo(arg1 = '我是默认值') {//不严谨的写法// arg1 = arg1 ? arg1 : '我是默认值'// arg1 = arg1 || '我是默认值'//严谨的写法// arg1 = (arg1 === undefined || arg1 === null) ? '我是默认值' : arg1//ES6后arg1 = arg1 ?? '我是默认值'}foo('')//null和undefined会成为默认值//''、0、false不会输出默认值</code></pre><h3 id="4-3-可选链的使用"><a href="#4-3-可选链的使用" class="headerlink" title="4.3 可选链的使用"></a>4.3 可选链的使用</h3><p>让代码在进行null和undefined判断时更加清晰和简洁</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',friend: {name: 'kobe',// running: function () {//     console.log('running~');// }}}obj?.friend?.running?.()</code></pre><h2 id="5-ES12-知识点"><a href="#5-ES12-知识点" class="headerlink" title="5. ES12 知识点"></a>5. ES12 知识点</h2><h3 id="5-1-Finalization-Registry"><a href="#5-1-Finalization-Registry" class="headerlink" title="5.1 Finalization Registry"></a>5.1 Finalization Registry</h3><p>FinalizationRegistry 对象可以让你<strong>在对象被垃圾回收时请求一个回调</strong>。</p><ul><li>当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）</li><li>通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let obj = { name: 'why', age: 18 }const finalRegistry = new FinalizationRegistry((value) =&gt; {console.log('对象被回收了', value)})finalRegistry.register(obj, 'why')obj = null</code></pre><h3 id="5-2-弱引用"><a href="#5-2-弱引用" class="headerlink" title="5.2 弱引用"></a>5.2 弱引用</h3><p>如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用；如果我们希望是一个弱引用的话，可以使用WeakRef</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let obj = {name: 'why'}let info = new WeakRef(obj)</code></pre><h3 id="5-3-逻辑赋值运算符"><a href="#5-3-逻辑赋值运算符" class="headerlink" title="5.3 逻辑赋值运算符"></a>5.3 逻辑赋值运算符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 赋值运算符let counter = 100// counter = counter + 100counter += 100// 逻辑赋值运算符function foo(message) {// 1.||逻辑赋值运算符message = message || "默认值"message ||= "默认值"// 2.??逻辑赋值运算符// message = message ?? "默认值"message ??= "默认值"console.log(message)}foo("abc")foo()// 3.&amp;&amp;逻辑赋值运算符let obj = {name: "why"}// obj = obj &amp;&amp; obj.nameobj &amp;&amp;= obj.nameconsole.log(obj)</code></pre><h3 id="5-4-字符串全部替换"><a href="#5-4-字符串全部替换" class="headerlink" title="5.4 字符串全部替换"></a>5.4 字符串全部替换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const message = "my name is why, why age is 18"const newMessage = message.replace("why", "kobe")const newMessage2 = message.replaceAll("why", "kobe")console.log(newMessage)console.log(newMessage2)</code></pre><h2 id="6-ES13-知识点"><a href="#6-ES13-知识点" class="headerlink" title="6. ES13 知识点"></a>6. ES13 知识点</h2><h3 id="6-1-at"><a href="#6-1-at" class="headerlink" title="6.1 at()"></a>6.1 at()</h3><p>应用于在数组、字符串查找元素</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var names = ['abc', 'cba', 'nba']console.log(names.at(1))//cbaconsole.log(names.at(-1))//nbavar str = 'Hello'console.log(str.at(1))console.log(str.at(-1))</code></pre><h3 id="6-2-对象属性-hasOwn"><a href="#6-2-对象属性-hasOwn" class="headerlink" title="6.2 对象属性 hasOwn"></a>6.2 对象属性 hasOwn</h3><p>Object中新增了一个静态方法（类方法）： <code>hasOwn(obj, propKey)</code><br>用于判断一个对象中<strong>是否有某个自己的属性</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',__proto__: {address: '广州'}}// console.log(obj.hasOwnProperty('name'));// console.log(obj.hasOwnProperty('address'));// hasOwn替换hasOwnProperty，防止对象内部有重写hasOwnPropertyconsole.log(Object.hasOwn(obj, 'name'));console.log(Object.hasOwn(obj, 'address'));</code></pre><h3 id="6-3-class-中的新成员"><a href="#6-3-class-中的新成员" class="headerlink" title="6.3 class 中的新成员"></a>6.3 class 中的新成员</h3><ul><li><p>public instance fields</p></li><li><p>public static fields</p></li><li><p>private instance fields</p></li><li><p>private static fields</p></li><li><p>static block</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {// 1.实例属性// 对象属性: public 公共 -&gt; public instance fieldsheight = 1.88// ES13对象属性: private 私有: 程序员之间的约定#intro = "name is why"// 2.类属性(static)// 类属性: publicstatic totalCount = "70亿"// 类属性: privatestatic #maleTotalCount = "20亿"constructor(name, age) {// 对象中的属性: 在constructor通过this设置this.name = namethis.age = agethis.address = "广州市"}// 3.静态代码块static {console.log("初始化")}}const p = new Person("why", 18)// console.log(p.#intro)console.log(Person.height);//undefinedconsole.log(Person.totalCount);//70亿</code></pre><h1 id="三、Proxy-和-Reflect-监听"><a href="#三、Proxy-和-Reflect-监听" class="headerlink" title="三、Proxy 和 Reflect 监听"></a>三、Proxy 和 Reflect 监听</h1><h2 id="1-Proxy"><a href="#1-Proxy" class="headerlink" title="1. Proxy"></a>1. Proxy</h2><p>需求：有一个对象，我们希望<strong>监听</strong>这个对象中的<strong>属性被设置或获取</strong>的过程</p><p>ES6之前，利用Object.defineProperty</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',age: 18}const keys = Object.keys(obj)// 遍历对象中每个属性for (const key of keys) {let value = obj[key]Object.defineProperty(obj, key, {set: function (newValue) {console.log(`监听：给${key}设置了新的值`, newValue);value = newValue},get: function () {console.log(`监听：获取${key}的值`);return value}})}console.log(obj.name);obj.name = 'kobe'</code></pre><p>缺点：Object.defineProperty设计的<strong>初衷</strong>，不是为了去监听截止一个对象中 所有的属性的；无法监听更加丰富的操作，比如新增属性、删除属性</p><h3 id="1-1-Proxy-基本使用"><a href="#1-1-Proxy-基本使用" class="headerlink" title="1.1 Proxy 基本使用"></a>1.1 Proxy 基本使用</h3><p>在ES6中，新增了一个Proxy类，用于帮助我们创建一个代理：</p><ul><li>需要<code>new Proxy()</code>对象，并且传入需要侦听的对象以及一个处理对象，可以称之为<code>handler</code><ul><li><code>const p = new Proxy(target, handler)</code></li></ul></li><li>之后的操作都是直接对Proxy的操作，而不是原有的对象，在handler里面进行侦听</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: 'why',age: 18}const objProxy = new Proxy(obj, {set: function (target, key, newValue) {console.log(`给属性${key}设置了新的值：`, newValue);target[key] = newValue},get: function (target, key) {console.log(`获取属性${key}的值`);return target[key]},deleteProperty: function (target, key) {console.log(`监听: 监听删除${key}属性`)delete obj.key},has: function (target, key) {console.log(`监听: 监听in判断 ${key}属性`)return key in target}})console.log(objProxy.name);//whyobjProxy.name = 'kobe'console.log(objProxy.name);//kobeconsole.log(obj);delete objProxy.nameconsole.log("age" in objProxy)</code></pre><h3 id="1-2-Proxy-捕获器"><a href="#1-2-Proxy-捕获器" class="headerlink" title="1.2 Proxy 捕获器"></a>1.2 Proxy 捕获器</h3><p>set函数有四个参数：</p><ul><li>target：目标对象（侦听的对象）</li><li>property：将被设置的属性key</li><li>value：新属性值</li><li>receiver：调用的代理对象</li></ul><p>get函数有三个参数：</p><ul><li>target：目标对象（侦听的对象）</li><li>property：被获取的属性key</li><li>receiver：调用的代理对象</li></ul><p><img src="312c258923554561b8c8aeb1a76757c2.png" alt="在这里插入图片描述"></p><h3 id="1-3-construct-和-apply"><a href="#1-3-construct-和-apply" class="headerlink" title="1.3 construct 和 apply"></a>1.3 construct 和 apply</h3><p>捕捉器中还有construct和apply，它们是<strong>应用于函数对象</strong>的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(num1, num2) {console.log(this, num1, num2)}const fooProxy = new Proxy(foo, {apply: function (target, thisArg, otherArgs) {console.log("监听执行了apply操作")target.apply(thisArg, otherArgs)},construct: function (target, otherArray) {console.log("监听执行了new操作")console.log(target, otherArray)//[function foo] ['aaa','bbb'] return new target(...otherArray)}})// fooProxy.apply("abc", [111, 222])new fooProxy("aaa", "bbb")</code></pre><h2 id="2-Reflect"><a href="#2-Reflect" class="headerlink" title="2. Reflect"></a>2. Reflect</h2><p>Reflect也是ES6新增的一个API，它是一个<strong>对象</strong>，字面的意思是反射，提供了很多<strong>操作 JavaScript 对象</strong>的方法</p><h3 id="2-1-Reflect-常见方法"><a href="#2-1-Reflect-常见方法" class="headerlink" title="2.1. Reflect 常见方法"></a>2.1. Reflect 常见方法</h3><p>Object作为一个构造函数，这些操作实际上放到它身上并不合适；另外还包含一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的</p><ul><li>所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上</li><li>另外在使用Proxy时，可以做到不操作原对象</li><li><strong>返回值为bool值，可以直接判断</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {name: "why",age: 18}// 1.用以前的方式进行操作// delete obj.name// if (obj.name) {//console.log("name没有删除成功")// } else {//console.log("name删除成功")// }// 2.Reflectif (Reflect.deleteProperty(obj, "name")) {console.log("name删除成功")} else {console.log("name没有删除成功")}</code></pre><p><img src="1d631df6f8c046e999dc1e02f948104d.png" alt="在这里插入图片描述"></p><h3 id="2-2-Reflect-和-Proxy-一起使用"><a href="#2-2-Reflect-和-Proxy-一起使用" class="headerlink" title="2.2 Reflect 和 Proxy 一起使用"></a>2.2 Reflect 和 Proxy 一起使用</h3><p>可以将之前Proxy案例中对原对象的操作，都修改为Reflect来操作：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj = {_name: 'why',set name(newValue) {console.log("this:", this) // this默认是obj，receiver后变为objProxythis._name = newValue // 此传参过程再次调用objProxy.set},get name() {return this._name}}const objProxy = new Proxy(obj, {set: function (target, key, newValue, receiver) {// 好处一：不再直接操作原对象// 好处二：返回bool值，可判断本次操作是否成功console.log('Proxy中设置方法被调用');// target[key] = newValueconst isSuccess = Reflect.set(target, key, newValue, receiver)if (!isSuccess) {throw new Error(`set ${key} failure`)}/* 好处三：receiver就是外层Proxy对象Reflect.set/get最后一个参数, 可以决定对象访问器setter/getter的this指向*/},get: function (target, key, receiver) {console.log("proxy中获取方法被调用")return Reflect.get(target, key, receiver)}})objProxy.name = 'kobe'console.log(obj);console.log(objProxy.name);</code></pre><h3 id="2-3-Reflect-的-construct-用法"><a href="#2-3-Reflect-的-construct-用法" class="headerlink" title="2.3 Reflect 的 construct 用法"></a>2.3 Reflect 的 construct 用法</h3><p>stu 的类型是 Student，但想执行Person()的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person(name, age) {this.name = namethis.age = age}function Student() {}const stu = Reflect.construct(Person, ['why', 18], Student)console.log(stu);console.log(stu.__proto__ === Student.prototype);//true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（三）函数、对象增强和继承</title>
      <link href="/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、函数增强"><a href="#一、函数增强" class="headerlink" title="一、函数增强"></a>一、函数增强</h1><h2 id="1-函数对象的属性和-arguments"><a href="#1-函数对象的属性和-arguments" class="headerlink" title="1. 函数对象的属性和 arguments"></a>1. 函数对象的属性和 arguments</h2><p>JavaScript中<strong>函数也是一个对象</strong>，那么对象中就可以有属性和方法：</p><ul><li><code>name</code>：一个函数的名字我们可以通过name来访问</li><li><code>length</code>：属性length用于返回函数参数的个数<ul><li>注意：rest参数是不参与参数的个数的</li></ul></li></ul><h3 id="1-1-arguments-转数组"><a href="#1-1-arguments-转数组" class="headerlink" title="1.1 arguments 转数组"></a>1.1 arguments 转数组</h3><p>arguments 是一个对应于<strong>传递给函数的参数</strong>的<strong>类数组(array-like)对象</strong></p><p>array-like意味着它不是一个数组类型，而是一个对象类型：</p><ul><li>但是它却拥有数组的一些特性，比如说length，比如可以通过index索引来访问；</li><li>但是它却没有数组的一些方法，比如filter、map等；</li></ul><p><strong>在开发中，我们经常需要将arguments转成Array，以便使用数组的一些特性。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 2.1 普通方式var newArguments = []for (var arg of arguments) {newArguments.push(arg)}console.log(newArguments);// 2.2 ES6方式var newArgs1 = Array.from(arguments)console.log(newArgs1);var newArgs2 = [...arguments]console.log(newArgs2);// 2.3 slice方法var newArgs3 = [].slice.apply(arguments)console.log(newArgs3);var names = ['abd', 'bca', 'nba']var newNames = names.slice() //this指向names，slice使用for遍历内部，截取数console.log(newNames);// 原数组}</code></pre><p>==PS：==</p><ul><li>箭头函数不绑定arguments</li></ul><h3 id="1-2-剩余-rest-参数"><a href="#1-2-剩余-rest-参数" class="headerlink" title="1.2 剩余 rest 参数"></a>1.2 剩余 rest 参数</h3><p>剩余参数必须放到<strong>最后一个位置</strong>，否则会报错</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(num1, num2, ...args) {console.log(num1, num2)comsole.log(args)}function bar(...args) {}</code></pre><p>和arguments的区别：</p><ul><li>剩余参数只包含那些<strong>没有对应形参的实参</strong>，而 arguments 对象包含了传给函数的所有实参；</li><li>arguments对象不是一个真正的数组，而<strong>rest参数是一个真正的数组</strong>，可以进行数组的所有操作（ES6新增）</li></ul><h2 id="2-纯函数"><a href="#2-纯函数" class="headerlink" title="2. 纯函数"></a>2. 纯函数</h2><h3 id="2-1-纯函数的概念"><a href="#2-1-纯函数的概念" class="headerlink" title="2.1 纯函数的概念"></a>2.1 纯函数的概念</h3><ul><li><strong>确定的输入</strong>，一定会产生<strong>确定的输出</strong>；</li><li>函数在执行过程中，<strong>不能产生副作用</strong><ul><li>副作用：在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响， 比如<strong>修改了全局变量，修改参数或者改变外部的存储</strong></li></ul></li></ul><p>举例：</p><ul><li><code>slice</code>：slice截取数组时不会对原数组进行任何操作，而是生成一个新的数组；<strong>（纯函数）</strong></li><li><code>splice</code>：splice截取数组, 会返回一个新的数组，也会对原数组进行修改</li></ul><h3 id="2-2-作用和优势"><a href="#2-2-作用和优势" class="headerlink" title="2.2 作用和优势"></a>2.2 作用和优势</h3><ul><li>在<strong>写的时候</strong>，保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心<strong>传入的内容</strong>是如何获得的或者<strong>依赖其他的外部变量</strong>是否已经发生了修改；</li><li>在<strong>用的时候</strong>，你确定你的<strong>输入内容不会被任意篡改</strong>，并且自己确定的输入，一定会有确定的输出</li></ul><h2 id="3-柯里化"><a href="#3-柯里化" class="headerlink" title="3. 柯里化"></a>3. 柯里化</h2><h3 id="3-1-柯里化的概念"><a href="#3-1-柯里化的概念" class="headerlink" title="3.1 柯里化的概念"></a>3.1 柯里化的概念</h3><p>把接收<strong>多个参数</strong>的函数，变成<strong>接受一个单一参数</strong>（最初函数的第一个参数）的函数，并且<strong>返回一个函数去处理剩余的参数</strong></p><p>==柯里化的优势:==</p><ul><li><p>函数的职责单一</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(x) {x = x + 2return function (y) {y = y * 2return function (z) {z = z ** 2return x + y + z}}}foo(10)(20)(30)</code></pre></li><li><p>函数的参数复用<br>creatAdder函数要求我们传入一个count<br>在之后使用返回的函数时，我们不需要再继续传入count</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function creatAdder(count) { return function(num) {return count + num}}var adder5 = creatAdder(5)adder5(100)adder5(55)var adder8 = creatAdder(8)adder8(22)adder8(35)</code></pre></li></ul><h3 id="3-2-自动柯里化函数"><a href="#3-2-自动柯里化函数" class="headerlink" title="3.2 自动柯里化函数"></a>3.2 自动柯里化函数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(x, y, z) {return x + y + z}function hyCurrying(fn) {function curryFn(...args) {//两类操作//1.继续返回新的函数，继续接受参数//2.直接执行fnif (args.length &gt;= fn.length) {return fn(...args)//展开args,由数组展为单个数字// return 需要将fn执行后的结果返回出去} else {return function (...newArgs) {return curryFn(... args.concat(newArgs))}}}return curryFn}var fooCurry = hyCurrying(foo)// fooCurry相当于curryFnvar result = fooCurry(10)(20)(30)console.log(result);</code></pre><h2 id="4-组合函数"><a href="#4-组合函数" class="headerlink" title="4. 组合函数"></a>4. 组合函数</h2><p>将<strong>多个函数组合起来</strong>，自动依次调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function double(num) {return num * 2}function pow(num) {return num ** 2}function compFn(...fns) {//1.边界场景var length = fns.lengthfor (var i = 0; i &lt; length; i++) {if (typeof fns[i] !== 'function') {throw new Error('index position ${i} must be function')}}return function (...args) {var result = fns[0].apply(this, args)for (var i = 1; i &lt; length; i++) {result = fns[i].apply(this, [result])// 依次执行多个函数}return result}}var newFn = compFn(double, pow, console.log)newFn(100)</code></pre><h2 id="5-额外知识"><a href="#5-额外知识" class="headerlink" title="5. 额外知识"></a>5. 额外知识</h2><h3 id="5-1-with-语句"><a href="#5-1-with-语句" class="headerlink" title="5.1 with 语句"></a>5.1 with 语句</h3><p>with语句 扩展一个语句的作用域链</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why',age: 18}with(obj) {console.log(name)console.log(age)}</code></pre><p>不建议使用with语句，因为它可能是混淆错误和兼容性问题的根源</p><h3 id="5-2-eval-函数"><a href="#5-2-eval-函数" class="headerlink" title="5.2 eval 函数"></a>5.2 eval 函数</h3><p>内建函数 eval 允许执行一个<strong>代码字符串</strong></p><ul><li>eval是一个特殊的函数，它可以将传入的字符串当做JavaScript代码来运行；</li><li>eval会将最后一句执行语句的结果，作为返回值<br>不建议在开发中使用eval</li></ul><h3 id="5-3-严格模式"><a href="#5-3-严格模式" class="headerlink" title="5.3 严格模式"></a>5.3 严格模式</h3><p>严格模式对正常的JavaScript语义进行了一些限制：</p><ul><li>严格模式通过 <strong>抛出错误</strong> 来消除一些原有的 <strong>静默（silent）错误</strong>；</li><li>严格模式让JS引擎在执行代码时可以进行<strong>更多的优化</strong>（不需要对一些特殊的语法进行处理）；</li><li>严格模式禁用了在ECMAScript<strong>未来版本</strong>中可能会定义的一些语法；</li></ul><h4 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h4><p><code>"use strict"</code></p><ul><li>支持在js文件中开启严格模式</li><li>支持对某一个函数开启严格模式</li></ul><h4 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">"use strict"//1.无法意外的创建全局变量function foo() {message = "Hello World"}foo()console.log(message)//2.发现静默错误//3.试图删除不可删除的属性会报错var obj = {name: "why"}Object.defineProperty(obj, "name", {writable: false,// 不可写configurable: false})obj.name = "kobe"delete obj.name//3.函数参数名称不能相同function foo(num, num) {}// 4.不允许0的八进制语法console.log(0o123)// 5.不允许使用with// 6.eval函数不能为上层创建变量eval(`var message = "Hello World"`)console.log(message)// 7.严格模式下, this不会默认转成对象类型function foo() {console.log(this)}foo.apply("abc")foo.apply(123)foo.apply(undefined)foo.apply(null)// 独立函数执行默认模式下, 绑定window对象// 在严格模式下, 不绑定全局对象而是undefinedfoo()</code></pre><h1 id="二、对象增强"><a href="#二、对象增强" class="headerlink" title="二、对象增强"></a>二、对象增强</h1><h2 id="1-对属性操作的控制"><a href="#1-对属性操作的控制" class="headerlink" title="1. 对属性操作的控制"></a>1. 对属性操作的控制</h2><p>通过属性描述符可以精准的<strong>添加或修改对象的属性</strong><br><code>Object.defineProperty(obj, prop, descriptor)</code></p><p>可接收三个参数：</p><ul><li>obj 要定义属性的<strong>对象</strong>；</li><li>prop 要定义或修改的<strong>属性</strong>的名称或 Symbol； </li><li>descriptor 要定义或修改的<strong>属性描述符</strong>；</li></ul><p>返回值： 被传递给函数的对象。</p><h3 id="1-1-数据属性描述符"><a href="#1-1-数据属性描述符" class="headerlink" title="1.1 数据属性描述符"></a>1.1 数据属性描述符</h3><p>数据数据描述符有如下四个特性：</p><ul><li><code>configurable</code>：表示属性可以通过delete<strong>删除</strong>属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；<ul><li>当我们直接在一个对象上定义某个属性时，这个属性的configurable为true；</li><li>当我们<strong>通过属性描述符</strong>定义一个属性时，这个属性的configurable默认为false；</li></ul></li><li><code>enumerable</code>：表示属性是否可以通过<strong>遍历</strong>for-in或者Object.keys()返回该属性；<ul><li>当我们直接在一个对象上定义某个属性时，这个属性的enumerable为true；</li><li>当我们通过属性描述符定义一个属性时，这个属性的enumerable默认为false；</li></ul></li><li><code>writable</code>：表示是否可以<strong>修改属性的值</strong>；<ul><li>当我们直接在一个对象上定义某个属性时，这个属性的writable为true；</li><li>当我们通过属性描述符定义一个属性时，这个属性的writable默认为false；</li></ul></li><li><code>value</code>：属性的value值，读取属性时会返回该值，修改属性时，会对其进行修改；<ul><li>默认情况下这个值是undefined；</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">var obj = {name: 'why',age: 18}</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.defineProperty(obj, 'name', {configurable: false,//不可删除enumerable: false,//不可遍历writable: false,//不可写value: 'codewhy'//name = 'codewhy'})delete obj.nameconsole.log(obj.name);//codewhyObject.defineProperty(obj, 'address', {})// 这样添加的属性默认不可删除delete obj.addressconsole.log(obj.address);//undefinedconsole.log(Object.keys(obj));//ageobj.name = 'kobe'console.log(obj.name);//codewhy</code></pre><h3 id="1-2-存储属性描述符"><a href="#1-2-存储属性描述符" class="headerlink" title="1.2 存储属性描述符"></a>1.2 存储属性描述符</h3><ul><li><code>configurable</code>：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；<ul><li><strong>和数据属性描述符是一致的</strong>；</li><li>当我们直接在一个对象上定义某个属性时，这个属性的configurable为true；</li><li>当我们通过属性描述符定义一个属性时，这个属性的configurable默认为false；</li></ul></li><li><code>enumerable</code>：表示属性是否可以通过for-in或者Object.keys()返回该属性；<ul><li><strong>和数据属性描述符是一致的</strong>；</li><li>当我们直接在一个对象上定义某个属性时，这个属性的enumerable为true；</li><li>当我们通过属性描述符定义一个属性时，这个属性的enumerable默认为false；</li></ul></li><li><code>get</code>：<strong>获取属性</strong>时会执行的函数。默认为undefined</li><li><code>set</code>：<strong>设置属性</strong>时会执行的函数。默认为undefined</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why'}var _name = ''Object.defineProperty(obj, 'name', {configurable: true,enumerable: false,set: function (value) {console.log('set方法被调用了', value);_name = value},get: function () {console.log('get方法被调用了');return _name // 不写的话默认undefined}})obj.name = 'kobe'obj.name = 'james'obj.name = 'codewhy'console.log(obj.name);// set方法被调用了 kobe// set方法被调用了 james// set方法被调用了 codewhy// get方法被调用了// codewhy</code></pre><h3 id="1-3-定义多个属性描述符"><a href="#1-3-定义多个属性描述符" class="headerlink" title="1.3 定义多个属性描述符"></a>1.3 定义多个属性描述符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why',age: 18,height: 1.88}        Object.defineProperties(obj, {name: {configurable: false,enumerable: false,writable: false},age: {},height: {}})</code></pre><h2 id="2-对象方法补充"><a href="#2-对象方法补充" class="headerlink" title="2. 对象方法补充"></a>2. 对象方法补充</h2><ol><li><p>获取对象的属性描述符：</p><ul><li><code>Object.getOwnPropertyDescriptor(obj, "name")</code></li><li><code>Object.getOwnPropertyDescriptors(obj)</code></li></ul></li><li><p>禁止对象扩展新属性：<code>Object.preventExtensions(obj)</code></p><ul><li>给一个对象添加新的属性会失败（在严格模式下会报错）；</li></ul></li><li><p>密封对象，不允许配置和删除属性：<code>Object.seal(obj)</code></p><ul><li>实际是调用preventExtensions</li><li>并且将现有属性的configurable:false</li></ul></li><li><p>冻结对象，不允许修改现有属性：<code>Object.freeze(obj)</code></p><ul><li>实际上是调用seal </li><li>并且将现有属性的writable: false</li></ul></li></ol><h1 id="三、ES5-实现继承"><a href="#三、ES5-实现继承" class="headerlink" title="三、ES5 实现继承"></a>三、ES5 实现继承</h1><h2 id="1-原型的理解"><a href="#1-原型的理解" class="headerlink" title="1. 原型的理解"></a>1. 原型的理解</h2><h3 id="1-1-对象的原型"><a href="#1-1-对象的原型" class="headerlink" title="1.1 对象的原型"></a>1.1 对象的原型</h3><p>JavaScript当中每个对象都有一个特殊的内置属性 prototype（隐式原型），这个特殊的对象<strong>可以指向另外一个对象</strong>。</p><p>获取对象原型：</p><ul><li><code>obj.__proto__</code>（是早期浏览器自己添加的，存在一定的兼容性问题）</li></ul><ul><li><code>Object.getPrototypeOf(obj)</code></li></ul><p>==作用==：在当前对象查找某一个属性时, 如果找不到, 会访问对象内置属性指向的对象上的属性</p><h3 id="1-2-函数的原型"><a href="#1-2-函数的原型" class="headerlink" title="1.2 函数的原型"></a>1.2 函数的原型</h3><p>任何一个函数（非箭头函数），都有自己的prototype 属性（显式原型）</p><p><code>foo.prototype</code>（此属性是函数独有的，对象没有）</p><p><em><strong>==作用：==</strong></em></p><ul><li>当通过 new 操作符调用构造函数时，创建一个新的对象</li><li>这个新的<strong>对象的隐式原型</strong>会指向这个<strong>函数的显式原型</strong></li><li><code>obj.__proto__ = F.prototype</code></li></ul><h4 id="1-2-1-函数原型上的constructor属性"><a href="#1-2-1-函数原型上的constructor属性" class="headerlink" title="1.2.1 函数原型上的constructor属性"></a>1.2.1 函数原型上的constructor属性</h4><p>默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(Person.prototype.constructor === Person);//trueconsole.log(Person.prototype.constructor.name);//'Person'</code></pre><h4 id="1-2-2-构造函数创建对象的内存表现"><a href="#1-2-2-构造函数创建对象的内存表现" class="headerlink" title="1.2.2 构造函数创建对象的内存表现"></a>1.2.2 构造函数创建对象的内存表现</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person(name, age) {this.name = name;this.age = age;}Person.prototype.running = function () {console.log('running~');} // 重复的函数放到Person.prototype的对象上var p1 = new Person('why', 18)var p2 = new Person('kobe', 30)Person.prototype.address = '中国'p1.__proto__.info = '中国很美丽'p1.height = 1.88p2.isAdmin = truep1.address = '广州市'//address不会更改，会直接在p1中增加address属性</code></pre><p>创建对象的内存表现<br><img src="97199a01dbad49ad9987d6437ade1569.png" alt="在这里插入图片描述"></p><p>新增属性<br><img src="4e032d273a8143fea987c303f895ddbc.png" alt="在这里插入图片描述"></p><h4 id="1-2-3-重写显式原型"><a href="#1-2-3-重写显式原型" class="headerlink" title="1.2.3 重写显式原型"></a>1.2.3 重写显式原型</h4><p>如果我们需要在原型上添加过多的属性，通常我们会重写整个原型对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() {}Person.prototype = {message: 'Hello world',info: { name: '哈哈哈', age: 30 },running: function () { },eating: function () { },constructor: Person}Object.defineProperty(Person.prototype, "constructor", {enumerable: false,configurable: true,writable: true,value: Person}) // 使constructor特性与原生保持一致</code></pre><h2 id="2-ES5-中的继承"><a href="#2-ES5-中的继承" class="headerlink" title="2. ES5 中的继承"></a>2. ES5 中的继承</h2><p>面向对象有三大特性：封装、继承、多态</p><ul><li>==封装==：我们前面将属性和方法封装到一个类中，可以称之为封装的过程</li><li>==继承==：继承可以帮助我们将<strong>重复的代码和逻辑抽取到父类</strong>中，子类只需要直接继承过来使用即可。也是多态的前提</li><li>==多态==：不同的对象在执行时表现出不同的形态</li></ul><h3 id="2-1-原型链的概念"><a href="#2-1-原型链的概念" class="headerlink" title="2.1 原型链的概念"></a>2.1 原型链的概念</h3><p>从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why',age: 18}obj.__proto__ = {} // 在__proto__上创建了对象obj.__proto__.__proto__ = {}obj.__proto__.__proto__.__proto__ = {address: "北京市"}console.log(obj.address);</code></pre><p><img src="63d9f47ab2634118b5c2db5bc1b16849.png" alt="在这里插入图片描述"></p><h4 id="原型链的尽头"><a href="#原型链的尽头" class="headerlink" title="原型链的尽头"></a>原型链的尽头</h4><p>什么地方是原型链的尽头呢？我们发现第三个对象的__proto__是<code>[Object: null prototype] {}</code>（原型链的尽头）</p><p>从<strong>Object直接创建</strong>出来的对象的原型都是 <code>[Object: null prototype] {}</code>，是最顶层的原型<br><img src="6556249f20a84aef91640965405a067a.png" alt="在这里插入图片描述"></p><p><img src="c3e07ed35ca6466db1450dfe47b4bd67.png" alt="在这里插入图片描述"></p><p>从我们上面的Object原型我们可以得出一个结论：原型链最顶层的原型对象就是Object的原型对象，<strong>Object是所有类的父类</strong></p><h3 id="2-2-通过原型链实现继承"><a href="#2-2-通过原型链实现继承" class="headerlink" title="2.2 通过原型链实现继承"></a>2.2 通过原型链实现继承</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person(name, age) {this.name = name;this.age = age;}Person.prototype.running = function () {console.log('running~');}Person.prototype.eating = function () {console.log('eating~');}function Student(name, age, sno, score) {Person.call(this, name, age) // 属性继承// this.name = name;// this.age = age;this.sno = sno;this.score = score;}var p = new Person('why', 18)Student.prototype = p // 方法继承Student.prototype.studying = function () {console.log('studying~');}var stu1 = new Student('why', 18, 111, 100)stu1.running()stu1.studying()</code></pre><p><img src="deb307831c2e4b91bec3eeadf1734557.png" alt="在这里插入图片描述"></p><h4 id="2-2-1-组合借用继承的问题"><a href="#2-2-1-组合借用继承的问题" class="headerlink" title="2.2.1 组合借用继承的问题"></a>2.2.1 组合借用继承的问题</h4><ul><li>组合继承最大的问题就是无论在什么情况下，都会<strong>调用两次父类构造函数</strong></li><li>所有的子类实例事实上会拥有两份父类的属性<ul><li>一份在当前的实例自己里面(也就是person本身的)，另一份在子类对应的原型对象中(也就是<code>person.__proto__</code>里面)</li></ul></li></ul><h4 id="2-2-2-原型式继承函数"><a href="#2-2-2-原型式继承函数" class="headerlink" title="2.2.2 原型式继承函数"></a>2.2.2 原型式继承函数</h4><p>最终的目的：<strong>student对象的原型 -&gt; 中间对象/函数 – 对象/函数的原型 -&gt; Person.prototype</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 之前的做法: 但是不想要这种做法// var p = new Person()// Student.prototype = p// 1.var obj = {}Object.setPrototypeOf(obj, Person.prototype)Student.prototype = obj// 2.function F() { }F.prototype = Person.prototypeStudent.prototype = new F()// 3.var obj = Object.create(Person.prototype)Student.prototype = obj</code></pre><h3 id="2-3-寄生组合式继承"><a href="#2-3-寄生组合式继承" class="headerlink" title="2.3 寄生组合式继承"></a>2.3 寄生组合式继承</h3><p>创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//创建对象function createObject(o) {function F() {}F.prototype = o.prototypereturn new F}function inherit(Subtype, Supertype) {Subtype.prototype = createObject(Supertype)Object.defineProperty(Subtype.prototype, 'constructor', {enumerable: false,configurable: true,writable: true,value: Subtype})// 新建对象添加'constructor'}function Person() {}function Student() {}inherit(Student, Person)</code></pre><h3 id="2-4-对象判断方法补充"><a href="#2-4-对象判断方法补充" class="headerlink" title="2.4 对象判断方法补充"></a>2.4 对象判断方法补充</h3><ul><li><code>hasOwnProperty</code>：对象是否有某一个属于自己的属性（<strong>不是在原型上的属性</strong>）</li><li><code>in/for in</code>：判断某个属性是否在<strong>某个对象或者对象的原型</strong>上</li><li><code>instanceOf</code>：用于检测构造函数（Person、Student类）的pototype，是否出现在某个实例对象的原型链上</li><li><code> obj.isPrototypeOf(info)</code>：用于检测某个对象，是否出现在某个实例对象的原型链上</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why',age: 18}var info = createObject(obj)info.address = '中国'info.intro = '中国大好河山'// hasOwnPropertyconsole.log(info.hasOwnProperty('name'));//falseconsole.log(info.hasOwnProperty('address'));//true// inconsole.log('name' in info);//trueconsole.log('address' in info);//true// for infor (var k in info) {console.log(k);}function Student() {}function Person() {}inherit(Student, Person)//instanceofvar stu = new Student()console.log(stu instanceof Student);console.log(stu instanceof Person);console.log(stu instanceof Object);console.log(stu instanceof Array);//false//isPrototypeOfconsole.log(Student.prototype.isPrototypeOf(stu));console.log(Person.prototype.isPrototypeOf(stu));</code></pre><h3 id="2-5-原型继承关系（重点）"><a href="#2-5-原型继承关系（重点）" class="headerlink" title="2.5 原型继承关系（重点）"></a>2.5 原型继承关系（重点）</h3><ol><li>Person()作为一个函数，有prototype属性（指向Person原型对象，此 <code>对象.__proto__</code> 为<code>[Object: null prototype]</code>）</li><li>Person作为一个对象，有__proto__属性（Person是Function()创建的，<code>Person.__proto__ === Function.prototype</code><br><img src="f7f5c0939e7a4ff89769f0c2d89c4532.png" alt="在这里插入图片描述"></li></ol><p>Function、Object、函数对象Person的关系</p><ul><li>Function/Object/Person 都是Function的实例对象</li><li>Object是Function/Person的父类</li><li>函数的<code>__proto__</code>都指向Function的显示原型,包括Function自己的<code>__proto__</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {}; //相当于new Object()  ---&gt; function Object(){}function Foo() {} //相当于 new Function() ---&gt; function Function(){}function Person() {}  console.log(obj.__proto__ === Object.prototype);  console.log(Foo.__proto__ === Function.prototype);console.log(Person.__proto__ === Function.prototype);console.log(Foo.__proto__ === Person.__proto__);console.log(Object.__proto__ === Function.prototype);console.log(Function.__proto__ === Function.prototype);  console.log(Foo.prototype.__proto__ === Object.prototype);console.log(Function.prototype.__proto__ === Object.prototype);  var p1 = new Person();console.log(p1.__proto__ === Person.prototype);</code></pre><h1 id="四、ES6-类的使用"><a href="#四、ES6-类的使用" class="headerlink" title="四、ES6 类的使用"></a>四、ES6 类的使用</h1><h2 id="1-class-定义类"><a href="#1-class-定义类" class="headerlink" title="1. class 定义类"></a>1. class 定义类</h2><p>类本质上是构造函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person() {}var Student = class {}</code></pre><h3 id="1-1-类中的-constructor"><a href="#1-1-类中的-constructor" class="headerlink" title="1.1 类中的 constructor"></a>1.1 类中的 constructor</h3><p><code>constructor</code>在创建对象的时候给类<strong>传递一些参数</strong></p><p>每个类都可以有一个自己的构造函数（方法），这个方法的名称是固定的<code>constructor</code>；每个类只能有<strong>一个</strong>构造函数，如果包含多个构造函数，那么会抛出异常</p><p>当我们通过new操作符，操作一个类的时候会调用这个类的构造函数constructor并且执行如下操作：</p><ol><li>在内存中创建一个新的对象（空对象）；</li><li>这个对象内部的prototype属性会被赋值为该类的prototype属性；</li><li>构造函数内部的this，会指向创建出来的新对象；</li><li>执行构造函数的内部代码（函数体代码）； </li><li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {constructor(name, age) {this.name = name;this.age = age;}}</code></pre><h3 id="1-2-类的实例方法"><a href="#1-2-类的实例方法" class="headerlink" title="1.2 类的实例方法"></a>1.2 类的实例方法</h3><p>在类中创建实例方法，<strong>放在原型上</strong>，被多个实例共享</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {constructor(name, age) {this.name = name;this.age = age;}running() {console.log(this.name + ' running~');}eating() {console.log(this.name + ' eating~');}}console.log(Person.running);//undefinedconsole.log(Person.prototype.running);//可以取到</code></pre><h3 id="1-3-类的访问器方法"><a href="#1-3-类的访问器方法" class="headerlink" title="1.3 类的访问器方法"></a>1.3 类的访问器方法</h3><p>类可以添加setter和getter函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {constructor(name, age) {this._name = name;this.age = age;}set name(value) {console.log('set了属性');this._name = value}get name() {console.log('get了属性');return this._name}}var p1 = new Person()p1.name = 'kobe' //调用的是set name()，但不可p1.name()这样使用console.log(p1.name);</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Rectangle {constructor(x, y, width, height) {this.x = x;this.y = y;this.width = width;this.height = height;}get position() {return { x: this.x, y: this.y }}}var rec = new Rectangle(1, 3, 100, 200)console.log(rec.position);</code></pre><h3 id="1-4-类的静态方法"><a href="#1-4-类的静态方法" class="headerlink" title="1.4 类的静态方法"></a>1.4 类的静态方法</h3><p>静态方法通常用于定义<strong>直接使用类来执行</strong>的方法，不需要有类的实例，使用static关键字来定义</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var names = ["abc", "cba", "nba", "mba"]class Person {constructor(name, age) {this.name = name;this.age = age;}running() { }eating() { }static randomPerson() {console.log(this);//Person{}var randomName = names[Math.floor(Math.random() * names.length)]return new this(randomName, Math.floor(Math.random() * 100))}}var p1 = new Person()console.log(Person.randomPerson());</code></pre><h3 id="1-5-类和构造函数的异同"><a href="#1-5-类和构造函数的异同" class="headerlink" title="1.5 类和构造函数的异同"></a>1.5 类和构造函数的异同</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {}var p = new Person("kobe", 30)console.log(p.__proto__ === Person.prototype)//trueconsole.log(Person.prototype.constructor)//[class Person]console.log(typeof Person) // function// 不同点：class定义的类, 不能作为一个普通的函数进行调用Person()//错误</code></pre><h2 id="2-ES6类的继承"><a href="#2-ES6类的继承" class="headerlink" title="2. ES6类的继承"></a>2. ES6类的继承</h2><h3 id="2-1-extends"><a href="#2-1-extends" class="headerlink" title="2.1 extends"></a>2.1 extends</h3><p>在ES6中新增了使用<code>extends</code>关键字，可以方便的帮助我们实现继承</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {}class Student extends Person {}</code></pre><h3 id="2-2-super-关键字"><a href="#2-2-super-关键字" class="headerlink" title="2.2 super 关键字"></a>2.2 super 关键字</h3><p><strong>方式一：构造方法 super()</strong></p><ul><li>一定在<strong>使用this之前</strong>以及返回对象之前先调用super</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Person {constructor(name, age) {this.name = name;this.age = age;}}class Person {constructor(name, age, sno, score) {// this.name = name;// this.age = age;super(name, age);this.sno = sno;this.score = score;}}</code></pre><p><strong>方式二：实例方法super.method</strong></p><p>调用父类函数</p><p><strong>方式三：静态方法super.staticMethod</strong></p><p>调用父类静态函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal {running() {console.log('running~');}eating() {console.log('eating~');}static sleep() {console.log('sleep');}}class Dog extends Animal {running() {console.log('dog四条腿');super.running() // 实例方法}static sleep() {console.log('趴着');super.sleep() // 静态方法}}</code></pre><h3 id="2-3-继承自内置类"><a href="#2-3-继承自内置类" class="headerlink" title="2.3 继承自内置类"></a>2.3 继承自内置类</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class HYArray extends Array {lastItem() {return this[this.length - 1]}}var arr = new HYArray(10, 20, 30)console.log(arr.length);console.log(arr.lastItem());//30Array.prototype.lastItem = function () {return this[this.length - 1]}</code></pre><h3 id="2-4-类的混入-mixin"><a href="#2-4-类的混入-mixin" class="headerlink" title="2.4 类的混入 mixin"></a>2.4 类的混入 mixin</h3><p>JavaScript的类只支持<strong>单继承</strong>：也就是只能有一个父类</p><p>需要多继承，则需要使用 mixin</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function mixinAnimal(BaseClass) {return class extends BaseClass {running() {console.log('running');}}}function mixinRunner(BaseClass) {return class extends BaseClass {flying() {console.log('flying');}}}class Bird {eating() {console.log('eating');}}var NewBird = mixinRunner(mixinAnimal(Bird));// 继承Animal和Runner类 后的新类var bird = new NewBird();bird.running();bird.flying();</code></pre><h2 id="3-babel-ES6-转-ES5源码"><a href="#3-babel-ES6-转-ES5源码" class="headerlink" title="3. babel ES6 转 ES5源码"></a>3. babel ES6 转 ES5源码</h2><p><a href="https://babeljs.io/">babel 转换网站</a></p><h2 id="4-面向对象的补充"><a href="#4-面向对象的补充" class="headerlink" title="4. 面向对象的补充"></a>4. 面向对象的补充</h2><h3 id="4-1-JavaScript-中的多态"><a href="#4-1-JavaScript-中的多态" class="headerlink" title="4.1 JavaScript 中的多态"></a>4.1 JavaScript 中的多态</h3><p><strong>不同的数据类型</strong>进行同一个操作，表现出<strong>不同的行为</strong>，就是多态的体现。</p><p>JavaScript是一定存在多态的</p><h3 id="4-2-对象字面量的增强"><a href="#4-2-对象字面量的增强" class="headerlink" title="4.2 对象字面量的增强"></a>4.2 对象字面量的增强</h3><p>字面量的增强主要包括下面几部分：</p><ul><li>属性的简写</li><li>方法的简写</li><li>计算属性名</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name = 'why'var age = 18var key = 'address' + 'city'var obj = {// 属性的简写// name: name,name,// age: ageage,running: function () {console.log(this);},// 方法的简写swimming() {console.log(this);},eating: () =&gt; {console.log(this);},// 计算属性名[key]: '广州市' // address city: '广州市'}obj.running();//objobj.swimming();//objobj.eating();//windowfunction foo() {var message = 'hello world'var info = 'my name is why'return {message,info}}var result = foo()console.log(result.message, result.info);</code></pre><h3 id="4-3-数组和对象的解构"><a href="#4-3-数组和对象的解构" class="headerlink" title="4.3 数组和对象的解构"></a>4.3 数组和对象的解构</h3><p>解构：从数组或对象中方便获取数据的方法，它使我们可以<strong>将数组或对象“拆包”至一系列变量</strong>中</p><h4 id="4-3-1-数组的解构"><a href="#4-3-1-数组的解构" class="headerlink" title="4.3.1 数组的解构"></a>4.3.1 数组的解构</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var names = ["abc", "cba", undefined, "nba", "mba"]// var name1 = names[0]// var name2 = names[1]// var name3 = names[2]// 1.1. 基本使用var [n1, n2, n3] = namesconsole.log(n1, n2, n3);// 1.2 按照严格顺序var [n1, , n3] = namesconsole.log(n1, n3);// 1.3 解构出部分数组var [n1, n2, ...newArr] = namesconsole.log(newArr);// [undefined, "nba", "mba"]// 1.4 解构的默认值var [n1, n2, n3 = 'default'] = namesconsole.log(n1, n2, n3);</code></pre><h4 id="4-3-2-对象的解构"><a href="#4-3-2-对象的解构" class="headerlink" title="4.3.2 对象的解构"></a>4.3.2 对象的解构</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = { name: "why", age: 18, height: 1.88 }// var name = obj.name// var age = obj.age// var height = obj.height// 2.1. 基本使用var { name, age, height } = objconsole.log(name, age, height);// 2.2 顺序按对应key获取var { height, name, age } = objconsole.log(name, age, height);// 2.3 对变量进行重命名var { height: wHeight, name: wName, age: wAge } = objconsole.log(wName, wAge, wHeight);// 2.4 默认值var {height: wHeight,name: wName,age: wAge,address: wAddress = '中国'} = objconsole.log(wName, wAge, wHeight, wAddress);// 2.5. 解构出部分对象var {name,...newObj} = objconsole.log(newObj)// {age: 18, height: 1.88}</code></pre><h4 id="4-3-3-应用场景"><a href="#4-3-3-应用场景" class="headerlink" title="4.3.3 应用场景"></a>4.3.3 应用场景</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function getPosition({ x, y }) {console.log(x, y);}getPosition({ x: 10, y: 25 })getPosition({ x: 20, y: 25 })</code></pre><h2 id="5-手写-apply-call-bind-函数实现"><a href="#5-手写-apply-call-bind-函数实现" class="headerlink" title="5. 手写 apply/call/bind 函数实现"></a>5. 手写 apply/call/bind 函数实现</h2><h3 id="5-1-apply-和-call-的实现"><a href="#5-1-apply-和-call-的实现" class="headerlink" title="5.1 apply 和 call 的实现"></a>5.1 apply 和 call 的实现</h3><ol><li>apply</li></ol><p><code>thisArg</code>代表调用apply时赋给this的值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(name, age) {console.log(this, name, age);}Function.prototype.hyapply = function (thisArg, otherArgs) {// 使 thisArg 是对象thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)thisArg.fn = this // thisArg.fn=foothisArg.fn(...otherArgs) // thisArg.foo() foo的this-&gt;thisArgdelete thisArg.fn}foo.hyapply({ name: 'why' }, ['kobe', 30])foo.hyapply(123, ['james', 25])foo.hyapply(null, ['james', 25])</code></pre><ol start="2"><li>call<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Function.prototype.hycall = function (thisArg, ...otherArgs) {// 让thisArg是对象thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)thisArg.fn = this // thisArg.fn=foothisArg.fn(...otherArgs) // thisArg.foo() foo的this-&gt;thisArgdelete thisArg.fn}foo.hycall({ name: 'why' }, 'kobe', 30)foo.hycall(123, 'james', 25)foo.hycall(null, 'james', 25)</code></pre></li></ol><h3 id="5-2-apply-和-call-的封装"><a href="#5-2-apply-和-call-的封装" class="headerlink" title="5.2 apply 和 call 的封装"></a>5.2 apply 和 call 的封装</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(name, age) {console.log(this, name, age);}// 封装Function.prototype.hyexec = function (thisArg, otherArgs) {thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)thisArg.fn = this // thisArg.fn=foothisArg.fn(...otherArgs) // thisArg.foo() foo的this-&gt;thisArgdelete thisArg.fn}// applyFunction.prototype.hyapply = function (thisArg, otherArgs) {// execFn(thisArg, otherArgs, this)this.hyexec(thisArg, otherArgs)}foo.hyapply({ name: 'why' }, ['kobe', 30])foo.hyapply(123, ['james', 25])foo.hyapply(null, ['james', 25])// callFunction.prototype.hycall = function (thisArg, ...otherArgs) {// execFn(thisArg, otherArgs, this)this.hyexec(thisArg, otherArgs)}foo.hycall({ name: 'why' }, 'kobe', 30)foo.hycall(123, 'james', 25)foo.hycall(null, 'james', 25)</code></pre><h3 id="5-3-bind-函数的实现"><a href="#5-3-bind-函数的实现" class="headerlink" title="5.3 bind 函数的实现"></a>5.3 bind 函数的实现</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(name, age, height, address) {console.log(this, name, age, height, address);}Function.prototype.hybind = function (thisArg, ...otherArgs) {thisArg = (thisArg === null || thisArg === undefined) ? window : Object(thisArg)thisArg.fn = this //thisArg.fn = fooreturn (...newArgs) =&gt; {var allArgs = [...otherArgs, ...newArgs]thisArg.fn(...allArgs)}}var newFoo = foo.hybind({ name: 'why' }, 'kobe', 30)newFoo(1.88, 'America') // 支持传递剩余参数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（二）浏览器和 JavaScript 的运行原理、内存管理</title>
      <link href="/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C-JavaScript-%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/01/15/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C-JavaScript-%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、浏览器的运行原理"><a href="#一、浏览器的运行原理" class="headerlink" title="一、浏览器的运行原理"></a>一、浏览器的运行原理</h1><p>一个网页URL从输入到浏览器中，到显示经历过怎么样的解析过程呢？</p><p><img src="42fd1742e6e540cbbe504464c369e448.png" alt="在这里插入图片描述"></p><h2 id="1-浏览器渲染流程"><a href="#1-浏览器渲染流程" class="headerlink" title="1. 浏览器渲染流程"></a>1. 浏览器渲染流程</h2><h3 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h3><p>我们经常说的<strong>浏览器内核</strong>指的是浏览器的<strong>排版引擎</strong>： </p><ul><li>排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。 </li><li>也就是一个网页下载下来后，就是<strong>由我们的渲染引擎来帮助我们解析的</strong>。</li></ul><p><img src="048f7d230da04781b76b549bfc1a8353.png" alt="在这里插入图片描述"></p><h3 id="1-1-HTML-解析过程"><a href="#1-1-HTML-解析过程" class="headerlink" title="1.1 HTML 解析过程"></a>1.1 HTML 解析过程</h3><ul><li>因为默认情况下服务器会给浏览器返回index.html文件，所以解析HTML是所有步骤的开始</li><li>解析HTML，会==构建 DOM Tree==<br><img src="eb6454051c0f4f03918994e38dfadd79.png" alt="在这里插入图片描述"></li></ul><h3 id="1-2-CSS-解析过程"><a href="#1-2-CSS-解析过程" class="headerlink" title="1.2 CSS 解析过程"></a>1.2 CSS 解析过程</h3><ul><li>在解析的过程中，如果遇到 CSS 的 link 元素，那么会由浏览器负责下载对应的 CSS 文件： <ul><li>注意：<strong>下载 CSS 文件是不会影响 DOM 的解析的</strong>；</li></ul></li><li>浏览器下载完 CSS 文件后，就会对 CSS 文件进行解析，解析出对应的<strong>规则树</strong>：<ul><li>我们可以称之为 ==CSSOM==（CSS Object Model，CSS对象模型）；<br><img src="7c9287885b964c0e994320512dd4768a.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="1-3-构建-Render-Tree"><a href="#1-3-构建-Render-Tree" class="headerlink" title="1.3 构建 Render Tree"></a>1.3 构建 Render Tree</h3><p>当有了 DOM Tree 和 CSSOM Tree 后，就可以两个结合来构建==Render Tree==了</p><p>注意：</p><ul><li>link 元素不会阻塞 DOM Tree 的构建过程，但是<strong>会阻塞 Render Tree 的构建过程</strong> <ul><li>这是因为 Render Tree 在构建时，需要对应的 CSSOM Tree；</li></ul></li><li>Render Tree 和 DOM Tree 并<strong>不是一一对应</strong>的关系，比如对于 <code>display = none</code> 的元素，压根不会出现在 render tree 中；<br><img src="1275bbcdf2fc4a9a9bce4cce1c1d84cc.png" alt="在这里插入图片描述"></li></ul><h3 id="1-4-布局（layout）和绘制（paint）"><a href="#1-4-布局（layout）和绘制（paint）" class="headerlink" title="1.4 布局（layout）和绘制（paint）"></a>1.4 布局（layout）和绘制（paint）</h3><ul><li>第四步是在渲染树（Render Tree）上运行==布局==以计算每个节点的几何体<ul><li>渲染树会表示显示哪些节点以及其他样式，但是<strong>不表示每个节点的尺寸、位置</strong>等信息； </li><li>布局是确定呈现树中<strong>所有节点的宽度、高度和位置信息</strong>；</li></ul></li><li>第五步是将每个节点==绘制==到屏幕上<ul><li>在绘制阶段，浏览器将布局阶段计算的<strong>每个frame转为屏幕上实际的像素点</strong></li><li>包括将<strong>元素的可见部分</strong>进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）</li></ul></li></ul><h2 id="2-回流和重绘解析"><a href="#2-回流和重绘解析" class="headerlink" title="2. 回流和重绘解析"></a>2. 回流和重绘解析</h2><p>==回流（reflow）：==</p><ul><li>第一次确定节点的大小和位置，称之为布局（layout）。 </li><li>之后<strong>对节点的大小、位置修改</strong>重新计算称之为回流。<br>==什么情况下引起回流呢？ ==</li><li>比如<strong>DOM结构发生改变</strong>（添加新的节点或者移除节点）；</li><li>比如<strong>改变了布局</strong>（修改了width、height、padding、font-size等值）</li><li>比如窗口<strong>resize</strong>（修改了窗口的尺寸等）</li><li>比如<strong>调用getComputedStyle方法</strong>获取尺寸、位置信息；</li></ul><p>==重绘（repaint）：==</p><ul><li>第一次渲染内容称之为绘制（paint）。</li><li>之后<strong>重新渲染</strong>称之为重绘。<br>==什么情况下会引起重绘呢？== </li><li>比如修改背景色、文字颜色、边框颜色、样式等；</li></ul><p>回流一定会引起重绘, 很消耗性能，开发中要尽量避免发送回流：</p><ol><li>修改样式时<strong>尽量一次性修改</strong> <ul><li>比如通过cssText修改，比如通过添加class修改</li></ul></li><li>尽量<strong>避免频繁的操作DOM</strong><ul><li>我们可以在一个 DocumentFragment 或者父元素中将要操作的DOM操作完成，再一次性的操作；</li></ul></li><li>尽量<strong>避免通过getComputedStyle获取</strong>尺寸、位置等信 息；</li><li>对某些元素使用<code>position=absolute或者fixed</code><ul><li>并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响</li></ul></li></ol><h2 id="3-合成和性能优化"><a href="#3-合成和性能优化" class="headerlink" title="3. 合成和性能优化"></a>3. 合成和性能优化</h2><p>绘制的过程，可以将布局后的元素绘制到多个合成图层中。这是浏览器的一种<strong>优化手段</strong></p><ul><li>默认情况下，标准流中的内容都是被<strong>绘制在同一个图层中</strong></li><li>某些特殊的CSS属性, 会生成新的合成图层，并且新的图层可以利用GPU来加速绘制（因为每个<strong>合成层都是单独渲染</strong>的）</li><li>分层确实可以提高性能，但是它<strong>以内存管理为代价</strong>，因此不应作为 web 性能优化策略的一部分过度使用。</li></ul><p><em><strong>可以形成新的合成层的属性：</strong></em></p><ul><li>3D transforms </li><li>video、canvas、iframe</li><li>opacity 动画转换时</li><li>position: fixed </li><li>will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化；</li><li>animation 或 transition 设置了opacity、transform；</li></ul><h2 id="4-script-元素和页面解析的关系"><a href="#4-script-元素和页面解析的关系" class="headerlink" title="4. script 元素和页面解析的关系"></a>4. script 元素和页面解析的关系</h2><p>浏览器在解析 HTML 的过程中，遇到了 script 元素会<strong>停止继续构建 DOM 树</strong>，首先<strong>下载</strong> JavaScript 代码，并且<strong>执行</strong> JavaScript 的脚本； 只有等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树；</p><p>这是因为 JavaScript 的作用之一就是<strong>操作 DOM，并且可以修改 DOM</strong>；如果我们等到 DOM 树构建完成并且渲染再执行 JavaScript，<strong>会造成严重的回流和重绘，影响页面的性能</strong></p><p>但是这个也往往会带来新的问题，在目前的开发模式中（比如Vue、React），<strong>脚本往往比HTML页面更“重”</strong>，处理时间需要更长；所以会造成页面的解析阻塞，在脚本下载、执行完成之前，<strong>用户在界面上什么都看不到</strong></p><h3 id="4-1-defer-属性"><a href="#4-1-defer-属性" class="headerlink" title="4.1 defer 属性"></a>4.1 defer 属性</h3><ul><li><p>告诉浏览器不要等待脚本下载，而<strong>继续解析</strong>HTML，构建DOM Tree</p></li><li><p>如果脚本提前下载好了，它会等待<strong>DOM Tree构建完成后</strong>，<strong>DOMContentLoaded事件之前</strong>先执行defer中的代码</p></li><li><p>多个带defer的脚本是可以保持正确的顺序执行的</p></li><li><p>从性能的角度最好放到head中</p></li><li><p>defer对于非外部引用的script元素，无效</p></li></ul><h3 id="4-2-async-属性"><a href="#4-2-async-属性" class="headerlink" title="4.2 async 属性"></a>4.2 async 属性</h3><ul><li>async 属性也能让脚本不阻塞页面（与 defer 类似）；</li><li>async 脚本<strong>不能保证顺序</strong>，它是独立下载、独立运行，不会等待其他脚本；</li><li>async <strong>不能保证在DOMContentLoaded之前或者之后执行</strong></li></ul><ol><li>defer 通常用于需要在文档解析后操作DOM的JavaScript代码，并且对<strong>多个script文件</strong>有顺序要求的；</li><li>async 通常用于<strong>独立的脚本</strong>，对其他脚本，甚至DOM没有依赖的</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>浏览器输入一个URL到页面显示的过程：</p><ol><li>首先通过DNS服务器进行<strong>域名解析</strong>，解析出对应的<strong>IP地址</strong>，然后从ip地址对应的主机发送http请求，<strong>获取对应的静态资源</strong></li><li>默认情况服务器会<strong>返回index.html文件</strong></li><li>然后浏览器内核开始<strong>解析HTML</strong><ol><li>首先会解析对应的html 生成<strong>DOM Tree</strong></li><li>解析过程中，如果遇到css的link标签则会下载对应的css文件（下载css文件和生成DOM树同时进行）</li><li>下载完对应的css文件后会进行css解析 生成<strong>CSSOM</strong>( CSS object model)</li><li>当DOM Tree和CSSTree都解析完成之后 会进行合并用来生成<strong>Render Tree</strong>(渲染树)</li><li>初步生成的渲染树会显示节点以及部分样式，但是并不表示每个节点的尺寸、位置信息。于是进行<strong>布局</strong>来生成渲染树中节点的宽度、高度、位置信息</li><li>经过Layout之后，浏览器内核将布局时的每个frame转为屏幕上的每个像素点、将每个节点<strong>绘制</strong>到屏幕上</li></ol></li></ol><h1 id="二、JavaScript-的运行原理"><a href="#二、JavaScript-的运行原理" class="headerlink" title="二、JavaScript 的运行原理"></a>二、JavaScript 的运行原理</h1><h2 id="1-深入-V8-引擎原理"><a href="#1-深入-V8-引擎原理" class="headerlink" title="1. 深入 V8 引擎原理"></a>1. 深入 V8 引擎原理</h2><p>浏览器内核是由两部分组成的，以webkit为例：</p><ul><li>WebCore：负责HTML解析、布局、渲染等等相关的工作； </li><li>JavaScriptCore：解析、执行JavaScript代码；</li></ul><p>另外一个强大的JavaScript引擎就是V8引擎</p><h3 id="1-1-V8-引擎的架构"><a href="#1-1-V8-引擎的架构" class="headerlink" title="1.1 V8 引擎的架构"></a>1.1 V8 引擎的架构</h3><p><img src="0f9e25fdf7924e4eb68677e6d0b9a876.png" alt="在这里插入图片描述"></p><ul><li><strong>Parse 模块</strong>会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码；</li><li><strong>Ignition</strong> 是一个解释器，会将AST转换成ByteCode（字节码） <ul><li>同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；</li><li>如果函数只调用一次，Ignition会解释执行ByteCode；</li></ul></li><li><strong>TurboFan</strong> 是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；<ul><li>如果一个函数被<strong>多次调用</strong>，那么就会被标记为<strong>热点函数</strong>，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能；</li><li>但是，机器码实际上也会被<strong>还原为ByteCode</strong>，这是因为如果后续执行函数的过程中，<strong>类型发生了变化</strong>（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码</li></ul></li></ul><p>在将JavaScript代码转换成AST（抽象语法树）的过程中：<br><img src="ee564add67e449e99328e27e62b6a575.png" alt="在这里插入图片描述"></p><p>词法分析：</p><ul><li>将对应的每一行的代码的字节流分解成<strong>有意义的代码块</strong>，代码块被称为词法单元 </li><li>token是记号化（tokenization）的缩写</li><li>词法分析器，也叫扫描器（scanner）</li></ul><p>语法分析：</p><ul><li>将对应的tokens<strong>分析成一个元素逐级嵌套的树</strong>， 这个树称之为抽象语法树</li><li>语法分析器也可以称之为 parser</li></ul><p><img src="a5a98f84e6e64685b6b824b3042e173c.png" alt="在这里插入图片描述"></p><h2 id="2-深入-JS-执行原理"><a href="#2-深入-JS-执行原理" class="headerlink" title="2. 深入 JS 执行原理"></a>2. 深入 JS 执行原理</h2><h2 id="2-1-执行全局代码"><a href="#2-1-执行全局代码" class="headerlink" title="2.1 执行全局代码"></a>2.1 执行全局代码</h2><h3 id="2-1-1-初始化全局对象"><a href="#2-1-1-初始化全局对象" class="headerlink" title="2.1.1 初始化全局对象"></a>2.1.1 初始化全局对象</h3><p>js引擎在<strong>执行代码之前</strong>，会在堆内存中创建一个全局对象：Global Object（GO）</p><ul><li>该对象<strong>所有的作用域</strong>都可以访问；</li><li>里面会包含<code>Date、Array、String、Number、setTimeout、setInterval</code>等等； </li><li>其中还有一个<code>window属性</code>指向自己</li></ul><p><img src="1db611d6d3e8491c88f857aa02095847.png" alt="在这里插入图片描述"></p><h3 id="2-1-2-执行上下文"><a href="#2-1-2-执行上下文" class="headerlink" title="2.1.2 执行上下文"></a>2.1.2 执行上下文</h3><p>js引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），它是用于<strong>执行代码的调用栈</strong>。</p><p>全局的代码块为了执行会构建一个 <strong>Global Execution Context（GEC）</strong>； GEC会被放入到ECS中执行，其中内容包括：</p><ul><li>==第一部分：==在代码执行前，在parser转成AST的过程中，会将<strong>全局定义的变量、函数</strong>等加入到Global Object中，但是并<strong>不会赋值</strong><ul><li>这个过程也称之为变量的作用域提升（hoisting）</li></ul></li><li>==第二部分：==在代码执行中，对变量<strong>赋值</strong>，或者<strong>执行其他的函数</strong></li></ul><h3 id="2-1-3-认识VO对象"><a href="#2-1-3-认识VO对象" class="headerlink" title="2.1.3 认识VO对象"></a>2.1.3 认识VO对象</h3><p>每一个执行上下文会<strong>关联一个VO</strong>（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中。</p><p>当全局代码被执行的时候，VO就是GO对象</p><p><em><strong>全局代码执行过程（执行前）的内存示意图：</strong></em></p><p><img src="b2d835697e3c4c96957f1cea3e1cd892.png" alt="在这里插入图片描述"></p><p>只有·会额外创建一个对象，<code>obj</code>、<code>var bar = function{}</code>这些在此阶段都视作变量</p><p><em><strong>全局代码执行过程（执行后）的内存示意图：</strong></em></p><p><img src="3427549525974752a91ceed1d7e5d215.png" alt="在这里插入图片描述"></p><h2 id="2-2-执行函数代码"><a href="#2-2-执行函数代码" class="headerlink" title="2.2 执行函数代码"></a>2.2 执行函数代码</h2><p>在执行的过程中<strong>执行到一个函数</strong>时，就会根据函数体创建一个<strong>函数执行上下文</strong>（Functional Execution Context，简称FEC）， 并且压入到EC Stack中。</p><p>因为每个执行上下文都会关联一个VO，那么函数执行上下文关联的VO是什么呢？ </p><ul><li>当进入一个函数执行上下文时，会<strong>创建一个AO对象</strong>（Activation Object）；</li><li>这个AO对象会使用 <code>arguments</code> 作为初始化，并且初始值是传入的参数；</li><li>这个AO对象会作为执行上下文的VO来存放变量的初始化</li></ul><p><em><strong>函数的执行过程（执行前）的内存示意图：</strong></em></p><p><img src="b8308d11fa9549e9a3df51d093265df3.png" alt="在这里插入图片描述"></p><p><em><strong>函数的执行过程（执行）的内存示意图：</strong></em></p><p><img src="feeeaa584db24dd6bb7680da9ec2fe23.png" alt="在这里插入图片描述"></p><h4 id="函数代码多次调用"><a href="#函数代码多次调用" class="headerlink" title="函数代码多次调用"></a>函数代码多次调用</h4><ol><li><p>foo第一次执行123：<br><img src="2013e004699343019f42c76993ff0a72.png" alt="在这里插入图片描述"></p></li><li><p>foo第二次执行321：<br><img src="9d98ff327fff46b2939c8129e43f03b8.png" alt="在这里插入图片描述"></p></li></ol><h4 id="函数代码相互调用"><a href="#函数代码相互调用" class="headerlink" title="函数代码相互调用"></a>函数代码相互调用</h4><ol><li><p>foo和bar函数执行：<br><img src="4492c9428f5349ba9b393aa8a653dcc6.png" alt="在这里插入图片描述"></p></li><li><p>bar函数执行完毕：<br><img src="8abfd257637d4b478ce0db5086e9b871.png" alt="在这里插入图片描述"></p></li><li><p>foo函数执行完毕：<br><img src="7496c6d7947c437a8a2a5d8d71a1b810.png" alt="在这里插入图片描述"></p></li></ol><h2 id="2-3-作用域、作用域链"><a href="#2-3-作用域、作用域链" class="headerlink" title="2.3 作用域、作用域链"></a>2.3 作用域、作用域链</h2><p>当进入到一个执行上下文时，执行上下文也会关联一个作用域链（Scope Chain） </p><ul><li><strong>作用域链是一个对象列表</strong>，用于变量标识符的求值；</li><li>当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象；</li></ul><h4 id="函数变量的查找过程"><a href="#函数变量的查找过程" class="headerlink" title="函数变量的查找过程"></a>函数变量的查找过程</h4><ol><li><p>函数有自己的message<br><img src="30255ac8392845a6a14432d9d11f3338.png" alt="在这里插入图片描述"></p></li><li><p>函数没有自己的message<br><img src="ea5f6c5937fc47ae9aff5d8086d2a01d.png" alt="在这里插入图片描述"></p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var message = "Global Message"function foo() {console.log(message)}foo()var obj = {name: "obj",bar: function () {var message = "bar message"foo()}}obj.bar() // Global Message 函数在刚创建时就已经形成了自己的作用域链，向上查找时为window</code></pre><h4 id="函数代码多层嵌套"><a href="#函数代码多层嵌套" class="headerlink" title="函数代码多层嵌套"></a>函数代码多层嵌套</h4><p><img src="e922cb9c982c49c7b4d68852fadbb50f.png" alt="在这里插入图片描述"></p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var n = 100function foo1() {console.log(n) //100 作用域链在定义时已经形成}function foo2() {var n = 200console.log(n) // 200foo1()}foo2()</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var n = 100function foo() {console.log(n) // undefinedreturnvar n = 200 // 已经定义}foo()</code></pre><h1 id="三、JS-的内存管理和闭包"><a href="#三、JS-的内存管理和闭包" class="headerlink" title="三、JS 的内存管理和闭包"></a>三、JS 的内存管理和闭包</h1><h2 id="1-内存管理的理解"><a href="#1-内存管理的理解" class="headerlink" title="1. 内存管理的理解"></a>1. 内存管理的理解</h2><p>内存的管理都会有如下的生命周期：</p><ul><li><p>第一步：分配申请你需要的内存（申请）；</p></li><li><p>第二步：使用分配的内存（存放一些东西，比如对象等）；</p></li><li><p>第三步：不需要使用时，对其进行释放</p></li><li><p>JS对于<strong>原始数据类型</strong>内存的分配会在执行时， 直接在<strong>栈空间</strong>进行分配；</p></li><li><p>JS对于<strong>复杂数据类型</strong>内存的分配会在<strong>堆内存</strong>中开辟一块空间，并且将这块空间的指针返回值 变量引用；</p></li></ul><h2 id="2-垃圾回收机制GC算法"><a href="#2-垃圾回收机制GC算法" class="headerlink" title="2. 垃圾回收机制GC算法"></a>2. 垃圾回收机制GC算法</h2><h3 id="2-1-引用计数（了解）"><a href="#2-1-引用计数（了解）" class="headerlink" title="2.1 引用计数（了解）"></a>2.1 引用计数（了解）</h3><ul><li>当一个对象有一个引用指向它时，那么这个对象的引用就+1； </li><li>当一个对象的引用为0时，这个对象就可以被销毁掉；</li></ul><p>这个算法有一个很大的弊端就是会产生<strong>循环引用</strong></p><h3 id="2-2-标记清除-可达性"><a href="#2-2-标记清除-可达性" class="headerlink" title="2.2 标记清除(可达性)"></a>2.2 标记清除(可达性)</h3><ul><li>标记清除的核心思路是<strong>可达性</strong></li><li>这个算法是设置一个<strong>根对象</strong>，垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象<br><img src="cd85810fc9b5402a8a0f08760bdae93f.png" alt="在这里插入图片描述"></li></ul><h3 id="2-3-其他算法补充"><a href="#2-3-其他算法补充" class="headerlink" title="2.3 其他算法补充"></a>2.3 其他算法补充</h3><p>V8引擎为了进行更好的优化，它在算法的实现细节上也结合一些其他的算法：</p><ul><li>标记整理<ul><li>回收期间同时会将保留的存储对象<strong>搬运汇集到连续的内存空间</strong>，从而整合空闲空间，<strong>避免内存碎片化</strong></li></ul></li></ul><ul><li>分带处理—— 对象被分成两组：“新的”和“旧的”<ul><li>许多对象出现，完成它们的工作并很快死去，它们可以<strong>很快被清理</strong></li><li>那些长期存活的对象会变得“老旧”，而且<strong>被检查的频次也会减少</strong></li></ul></li><li>增量收集<ul><li>如果有许多对象，并且我们<strong>试图一次遍历并标记整个对象集</strong>，则可能需要一些时间，并在执行过程中带来<strong>明显的延迟</strong>。</li><li>所以引擎试图将垃圾收集工作<strong>分成几部分</strong>逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟</li></ul></li><li>闲时收集<ul><li>垃圾收集器只会在 <strong>CPU 空闲时</strong>尝试运行，以减少可能对代码执行的影响</li></ul></li></ul><h2 id="3-闭包的概念理解"><a href="#3-闭包的概念理解" class="headerlink" title="3. 闭包的概念理解"></a>3. 闭包的概念理解</h2><p>一个<strong>函数和对其周围状态</strong>（词法环境）的引用捆绑在一起，这样的组合就是闭包（closure）</p><ul><li>一个普通的函数function，如果它可以访问外层作用域的自由变量，那么<strong>这个函数和周围环境就是一个闭包</strong>；<ul><li>从广义的角度来说：JavaScript中的函数都是闭包</li><li>从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包</li></ul></li></ul><h3 id="3-1-闭包的执行过程"><a href="#3-1-闭包的执行过程" class="headerlink" title="3.1 闭包的执行过程"></a>3.1 闭包的执行过程</h3><ol><li><p>第一次调用createAdder<br><img src="124b70afbf8f4d76a7da1dd139ed9fbf.png" alt="在这里插入图片描述"></p></li><li><p>执行adder5<br><img src="4cec1b7a21a44ca984ef8f77ac4e8985.png" alt="在这里插入图片描述"></p></li><li><p>adder5执行完成<br><img src="d7fa491507a24ed7990b14e40d288981.png" alt="在这里插入图片描述"></p></li><li><p>第二次调用createAdder<br><img src="c5d1d25052524d7b8323cd63557ceee0.png" alt="在这里插入图片描述"></p></li></ol><h3 id="3-2-闭包的内存泄漏和释放"><a href="#3-2-闭包的内存泄漏和释放" class="headerlink" title="3.2 闭包的内存泄漏和释放"></a>3.2 闭包的内存泄漏和释放</h3><ul><li>在上面的案例中，如果后续我们不再使用<code>adder8</code>函数了，那么该函数对象应该要被销毁掉，并且其引用着的父作用域AO也应该被销毁掉；</li><li>但是目前因为在全局作用域下<code>adder8</code>变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引用，所以最终会造成这些<strong>内存都是无法被释放</strong>的；</li><li>所以我们经常说的闭包会造成<strong>内存泄露</strong>，其实就是刚才的引用链中的所有对象都是无法释放的；</li></ul><p>此时，将 <code>adder8 = null</code> 即可释放内存<br><img src="56609109b0a14423bae037d6b3bc4f0a.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级（一）函数 this 指向</title>
      <link href="/2023/01/13/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0-this-%E6%8C%87%E5%90%91/"/>
      <url>/2023/01/13/JavaScript-%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89%E5%87%BD%E6%95%B0-this-%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一-this-的绑定规则"><a href="#一-this-的绑定规则" class="headerlink" title="一. this 的绑定规则"></a>一. this 的绑定规则</h1><h2 id="1-绑定规则"><a href="#1-绑定规则" class="headerlink" title="1. 绑定规则"></a>1. 绑定规则</h2><h3 id="1-1-默认绑定"><a href="#1-1-默认绑定" class="headerlink" title="1.1 默认绑定"></a>1.1 默认绑定</h3><p>什么情况下使用默认绑定呢？独立函数调用。 </p><p><strong>独立的函数调用</strong>：函数没有被绑定到某个对象上进行调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = {name: 'why',bar: function () {console.log(this);}}var baz = obj.bar;baz();// 独立函数调用，输出仍是windowfunction fool(fn) {fn();}fool(obj.bar);// 高阶函数,window</code></pre><h3 id="1-2-隐式绑定"><a href="#1-2-隐式绑定" class="headerlink" title="1.2 隐式绑定"></a>1.2 隐式绑定</h3><p>隐式绑定的调用位置中，是通过<strong>某个对象发起的函数调用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo() {console.log(this);}var obj = {bar: foo}obj.bar();// obj</code></pre><h3 id="1-3-显式绑定"><a href="#1-3-显式绑定" class="headerlink" title="1.3 显式绑定"></a>1.3 显式绑定</h3><ul><li><p>隐式绑定有一个前提条件： </p><ul><li>必须在<strong>调用的对象内部有一个对函数的引用</strong>（比如一个属性）；</li><li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li><li>正是通过这个引用，间接的将this绑定到了这个对象上；</li></ul></li><li><p>如果我们不希望在 <strong>对象内部</strong> 包含这个<strong>函数的引用</strong>，同时又希望在这个对象上进行强制调用，该怎么做呢？ </p></li><li><p>JavaScript所有的函数都可以使用<code>call</code>和<code>apply</code>方法</p></li></ul><h4 id="1-3-1-apply-和-call"><a href="#1-3-1-apply-和-call" class="headerlink" title="1.3.1 apply 和 call"></a>1.3.1 apply 和 call</h4><ul><li><strong>第一个参数</strong>是相同的，要求传入一个对象 <ul><li>在调用这个函数时，会将this绑定到这个传入的对象上。</li></ul></li><li>后面的参数，apply为<strong>数组</strong>，call为<strong>参数列表</strong><ul><li><code>foo.call('call', 'kobe', 30, 1.9);</code></li><li><code>foo.apply('apply', ['james', 25, 2.0]);</code></li></ul></li></ul><h4 id="1-3-2-bind"><a href="#1-3-2-bind" class="headerlink" title="1.3.2 bind"></a>1.3.2 bind</h4><p>如果我们希望一个函数<strong>总是显式绑定到一个对象上</strong>，可以怎么做呢？</p><ul><li>使用bind方法，bind() 方法创建一个新的<strong>绑定函数</strong>（bound function，BF）<ul><li>绑定函数是一个 exotic function object（<strong>怪异函数对象</strong>，ECMAScript 2015 中的术语）</li></ul></li><li>在 bind() 被调用时，这个新函数的 <strong>this 被指定为 bind() 的第一个参数</strong>，而其余参数将作为新函数的参数，供调用时使用（传参不经常使用，阅读性差）。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(name, age, height, address) {console.log('foo函数：', this);console.log(name, age, height, address);}obj = {name: 'why'}var bar = foo.bind(obj, 'kobe', 30, 1.9);bar('T2 Stress');bar();bar();bar();bar();</code></pre><h3 id="1-4-new-绑定"><a href="#1-4-new-绑定" class="headerlink" title="1.4 new 绑定"></a>1.4 new 绑定</h3><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</p><p>使用new关键字来调用函数，会执行如下的操作： </p><ol><li>创建一个全新的对象； </li><li>这个新对象会被执行prototype连接； </li><li>这个新对象会绑定到函数调用的this上（<strong>this的绑定在这个步骤完成</strong>）；</li><li>如果函数没有返回其他对象，表达式会返回这个新对象；</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Fun(name) {this.name = name;console.log(this);}var a = new Fun('ldh'); // 实例Fun对象</code></pre><h2 id="2-内置函数的规则"><a href="#2-内置函数的规则" class="headerlink" title="2. 内置函数的规则"></a>2. 内置函数的规则</h2><ul><li>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。<ul><li>这些内置函数会要求我们传入另外一个函数；</li><li>我们自己并不会显式调用这些函数，而是 <strong>JavaScript 内部或者第三方库内部会帮助我们执行</strong>；</li></ul></li><li>这些函数中的this绑定规则一般都基于经验<ul><li>setTimeout 绑定 window</li><li>div的点击绑定点击的那个div</li><li>数组的forEach绑定</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">var names = ['abc', '123', 'wsd'];names.forEach(function () {console.log(this);}, 'name'); // 绑定三次name字符串对象String</code></pre><h2 id="3-规则的优先级"><a href="#3-规则的优先级" class="headerlink" title="3. 规则的优先级"></a>3. 规则的优先级</h2><ul><li>new &gt; bind &gt; apply/call &gt; 隐式绑定 &gt; 默认绑定</li></ul><ul><li>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</li></ul><h2 id="4-规则之外的情况"><a href="#4-规则之外的情况" class="headerlink" title="4. 规则之外的情况"></a>4. 规则之外的情况</h2><h3 id="4-1-忽略显式绑定"><a href="#4-1-忽略显式绑定" class="headerlink" title="4.1 忽略显式绑定"></a>4.1 忽略显式绑定</h3><p>如果在显式绑定中，我们传入一个<code>null</code>或者<code>undefined</code>，那么这个显式绑定会被忽略，<strong>使用默认绑定</strong></p><h3 id="4-2-间接函数引用-了解"><a href="#4-2-间接函数引用-了解" class="headerlink" title="4.2 间接函数引用(了解)"></a>4.2 间接函数引用(了解)</h3><p>创建一个函数的 <strong>间接引用</strong>，这种情况使用默认绑定规则</p><p><code>(obj2.foo = obj1.foo)();</code><br>上面函数赋值给 obj2 的为 foo 函数，因此返回foo，函数立即调用 foo</p><h1 id="二-箭头函数的使用"><a href="#二-箭头函数的使用" class="headerlink" title="二. 箭头函数的使用"></a>二. 箭头函数的使用</h1><p>箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：</p><ul><li>箭头函数<strong>不会绑定this、arguments属性</strong></li><li>箭头函数<strong>不能作为构造函数来使用</strong>（不能和new一起来使用，会抛出错误）</li></ul><h2 id="1-箭头函数的写法"><a href="#1-箭头函数的写法" class="headerlink" title="1. 箭头函数的写法"></a>1. 箭头函数的写法</h2><h3 id="1-1-基本写法"><a href="#1-1-基本写法" class="headerlink" title="1.1 基本写法"></a>1.1 基本写法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(函数的参数) =&gt; {函数的执行体}</code></pre><h3 id="1-2-优化写法"><a href="#1-2-优化写法" class="headerlink" title="1.2 优化写法"></a>1.2 优化写法</h3><ul><li><p>只有一个参数时，可以省略<code>()</code></p></li><li><p>只有一行代码时，可以省略<code>{}</code></p><ul><li>这行代码的返回值会作为<strong>箭头函数的默认返回值</strong>，所以可以省略return</li></ul></li></ul><ul><li><p>如果函数执行体<strong>返回一个对象</strong>, 在省略<code>{}</code>的时候, 对象必须使用<code>()</code>包裹</p><ul><li><code>() =&gt; ({ name: 'why' })</code></li></ul></li></ul><h2 id="2-箭头函数中的this"><a href="#2-箭头函数中的this" class="headerlink" title="2. 箭头函数中的this"></a>2. 箭头函数中的this</h2><p>箭头函数不使用this的四种标准规则（也就是<strong>不绑定this</strong>），而是根据外层作用域来决定this。</p><p>this的查找规则:</p><ul><li>去<strong>上层作用域</strong>中查找this</li><li>直到找到全局this</li></ul><h2 id="3-箭头函数this应用"><a href="#3-箭头函数this应用" class="headerlink" title="3. 箭头函数this应用"></a>3. 箭头函数this应用</h2><p>案例：模拟网络请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//网络请求工具函数function request(url, callbackFn) {var results = ['abc', '123', 'wsd'];// 用户请求这些数据callbackFn(results);// 回调传参}//实际操作的位置var obj = {name: [],network: function () {// 1.早期做法// var _this = this;// request('/names', function (res) {//_this.name = [].concat(res);// })// 2.箭头函数写法request('/names/www', (res) =&gt; {this.name = [].concat(res);// this 查找到network函数的this})}}obj.network();console.log(obj);</code></pre><h1 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h1><p>面试题1</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name = "window";var person = {name: "person",sayName: function () {console.log(this.name);}};function sayName() {var sss = person.sayName;sss(); // windowperson.sayName(); // person(person.sayName)(); // person(b = person.sayName)(); // 间接函数引用，返回一个独立的函数，然后再调用 window}sayName();</code></pre><p>面试题2</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name = 'window'var person1 = {name: 'person1',foo1: function () {console.log(this.name)},foo2: () =&gt; console.log(this.name),foo3: function () {return function () {console.log(this.name) // 返回一个函数}},foo4: function () { // 1.this为person1 2.this为person2 3.this为person1return () =&gt; {console.log(this.name)}}}var person2 = { name: 'person2' }person1.foo1(); // 隐式绑定 person1person1.foo1.call(person2); // 显式绑定 person2person1.foo2(); // windowperson1.foo2.call(person2); // windowperson1.foo3()(); // 默认绑定 windowperson1.foo3.call(person2)(); // 默认绑定 windowperson1.foo3().call(person2); // 显式绑定 person2person1.foo4()(); // person1person1.foo4.call(person2)(); // person2person1.foo4().call(person2); // person1</code></pre><p>面试题3</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name = 'window'function Person(name) {this.name = name;//console.log(this); //此时才与new绑定相关this.foo1 = function () {console.log(this.name);};this.foo2 = () =&gt; console.log(this.name);this.foo3 = function () {return function () {console.log(this.name);}};this.foo4 = function () {return () =&gt; {console.log(this.name);}};}var person1 = new Person('person1')var person2 = new Person('person2')person1.foo1() // 隐式绑定 person1person1.foo1.call(person2) // 显式绑定 person2person1.foo2() // 上层作用域function Person(name){} 查找 person1person1.foo2.call(person2) // call没有起效，仍去上层找 person1person1.foo3()() // 默认绑定 windowperson1.foo3.call(person2)() // 默认绑定 windowperson1.foo3().call(person2) // 显式绑定 person2person1.foo4()() // 上层作用域查找 person1（隐式绑定）person1.foo4.call(person2)() // 上层作用域查找 person2（显式绑定）person1.foo4().call(person2) // 上层作用域查找 person1（隐式绑定）</code></pre><p>面试题4</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name = 'window'function Person(name) {this.name = namethis.obj = {name: 'obj',foo1: function () {return function () {console.log(this.name)}},foo2: function () {return () =&gt; {console.log(this.name)}}}}var person1 = new Person('person1')var person2 = new Person('person2')person1.obj.foo1()() // 默认绑定 windowperson1.obj.foo1.call(person2)() // 默认绑定 windowperson1.obj.foo1().call(person2) // 显式绑定 person2person1.obj.foo2()() // 上层作用域查找 隐式绑定objperson1.obj.foo2.call(person2)() // 上层作用域查找 显式绑定person2person1.obj.foo2().call(person2) // 显式绑定无效，上层作用域查找 obj</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 进阶（六）PC 端网页特效、本地存储</title>
      <link href="/2023/01/12/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%85%AD%EF%BC%89PC-%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <url>/2023/01/12/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%85%AD%EF%BC%89PC-%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、元素偏移量-offset-系列"><a href="#一、元素偏移量-offset-系列" class="headerlink" title="一、元素偏移量 offset 系列"></a>一、元素偏移量 offset 系列</h1><h2 id="1-offset-概述"><a href="#1-offset-概述" class="headerlink" title="1. offset 概述"></a>1. offset 概述</h2><p><code>offset</code> 翻译过来就是偏移量，我们使用 <code>offset</code> 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><ul><li>获得元素距离<strong>带有定位父元素</strong>的位置</li><li>获得元素自身的大小（宽度高度）</li><li>注意：返回的数值都<strong>不带单位</strong></li></ul><p>offset 系列常用属性：</p><p><img src="https://img-blog.csdnimg.cn/8b74367246224e75af8ec56639864e1b.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d4db7830f6414c1da9e87b7cc2296e77.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-offset-与-style-区别"><a href="#2-offset-与-style-区别" class="headerlink" title="2. offset 与 style 区别"></a>2. offset 与 style 区别</h2><table><thead><tr><th>offset</th><th>style</th></tr></thead><tbody><tr><td><code>offset</code> 可以得到任意样式表中的样式值</td><td><code>style</code> 只能得到行内样式表（内嵌样式表等不行）中的样式值</td></tr><tr><td><code>offset</code> 系列获得的数值是没有单位的</td><td><code>style.width</code> 获得的是带有单位的字符串</td></tr><tr><td><code>offsetWidth</code> 包含 <code>padding+border+width</code></td><td><code>style.width</code> 获得不包含 <code>padding</code> 和 <code>border</code> 的值</td></tr><tr><td><code>offsetWidth</code> 等属性是只读属性，只能获取不能赋值</td><td><code>style.width</code> 是可读写属性，可以获取也可以赋值</td></tr><tr><td>所以，我们想要<strong>获取元素大小位置</strong>，用 <code>offset</code>更合适</td><td>所以，我们想要<strong>给元素更改值</strong>，则需要用 <code>style</code> 改变</td></tr></tbody></table><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><h3 id="3-1-获取鼠标在盒子内部的坐标"><a href="#3-1-获取鼠标在盒子内部的坐标" class="headerlink" title="3.1 获取鼠标在盒子内部的坐标"></a>3.1 获取鼠标在盒子内部的坐标</h3><ol><li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。<ol><li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li><li>其次得到盒子在页面中的距离( box.offsetLeft, box.offsetTop)</li><li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到鼠标在盒子内的坐标</li></ol></li><li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件mousemove</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script&gt;var box = document.querySelector('.box');box.addEventListener('mousemove', function (e) {var x = e.pageX - this.offsetLeft;var y = e.pageY - this.offsetTop;this.innerHTML = 'x的坐标为' + x + ' y的坐标为' + y;})&lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="3-2-模态框拖拽"><a href="#3-2-模态框拖拽" class="headerlink" title="3.2 模态框拖拽"></a>3.2 模态框拖拽</h3><ol><li>点击弹出层， 会弹出模态框， 并且显示灰色半透明的遮挡层。 </li><li>点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。 </li><li>鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。 </li><li>鼠标松开，可以停止拖动模态框移动。</li></ol><ul><li>在页面中拖拽的原理： 鼠标按下mousedown并且移动mousemove，之后松开鼠标mouseup</li><li>鼠标按下触发的事件源是 最上面一行，就是 id 为 title</li><li>拖拽过程: <strong>鼠标移动过程中</strong>，获得<strong>最新的值</strong>赋值给模态框的left和top值， 这样模态框可以跟着鼠标走了<ul><li>鼠标的坐标 - 鼠标在盒子内的坐标， 才是模态框真正的位置。<ul><li>==鼠标按下==，我们要得到<strong>鼠标在盒子的坐标</strong>。 </li><li>==鼠标移动==，就让<strong>模态框的坐标</strong>设置为 ： 鼠标坐标 - 盒子坐标即可，注意移动事件写到按下事件里面。</li><li>==鼠标松开==，就停止拖拽，就是可以让鼠标移动事件解除</li></ul></li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1. 鼠标按下时，获取鼠标在盒子中的位置title.addEventListener('mousedown', function (e) {var x = e.pageX - login.offsetLeft;var y = e.pageY - login.offsetTop;//2. 鼠标移动过程中，获取鼠标实时位置，盒子跟随移动document.addEventListener('mousemove', move);function move(e) {login.style.left = e.pageX - x + 'px';login.style.top = e.pageY - y + 'px';}//3. 鼠标弹起，移动事件解除document.addEventListener('mouseup', function () {document.removeEventListener('mousemove', move);})})</code></pre><h3 id="3-3-仿京东放大镜"><a href="#3-3-仿京东放大镜" class="headerlink" title="3.3 仿京东放大镜"></a>3.3 仿京东放大镜</h3><p>整个案例可以分为三个功能模块：</p><ol><li>鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能</li><li>黄色的遮挡层跟随鼠标功能。</li><li>移动黄色遮挡层，大图片跟随移动功能。</li></ol><ul><li>==黄色的遮挡层跟随鼠标功能==<ul><li>把鼠标坐标给遮挡层不合适。因为遮挡层坐标<strong>以父盒子为准</strong>。</li><li>首先是获得鼠标在盒子的坐标。</li><li>之后把数值给遮挡层做为left 和top值。</li><li>发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</li></ul></li><li>==遮挡层不能超出小图片盒子范围==<ul><li>如果小于零，就把坐标设置为0</li><li>如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离<ul><li>遮挡层的最大移动距离：小图片盒子宽度 - 遮挡层盒子宽度</li></ul></li></ul></li><li>==移动黄色遮挡层，大图片跟随移动功能==<ul><li>遮挡层移动距离 / 遮挡层最大移动距离 = 大图片移动距离 / 大图片最大移动距离<ul><li>大图片移动距离 = 遮挡层移动距离* 大图片最大移动距离 / 遮挡层最大移动距离</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">// 1. 鼠标移动，mask跟随移动preview_img.addEventListener('mousemove', function (e) {var x = e.pageX - this.offsetLeft;var y = e.pageY - this.offsetTop;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 遮挡层移动距离var maskX = x - mask.offsetWidth / 2; // 再减去盒子自身宽度的一半var maskY = y - mask.offsetHeight / 2; // 再减去盒子自身高度的一半// 遮挡层的最大移动距离var maskMaxX = this.offsetWidth - mask.offsetWidth;var maskMaxY = this.offsetHeight - mask.offsetHeight;// 大图片最大移动距离var bigMaxX = bigImg.offsetWidth - big.offsetWidth;var bigMaxY = bigImg.offsetHeight - big.offsetHeight;// 限制mask的移动范围在图片框内if (maskX &lt;= 0) {maskX = 0;} else if (maskX &gt;= maskMaxX) {maskX = maskMaxX;}if (maskY &lt;= 0) {maskY = 0;} else if (maskY &gt;= maskMaxY) {maskY = maskMaxY;}mask.style.left = maskX + 'px'; // 赋坐标值给 maskmask.style.top = maskY + 'px';// 3. 鼠标移动，大图跟随移动// 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离var bigX = maskX * bigMaxX / maskMaxX;var bigY = maskY * bigMaxY / maskMaxY;bigImg.style.left = -bigX + 'px';bigImg.style.top = -bigY + 'px';})</code></pre><h1 id="二、元素可视区-client-系列"><a href="#二、元素可视区-client-系列" class="headerlink" title="二、元素可视区 client 系列"></a>二、元素可视区 client 系列</h1><h2 id="1-系列属性"><a href="#1-系列属性" class="headerlink" title="1. 系列属性"></a>1. 系列属性</h2><p><code>client</code> 翻译过来就是客户端，我们使用 <code>client</code> 系列的相关属性来获取元素可视区的相关信息。通过<code>client</code> 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><table><thead><tr><th>client系列属性</th><th>作用</th></tr></thead><tbody><tr><td><code>element.clientTop</code></td><td>返回元素上边框的大小</td></tr><tr><td><code>element.clientLeft</code></td><td>返回元素左边框的大小</td></tr><tr><td><code>element.clientWidth</code></td><td>返回自身包括 padding、内容区的宽度，<strong>不含边框</strong>，返回数值不带单位</td></tr><tr><td><code>element.clientHeight</code></td><td>返回自身包括 padding、内容区的高度，<strong>不含边框</strong>，返回数值不带单位</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/c3646a991d8f42d19213f0c0dbde6f7f.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2. 案例"></a>2. 案例</h2><p>淘宝 flexible.js 源码分析</p><h3 id="2-1-立即执行函数"><a href="#2-1-立即执行函数" class="headerlink" title="2.1 立即执行函数"></a>2.1 立即执行函数</h3><p>立即执行函数是指函数定义好后，<strong>不需要调用直接执行</strong>。即一引入 JS 文件，则该函数自动执行。</p><p>语法：<code>(function() {})()</code> 或者 <code>(function(){}())</code></p><p>主要作用： </p><ul><li>创建一个独立的作用域</li><li>避免了命名冲突问题</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;&lt;script&gt;(function (a, b) {console.log(a + b);})(1, 2);(function sum(a, b) {console.log(a + b);}(2, 3));&lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="2-2-pageShow-事件"><a href="#2-2-pageShow-事件" class="headerlink" title="2.2 pageShow 事件"></a>2.2 pageShow 事件</h3><p>pageShow 是加载页面功能</p><p>下面三种情况都会刷新页面都会触发<code>load</code> 事件。</p><ol><li>a标签的超链接</li><li>F5或者刷新按钮（强制刷新）</li><li>前进后退按钮</li></ol><p>但是<strong>火狐</strong>中，有个特点，有个“<strong>往返缓存</strong>”，这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。<br>所以此时<strong>后退按钮不能刷新页面</strong>。</p><ul><li>此时可以使用 <code>pageshow</code> 事件来触发。这个事件在页面显示时触发，<strong>无论页面是否来自缓存</strong>。注意这个事件给 <code>window</code> 添加。</li><li>在重新加载页面中，<code>pageshow</code> 会在 <code>load</code> 事件触发后触发；根据事件对象中的 <code>persisted</code> 来判断是否是缓存中的页面触发的<code>pageshow</code> 事件（为true 则是缓存取过来的）。</li></ul><h1 id="三、元素-scroll-系列属性"><a href="#三、元素-scroll-系列属性" class="headerlink" title="三、元素 scroll 系列属性"></a>三、元素 scroll 系列属性</h1><h2 id="1-系列属性-1"><a href="#1-系列属性-1" class="headerlink" title="1. 系列属性"></a>1. 系列属性</h2><p><code>scroll</code> 翻译过来就是滚动的，我们使用 <code>scroll</code> 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><table><thead><tr><th>scroll系列属性</th><th>作用</th></tr></thead><tbody><tr><td><code>element.scrollTop</code></td><td>返回<strong>被卷上去</strong>的上侧距离，返回数值不带单位</td></tr><tr><td><code>element.scrollLeft</code></td><td>返回<strong>被卷上去</strong>的左侧距离，返回数值不带单位</td></tr><tr><td><code>element.scrollWidth</code></td><td>返回自身<strong>实际</strong>宽度，不含边框，返回数值不带单位</td></tr><tr><td><code>element.scrollHeight</code></td><td>返回自身<strong>实际</strong>高度，不含边框，返回数值不带单位</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/716c0e587f8f4ed2b84616031cae31ba.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-页面被卷去的头部"><a href="#2-页面被卷去的头部" class="headerlink" title="2. 页面被卷去的头部"></a>2. 页面被卷去的头部</h2><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 <code>onscroll</code> 事件。</p><p><strong>获取页面被卷去的头部</strong>：</p><ul><li><strong>页面</strong> 被卷去的头部：可以通过 <code>window.pageYOffset</code> 获得，如果是被卷去的左侧 <code>window.pageXOffset</code></li><li>注意，元素被卷去的头部是 <code>element.scrollTop</code>，左侧 <code>element.scrollLeft</code></li></ul><h2 id="3-案例-1"><a href="#3-案例-1" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>仿淘宝固定右侧侧边栏</p><ol><li>原先侧边栏是绝对定位 </li><li>当页面滚动到一定位置，侧边栏改为固定定位 </li><li>页面继续滚动，会让 ‘返回顶部’ 显示出来</li></ol><ul><li>需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是 document </li><li>滚动到某个位置，就是判断页面被卷去的上部值。</li><li>页面被卷去的头部：可以通过window.pageYOffset 获得 如果是被卷去的左侧 window.pageXOffset</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.addEventListener('scroll', function () {if (window.pageYOffset &gt;= banner.offsetTop) {sliderbar.style.position = 'fixed';sliderbar.style.top = sliderbarTop + 'px';} else {sliderbar.style.position = 'absolute';sliderbar.style.top = '300px';}if (window.pageYOffset &gt;= main.offsetTop) {goBack.style.display = 'block';} else {goBack.style.display = 'none';}})</code></pre><ol><li><code>offset</code> 系列经常用于获得元素位置 <code>offsetLeft</code>、<code>offsetTop</code></li><li><code>client</code> 经常用于获取元素大小 <code>clientWidth</code> 、<code>clientHeight</code></li><li><code>scroll</code> 经常用于获取滚动距离 <code>scrollTop</code>、<code>scrollLeft</code></li><li>注意页面滚动的距离通过 <code>window.pageXOffset</code> 获得</li></ol><h1 id="四、动画函数封装"><a href="#四、动画函数封装" class="headerlink" title="四、动画函数封装"></a>四、动画函数封装</h1><h2 id="1-动画实现原理"><a href="#1-动画实现原理" class="headerlink" title="1. 动画实现原理"></a>1. 动画实现原理</h2><p>核心原理：通过定时器 <code>setInterval()</code> 不断移动盒子位置。 实现步骤：</p><ol><li>获得盒子当前位置</li><li>让盒子在当前位置加上 1 个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位（<code>position: absolute</code>），才能使用 <code>element.style.left</code></li></ol><h2 id="2-动画函数简单封装"><a href="#2-动画函数简单封装" class="headerlink" title="2. 动画函数简单封装"></a>2. 动画函数简单封装</h2><p>函数需要传递 2 个参数，<strong>动画对象和移动到的距离</strong>。</p><ul><li>如果多个元素都使用这个动画函数，每次都要 <code>var</code> 声明定时器。可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</li><li>核心原理：利用 JS 是一门动态语言，可以很方便的<strong>给当前对象添加属性</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function animate(obj, target) {    // 给不同节点对象 obj 设置定时器    obj.timer = setInterval(function () {        if (obj.offsetLeft &lt;= target) {            obj.style.left = obj.offsetLeft + 1 + 'px';        } else {            // 清除对象自己的定时器            clearInterval(timer);        }    }, 30);}</code></pre><h2 id="3-缓动动画效果原理"><a href="#3-缓动动画效果原理" class="headerlink" title="3. 缓动动画效果原理"></a>3. 缓动动画效果原理</h2><p>之前讲的是<strong>匀速动画</strong>：<code>盒子当前位置 = 盒子当前位置 + 固定值</code></p><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><ol><li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li><li><strong>核心算法</strong>：<code>每次移动的距离步长 = (目标值 - 现在的位置) / 10</code></li><li>停止的条件是：让当前盒子位置等于目标位置就停止定时器</li><li>注意步长值需要取整</li></ol><p>PS：<br>可以让动画函数从 <code>800</code> 移动到 <code>500</code>。  当我们点击按钮时候，判断步长是正值还是负值：</p><ol><li>如果是正值，则步长往大了取整（<code>Math.ceil()</code>）</li><li>如果是负值，则步长向小了取整（<code>Math.floor()</code>）</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function animate(obj, target) {    clearInterval(obj.timer);    obj.timer = setInterval(function () {        // 缓冲动画核心算法        var step = (target - obj.offsetLeft) / 10;        // 左右移动步值正负处理        step = step &gt;= 0 ?  Math.ceil(step) :  Math.floor(step);        if (obj.offsetLeft === target) {            clearInterval(obj.timer);        }        obj.style.left = obj.offsetLeft + step + 'px';    }, 30);}</code></pre><h2 id="4-动画函数添加回调函数"><a href="#4-动画函数添加回调函数" class="headerlink" title="4. 动画函数添加回调函数"></a>4. 动画函数添加回调函数</h2><ul><li><p><strong>回调函数原理</strong>：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做 <strong>回调（<code>callback</code>）</strong>。</p></li><li><p><strong>回调函数写的位置：定时器结束的位置</strong>。</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function animate(obj, target, callback) {    clearInterval(obj.timer);    obj.timer = setInterval(function () {        // 缓冲动画核心算法        var step = (target - obj.offsetLeft) / 10;        // 左右移动步值正负处理        step = step &gt;= 0 ?  Math.ceil(step) :  Math.floor(step);        if (obj.offsetLeft === target) {            clearInterval(obj.timer);            // 判断，回调函数 callback 存在则调用            if (callback) { callback(); }    }        obj.style.left = obj.offsetLeft + step + 'px';    }, 30);}// 回调函数作为实参传入 animate(span, 800, function () { span.style.backgroundColor = 'pink'; });</code></pre><h1 id="五、常见网页特效"><a href="#五、常见网页特效" class="headerlink" title="五、常见网页特效"></a>五、常见网页特效</h1><h2 id="1-网页轮播图"><a href="#1-网页轮播图" class="headerlink" title="1. 网页轮播图"></a>1. 网页轮播图</h2><p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p><p>功能需求：</p><ol><li>鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</li><li>点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</li><li>图片播放的同时，下面小圆圈模块跟随一起变化。</li><li>点击小圆圈，可以播放相应图片。</li><li>鼠标不经过轮播图，轮播图也会自动播放图片。</li><li>鼠标经过，轮播图模块，自动播放停止。</li></ol><p>案例分析：</p><ol><li>因为 js 较多，我们单独新建 js 文件夹，再新建 js 文件，引入页面中。</li><li>此时需要添加 <code>load</code> 事件。</li></ol><h3 id="1-1-动态生成小圆圈"><a href="#1-1-动态生成小圆圈" class="headerlink" title="1.1 动态生成小圆圈"></a>1.1 动态生成小圆圈</h3><ol><li>核心思路：小圆圈的个数要跟图片张数一致</li><li>所以首先先得到 <code>ul</code> 里面图片的张数（图片放入 <code>li</code> 里面，所以就是 <code>li</code> 的个数）</li><li>利用循环动态生成小圆圈（这个小圆圈要放入 <code>ol</code> 里面）</li><li>创建节点 <code>createElement('li')</code></li><li>插入节点 <code>ol.appendChild(li)</code></li><li>第一个小圆圈需要添加 <code>current</code> 类</li></ol><h3 id="1-2-给小圆圈绑定点击事件"><a href="#1-2-给小圆圈绑定点击事件" class="headerlink" title="1.2 给小圆圈绑定点击事件"></a>1.2 给小圆圈绑定点击事件</h3><h4 id="1-2-1-点击圆圈选中圆圈"><a href="#1-2-1-点击圆圈选中圆圈" class="headerlink" title="1.2.1 点击圆圈选中圆圈"></a>1.2.1 点击圆圈选中圆圈</h4><ol><li>点击当前小圆圈，就添加 <code>current</code> 类</li><li>其余的小圆圈就移除这个 <code>current</code> 类</li><li>注意：我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了。</li></ol><h4 id="1-2-2-点击小圆圈跳转到相应图片"><a href="#1-2-2-点击小圆圈跳转到相应图片" class="headerlink" title="1.2.2 点击小圆圈跳转到相应图片"></a>1.2.2 点击小圆圈跳转到相应图片</h4><ol><li>此时用到 <code>animate</code> 动画函数，将 js 文件引入（注意，因为 index.js 依赖 animate.js 所以，animate.js 要写到index.js 上面）</li><li>使用动画函数的前提，该元素必须有定位</li><li>注意是 <code>ul</code> 移动而不是小 <code>li</code></li><li>滚动图片的核心算法：点击某个小圆圈，就让图片滚动小圆圈的索引号乘以图片的宽度做为 <code>ul</code> 移动距离<ol><li>此时需要知道小圆圈的索引号，我们可以在生成小圆圈的时候，<strong>给它设置一个自定义属性</strong>，点击的时候获取这个自定义属性即可。</li></ol></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 2.动态生成小圆圈，几张轮播图就生成几个小圆圈for (var i = 0; i &lt; ul.children.length; i++) {var li = document.createElement('li');// 在生成小圆圈时，同步新增index属性li.setAttribute('index', i);ol.appendChild(li);// 3.在创建小圆圈时绑定点击事件，这样所有的li都能绑定到事件li.addEventListener('click', function () {// 3.1点击圆圈选中圆圈// 排他for (var i = 0; i &lt; ol.children.length; i++) {ol.children[i].className = '';}this.className = 'current';// 3.2点击小圆圈，跳转到相应图片var index = this.getAttribute('index');// 当我们点击小li，就要把li的索引号赋给num(后续用)// 这样以后点击任一圆圈后，再点击左右侧按钮时，就可以从圆圈对应的图片处跳到下或上一张图片了num = index;// 当我们点击小li，就要把li的索引号赋给circle(后续用)circle = index;animate(ul, -index * focusWidth);})}ol.children[0].className = 'current';</code></pre><h3 id="1-3-右侧按钮功能"><a href="#1-3-右侧按钮功能" class="headerlink" title="1.3 右侧按钮功能"></a>1.3 右侧按钮功能</h3><h4 id="1-3-1-点击右侧按钮图片滚动"><a href="#1-3-1-点击右侧按钮图片滚动" class="headerlink" title="1.3.1 点击右侧按钮图片滚动"></a>1.3.1 点击右侧按钮图片滚动</h4><ol><li>声明一个变量 <code>num</code>，点击一次，自增 1，让这个变量乘以图片宽度，就是ul 的滚动距离。</li><li>图片无缝滚动原理：<ol><li>把 <code>ul</code> 第一个 <code>li</code> 克隆一份，放到 <code>ul</code> 的最后面</li><li>当图片滚动到克隆的最后一张图片时，让 <code>ul</code> 快速的、不做动画的跳到最左侧：<code>left</code> 为0</li><li>同时 <code>num</code> 赋值为0，可以重新开始滚动图片了</li></ol></li></ol><h4 id="1-3-2-点击右侧按钮小圆圈跟随变化"><a href="#1-3-2-点击右侧按钮小圆圈跟随变化" class="headerlink" title="1.3.2 点击右侧按钮小圆圈跟随变化"></a>1.3.2 点击右侧按钮小圆圈跟随变化</h4><ol><li>最简单的做法是再声明一个变量 <code>circle</code>，每次点击自增1，注意，左侧按钮也需要这个变量，因此要声明全局变量。</li><li>但是图片有5张，我们小圆圈只有4个少一个，必须加一个判断条件</li><li>如果 <code>circle == 4</code> 就从新复原为 0</li></ol><h4 id="1-3-3-节流阀"><a href="#1-3-3-节流阀" class="headerlink" title="1.3.3 节流阀"></a>1.3.3 节流阀</h4><ul><li>功能：<strong>防止轮播图按钮连续点击造成播放过快。</strong></li><li>原理：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</li><li>思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<ol><li>开始设置一个变量：<code>var flag = true;</code></li><li><code>if(flag) {flag = false; do something}</code>：关闭水龙头</li><li>利用回调函数动画执行完毕：<code>flag = true</code> 打开水龙头</li></ol></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 4.克隆第一张图片var first = ul.children[0].cloneNode(true);ul.appendChild(first);// 5.点击右侧按钮，图片移动一张var num = 0;var circle = 0;// 节流阀var flag = true;arrowr.addEventListener('click', function () {if (flag) {flag = false;if (num == ul.children.length - 1) {ul.style.left = 0;num = 0;}num++;animate(ul, -num * focusWidth, function () {flag = true;});// 6.点击右侧按钮，小圆圈跟随一起变化circle++;if (circle == ol.children.length) {circle = 0;}circleChange();}})function circleChange() {// 清除其他小圆圈的current类名for (var i = 0; i &lt; ol.children.length; i++) {ol.children[i].className = '';}// 留下当前小圆圈类名ol.children[circle].className = 'current';}// 7.左侧按钮arrowl.addEventListener('click', function () {if (flag) {flag = false;if (num == 0) {num = ul.children.length - 1;ul.style.left = -num * focusWidth + 'px';}num--;animate(ul, -num * focusWidth, function () {flag = true;});// 点击左侧按钮，小圆圈跟随一起变化if (circle == 0) {circle = ol.children.length;}circle--;circleChange();}})</code></pre><h3 id="1-4-自动播放功能"><a href="#1-4-自动播放功能" class="headerlink" title="1.4 自动播放功能"></a>1.4 自动播放功能</h3><ol><li>添加一个定时器</li><li>自动播放轮播图，实际就类似于点击了右侧按钮</li><li>此时我们使用手动调用右侧按钮点击事件 <code>arrowr.click()</code></li><li>鼠标经过 <code>focus</code> 就停止定时器</li><li>鼠标离开 <code>focus</code> 就开启定时器</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 8.自动播放图片var timer = setInterval(function () {arrowr.click();}, 2000);</code></pre><h2 id="2-返回顶部"><a href="#2-返回顶部" class="headerlink" title="2. 返回顶部"></a>2. 返回顶部</h2><ol><li>此时可以继续使用我们封装的动画函数</li><li>只需要把所有的 <code>left</code> 相关的值改为跟页面垂直滚动距离相关就可以了</li><li>页面滚动了多少，可以通过 <code>window.pageYOffset</code> 得到</li><li>页面滚动事件，使用 <code>window.scroll(x, y)</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.addEventListener('scroll', function () {if (window.pageYOffset &gt;= banner.offsetTop) {// 侧边盒子固定住，不受页面滑动影响sliderbar.style.position = 'fixed';sliderbar.style.top = sliderbar.offsetTop - banner.offsetTop + 'px';} else {sliderbar.style.position = 'absolute';sliderbar.style.top = '300px';}if (window.pageYOffset &gt;= main.offsetTop) {goBack.style.display = 'block';} else {goBack.style.display = 'none';}})// 点击返回顶部模块，页面滚动至最上方goBack.addEventListener('click', function () {animate(window, 0);})</code></pre><h2 id="3-筋斗云"><a href="#3-筋斗云" class="headerlink" title="3. 筋斗云"></a>3. 筋斗云</h2><ul><li>鼠标经过某个小 <code>li</code>，筋斗云跟这到当前小 <code>li</code> 位置</li><li>鼠标离开这个小 <code>li</code>，筋斗云复原为原来的位置</li><li>鼠标点击了某个小 <code>li</code>，筋斗云就会留在点击这个小 <code>li</code> 的位置</li></ul><ol><li>利用动画函数做动画效果</li><li>原先筋斗云的起始位置是 <code>0</code></li><li>鼠标经过某个小 <code>li</code>，把当前小 <code>li</code> 的 <code>offsetLeft</code> 位置做为目标值即可</li><li>鼠标离开某个小 <code>li</code>，就把目标值设为起始位置</li><li>如果点击了某个小 <code>li</code>，就把 <code>li</code> 当前的位置存储起来，作为筋斗云的起始位</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var current = 0;for (var i = 0; i &lt; lis.length; i++) {    // (1) 鼠标经过把当前小li 的位置做为目标值    lis[i].addEventListener('mouseenter', function() {        animate(cloud, this.offsetLeft);    });    // (2) 鼠标离开就回到起始的位置     lis[i].addEventListener('mouseleave', function() {        animate(cloud, current);    });    // (3) 当我们鼠标点击，就把当前位置做为目标值    lis[i].addEventListener('click', function() {        current = this.offsetLeft;    });}</code></pre><h1 id="六、本地存储"><a href="#六、本地存储" class="headerlink" title="六、本地存储"></a>六、本地存储</h1><p><strong>==本地存储特性==</strong></p><ul><li>数据存储在<strong>用户浏览器</strong>中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，<code>sessionStorage</code> 约5M、<code>localStorage</code> 约20M</li><li>只能存储字符串，可以将对象 <code>JSON.stringify()</code> 编码后存储</li></ul><h2 id="1-window-sessionStorage"><a href="#1-window-sessionStorage" class="headerlink" title="1. window.sessionStorage"></a>1. window.sessionStorage</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>生命周期为 <strong>关闭浏览器窗口</strong></li><li>在<strong>同一个窗口</strong>（页面）下数据可以共享</li><li>以键值对的形式存储使用</li></ul><h3 id="1-2-相关操作"><a href="#1-2-相关操作" class="headerlink" title="1.2 相关操作"></a>1.2 相关操作</h3><ol><li>存储数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.setItem(key, value)</code></pre><ol start="2"><li>获取数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.getItem(key)</code></pre><ol start="3"><li>删除数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.removeItem(key)</code></pre><ol start="4"><li>删除所有数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.clear()</code></pre><ol start="5"><li>返回一个整数，表示存储在Storage对象中的数据项数量：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.length</code></pre><ol start="6"><li>返回存储中的第n个key名称：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage.key(n)</code></pre><h2 id="2-window-localStorage"><a href="#2-window-localStorage" class="headerlink" title="2. window.localStorage"></a>2. window.localStorage</h2><h3 id="1-1-特点-1"><a href="#1-1-特点-1" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>生命周期 <strong>永久生效</strong>，除非手动删除否则关闭页面也会存在</li><li>可以<strong>多窗口</strong>（页面）共享（同一浏览器可以共享）</li><li>以键值对的形式存储使用</li></ul><h3 id="1-2-相关操作-1"><a href="#1-2-相关操作-1" class="headerlink" title="1.2 相关操作"></a>1.2 相关操作</h3><ol><li>存储数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">localStorage.setItem(key, value)</code></pre><ol start="2"><li>获取数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">localStorage.getItem(key)</code></pre><ol start="3"><li>删除数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">loaclStorage.removeItem(key)</code></pre><ol start="4"><li>删除所有数据：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">localStorage.clear()</code></pre><ol start="5"><li>返回一个整数，表示存储在Storage对象中的数据项数量：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">localStorage.length</code></pre><ol start="6"><li>返回存储中的第n个key名称：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">localStorage.key(n)</code></pre><h2 id="3-案例：记住用户名"><a href="#3-案例：记住用户名" class="headerlink" title="3. 案例：记住用户名"></a>3. 案例：记住用户名</h2><p>如果勾选记住用户名，下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名。</p><ul><li>把数据存起来，用到本地存储</li><li>关闭页面，也可以显示用户名，所以用到 <code>localStorage</code></li><li>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</li><li>当复选框发生改变的时候 <code>change</code> 事件</li><li>如果勾选，就存储，否则就移除</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var nameInput = document.querySelector('#username');var remember = document.querySelector('#remember');if (localStorage.getItem('username')) {    nameInput.value = localStorage.getItem('username');    remember.checked = true;}remember.addEventListener('change', function () {    if (remember.checked) {        localStorage.setItem('username', nameInput.value);    } else {        localStorage.removeItem('username');    }})</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 进阶（五）BOM技术</title>
      <link href="/2023/01/11/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%94%EF%BC%89BOM%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/01/11/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%94%EF%BC%89BOM%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、BOM概述"><a href="#一、BOM概述" class="headerlink" title="一、BOM概述"></a>一、BOM概述</h1><ul><li>BOM（Browser Object Model），即<strong>浏览器对象模型</strong>，它提供了独立于内容而<strong>与浏览器窗口进行交互</strong>的对象，其核心对象是 window</li><li>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性</li><li>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA, DOM 的标准化组织是 W3C, BOM最初是Netscape 浏览器标准的一部分</li></ul><table><thead><tr><th>DOM</th><th>BOM</th></tr></thead><tbody><tr><td>文档对象模型</td><td>浏览器对象模型</td></tr><tr><td>DOM 就是把<strong>文档</strong>当作一个对象来看待</td><td>把<strong>浏览器</strong>当作一个对象来看待</td></tr><tr><td>DOM 的顶级对象是 <strong>document</strong></td><td>BOM 的顶级对象是 <strong>window</strong></td></tr><tr><td>DOM 主要学习的是操作页面元素</td><td>BOM 学习的是浏览器窗口交互的一些对象</td></tr><tr><td>DOM 是 W3C 标准规范</td><td>BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差</td></tr></tbody></table><h2 id="1-BOM的构成"><a href="#1-BOM的构成" class="headerlink" title="1. BOM的构成"></a>1. BOM的构成</h2><p>BOM 比 DOM 更大。它包含 DOM。</p><p><img src="71ba20591f2a4d15b6a5a01b821d0dac.png" alt="在这里插入图片描述"></p><p>window 对象是浏览器的顶级对象，它具有双重角色</p><ol><li>它是 JS 访问浏览器窗口的一个接口</li><li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法</li></ol><p>在调用的时候可以<strong>省略 window</strong>，前面学习的对话框都属于 window 对象方法，如 <code>alert()</code>、<code>prompt()</code>等。<br><strong>注意：window下有一个特殊属性 window.name</strong>，在定义变量时不要使用name这个名称</p><h1 id="二、window-对象的常见事件"><a href="#二、window-对象的常见事件" class="headerlink" title="二、window 对象的常见事件"></a>二、window 对象的常见事件</h1><h2 id="1-窗口加载事件"><a href="#1-窗口加载事件" class="headerlink" title="1. 窗口加载事件"></a>1. 窗口加载事件</h2><p><code>window.onload</code>是窗口（页面）加载事件，当<strong>文档内容完全加载完成</strong>会触发该事件（包括图像，脚本文件，CSS文件等），就调用的处理函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.onload = function(){    };// 或者window.addEventListener("load",function(){});</code></pre><p><strong>注意</strong>：</p><ul><li>有了<code>window.onload</code>就可以把JS代码写到页面元素的上方，因为<code>onload</code>是等页面内容全部加载完毕，再去执行处理函数</li><li><code>window.onload</code> 传统注册事件方式，只能写一次；如果有多个，会以最后一个为准</li><li>如果使用 <code>addEventListener</code> 则没有限制</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.addEventListener('DOMContentLoaded',function(){})</code></pre><ul><li><p>DOMCountentLoaded事件触发时，仅当DOM加载完成，<strong>不包括样式表，图片，flash等等</strong></p></li><li><p>如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验。此时用 <code>DOMContentLoaded</code>事件比较合适。</p></li></ul><h2 id="2-调整窗口大小事件"><a href="#2-调整窗口大小事件" class="headerlink" title="2. 调整窗口大小事件"></a>2. 调整窗口大小事件</h2><p><code>window.onresize</code> 是调整窗口大小加载事件，当触发时就调用的处理函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.onresize = function() {}// 或者window.addEventListener('resize',function(){});</code></pre><ul><li>只要窗口大小发生像素变化，就会触发这个事件</li><li>我们经常利用这个事件完成响应式布局。<code>window.innerWidth</code> 当前屏幕的宽度</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;script&gt;        window.addEventListener('load', function() {            var div = document.querySelector('div');                        window.addEventListener('resize', function() {                console.log(window.innerWidth);                console.log('变化了');                                if (window.innerWidth &lt;= 800) {                    div.style.display = 'none';                } else {                    div.style.display = 'block';                }            })        })    &lt;/script&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h1 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h1><p>window 对象给我们提供了两个定时器</p><ul><li><code>setTimeout()</code></li><li><code>setInterval()</code></li></ul><h2 id="1-setTimeout-定时器"><a href="#1-setTimeout-定时器" class="headerlink" title="1. setTimeout() 定时器"></a>1. setTimeout() 定时器</h2><p><code>setTimeout()</code>方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.setTimeout(调用函数,[延迟的毫秒数]);</code></pre><p><strong>注意</strong>：</p><ul><li><code>window</code>可以省略</li><li>这个调用函数<ul><li>可以直接写函数</li><li>或者写函数名</li><li>或者采取字符串 ‘函数名()’（不推荐）</li></ul></li><li>延迟的毫秒数省略默认是0，如果写，必须是毫秒</li><li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符</li><li><code>setTimeout()</code> 这个调用函数我们也称为<strong>回调函数</strong> callback</li><li>普通函数是按照代码顺序直接调用，而这个函数，<strong>需要等待时间</strong>，时间到了才会回头去调用这个函数，因此称为回调函数。<ul><li>以前我们讲的 <code>element.onclick = function(){}</code> 或者 <code>element.addEventListener(“click”, fn);</code> 里面的 函数也是回调函数。</li></ul></li></ul><h2 id="2-clearTimeout-停止定时器"><a href="#2-clearTimeout-停止定时器" class="headerlink" title="2. clearTimeout() 停止定时器"></a>2. clearTimeout() 停止定时器</h2><ul><li><code>clearTimeout()</code>方法取消了先前通过调用 <code>setTimeout()</code>建立的定时器</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.clearTimeout(timeoutID)</code></pre><ul><li>里面的参数就是定时器的标识符</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;button&gt;点击停止定时器&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector('button');        var timer = setTimeout(function() {            console.log('爆炸了');        }, 5000);        btn.addEventListener('click', function() {            clearTimeout(timer);        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="3-setInterval-定时器"><a href="#3-setInterval-定时器" class="headerlink" title="3. setInterval() 定时器"></a>3. setInterval() 定时器</h2><ul><li><code>setInterval()</code>方法<strong>重复调用</strong>一个函数，每隔这个时间，就去调用一次回调函数</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.setInterval(回调函数,[间隔的毫秒数]);</code></pre><p><strong>注意</strong>：</p><ul><li><code>window</code>可以省略</li><li>这个回调函数:<ul><li>可以直接写函数</li><li>或者写函数名</li><li>或者采取字符 ‘函数名()’</li></ul></li><li>第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次</li></ul><h4 id="案例：倒计时效果"><a href="#案例：倒计时效果" class="headerlink" title="案例：倒计时效果"></a>案例：倒计时效果</h4><ul><li>这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval）</li><li>三个黑色盒子里面分别存放时分秒 <ul><li>三个黑色盒子利用innerHTML 放入计算的小时分钟秒数</li></ul></li><li>第一次执行也是间隔毫秒数，因此刚刷新页面会有空白<ul><li>最好采取<strong>封装函数</strong>的方式， 这样可以<strong>先调用一次</strong>这个函数，防止刚开始刷新页面有空白问题<br><img src="a880106969904e478bd70759190d1454.png" alt="在这里插入图片描述"></li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;&lt;div&gt;&lt;span class="hour"&gt;1&lt;/span&gt;&lt;span class="minute"&gt;2&lt;/span&gt;&lt;span class="second"&gt;3&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var hour = document.querySelector('.hour');var minute = document.querySelector('.minute');var second = document.querySelector('.second');var inputTime = +new Date('2023-01-22 00:00:00'); // 设定目标时间，并求目标时间的总毫秒数countDown();//先调用一次,防止刷新出现空白间隔1ssetInterval(countDown, 1000);function countDown() {var nowTime = +new Date(); // 返回的是当前时间总的毫秒数var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数var h = parseInt(times / 60 / 60); //时h = h &lt; 10 ? '0' + h : h;hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子var m = parseInt(times / 60 % 60); // 分m = m &lt; 10 ? '0' + m : m;minute.innerHTML = m;var s = parseInt(times % 60); // 当前的秒s = s &lt; 10 ? '0' + s : s;second.innerHTML = s;}&lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="4-clearInterval-停止定时器"><a href="#4-clearInterval-停止定时器" class="headerlink" title="4. clearInterval() 停止定时器"></a>4. clearInterval() 停止定时器</h2><ul><li><code>clearInterval()</code> 方法取消了先前通过调用 <code>setInterval()</code> 建立的定时器</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.clearInterval(intervalID);</code></pre><p><strong>注意</strong>：</p><ul><li><code>window</code>可以省略</li><li>里面的参数就是定时器的标识符</li></ul><h4 id="案例：发送短信"><a href="#案例：发送短信" class="headerlink" title="案例：发送短信"></a>案例：发送短信</h4><p>点击按钮后，该按钮3秒之内不能再次点击，防止重复发送短信</p><ul><li>按钮点击之后，会禁用 disabled 为true </li><li>同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改<ul><li>里面秒数是有变化的，因此需要用到定时器</li><li>定义一个变量，在定时器里面，不断递减</li><li>如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态。</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;手机号码：&lt;input type="number"&gt; &lt;button&gt;发送&lt;/button&gt;&lt;script&gt;var btn = document.querySelector('button');var time = 3;btn.addEventListener('click', function () {this.disabled = true; // 按钮不可点击var timer = setInterval(function () {if (time == 0) {clearInterval(timer);btn.disabled = false;btn.innerHTML = '发送';time = 3;} else {btn.innerHTML = '还剩下' + time-- + 's';}}, 1000);})&lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="5-this指向"><a href="#5-this指向" class="headerlink" title="5. this指向"></a>5. this指向</h2><ul><li><code>this</code>的指向在函数定义的时候是确定不了的，只有<strong>函数执行</strong>的时候才能确定<code>this</code>到底指向谁</li></ul><p>现阶段，我们先了解一下几个this指向：</p><ul><li>全局作用域或者普通函数中<code>this</code>指向全局对象<code>window</code>(注意定时器里面的this指向window)</li><li>方法调用中谁调用<code>this</code>指向谁</li><li>构造函数中<code>this</code>指向构造函数实例</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）        console.log(this);        function fn() {            console.log(this);        }        window.fn();        window.setTimeout(function() {            console.log(this);        }, 1000);                // 2. 方法调用中谁调用this指向谁        var o = {            sayHi: function() {                console.log(this); // this指向的是 o 这个对象            }        }        o.sayHi();                var btn = document.querySelector('button');        btn.addEventListener('click', function() {                console.log(this); // this指向的是btn这个按钮对象            })                        // 3. 构造函数中this指向构造函数的实例        function Fun() {            console.log(this); // this 指向的是fun的实例对象Fun()        }        var fun = new Fun();    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="四、JS执行机制"><a href="#四、JS执行机制" class="headerlink" title="四、JS执行机制"></a>四、JS执行机制</h1><h2 id="1-JS是单线程"><a href="#1-JS是单线程" class="headerlink" title="1. JS是单线程"></a>1. JS是单线程</h2><ul><li>JavaScript 语言的一大特点就是<strong>单线程</strong>，也就是说，<strong>同一个时间只能做一件事</strong>。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。</li><li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</li></ul><h2 id="2-一个问题"><a href="#2-一个问题" class="headerlink" title="2. 一个问题"></a>2. 一个问题</h2><p>以下代码执行的结果是什么？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(1);setTimeout(function() {    console.log(3);},1000);console.log(2);// 1 2 3</code></pre><p>那么以下代码执行的结果又是什么？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(1);setTimeout(function() {    console.log(3);},0);console.log(2);// 1 2 3</code></pre><h2 id="3-同步和异步"><a href="#3-同步和异步" class="headerlink" title="3. 同步和异步"></a>3. 同步和异步</h2><ul><li>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程</li><li>于是，JS 中出现了同步和异步。</li><li><strong>同步</strong>:<ul><li>前一个任务结束后再执行后一个任务</li></ul></li><li><strong>异步</strong>：<ul><li>在做这件事的同时，你还可以去处理其他事情</li></ul></li></ul><h4 id="3-1-同步任务"><a href="#3-1-同步任务" class="headerlink" title="3.1 同步任务"></a>3.1 同步任务</h4><ul><li>同步任务都在主线程上执行，形成一个<strong>执行栈</strong></li></ul><p><img src="34155f23aebe49e7a82058341f33d3c5.png" alt="在这里插入图片描述"></p><h4 id="3-2-异步任务"><a href="#3-2-异步任务" class="headerlink" title="3.2 异步任务"></a>3.2 异步任务</h4><ul><li>JS中的异步是通过<strong>回调函数</strong>实现的</li><li>异步任务有以下三种类型<ul><li>普通事件，如<code>click</code>，<code>resize</code>等</li><li>资源加载，如<code>load</code>，<code>error</code>等</li><li>定时器，包括<code>setInterval</code>，<code>setTimeout</code>等</li></ul></li><li>异步任务相关<strong>回调函数添加到任务队列</strong>中</li></ul><p><img src="a999c1725afa4a69ae5aa1be4bc5ad91.png" alt="在这里插入图片描述"></p><ol><li>先执行<strong>执行栈中的同步任务</strong></li><li>异步任务(回调函数)放入任务队列中</li><li>一旦执行栈中的所有同步任务执行<strong>完毕</strong>，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务<strong>结束等待状态</strong>，进入执行栈，开始执行</li></ol><p><img src="96d9e0803d0a498480cda7fff35bf302.png" alt="在这里插入图片描述"></p><p><img src="1a7e56ba00c847a8826d6ba4a73d1d6c.png" alt="在这里插入图片描述"></p><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<strong>事件循环</strong>（ event loop）。</p><h1 id="五、location-对象"><a href="#五、location-对象" class="headerlink" title="五、location 对象"></a>五、location 对象</h1><ul><li>window 对象给我们提供了一个 <code>location</code>属性用于<strong>获取或者设置窗体的url，并且可以解析url</strong>。因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。</li></ul><h2 id="1-url"><a href="#1-url" class="headerlink" title="1. url"></a>1. url</h2><p>==统一资源定位符（uniform resouce locator）是互联网上标准资源的地址==。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>url 的一般语法格式为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">protocol://host[:port]/path/[?query]#fragmenthttp://www.itcast.cn/index.html?name=andy&amp;age=18#link</code></pre><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>通信协议 常用的http,ftp,maito等</td></tr><tr><td>host</td><td>主机(域名) 如<a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>port</td><td>端口号，可选</td></tr><tr><td>path</td><td>路径 由零或多个’/‘符号隔开的字符串</td></tr><tr><td>query</td><td>参数 以键值对的形式，通过<code>&amp;</code>符号分隔开来</td></tr><tr><td>fragment</td><td>片段 <code>#</code>后面内容 常见于链接、锚点</td></tr></tbody></table><h2 id="2-location-对象属性"><a href="#2-location-对象属性" class="headerlink" title="2. location 对象属性"></a>2. location 对象属性</h2><table><thead><tr><th>location对象属性</th><th>返回值</th></tr></thead><tbody><tr><td><code>location.href</code></td><td>获取或者设置整个URL</td></tr><tr><td><code>location.host</code></td><td>返回主机（域名）<a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td><code>location.port</code></td><td>返回端口号，如果未写返回空字符串</td></tr><tr><td><code>location.pathname</code></td><td>返回路径</td></tr><tr><td><code>location.search</code></td><td>返回参数</td></tr><tr><td><code>location.hash</code></td><td>返回片段 <code>#</code>后面内容常见于链接 锚点</td></tr><tr><td>重点记住： <code>href</code>和<code>search</code></td><td></td></tr></tbody></table><h4 id="案例1：5s之后跳转页面"><a href="#案例1：5s之后跳转页面" class="headerlink" title="案例1：5s之后跳转页面"></a>案例1：5s之后跳转页面</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;button&gt;点击&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        var btn = document.querySelector('button');        var div = document.querySelector('div');        var timer = 5;        setInterval(function() {            if (timer == 0) {                location.href = 'http://www.itcast.cn';            } else {                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';                timer--;            }        }, 1000);    &lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="案例2：获取-URL-参数数据"><a href="#案例2：获取-URL-参数数据" class="headerlink" title="案例2：获取 URL 参数数据"></a>案例2：获取 URL 参数数据</h4><ul><li>第一个登录页面，里面有提交表单， action 提交到 index.html页面 </li><li>第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果<ul><li>第二个页面之所以可以使用第一个页面的数据，是利用了URL 里面的 location.search参数</li></ul></li><li>在第二个页面中，需要把这个参数提取。<ul><li>第一步去掉？ 利用 <code>substr</code> </li><li>第二步 利用=号分割键和值 <code>split('=')</code> </li><li>第一个数组就是键 第二个数组就是值</li></ul></li></ul><p>简单写一个登录框，点击登录跳转到 index.html</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;form action="index.html"&gt;        用户名： &lt;input type="text" name="uname"&gt;        &lt;input type="submit" value="登录"&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><p>接下来我们写 index.html</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        console.log(location.search); // ?uname=andy        // 1.先去掉？  substr('起始的位置'，截取几个字符);        var params = location.search.substr(1); // uname=andy        console.log(params);        // 2. 利用=把字符串分割为数组 split('=');        var arr = params.split('=');        console.log(arr); // ["uname", "ANDY"]        var div = document.querySelector('div');        // 3.把数据写入div中        div.innerHTML = arr[1] + '欢迎您';    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="3-location-对象方法"><a href="#3-location-对象方法" class="headerlink" title="3. location 对象方法"></a>3. location 对象方法</h2><table><thead><tr><th>location对象方法</th><th>返回值</th></tr></thead><tbody><tr><td><code>location.assign()</code></td><td>跟href一样，可以跳转页面（也称为重定向页面）</td></tr><tr><td><code>location.replace()</code></td><td>替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td><code>location.reload()</code></td><td>重新加载页面，相当于刷新按钮或者f5；如果参数为true 强制刷新，相当于ctrl+f5</td></tr></tbody></table><h1 id="六、navigator-对象"><a href="#六、navigator-对象" class="headerlink" title="六、navigator 对象"></a>六、navigator 对象</h1><ul><li>navigator 对象包含有关浏览器的信息，它有很多属性</li><li>我们常用的是<code>userAgent</code>,该属性可以返回由客户机发送服务器的<code>user-agent</code>头部的值</li></ul><p>下面前端代码可以判断用户是用哪个终端打开页面的，如果是用 PC 打开的，我们就跳转到 PC 端的页面，如果是用手机打开的，就跳转到手机端页面</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    window.location.href = "";     //手机 } else {    window.location.href = "";     //电脑 }</code></pre><h1 id="七、history对象"><a href="#七、history对象" class="headerlink" title="七、history对象"></a>七、history对象</h1><ul><li>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互</li><li>该对象包含用户（在浏览器窗口中）访问过的 URL。</li></ul><table><thead><tr><th>history对象方法</th><th>作用</th></tr></thead><tbody><tr><td><code>back()</code></td><td>后退功能</td></tr><tr><td><code>forward()</code></td><td>前进功能</td></tr><tr><td><code>go(参数)</code></td><td>前进后退功能，参数如果是 1 前进1个页面 如果是 -1 后退1个页面</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 进阶（四）DOM技术</title>
      <link href="/2023/01/08/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89DOM%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/01/08/JavaScript-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89DOM%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DOM-简介"><a href="#一、DOM-简介" class="headerlink" title="一、DOM 简介"></a>一、DOM 简介</h1><p>文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口</p><p>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变<strong>网页的内容、结构和样式</strong>。</p><p><img src="d3adce841e3f43e28069f49587da0436.png" alt="在这里插入图片描述"></p><ul><li>文档：一个页面就是一个文档，DOM中使用doucument来表示</li><li>元素：页面中的所有标签都是元素，DOM中使用 element 表示</li><li>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示</li></ul><p>DOM 把以上内容都看做是==对象==</p><h1 id="二、获取元素"><a href="#二、获取元素" class="headerlink" title="二、获取元素"></a>二、获取元素</h1><p>获取页面中的元素可以使用以下几种方式:</p><ul><li>根据 ID 获取</li><li>根据标签名获取</li><li>通过 HTML5 新增的方法获取</li><li>特殊元素获取</li></ul><h2 id="1-根据-ID-获取"><a href="#1-根据-ID-获取" class="headerlink" title="1. 根据 ID 获取"></a>1. 根据 ID 获取</h2><p>使用 <code>getElementByld()</code> 方法可以获取带ID的元素对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">doucument.getElementByld('id名');</code></pre><p>使用 <code>console.dir()</code> 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。</p><h2 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2. 根据标签名获取"></a>2. 根据标签名获取</h2><p>根据标签名获取，使用 getElementByTagName() 方法可以返回带有指定标签名的对象的集合</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">doucument.getElementsByTagName('标签名');</code></pre><ul><li>返回的是获取过来元素对象的集合，以<strong>伪数组</strong>的形式存储。我们想要操作里面的元素就需要<strong>遍历</strong></li><li>得到元素对象是动态的</li><li>如果获取不到元素，则返回为空的伪数组</li></ul><p>==ps：==</p><p>可以根据标签名获取<strong>某个元素（父元素）内部</strong>所有指定标签名的子元素</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.getElementsByTagName('标签名')ol.getElementsByTagName('li');</code></pre><h2 id="3-通过H5新增方法获取"><a href="#3-通过H5新增方法获取" class="headerlink" title="3. 通过H5新增方法获取"></a>3. 通过H5新增方法获取</h2><h3 id="3-1-getElementsByClassName"><a href="#3-1-getElementsByClassName" class="headerlink" title="3.1 getElementsByClassName"></a>3.1 getElementsByClassName</h3><p>根据<strong>类名</strong>返回元素对象合集</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.getElementsByClassName('类名'); </code></pre><h3 id="3-2-document-querySelector"><a href="#3-2-document-querySelector" class="headerlink" title="3.2 document.querySelector"></a>3.2 document.querySelector</h3><p>根据指定选择器返回<strong>第一个</strong>元素对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.querySelector('选择器');// 切记里面的选择器需要加符号 // 类选择器.box // id选择器 #navvar firstBox = document.querySelector('.box');</code></pre><h3 id="3-3-document-querySelectorAll"><a href="#3-3-document-querySelectorAll" class="headerlink" title="3.3 document.querySelectorAll"></a>3.3 document.querySelectorAll</h3><p>根据指定选择器返回<strong>所有</strong>元素对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.querySelectorAll('选择器');</code></pre><h2 id="4-获取特殊元素"><a href="#4-获取特殊元素" class="headerlink" title="4. 获取特殊元素"></a>4. 获取特殊元素</h2><h3 id="4-1-获取-body-元素"><a href="#4-1-获取-body-元素" class="headerlink" title="4.1 获取 body 元素"></a>4.1 获取 body 元素</h3><p>返回body元素对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.body;</code></pre><h3 id="4-2-获取-html-元素"><a href="#4-2-获取-html-元素" class="headerlink" title="4.2 获取 html 元素"></a>4.2 获取 html 元素</h3><p>返回html元素对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.documentElement;</code></pre><h1 id="三、事件基础"><a href="#三、事件基础" class="headerlink" title="三、事件基础"></a>三、事件基础</h1><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p><p>简单理解： 触发 – 响应机制。</p><p>网页中的<strong>每个元素都可以产生某些可以触发 JavaScript 的事件</strong>，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</p><h2 id="1-事件三要素"><a href="#1-事件三要素" class="headerlink" title="1. 事件三要素"></a>1. 事件三要素</h2><ol><li>事件源（谁）</li><li>事件类型（什么事件）</li><li>事件处理程序（做啥）</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;    // 点击一个按钮，弹出对话框    // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素    //(1) 事件源 事件被触发的对象   谁  按钮    var btn = document.getElementById('btn');    //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下    //(3) 事件处理程序  通过一个函数赋值的方式 完成    btn.onclick = function() {        alert('点秋香');    }&lt;/script&gt;</code></pre><h2 id="2-执行事件的步骤"><a href="#2-执行事件的步骤" class="headerlink" title="2. 执行事件的步骤"></a>2. 执行事件的步骤</h2><ol><li>获取事件源</li><li>注册事件(绑定事件)</li><li>添加事件处理程序(采取函数赋值形式)</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;    // 执行事件步骤    // 点击div 控制台输出 我被选中了    // 1. 获取事件源    var div = document.querySelector('div');    // 2.绑定事件 注册事件    // div.onclick     // 3.添加事件处理程序     div.onclick = function() {        console.log('我被选中了');    }&lt;/script&gt;</code></pre><h2 id="3-鼠标事件"><a href="#3-鼠标事件" class="headerlink" title="3. 鼠标事件"></a>3. 鼠标事件</h2><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td><code>onclick</code></td><td>鼠标点击左键触发</td></tr><tr><td><code>onmouseover</code></td><td>鼠标经过触发</td></tr><tr><td><code>onmouseout</code></td><td>鼠标离开触发</td></tr><tr><td><code>onfocus</code></td><td>获得鼠标焦点触发</td></tr><tr><td><code>onblur</code></td><td>失去鼠标焦点触发</td></tr><tr><td><code>onmousemove</code></td><td>鼠标移动触发</td></tr><tr><td><code>onmousedown</code></td><td>鼠标按下触发</td></tr><tr><td><code>onmouseup</code></td><td>鼠标弹起触发</td></tr></tbody></table><h1 id="四、操作元素"><a href="#四、操作元素" class="headerlink" title="四、操作元素"></a>四、操作元素</h1><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来<strong>改变元素里面的内容 、属性</strong>等。</p><h2 id="1-改变元素内容"><a href="#1-改变元素内容" class="headerlink" title="1. 改变元素内容"></a>1. 改变元素内容</h2><ul><li>从起始位置到终止位置的内容，但它会<strong>去掉html标签</strong>，同时<strong>去掉空格和换行</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.innerText</code></pre><ul><li>起始位置到终止位置的<strong>全部内容</strong>，包括html标签，同时保留空格和换行</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.innerHTML</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p&gt;        我是文字        &lt;span&gt;123&lt;/span&gt;    &lt;/p&gt;    &lt;script&gt;        // innerText 和 innerHTML的区别         // 1. innerText 不识别html标签,去除空格和换行        var div = document.querySelector('div');        div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';        // 2. innerHTML 识别html标签 保留空格和换行的        div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';        // 这两个属性是可读写的  可以获取元素里面的内容        var p = document.querySelector('p');        console.log(p.innerText);        console.log(p.innerHTML);    &lt;/script&gt;&lt;/body&gt;</code></pre><p><img src="545a26770b544ab5800a4b7efd77cdf2.png" alt="在这里插入图片描述"></p><h2 id="2-改变元素属性"><a href="#2-改变元素属性" class="headerlink" title="2. 改变元素属性"></a>2. 改变元素属性</h2><p>常用元素的属性操作</p><ol><li><code>innerText</code>、<code>innerHTML</code> 改变元素内容</li><li><code>src</code>、<code>href</code></li><li><code>id</code>、<code>alt</code>、<code>title</code></li><li>表单元素属性 <code>type, value, checked, selected, disabled</code></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// img.属性img.src = "xxx";input.value = "xxx";input.type = "xxx";input.checked = "xxx";input.selected = true / false;input.disabled = true / false;</code></pre><h2 id="3-改变样式属性"><a href="#3-改变样式属性" class="headerlink" title="3. 改变样式属性"></a>3. 改变样式属性</h2><p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p><ul><li><strong>行内样式操作</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// element.stylediv.style.backgroundColor = 'pink';div.style.width = '250px';</code></pre><ul><li><strong>类名样式操作</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// element.classNamediv.className = 'wrong'</code></pre><p>注意：</p><ol><li>JS里面的样式采取<strong>驼峰命名法</strong>，比如 fontSize ，backgroundColor</li><li>JS 修改 style 样式操作 ，产生的是行内样式，<strong>权重比较高</strong></li><li>==如果样式修改较多，可以采取操作类名方式更改元素样式==</li><li>className 会直接更改元素的类名，<strong>会覆盖原先的类名</strong></li></ol><p><strong>案例</strong>：用户如果离开密码框，里面输入个数不是6~16，则提示错误信息，否则提示输入正确信息</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;style&gt;div {width: 600px;margin: 100px auto;    }.message {display: inline-block;font-size: 12px;color: #999;background: url(images/mess.png) no-repeat left center;padding-left: 20px;}// 样式用类名封装.wrong {color: red;background-image: url(images/wrong.png);}// 样式用类名封装.right {color: green;background-image: url(images/right.png);}&lt;/style&gt;&lt;body&gt;&lt;div class="register"&gt;&lt;input type="password" class="ipt"&gt;&lt;p class="message"&gt;请输入6~16位密码&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var ipt = document.querySelector('.ipt');var message = document.querySelector('.message');ipt.onblur = function () {if (ipt.value.length &lt; 6 || ipt.value.length &gt; 16) {message.className = 'message wrong'; // 直接更改类名message.innerHTML = '您输入的位数不对';} else {message.className = 'message right'; // 直接更改类名message.innerHTML = '密码符合条件';}}&lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="4-排他思想"><a href="#4-排他思想" class="headerlink" title="4. 排他思想"></a>4. 排他思想</h2><p>如果有同一组元素，我们相要某一个元素实现某种样式，需要用到循环的排他思想算法：</p><ol><li>所有元素全部清除样式（干掉其他人）</li><li>给当前元素设置样式 （留下我自己）</li><li>注意顺序不能颠倒，首先干掉其他人，再设置自己</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;button&gt;按钮1&lt;/button&gt;    &lt;button&gt;按钮2&lt;/button&gt;    &lt;button&gt;按钮3&lt;/button&gt;    &lt;button&gt;按钮4&lt;/button&gt;    &lt;button&gt;按钮5&lt;/button&gt;        &lt;script&gt;        // 1. 获取所有按钮元素        var btns = document.getElementsByTagName('button');        // btns得到的是伪数组  里面的每一个元素 btns[i]        for (var i = 0; i &lt; btns.length; i++) {            btns[i].onclick = function() {                // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人                for (var i = 0; i &lt; btns.length; i++) {                    btns[i].style.backgroundColor = '';                }                // (2) 然后才让当前的元素背景颜色为pink 留下我自己                this.style.backgroundColor = 'pink';            }        }        //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="5-自定义属性"><a href="#5-自定义属性" class="headerlink" title="5. 自定义属性"></a>5. 自定义属性</h2><h3 id="5-1-获取属性值"><a href="#5-1-获取属性值" class="headerlink" title="5.1 获取属性值"></a>5.1 获取属性值</h3><ul><li>获取内置属性值(元素<strong>本身自带</strong>的属性)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.属性;</code></pre><ul><li>获取自定义的属性</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.getAttribute('属性');</code></pre><h3 id="5-2-设置属性值"><a href="#5-2-设置属性值" class="headerlink" title="5.2 设置属性值"></a>5.2 设置属性值</h3><ul><li>设置内置属性值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.属性 = '值';</code></pre><ul><li>主要设置自定义的属性</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.setAttribute('属性','值');</code></pre><h3 id="5-3-移除属性"><a href="#5-3-移除属性" class="headerlink" title="5.3 移除属性"></a>5.3 移除属性</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">element.removeAttribute('属性');</code></pre><p><strong>案例：tab 栏切换</strong></p><p>当鼠标点击上面相应的选项卡（tab），下面内容跟随变化<br><img src="fed2476fb7bf46aab65cc31d19195fdb.png" alt="在这里插入图片描述"></p><p>核心思路：</p><ul><li>给上面的tab_list 里面的所有小li <strong>添加自定义属性</strong>，属性值从0开始编号。</li><li>当我们点击tab_list 里面的某个小li，让tab_con 里面对应序号的内容显示，其余隐藏（排他 思想）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;var lis = document.querySelector('.tab_list').querySelectorAll('li');//获取tab切换栏var items = document.querySelectorAll('.item');//获取各个tab下的内容for (var i = 0; i &lt; lis.length; i++) {lis[i].setAttribute('index', i);// 给每个tab栏添加序号属性lis[i].onclick = function () {for (var i = 0; i &lt; lis.length; i++) {lis[i].className = '';items[i].style.display = 'none';} // 排他思想this.className = 'current'; // 选中点击的此tabvar index = this.getAttribute('index');items[index].style.display = 'block'; // 匹配}}&lt;/script&gt;</code></pre><h3 id="H5-规定自定义属性"><a href="#H5-规定自定义属性" class="headerlink" title="H5 规定自定义属性"></a>H5 规定自定义属性</h3><p>自定义属性目的：</p><ul><li>保存并保存数据，有些数据可以保存到页面中而不用保存到数据库中</li><li>有些自定义属性很容易引起歧义，<strong>不容易判断到底是内置属性还是自定义的</strong></li></ul><p>H5规定自定义属性 <code>data-</code>开头作为属性名并赋值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div data-index = "1"&gt;&lt;/div&gt;// 或者使用JavaScript设置div.setAttribute('data-index',1);</code></pre><ul><li>兼容性获取 <code>element.getAttribute('data-index')</code></li><li>H5新增的：<code>element.dataset.index</code> 或<code>element.dataset['index']</code> IE11才开始支持</li></ul><h1 id="五、节点操作"><a href="#五、节点操作" class="headerlink" title="五、节点操作"></a>五、节点操作</h1><p>获取元素通常使用两种方式:</p><ol><li><p>利用DOM提供的方法获取元素，缺点：逻辑性不强、繁琐</p><ul><li><code>document.getElementByld()</code></li><li><code>document.getElementsByTagName()</code></li><li><code>document.querySelector()</code></li></ul></li><li><p>利用 <strong>节点层级关系</strong> 获取元素</p><ul><li>利用父子兄节点关系获取元素</li><li>优点：逻辑性强</li><li>缺点：兼容性稍差</li></ul></li></ol><h2 id="1-节点概述"><a href="#1-节点概述" class="headerlink" title="1. 节点概述"></a>1. 节点概述</h2><p>网页中的<strong>所有内容都是节点（标签、属性、文本、注释等）</strong>，在DOM 中，节点使用 node 来表示。</p><p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><p>一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点：nodeType 为1</li><li>属性节点：nodeType 为2</li><li>文本节点：nodeType 为3(文本节点包括文字、空格、换行等)</li></ul><p>我们在实际开发中，节点操作主要操作的是<strong>元素节点</strong>。</p><h2 id="2-节点层级"><a href="#2-节点层级" class="headerlink" title="2. 节点层级"></a>2. 节点层级</h2><p>利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p><h3 id="2-1-父级节点"><a href="#2-1-父级节点" class="headerlink" title="2.1 父级节点"></a>2.1 父级节点</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.parentNode</code></pre><ul><li><code>parentNode</code>属性可以返回某节点的父结点，注意是<strong>最近的一个父结点</strong></li><li>如果指定的节点没有父结点则返回null</li></ul><h3 id="2-2-子结点"><a href="#2-2-子结点" class="headerlink" title="2.2 子结点"></a>2.2 子结点</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.childNodes(标准)</code></pre><ul><li><code>parentNode.childNodes</code> 返回包含指定节点的子节点的集合，该集合为即时更新的集合</li><li>返回值<strong>包含了所有的子结点</strong>，包括元素节点，文本节点等</li><li>如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用<code>childNodes</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.children(非标准)</code></pre><ul><li><code>parentNode.children</code> 是一个只读属性，返回所有的子元素节点</li><li>它只返回子元素节点，其余节点不返回 （<strong>这个是我们重点掌握的</strong>）</li><li>虽然 children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;span&gt;我是span&lt;/span&gt;    &lt;ul&gt;        &lt;li&gt;我是li&lt;/li&gt;        &lt;li&gt;我是li&lt;/li&gt;        &lt;li&gt;我是li&lt;/li&gt;        &lt;li&gt;我是li&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt; &lt;li&gt;我是li&lt;/li&gt;     &lt;li&gt;我是li&lt;/li&gt;     &lt;li&gt;我是li&lt;/li&gt;     &lt;li&gt;我是li&lt;/li&gt;     &lt;/ol&gt;    &lt;div class="demo"&gt;        &lt;div class="box"&gt;            &lt;span class="erweima"&gt;×&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 1. 父节点 parentNode        var erweima = document.querySelector('.erweima');        console.log(erweima.parentNode); //得到的是离元素最近的父级节点(亲爸爸)box                var ul = document.querySelector('ul');        // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等        console.log(ul.childNodes);        // 2. children 获取所有的子元素节点 也是我们实际开发常用的        console.log(ul.children);    &lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="2-2-1-第一个子结点"><a href="#2-2-1-第一个子结点" class="headerlink" title="2.2.1 第一个子结点"></a>2.2.1 第一个子结点</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.firstChild</code></pre><ul><li><code>firstChild</code> 返回第一个子节点，找不到则返回null</li><li>同样，也是包含所有的节点（空格、换行）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.firstElementChild</code></pre><ul><li><code>firstElementChild</code> 返回第一个子元素节点，找不到则返回null</li></ul><h4 id="2-2-2-最后一个子结点"><a href="#2-2-2-最后一个子结点" class="headerlink" title="2.2.2 最后一个子结点"></a>2.2.2 最后一个子结点</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.lastChild</code></pre><ul><li><code>lastChild</code> 返回最后一个子节点，找不到则返回null</li><li>同样，也是包含所有的节点（空格、换行）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">parentNode.lastElementChild</code></pre><ul><li><code>lastElementChild</code> 返回最后一个子元素节点，找不到则返回null</li></ul><h3 id="2-3-兄弟节点"><a href="#2-3-兄弟节点" class="headerlink" title="2.3 兄弟节点"></a>2.3 兄弟节点</h3><h4 id="2-3-1-下一个兄弟节点"><a href="#2-3-1-下一个兄弟节点" class="headerlink" title="2.3.1 下一个兄弟节点"></a>2.3.1 下一个兄弟节点</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.nextSibling</code></pre><ul><li><code>nextSibling</code> 返回当前元素的下一个兄弟元素节点，找不到则返回null</li><li>同样，也是<strong>包含所有的节点</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.nextElementSibling</code></pre><ul><li><code>nextElementSibling</code> 返回当前元素下一个兄弟元素节点，找不到则返回null</li></ul><h4 id="2-3-2-上一个兄弟节点"><a href="#2-3-2-上一个兄弟节点" class="headerlink" title="2.3.2 上一个兄弟节点"></a>2.3.2 上一个兄弟节点</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.previousSibling</code></pre><ul><li><code>previousSibling</code> 返回当前元素上一个兄弟元素节点，找不到则返回null</li><li>同样，也是<strong>包含所有的节点</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.previousElementSibling</code></pre><ul><li><code>previousElementSibling</code> 返回当前元素上一个兄弟元素节点，找不到则返回null</li></ul><h2 id="3-创建节点"><a href="#3-创建节点" class="headerlink" title="3. 创建节点"></a>3. 创建节点</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.createElement('tagName');</code></pre><ul><li><code>document.createElement()</code> 方法创建由 tagName 指定的HTML 元素</li><li>因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为<strong>动态创建元素节点</strong></li></ul><h3 id="3-1-添加节点"><a href="#3-1-添加节点" class="headerlink" title="3.1 添加节点"></a>3.1 添加节点</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.appendChild(child)</code></pre><ul><li><code>node.appendChild()</code> 方法将一个节点添加到指定父节点的子节点列表<strong>末尾</strong>。类似于 CSS 里面的 after 伪元素。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.insertBefore(child,指定元素)</code></pre><ul><li><code>node.insertBefore()</code> 方法将一个节点添加到父节点的<strong>指定子节点前面</strong>。类似于 CSS 里面的 before 伪元素。</li></ul><h3 id="3-2-删除节点"><a href="#3-2-删除节点" class="headerlink" title="3.2 删除节点"></a>3.2 删除节点</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.removeChild(child)</code></pre><ul><li><code>node.removeChild()</code>方法从 DOM 中删除一个子节点，返回删除的节点</li></ul><h3 id="3-3-复制节点-克隆节点"><a href="#3-3-复制节点-克隆节点" class="headerlink" title="3.3 复制节点(克隆节点)"></a>3.3 复制节点(克隆节点)</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">node.cloneNode()</code></pre><ul><li><code>node.cloneNode()</code>方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点</li><li>如果括号参数为<strong>空或者 false</strong> ，则是<strong>浅拷贝</strong>，即只克隆复制节点本身，不克隆里面的子节点</li><li>如果括号参数为 <strong>true</strong> ，则是<strong>深拷贝</strong>，会复制节点==本身以及里面所有的子节点==</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>三种动态创建元素的区别</p><ul><li>doucument.write()</li><li>element.innerHTML</li><li>document.createElement()</li></ul><p>区别：</p><ul><li><code>document.write()</code> 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li><li><code>innerHTML</code> 是将内容写入某个 DOM 节点，不会导致页面全部重绘<ul><li><code>innerHTML</code> 创建多个元素效率更高（<strong>不要拼接字符串，采取数组形式拼接</strong>），结构稍微复杂</li></ul></li><li><code>createElement()</code>创建多个元素效率稍低一点点，但是结构更清晰</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div class="innner"&gt;&lt;/div&gt;    &lt;div class="create"&gt;&lt;/div&gt;    &lt;script&gt;        // 2. innerHTML 创建元素        var inner = document.querySelector('.inner');        // 2.1 innerHTML 用拼接字符串方法        for (var i = 0; i &lt;= 100; i++) {            inner.innerHTML += '&lt;a href="#"&gt;百度&lt;/a&gt;';        }        // 2.2 innerHTML 用数组形式拼接        var arr = [];        for (var i = 0; i &lt;= 100; i++) {            arr.push('&lt;a href="#"&gt;百度&lt;/a&gt;');        }        inner.innerHTML = arr.join('');        // 3.document.createElement() 创建元素        var create = document.querySelector('.create');        var a = document.createElement('a');        create.appendChild(a);    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="六、DOM核心"><a href="#六、DOM核心" class="headerlink" title="六、DOM核心"></a>六、DOM核心</h1><p>对于DOM操作，我们主要针对子元素的操作，主要有</p><ul><li>创建</li><li>增</li><li>删</li><li>改</li><li>查</li><li>属性操作</li><li>事件操作</li></ul><h2 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h2><ol><li>document.write</li><li>innerHTML</li><li>createElement</li></ol><h2 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h2><ol><li>appendChild</li><li>insertBefore</li></ol><h2 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h2><ol><li>removeChild</li></ol><h2 id="6-4-改"><a href="#6-4-改" class="headerlink" title="6.4 改"></a>6.4 改</h2><ul><li>主要修改dom的元素属性，dom元素的内容、属性、表单的值等</li></ul><ol><li>修改元素属性：src、href、title 等</li><li>修改普通元素内容：innerHTML、innerText</li><li>修改表单元素：value、type、disabled</li><li>修改元素样式：style、className</li></ol><h2 id="6-5-查"><a href="#6-5-查" class="headerlink" title="6.5 查"></a>6.5 查</h2><ul><li>主要获取查询dom的元素</li></ul><ol><li><strong>DOM提供的API方法</strong>：getElementById、getElementsByTagName (古老用法，不推荐)</li><li><strong>H5提供的新方法</strong>：querySelector、querySelectorAll (提倡)</li><li>利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling) 提倡</li></ol><h2 id="6-6-属性操作"><a href="#6-6-属性操作" class="headerlink" title="6.6 属性操作"></a>6.6 属性操作</h2><ul><li>主要针对于自定义属性</li></ul><ol><li>setAttribute：设置dom的属性值</li><li>getAttribute：得到dom的属性值</li><li>removeAttribute：移除属性</li></ol><h1 id="七、事件高级"><a href="#七、事件高级" class="headerlink" title="七、事件高级"></a>七、事件高级</h1><h2 id="1-注册事件-绑定事件"><a href="#1-注册事件-绑定事件" class="headerlink" title="1. 注册事件(绑定事件)"></a>1. 注册事件(绑定事件)</h2><p>给元素添加事件，称为注册事件或者绑定事件。</p><p>注册事件有两种方式：<strong>传统方式</strong>和<strong>方法监听注册方式</strong></p><table><thead><tr><th>传统注册方式</th><th>方法监听注册方式</th></tr></thead><tbody><tr><td>利用 on 开头的事件 onclick</td><td>w3c 标准推荐方式</td></tr><tr><td><code>&lt;button onclick = "alert("hi")"&gt;&lt;/button&gt;</code></td><td>addEventListener() 它是一个方法</td></tr><tr><td>btn.onclick = function() {}</td><td>IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替</td></tr><tr><td>特点：注册事件的<strong>唯一性</strong></td><td>特点：同一个元素同一个事件可以<strong>注册多个监听器</strong></td></tr><tr><td>同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数</td><td>按注册顺序依次执行</td></tr></tbody></table><h3 id="1-1-addEventListener事件监听方式"><a href="#1-1-addEventListener事件监听方式" class="headerlink" title="1.1 addEventListener事件监听方式"></a>1.1 addEventListener事件监听方式</h3><ul><li><code>eventTarget.addEventListener()</code>方法将指定的监听器注册到 eventTarget（目标对象）上</li><li>当该对象触发指定的事件时，就会执行事件处理函数</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.addEventListener(type,listener[,useCapture])</code></pre><p>该方法接收三个参数：</p><ul><li><code>type</code>:事件类型字符串，比如click,mouseover,注意这里<strong>不要带on</strong></li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习</li></ul><h3 id="attachEvent事件监听方式-兼容"><a href="#attachEvent事件监听方式-兼容" class="headerlink" title="attachEvent事件监听方式(兼容)"></a>attachEvent事件监听方式(兼容)</h3><ul><li><code>eventTarget.attachEvent()</code>方法将指定的监听器注册到 eventTarget（目标对象） 上</li><li>当该对象触发指定的事件时，指定的回调函数就会被执行</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.attachEvent(eventNameWithOn,callback)</code></pre><p>该方法接收两个参数：</p><ul><li><code>eventNameWithOn</code>：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on</li><li><code>callback</code>： 事件处理函数，当目标触发事件时回调函数被调用</li><li>ie9以前的版本支持</li></ul><h2 id="2-删除事件-解绑事件"><a href="#2-删除事件-解绑事件" class="headerlink" title="2. 删除事件(解绑事件)"></a>2. 删除事件(解绑事件)</h2><h3 id="2-1-removeEventListener删除事件方式"><a href="#2-1-removeEventListener删除事件方式" class="headerlink" title="2.1 removeEventListener删除事件方式"></a>2.1 removeEventListener删除事件方式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.removeEventListener(type,listener[,useCapture]);</code></pre><p>该方法接收三个参数：</p><ul><li><code>type</code>:事件类型字符串，比如click,mouseover,注意这里<strong>不要带on</strong></li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习</li></ul><h3 id="2-2-detachEvent删除事件方式-兼容"><a href="#2-2-detachEvent删除事件方式-兼容" class="headerlink" title="2.2 detachEvent删除事件方式(兼容)"></a>2.2 detachEvent删除事件方式(兼容)</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.detachEvent(eventNameWithOn,callback);</code></pre><p>该方法接收两个参数：</p><ul><li><code>eventNameWithOn</code>：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on</li><li><code>callback</code>： 事件处理函数，当目标触发事件时回调函数被调用</li><li>ie9以前的版本支持</li></ul><h3 id="2-3-传统事件删除方式"><a href="#2-3-传统事件删除方式" class="headerlink" title="2.3 传统事件删除方式"></a>2.3 传统事件删除方式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.onclick = null;</code></pre><h2 id="3-DOM事件流"><a href="#3-DOM事件流" class="headerlink" title="3. DOM事件流"></a>3. DOM事件流</h2><ul><li>事件流描述的是从页面中<strong>接收事件的顺序</strong></li><li>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</li></ul><p><strong>DOM 事件流分为3个阶段：</strong></p><ol><li>捕获阶段 </li><li>当前目标阶段 </li><li>冒泡阶段</li></ol><p><img src="0f062537d4634efcae5e1d1a20fa3d72.png" alt="在这里插入图片描述"></p><ul><li>==事件冒泡==： IE 最早提出，事件开始时由<strong>最具体的元素接收</strong>，然后逐级<strong>向上</strong>传播到到 DOM 最顶层节点的过程。</li><li>==事件捕获==： 网景最早提出，由 DOM <strong>最顶层</strong>节点开始，然后逐级<strong>向下</strong>传播到到最具体的元素接收的过程。</li></ul><p><strong>加深理解</strong>：<br>我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</p><p><img src="167fad1439cc40969c9257fccd27a866.png" alt="在这里插入图片描述"></p><h3 id="3-1-应用说明"><a href="#3-1-应用说明" class="headerlink" title="3.1 应用说明"></a>3.1 应用说明</h3><ul><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段</li><li><code>onclick</code> 和 <code>attachEvent</code>只能得到冒泡阶段</li><li><code>addEventListener(type,listener[,useCapture])</code>第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false)，表示在事件冒泡阶段调用事件处理程序</li><li>实际开发中我们很少使用事件捕获，我们<strong>更关注事件冒泡</strong>。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ul><h3 id="3-2-捕获阶段"><a href="#3-2-捕获阶段" class="headerlink" title="3.2 捕获阶段"></a>3.2 捕获阶段</h3><ul><li>document -&gt; html -&gt; body -&gt; father -&gt; son</li></ul><p>两个盒子嵌套，一个父盒子一个子盒子，我们的需求是当点击父盒子时弹出 father ，当点击子盒子时弹出 son</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector('.son');        var father = document.querySelector('.father');                son.addEventListener('click', function() {             alert('son');        }, true); // 捕获阶段        father.addEventListener('click', function() {            alert('father');        }, true);    &lt;/script&gt;&lt;/body&gt;</code></pre><p>但是因为DOM流的影响，我们点击子盒子，会先弹出 father，之后再弹出 son</p><p>这是因为捕获阶段由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收</p><ul><li>document -&gt; html -&gt; body -&gt; father -&gt; son</li><li>先看 document 的事件，没有；再看 html 的事件，没有；再看 body 的事件，没有；再看 father 的事件，有就先执行；再看 son 的事件，再执行。</li></ul><h3 id="3-3-冒泡阶段"><a href="#3-3-冒泡阶段" class="headerlink" title="3.3 冒泡阶段"></a>3.3 冒泡阶段</h3><ul><li>son -&gt; father -&gt;body -&gt; html -&gt; document</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector('.son');        var father = document.querySelector('.father');                son.addEventListener('click', function() {            alert('son');        }, false); // 冒泡阶段        father.addEventListener('click', function() {            alert('father');        }, false);        document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>我们点击子盒子，会弹出 son、father、document</p><p>这是因为冒泡阶段开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点</p><ul><li>son -&gt; father -&gt;body -&gt; html -&gt; document</li></ul><h2 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4. 事件对象"></a>4. 事件对象</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">eventTarget.onclick = function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt } eventTarget.addEventListener('click', function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  })</code></pre><ul><li>官方解释：event 对象代表<strong>事件的状态</strong>，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</li><li>简单理解：<ul><li>事件发生后，<strong>跟事件相关的一系列信息数据</strong>的集合都放到这个对象里面</li><li>这个对象就是事件对象 event，它有很多属性和方法，比如：<ul><li>谁绑定了这个事件</li><li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置</li><li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</li></ul></li></ul></li><li>这个 event 是个<strong>形参</strong>，系统帮我们设定为事件对象，<strong>不需要传递实参</strong>过去</li><li>当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</li></ul><h3 id="4-1-事件对象的常见属性和方法"><a href="#4-1-事件对象的常见属性和方法" class="headerlink" title="4.1 事件对象的常见属性和方法"></a>4.1 事件对象的常见属性和方法</h3><table><thead><tr><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr><td><code>e.target</code></td><td>返回触发事件的对象（标准）</td></tr><tr><td><code>e.srcElement</code></td><td>返回触发事件的对象（非标准）</td></tr><tr><td><code>e.type</code></td><td>返回事件类型</td></tr><tr><td><code>e.preventDefault()</code></td><td>阻止默认事件（标准）让链接不跳转、让提交按钮不提交</td></tr><tr><td><code>e.returnValue = true</code></td><td>阻止默认事件（非标准，IE678）</td></tr><tr><td><code>e.stopPropagation()</code></td><td>阻止冒泡（标准）</td></tr><tr><td><code>e.cancelBubble</code></td><td>阻止冒泡（非标准，IE678）</td></tr></tbody></table><p><code>e.target</code> 和 <code>this</code> 的区别：</p><ul><li>this 是事件绑定的元素， 这个<strong>函数的调用者</strong>（绑定这个事件的元素）</li><li>e.target 是<strong>事件触发的元素</strong>。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div&gt;123&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 区别 ： e.target 点击了那个元素，就返回那个元素 this 那个元素绑定了这个点击事件，那么就返回谁        var div = document.querySelector('div');        div.addEventListener('click', function(e) {            console.log(e.target); // div            console.log(this); // div        })                var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {                // 我们给ul 绑定了事件  那么this 就指向ul                  console.log(this);                // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li                console.log(e.target);            })    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="4-2-事件对象阻止默认行为"><a href="#4-2-事件对象阻止默认行为" class="headerlink" title="4.2 事件对象阻止默认行为"></a>4.2 事件对象阻止默认行为</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;    &lt;form action="http://www.baidu.com"&gt;        &lt;input type="submit" value="提交" name="sub"&gt;    &lt;/form&gt;    &lt;script&gt;        // 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交        var a = document.querySelector('a');        a.addEventListener('click', function(e) {                e.preventDefault(); //  dom 标准写法            })    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="4-3-阻止事件冒泡"><a href="#4-3-阻止事件冒泡" class="headerlink" title="4.3 阻止事件冒泡"></a>4.3 阻止事件冒泡</h3><p>事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点</p><p>事件冒泡本身的特性，会带来的<strong>坏处</strong>，也会带来的<strong>好处</strong>，需要我们灵活掌握。</p><ul><li><p>标准写法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">e.stopPropagation();</code></pre></li><li><p>非标准写法： IE6-8 利用对象事件 cancelBubble属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">e.cancelBubble = true;</code></pre></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;         var son = document.querySelector('.son');        son.addEventListener('click', function(e) {            alert('son');            e.stopPropagation(); // 阻止冒泡        }, false);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);                document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>此时点击son只会弹出son，而点击father会弹出father和document</p><h2 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5. 事件委托"></a>5. 事件委托</h2><ul><li>事件委托也称为事件代理，在 jQuery 里面称为事件委派</li><li>事件委托的原理<ul><li><strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></li><li>作用：我们 <strong>只操作了一次 DOM ，提高了程序的性能。</strong></li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';            // 点了谁，就让谁的style里面的backgroundColor颜色变为pink        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，<strong>事件会冒泡到 ul 上</strong>， ul 有注册事件，就会触发事件监听器。</p><h2 id="6-常见的鼠标事件"><a href="#6-常见的鼠标事件" class="headerlink" title="6. 常见的鼠标事件"></a>6. 常见的鼠标事件</h2><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击左键触发</td></tr><tr><td>onmouseover</td><td>鼠标经过触发</td></tr><tr><td>onmouseout</td><td>鼠标离开触发</td></tr><tr><td>onfocus</td><td>获得鼠标焦点触发</td></tr><tr><td>onblur</td><td>失去鼠标焦点触发</td></tr><tr><td>onmousemove</td><td>鼠标移动触发</td></tr><tr><td>onmouseup</td><td>鼠标弹起触发</td></tr><tr><td>onmousedown</td><td>鼠标按下触发</td></tr><tr><td><strong>mouseenter / mouseleave 鼠标事件</strong></td><td></td></tr></tbody></table><ul><li><code>mouseenter</code> 事件：鼠标移动到元素上</li><li><code>mouseleave</code>事件：鼠标离开元素</li><li>类似 <code>mouseover</code>，它们两者之间的差别是<ul><li><code>mouseover</code> 鼠标经过自身盒子会触发，经过子盒子还会触发。<code>mouseenter</code> 只会经过自身盒子触发</li><li>因为 <code>mouseenter</code> <strong>不会冒泡</strong>，<code>mouseleave</code>同理</li></ul></li></ul><h3 id="6-1-禁止鼠标右键与鼠标选中"><a href="#6-1-禁止鼠标右键与鼠标选中" class="headerlink" title="6.1 禁止鼠标右键与鼠标选中"></a>6.1 禁止鼠标右键与鼠标选中</h3><ul><li><code>contextmenu</code>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</li><li><code>selectstart</code> 禁止鼠标选中</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;    &lt;h1&gt;我是一段不愿意分享的文字&lt;/h1&gt;    &lt;script&gt;        // 1. contextmenu 我们可以禁用右键菜单        document.addEventListener('contextmenu', function(e) {                e.preventDefault(); // 阻止默认行为            })        // 2. 禁止选中文字 selectstart        document.addEventListener('selectstart', function(e) {            e.preventDefault();        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="6-2-鼠标事件对象"><a href="#6-2-鼠标事件对象" class="headerlink" title="6.2 鼠标事件对象"></a>6.2 鼠标事件对象</h3><ul><li><strong>event</strong>对象代表事件的状态，跟事件相关的一系列信息的集合</li><li>现阶段我们主要是用鼠标事件对象 <strong>MouseEvent</strong> 和键盘事件对象 <strong>KeyboardEvent。</strong></li></ul><table><thead><tr><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr><td>e.clientX</td><td>返回鼠标相对于浏览器窗口<strong>可视区</strong>的X坐标</td></tr><tr><td>e.clientY</td><td>返回鼠标相对于浏览器窗口<strong>可视区</strong>的Y坐标</td></tr><tr><td>e.pageX（重点）</td><td>返回鼠标相对于<strong>文档页面</strong>的X坐标</td></tr><tr><td>e.pageY（重点）</td><td>返回鼠标相对于<strong>文档页面</strong>的Y坐标</td></tr><tr><td>e.screenX</td><td>返回鼠标相对于<strong>电脑屏幕</strong>的X坐标</td></tr><tr><td>e.screenY</td><td>返回鼠标相对于<strong>电脑屏幕</strong>的Y坐标</td></tr></tbody></table><p><strong>案例：跟随鼠标的天使</strong><br>这个天使图片一直跟随鼠标移动</p><ol><li>鼠标不断的移动，使用鼠标移动事件： mousemove </li><li>在页面中移动，给document注册事件</li><li>图片要移动距离，而且不占位置，我们使用绝对定位即可</li><li>核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的 top和left 值就可以移动图片</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;style&gt;img {position: absolute;}&lt;/style&gt;&lt;body&gt;&lt;img src="images/angel.gif" alt=""&gt;&lt;script&gt;var img = document.querySelector('img');document.addEventListener('mousemove', function (e) {var x = e.pageX;var y = e.pageY;img.style.top = y - 40 + 'px'; // 减去图片高度的一半img.style.left = x - 50 + 'px'; // 减去图片长度的一半});&lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="7-常用的键盘事件"><a href="#7-常用的键盘事件" class="headerlink" title="7. 常用的键盘事件"></a>7. 常用的键盘事件</h2><table><thead><tr><th>键盘事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键被松开时触发</td></tr><tr><td>onkeydown</td><td>某个键盘按键被按下时触发</td></tr><tr><td>onkeypress</td><td>某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl shift 箭头等</td></tr></tbody></table><ul><li><strong>如果使用addEventListener 不需要加 on</strong></li><li><code>onkeypress</code> 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等</li><li>三个事件的执行顺序是： keydown – keypress – keyup</li></ul><h3 id="7-1-键盘对象属性"><a href="#7-1-键盘对象属性" class="headerlink" title="7.1 键盘对象属性"></a>7.1 键盘对象属性</h3><p><code>e.key</code> 返回键值，可区分大小写<br><code>e.code</code> 返回键值，如按下s，返回KeyS，不区分大小写</p><ul><li>在我们实际开发中，我们更多的使用<code>keydown</code>和<code>keyup</code>， 它能识别所有的键（包括功能键）</li></ul><h4 id="案例：-模拟京东按键输入内容"><a href="#案例：-模拟京东按键输入内容" class="headerlink" title="案例： 模拟京东按键输入内容"></a>案例： 模拟京东按键输入内容</h4><p>当我们按下 s / S 键， 光标就定位到搜索框</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;&lt;input type="text"&gt;&lt;script&gt;var search = document.querySelector('input');document.addEventListener('keyup', function (e) {if (e.code == 'KeyS') { // 注意此处search.focus();}})&lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="案例：-模拟京东快递单号查询"><a href="#案例：-模拟京东快递单号查询" class="headerlink" title="案例： 模拟京东快递单号查询"></a>案例： 模拟京东快递单号查询</h4><p>当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</p><ol><li>快递单号输入内容时， 上面的大号字体盒子（con）显示<ol><li>同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容 </li><li>如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子</li></ol></li><li>注意： <ol><li>keydown 和 keypress他们两个事件触发的时候，<strong>文字还没有落入文本框中</strong></li><li>keyup事件触发的时候，<strong>文字已经落入文本框里面了</strong></li></ol></li><li>当我们失去焦点，就隐藏这个con盒子</li><li>当我们获得焦点，并且文本框内容不为空，就显示这个con盒子</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;body&gt;&lt;div class="search"&gt;&lt;div class="con"&gt;123&lt;/div&gt;&lt;input type="text" placeholder="请输入您的快递单号" class="jd"&gt;&lt;/div&gt;&lt;script&gt;var con = document.querySelector('.con');var jd_input = document.querySelector('.jd');jd_input.addEventListener('keyup', function () {if (this.value === '') {con.style.display = 'none';} else {con.style.display = 'block';con.innerHTML = this.value;}})jd_input.addEventListener('blur', function () {con.style.display = 'none';})        jd_input.addEventListener('focus', function () {if (this.value !== '') {con.style.display = 'block';}})&lt;/script&gt;&lt;/body&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础（三）对象与内置对象</title>
      <link href="/2023/01/05/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/01/05/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h1><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p><p>对象是由<strong>属性和方法</strong>组成的：</p><ul><li>属性：事物的<strong>特征</strong>（常用名词）</li><li>方法：事物的<strong>行为</strong>（常用动词）</li></ul><h2 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a>1. 创建对象</h2><p>在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：</p><ul><li>利用<strong>字面量</strong>创建对象</li><li>利用 <strong>new Object</strong>创建对象</li><li>利用<strong>构造函数</strong>创建对象</li></ul><h3 id="1-1-利用字面量创建对象"><a href="#1-1-利用字面量创建对象" class="headerlink" title="1.1 利用字面量创建对象"></a>1.1 利用字面量创建对象</h3><p>对象字面量：就是花括号 <code>{}</code> 里面包含了表达这个具体事物（对象）的属性和方法</p><p><code>{}</code> 里面采取键值对的形式表示</p><ul><li>键：相当于属性名</li><li>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var star = {    name : 'pink',    age : 18,    sex : '男',    sayHi : function(){        alert('大家好啊~');    }};// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数</code></pre><h4 id="对象的调用"><a href="#对象的调用" class="headerlink" title="对象的调用"></a>对象的调用</h4><ul><li>对象里面的属性调用 : ==对象.属性名== ，这个小点 . 就理解为“ <strong>的</strong> ”</li><li>对象里面属性的另一种调用方式 : ==对象[‘属性名’]==，注意方括号里面的属性必须<strong>加引号</strong>，我们后面会用</li><li>对象里面的方法调用：==对象.方法名()== ，注意这个方法名字后面<strong>一定加括号</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(star.name)     // 调用名字属性console.log(star['name'])  // 调用名字属性star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号</code></pre><h4 id="变量、属性、函数、方法总结"><a href="#变量、属性、函数、方法总结" class="headerlink" title="变量、属性、函数、方法总结"></a>变量、属性、函数、方法总结</h4><ul><li>变量：单独声明赋值，单独存在</li><li>属性：<strong>对象里面的变量</strong>称为属性，不需要声明，用来描述该对象的特征</li><li>函数：单独存在的，通过==“函数名()”==的方式就可以调用</li><li>方法：<strong>对象里面的函数</strong>称为方法，方法不需要声明，使用==“对象.方法名()”==的方式就可以调用，方法用来描述该对象的行为和功能。</li></ul><h3 id="1-2-利用-new-Object-创建对象"><a href="#1-2-利用-new-Object-创建对象" class="headerlink" title="1.2 利用 new Object 创建对象"></a>1.2 利用 new Object 创建对象</h3><p>跟之前的 <code>new Array()</code> 原理一致：<code>var 对象名 = new Object();</code></p><p>使用的格式：对象.属性 = 值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj = new Object(); //创建了一个空的对象obj.name = '张三';obj.age = 18;obj.sex = '男';obj.sayHi = function() {    console.log('hi~');}//1.我们是利用等号赋值的方法添加对象//2.每个属性和方法之间用分号结束console.log(obj.name);console.log(obj['sex']);obj.sayHi();</code></pre><h3 id="1-3-利用构造函数创建对象"><a href="#1-3-利用构造函数创建对象" class="headerlink" title="1.3 利用构造函数创建对象"></a>1.3 利用构造函数创建对象</h3><p>构造函数 ：是一种特殊的函数，主要用来初始化对象，即<strong>为对象成员变量赋初始值</strong>，它总与 <code>new</code> 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//构造函数的语法格式function 构造函数名() {    this.属性 = 值;    this.方法 = function() {}}new 构造函数名();</code></pre><p>在 js 中，使用构造函数要时要注意以下两点：</p><ul><li>构造函数用于<strong>创建某一类对象</strong>，其<strong>首字母要大写</strong></li><li>构造函数要和 new 一起使用才有意义</li><li>函数内的属性和方法前面需要<strong>添加 this</strong> ，表示当前对象的属性和方法。</li><li>构造函数中<strong>不需要 return</strong> 返回结果。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1. 构造函数名字首字母要大写//2. 构造函数不需要return就可以返回结果//3. 调用构造函数必须使用 new//4. 我们只要new Star() 调用函数就创建了一个对象//5. 我们的属性和方法前面必须加thisfunction Star(uname,age,sex) {    this.name = uname;    this.age = age;    this.sex = sex;    this.sing = function(sang){        console.log(sang);    }}var ldh = new Star('刘德华',18,'男');console.log(typeof ldh) // object对象，调用函数返回的是对象console.log(ldh.name);console.log(ldh['sex']);ldh.sing('冰雨'); //把冰雨传给了sangvar zxy = new Star('张学友',19,'男');</code></pre><h4 id="构造函数和对象"><a href="#构造函数和对象" class="headerlink" title="构造函数和对象"></a>构造函数和对象</h4><ul><li>构造函数，如 Stars()，<strong>抽象了对象的公共部分</strong>，封装到了函数里面，它<strong>泛指某一大类</strong>（class）</li><li>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为<strong>对象实例化</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/2faf15c63b204476a628c1d24d6825a0.png#pic_center" alt="在这里插入图片描述"></p><h4 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h4><p>new 在执行时会做四件事:</p><ol><li>在内存中创建一个新的空对象。</li><li><strong>让 this 指向这个新的对象</strong>。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法</li><li>返回这个新对象（所以构造函数里面不需要return）</li></ol><h2 id="2-遍历对象的属性"><a href="#2-遍历对象的属性" class="headerlink" title="2. 遍历对象的属性"></a>2. 遍历对象的属性</h2><ul><li><code>for...in</code> 语句用于对数组或者对象的属性进行循环操作</li><li><strong>对象有几个属性，循环就会执行几次</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for(变量 in 对象名字){    // 在此执行代码}</code></pre><p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 <code>k</code> 或者 <code>key</code>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for(var k in obj) {    console.log(k);//这里的 k 是属性名    console.log(obj[k]);//这里的 obj[k] 是属性值}</code></pre><p><strong>案例：</strong></p><p>找出未交作业的学生</p><ul><li>拿所有学生的名单与交作业的学生名单一一匹配</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = ["张瑞淑", "徐海涛", "谢岗岗", "薛鹏", "魏明杨", "党婷", "熊飞", "郑翠翠", "李航卫", '张大大', "屈涛", "汪孝双", "代攀飞", "武志钰"];var currentArr = ["张瑞淑", "徐海涛", "谢岗岗", "魏明杨", "党婷", "熊飞", "郑翠翠"];function choose(arr, currentArr) {var flag = false;var newArr = new Array();for (var i = 0; i &lt; arr.length; i++) {for (var j = 0; j &lt; currentArr.length; j++) {if (arr[i] === currentArr[j]) {flag = false;break;} else {flag = true;}}if (flag === true) {newArr[newArr.length] = arr[i];}}return newArr;}var mindan = choose(arr, currentArr);console.log(mindan);</code></pre><h1 id="二、内置对象"><a href="#二、内置对象" class="headerlink" title="二、内置对象"></a>二、内置对象</h1><ul><li>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象</li><li>内置对象就是指 <strong>JS 语言自带的一些对象</strong>，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能</li><li>JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</li></ul><h2 id="1-查文档"><a href="#1-查文档" class="headerlink" title="1. 查文档"></a>1. 查文档</h2><p>学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询</p><p>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><p>学习对象中的方法：</p><ol><li>查阅该方法的功能</li><li>查看里面参数的意义和类型</li><li>查看返回值的意义和类型</li><li>通过 demo 进行测试</li></ol><h2 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2. Math对象"></a>2. Math对象</h2><p>Math 对象<strong>不是构造函数</strong>，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// Math数学对象，不是一个构造函数，所以我们不需要new 来调用，而是直接使用里面的属性和方法即可Math.PI // 圆周率Math.floor()  // 向下取整Math.ceil()             // 向上取整Math.round()            // 四舍五入版Math.abs() // 绝对值Math.max()/Math.min()// 求最大和最小值 </code></pre><p><strong>练习：封装自己的数学对象</strong></p><p>利用对象封装自己的数学对象，里面有PI 最大值 和最小值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var myMath = {    PI: 3.141592653,    max: function() {        var max = arguments[0];        for (var i = 1; i &lt; arguments.length; i++) {            if (arguments[i] &gt; max) {                max = arguments[i];            }        }        return max;    },    min: function() {        var min = arguments[0];        for (var i = 1; i &lt; arguments.length; i++) {            if (arguments[i] &lt; min) {                min = arguments[i];            }        }        return min;    }}console.log(myMath.PI);console.log(myMath.max(1, 5, 9));console.log(myMath.min(1, 5, 9));</code></pre><h3 id="2-1-Math绝对值和取整"><a href="#2-1-Math绝对值和取整" class="headerlink" title="2.1 Math绝对值和取整"></a>2.1 Math绝对值和取整</h3><ul><li><code>Math.abs()</code> 取绝对值</li><li>三个取整方法：<ul><li><code>Math.floor()</code> : 向下取整</li><li><code>Math.ceil()</code> : 向上取整</li><li><code>Matg.round()</code> : 四舍五入</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">//1.绝对值方法console.log(Math.abs(-1)); // 1console.log(Math.abs('-1')); // 1 隐式转换，会把字符串 -1 转换为数字型console.log(Math.abs('pink')); //NaN//2.三个取整方法console.log(Math.floor(1.1)); // 1 向下取整，向最小的取值 floor-地板console.log(Math.floor(1.9)); //1console.log(Math.ceil(1.1)); //2 向上取整，向最大的取值 ceil-天花板console.log(Math.ceil(1.9)); //2 //四舍五入console.log(Math.round(1.1)); //1 四舍五入console.log(Math.round(1.5)); //2console.log(Math.round(-1.1)); // -1console.log(Math.round(-1.5)); // -1 .5往大了取</code></pre><h3 id="2-2-随机数方法random"><a href="#2-2-随机数方法random" class="headerlink" title="2.2 随机数方法random()"></a>2.2 随机数方法random()</h3><ul><li>random() 方法可以随机返回一个小数，其取值范围是<code> [0，1)</code>，左闭右开 0 &lt;= x &lt; 1</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 得到两个数之间的随机整数，并且包含这两个整数function getRandom(min,max) {    return Math.floor(Math.random() * (max - min + 1)) + min;}console.log(getRandom(1,10));</code></pre><p><strong>1.随机点名</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = ['张三', '李四','王五','秦六']；console.log(arr[getRandom(0, arr.length - 1)]);</code></pre><p><strong>2.猜数字游戏</strong></p><p>程序随机生成一个 1~ 10 之间的数字，并让用户输入一个数字，</p><ol><li>如果大于该数字，就提示，数字大了，继续猜；</li><li>如果小于该数字，就提示数字小了，继续猜；</li><li>如果等于该数字，就提示猜对了， 结束程序。。</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var random = getRandom(1,10);while(true) { //死循环 ，需要退出循环条件     var num = prompt('请输入1~10之间的一个整数:');     if(num &gt; random) {         alert('你猜大了');     }else if (num &lt; random) {         alert('你猜小了');     }else {         alert('你猜中了');         break; //退出整个循环     }}</code></pre><h2 id="3-Data-日期对象"><a href="#3-Data-日期对象" class="headerlink" title="3. Data()日期对象"></a>3. Data()日期对象</h2><ul><li>Date 对象和 Math 对象不一样，他是一个<strong>构造函数</strong>，所以我们需要实例化后才能使用</li><li>Date 实例用来处理日期和时间</li></ul><h3 id="3-1-Date-方法的使用"><a href="#3-1-Date-方法的使用" class="headerlink" title="3.1 Date()方法的使用"></a>3.1 Date()方法的使用</h3><h4 id="3-1-1-获取当前时间必须实例化"><a href="#3-1-1-获取当前时间必须实例化" class="headerlink" title="3.1.1 获取当前时间必须实例化"></a>3.1.1 获取当前时间必须实例化</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var now = new Date();console.log(now);</code></pre><h4 id="3-1-2-Date-构造函数的参数"><a href="#3-1-2-Date-构造函数的参数" class="headerlink" title="3.1.2 Date()构造函数的参数"></a>3.1.2 Date()构造函数的参数</h4><p>如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为 <code>‘2019-5-1’</code>，可以写成<code>new Date('2019-5-1')</code> 或者 <code>new Date('2019/5/1')</code></p><ul><li><strong>如果Date()不写参数，就返回当前时间</strong></li><li><strong>如果Date()里面写参数，就返回括号里面输入的时间</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.如果没有参数，返回当前系统的当前时间var now = new Date();console.log(now);// 2.参数常用的写法 数字型 2019,10,1  字符串型 '2019-10-1 8:8:8' 时分秒// 如果Date()里面写参数，就返回括号里面输入的时间 var data = new Date(2019,10,1);console.log(data);  // 返回的是11月不是10月var data2 = new Date('2019-10-1 8:8:8');console.log(data2);</code></pre><h3 id="3-2-日期格式化"><a href="#3-2-日期格式化" class="headerlink" title="3.2 日期格式化"></a>3.2 日期格式化</h3><p>我们想要 2019-8-8 8:8:8 格式的日期，要怎么办？</p><p>需要获取日期指定的部分，所以我们要手动的得到这种格式</p><table><thead><tr><th>方法名</th><th>说明</th><th>代码</th></tr></thead><tbody><tr><td>getFullYear()</td><td>获取当年</td><td>dObj.getFullYear()</td></tr><tr><td>getMonth()</td><td>获取当月(0-11)</td><td>dObj.getMonth()</td></tr><tr><td>getDate()</td><td>获取当天日期</td><td>dObj.getDate()</td></tr><tr><td>getDay()</td><td>获取星期几(周日0到周六6)</td><td>dObj.getDay()</td></tr><tr><td>getHours()</td><td>获取当前小时</td><td>dObj.getHours()</td></tr><tr><td>getMinutes()</td><td>获取当前小时</td><td>dObj.getMinutes()</td></tr><tr><td>getSeconds()</td><td>获取当前秒钟</td><td>dObj.gerSeconds()</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 写一个 2019年 5月 1日 星期三var date = new Date(); var year =  date.getFullYear();var month = date.getMonth() + 1; //返回的月份小一个月 记得月份 +1var dates = date.getDate(); //周一返回1 周6返回六 周日返回0console.log('今天是' + year +'年' + month + '月' + dates +'日' );// 封装一个函数返回当前的时分秒 格式 08:08:08function getTimer() {    var time = new Date();    var h = time.getHours();    h = h &lt; 10 ? '0' + h : h; //补零    var m = time.getMinutes();    m = m &lt; 10 ? '0' + m : m;    var s = time.getSeconds();    s = s &lt; 10 ? '0' + s : s;    return h + ':' + m + ':' + s;}console.log(getTimer());</code></pre><h3 id="3-3-获取日期的总的毫秒形式"><a href="#3-3-获取日期的总的毫秒形式" class="headerlink" title="3.3 获取日期的总的毫秒形式"></a>3.3 获取日期的总的毫秒形式</h3><p>得到现在时间距离1970.1.1总的毫秒数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1 .通过 valueOf()  getTime() 用于获取对象的原始值var date = new Date();console.log(date.valueOf()); console.log(date.getTime());// 2.简单的写法var date1 = +new Date();  // +new Date()返回的就是总的毫秒数，console.log(date1);// 3. HTML5中提供的方法 获得总的毫秒数 有兼容性问题console.log(Date.now());</code></pre><h4 id="倒计时效果"><a href="#倒计时效果" class="headerlink" title="倒计时效果"></a>倒计时效果</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function countDown(time) {    var nowTime = +new Date(); //没有参数，返回的是当前时间总的毫秒数    var inputTime = +new Date(time); // 有参数，返回的是用户输入时间的总毫秒数    var times = (inputTime - nowTime) / 1000; //times就是剩余时间的总的秒数    var d = parseInt(times / 60 / 60 / 24); //天数    d &lt; 10 ? '0' + d : d;    var h = parseInt(times / 60 / 60 % 24); //小时    h &lt; 10 ? '0' + h : h;    var m = parseInt(times / 60 % 60); //分    m &lt; 10 ? '0' + m : m;    var s = parseInt(times % 60); //秒    s &lt; 10 ? '0' + s : s;        return d + '天' + h + '时' + m + '分' + s + '秒';}console.log(countDown('2022-10-01 00:00:00'));var date = new Date;console.log(date); //现在时间</code></pre><h2 id="4-数组对象"><a href="#4-数组对象" class="headerlink" title="4. 数组对象"></a>4. 数组对象</h2><h3 id="4-1-数组对象的创建"><a href="#4-1-数组对象的创建" class="headerlink" title="4.1 数组对象的创建"></a>4.1 数组对象的创建</h3><p>创建数组对象的两种方式</p><ul><li>字面量方式</li><li>new Array()</li></ul><h3 id="4-2-检测是否为数组"><a href="#4-2-检测是否为数组" class="headerlink" title="4.2 检测是否为数组"></a>4.2 检测是否为数组</h3><ul><li><code>instanceof</code> 运算符，可以判断一个对象是否属于某种类型</li><li><code>Array.isArray()</code> 用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [1, 23];var obj = {};console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // falseconsole.log(Array.isArray(arr));   // trueconsole.log(Array.isArray(obj));   // false</code></pre><h3 id="4-3-添加删除数组元素"><a href="#4-3-添加删除数组元素" class="headerlink" title="4.3 添加删除数组元素"></a>4.3 添加删除数组元素</h3><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>push(参数1…)</td><td><strong>末尾</strong>添加<strong>一个或多个</strong>元素，注意修改原数组</td><td>返回新的长度</td></tr><tr><td>pop()</td><td>删除数组<strong>最后一个</strong>元素</td><td>返回它删除的元素的值</td></tr><tr><td>unshift(参数1…)</td><td>向数组的<strong>开头</strong>添加<strong>一个或多个</strong>元素，注意修改原数组</td><td>返回新的长度</td></tr><tr><td>shift()</td><td>删除数组的<strong>第一个</strong>元素，数组长度减1，无参数，修改原数组</td><td>返回它删除的元素的值</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [1, 2, 3];// 1.push() 在我们数组的末尾，添加一个或者多个数组元素 push 推arr.push(4, '秦晓');console.log(arr);console.log(arr.push(4, '秦晓'));console.log(arr);// push 完毕之后，返回结果是新数组的长度// 2. unshift 在我们数组的开头 添加一个或者多个数组元素arr.unshift('red');console.log(arr);// pop() 它可以删除数组的最后一个元素，一次只能删除一个元素arr.pop(); //不加参数// shift() 它可以删除数组的第一个元素,一次只能删除一个元素arr.shift(); //不加参数</code></pre><h4 id="筛选数组"><a href="#筛选数组" class="headerlink" title="筛选数组"></a>筛选数组</h4><p>有一个包含工资的数组[1500,1200,2000,2100,1800]，要求把数组中工资超过2000的删除，剩余的放到新数组里面</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [1500, 1200, 2000, 2100, 1800];var newArr = [];for (var i = 0; i &lt; arr.length; i++) {    if (arr[i] &lt; 2000) {        newArr.push(arr[i]); // 直接加    }}console.log(newArr);</code></pre><h3 id="4-4-数组索引"><a href="#4-4-数组索引" class="headerlink" title="4.4 数组索引"></a>4.4 数组索引</h3><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>indexOf()</td><td>数组中查找给定元素的第一个索引</td><td>如果存在返回索引号，<strong>如果不存在，则返回-1</strong></td></tr><tr><td>lastIndexOf()</td><td>在数组的最后一个索引，从后向前索引</td><td>如果存在返回索引号，<strong>如果不存在，则返回-1</strong></td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//只返回第一个满足条件的索引号//如果找不到元素，则返回-1var arr = ['red','green','blue','pink','blue'];console.log(arr.indexOf('blue'));  // 2console.log(arr.lastIndexOf('blue')); // 4</code></pre><h4 id="案例：数组去重"><a href="#案例：数组去重" class="headerlink" title="案例：数组去重"></a>案例：数组去重</h4><p>有一个数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]，要求去除数组中重复的元素。</p><p>分析：把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放到新数组中。</p><p>核心算法：我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过（利用 <strong>新数组.indexOf(数组元素)</strong> 如果返回是 -1 就说明新数组里面没有该元素），我们就添加，否则不添加。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function unique(arr) {    var newArr = [];    for (var i = 0; i &lt; arr.length; i++) {        if (newArr.indexOf(arr[i]) === -1) {            newArr.push(arr[i]);        }    }    return newArr;}var demo = unique(['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b']);console.log(demo);</code></pre><h3 id="4-5-数组排序"><a href="#4-5-数组排序" class="headerlink" title="4.5 数组排序"></a>4.5 数组排序</h3><table><thead><tr><th>方法名</th><th>说明</th><th>是否修改原数组</th></tr></thead><tbody><tr><td>reverse()</td><td>颠倒数组中元素的顺序，无参数</td><td>该方法会改变原来的数组，返回新数组</td></tr><tr><td>sort()</td><td>对数组的元素进行排序</td><td>该方法会改变原来的数组，返回新数组</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.翻转数组var arr = ['pink','red','blue'];arr.reverse();console.log(arr);// 2.数组排序(冒泡排序)var arr1 = [3,4,7,1];arr1.sort();console.log(arr1); //1 3 4 7// 对于双位数var arr = [1,64,9,61];arr.sort(function(a,b) {     return b - a;  //降序排序     return a - b; //升序排序 } )</code></pre><h3 id="4-6-数组转化为字符串"><a href="#4-6-数组转化为字符串" class="headerlink" title="4.6 数组转化为字符串"></a>4.6 数组转化为字符串</h3><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>toString()</td><td>把数组转换成字符串，逗号分隔每一项</td><td>返回一个字符串</td></tr><tr><td>join(‘分隔符’)</td><td>方法用于把数组中的所有元素转换为一个字符串</td><td>返回一个字符串</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.toString() 将我们的数组转换为字符串var arr = [1, 2, 3];console.log(arr.toString()); // 1,2,3// 2.join('分隔符')var arr1 = ['green', 'blue', 'red'];console.log(arr1.join()); // 不写默认用逗号分割console.log(arr1.join('-')); //  green-blue-redconsole.log(arr1.join('&amp;')); // green&amp;blue&amp;red</code></pre><h3 id="4-7-数组拼接和截取"><a href="#4-7-数组拼接和截取" class="headerlink" title="4.7 数组拼接和截取"></a>4.7 数组拼接和截取</h3><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>concat()</td><td>连接两个或多个数组 不影响原数组</td><td>返回一个新的数组</td></tr><tr><td>slice()</td><td>数组截取slice(begin,end)</td><td>返回被截取项目的新数组</td></tr><tr><td>splice()</td><td>数组删除splice(第几个开始要删除的个数)</td><td>返回被删除项目的新数组，这个会影响原数组</td></tr></tbody></table><h2 id="5-字符串对象"><a href="#5-字符串对象" class="headerlink" title="5. 字符串对象"></a>5. 字符串对象</h2><h3 id="5-1-基本包装类型"><a href="#5-1-基本包装类型" class="headerlink" title="5.1 基本包装类型"></a>5.1 基本包装类型</h3><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p><strong>基本包装类型</strong>就是<strong>把简单数据类型包装成为复杂数据类型</strong>，这样基本数据类型就有了属性和方法。</p><p>我们看看下面代码有什么问题吗？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = 'andy';console.log(str.length);</code></pre><p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.生成临时变量,把简单类型包装为复杂数据类型var temp = new String('andy');// 2.赋值给我们声明的字符变量str = temp;// 3.销毁临时变量temp = null;</code></pre><h3 id="5-2-字符串的不可变"><a href="#5-2-字符串的不可变" class="headerlink" title="5.2 字符串的不可变"></a>5.2 字符串的不可变</h3><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = 'abc';str = 'hello';// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题var str = '';for(var i = 0; i &lt; 10000;  i++){    str += i;}console.log(str);// 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间</code></pre><h3 id="5-3-根据字符返回位置"><a href="#5-3-根据字符返回位置" class="headerlink" title="5.3 根据字符返回位置"></a>5.3 根据字符返回位置</h3><p>字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，<strong>操作完成会返回一个新的字符串</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>indexOf(‘要查找的字符’，开始的位置)</td><td>返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号</td></tr><tr><td>lastIndexOf()</td><td>从后往前找，只找第一个匹配的</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = '改革春风吹满地，春天来了';console.log(str.indexOf('春')); //默认从0开始查找 ，结果为2console.log(str.indexOf('春', 3)); // 从索引号是 3的位置开始往后查找，结果是8</code></pre><h4 id="案例：返回字符位置"><a href="#案例：返回字符位置" class="headerlink" title="案例：返回字符位置"></a>案例：返回字符位置</h4><p>查找字符串 “abcoefoxyozzopp” 中所有o出现的位置以及次数</p><ul><li>核心算法：先查找第一个o出现的位置</li><li>然后 只要 indexOf返回的结果不是 -1 就继续往后查找</li><li>因为 indexOf 只能查找到第一个，所以后面的查找，一定是<strong>当前索引加1</strong>，从而继续查找</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = "oabcoefoxyozzopp";var index = str.indexOf('o');var num = 0;while (index !== -1) {    console.log(index);    num++;    index = str.indexOf('o', index + 1);}console.log('o出现的次数是: ' + num);</code></pre><h3 id="5-4-根据位置返回字符"><a href="#5-4-根据位置返回字符" class="headerlink" title="5.4 根据位置返回字符"></a>5.4 根据位置返回字符</h3><table><thead><tr><th>方法名</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>charAt(index)</td><td>返回指定位置的字符(index字符串的索引号)</td><td>str.charAt(0)</td></tr><tr><td>charCodeAt(index)</td><td>获取指定位置处字符的ASCII码(index索引号)</td><td>str.charCodeAt(0)</td></tr><tr><td>str[index]</td><td>获取指定位置处字符</td><td>HTML,IE8+支持和charAt()等效</td></tr></tbody></table><h4 id="案例：判断出现次数最多的字符"><a href="#案例：判断出现次数最多的字符" class="headerlink" title="案例：判断出现次数最多的字符"></a>案例：判断出现次数最多的字符</h4><p>判断一个字符串 “abcoefoxyozzopp” 中出现次数最多的字符，并统计其次数</p><ul><li>核心算法：利用 charAt() 遍历这个字符串</li><li>把每个字符都<strong>存储给对象</strong>， 如果<strong>对象没有该属性</strong>，就为1，如果存在了就 +1</li><li><strong>遍历对象</strong>，得到最大值和该字符</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = 'abcoefoxyozzopp';var o = {};for (var i = 0; i &lt; str.length; i++) {    var chars = str.charAt(i); // chars 是 字符串的每一个字符    if (o[chars]) { // o[chars] 得到的是属性值        o[chars]++;    } else {        o[chars] = 1;    }}console.log(o);// 2. 遍历对象var max = 0;var ch = '';for (var k in o) {    // k 得到是 属性名    // o[k] 得到的是属性值    if (o[k] &gt; max) {        max = o[k];        ch = k;    }}console.log(max);console.log('最多的字符是' + ch);</code></pre><h3 id="5-5-字符串拼接和截取（重点）"><a href="#5-5-字符串拼接和截取（重点）" class="headerlink" title="5.5 字符串拼接和截取（重点）"></a>5.5 字符串拼接和截取（重点）</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>concat(str1,str2,str3…)</td><td>concat() 方法用于连接两个或对各字符串。拼接字符串</td></tr><tr><td>substr(start,length)</td><td>从 start 位置开始(索引号), length 取的个数。</td></tr><tr><td>slice(start,end)</td><td>从 start 位置开始，截取到 end 位置 ，end 取不到 (两个都是索引号)</td></tr><tr><td>substring(start,end)</td><td>从 start 位置开始，截取到 end 位置 ，end 取不到 (基本和 slice 相同，但是不接受负)</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1. concat('字符串1','字符串2'....)var str = 'andy';console.log(str.concat('red'));// 2. substring('截取的起始位置', '截取几个字符');var str1 = '改革春风吹满地';console.log(str1.substring(2, 4)); // 春风</code></pre><h3 id="5-6-replace-方法"><a href="#5-6-replace-方法" class="headerlink" title="5.6 replace()方法"></a>5.6 replace()方法</h3><p>replace() 方法用于在字符串中用一些字符替换另一些字符</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1. 替换字符 replace('被替换的字符', '替换为的字符')  它只会替换第一个字符var str = 'andyandy';console.log(str.replace('a', 'b'));// 有一个字符串 'abcoefoxyozzopp'  要求把里面所有的 o 替换为 *var str1 = 'abcoefoxyozzopp';while (str1.indexOf('o') !== -1) {    str1 = str1.replace('o', '*');}console.log(str1);</code></pre><h3 id="5-7-split-方法"><a href="#5-7-split-方法" class="headerlink" title="5.7 split()方法"></a>5.7 split()方法</h3><p>split() 方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//字符转换为数组 split('分隔符')    前面我们学过 join 把数组转换为字符串var str1 = 'red, pink, blue';console.log(str1.split(','));var str2 = 'red&amp;pink&amp;blue';console.log(str2.split('&amp;'));</code></pre><h3 id="5-8-大小写转换"><a href="#5-8-大小写转换" class="headerlink" title="5.8 大小写转换"></a>5.8 大小写转换</h3><ul><li><code>toUpperCase()</code> 转换大写</li><li><code>toLowerCase()</code> 转换小写</li></ul><h1 id="三、简单类型与复杂类型"><a href="#三、简单类型与复杂类型" class="headerlink" title="三、简单类型与复杂类型"></a>三、简单类型与复杂类型</h1><p>简单类型又叫做基本数据类型或者<strong>值类型</strong>，复杂类型又叫做<strong>引用类型</strong>。</p><ul><li>值类型：简单数据类型/基本数据类型，在存储时变量中<strong>存储的是值本身</strong>，因此叫做值类型<br>string ，number，boolean，undefined，null</li><li>引用类型：复杂数据类型，在存储时变量中<strong>存储的是地址</strong>（引用），因此叫做引用数据类型<ul><li>通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</li></ul></li></ul><h2 id="1-堆和栈"><a href="#1-堆和栈" class="headerlink" title="1. 堆和栈"></a>1. 堆和栈</h2><p>堆栈空间分配区别：</p><ul><li>栈（操作系统）：由操作系统<strong>自动分配释放</strong>存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；<ul><li>==简单数据类型存放到栈里面==</li></ul></li><li>堆（操作系统）：存储复杂类型(对象)，一般<strong>由程序员分配释放</strong>，若程序员不释放，由垃圾回收机制回收。<ul><li>==复杂数据类型存放到堆里面==</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/d6ada709e0194973b9ab6373ccb301de.png#pic_center" alt="在这里插入图片描述"></p><p>注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。</p><h2 id="2-简单类型的内存分配"><a href="#2-简单类型的内存分配" class="headerlink" title="2. 简单类型的内存分配"></a>2. 简单类型的内存分配</h2><ul><li>值类型（简单数据类型）： string ，number，boolean，undefined，null</li><li>值类型变量的数据直接存放在变量（栈空间）中</li></ul><p><img src="https://img-blog.csdnimg.cn/5426610b379a4cf4ba1d61b07900ff8a.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-复杂类型的内存分配"><a href="#3-复杂类型的内存分配" class="headerlink" title="3. 复杂类型的内存分配"></a>3. 复杂类型的内存分配</h2><ul><li>引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</li><li>引用类型变量（栈空间）里<strong>存放的是地址</strong>，真正的对象实例存放在堆空间中</li></ul><p><img src="https://img-blog.csdnimg.cn/083c043653b646baba0205faaa7e3758.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4-简单类型传参"><a href="#4-简单类型传参" class="headerlink" title="4. 简单类型传参"></a>4. 简单类型传参</h2><p>函数的形参也可以看做是一个变量，当我们把一个<strong>值类型变量</strong>作为参数传给函数的形参时，其实是把<strong>变量在栈空间里的值复制了一份给形参</strong>，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 简单数据类型传参function fn(a) {    a++;    console.log(a);}var x = 10;fn(x);console.log(x);</code></pre><h2 id="5-复杂类型传参"><a href="#5-复杂类型传参" class="headerlink" title="5. 复杂类型传参"></a>5. 复杂类型传参</h2><p>函数的形参也可以看做是一个变量，当我们把<strong>引用类型变</strong>量传给形参时，其实是把<strong>变量在栈空间里保存的堆地址复制给了形参</strong>，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 复杂数据类型传参function Person(name) {    this.name = name;}function f1(x) { // x = p 把p的地址传给了x    console.log(x.name); // 2. 这个输出刘德华       x.name = "张学友";    console.log(x.name); // 3. 这个输出张学友}var p = new Person("刘德华");console.log(p.name); // 1. 这个输出刘德华 f1(p);console.log(p.name); // 4. 这个输出张学友</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 语法速查</title>
      <link href="/2023/01/04/markdown-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/"/>
      <url>/2023/01/04/markdown-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、标题和正文"><a href="#一、标题和正文" class="headerlink" title="一、标题和正文"></a>一、标题和正文</h1><p>使用 <code>#</code> 表示标题，其中 <code>#</code> 号必须在行首，例如：</p><h1 id="一号标题"><a href="#一号标题" class="headerlink" title="一号标题"></a>一号标题</h1><h2 id="二号标题"><a href="#二号标题" class="headerlink" title="二号标题"></a>二号标题</h2><h3 id="三号标题"><a href="#三号标题" class="headerlink" title="三号标题"></a>三号标题</h3><h4 id="四号标题"><a href="#四号标题" class="headerlink" title="四号标题"></a>四号标题</h4><h5 id="五号标题"><a href="#五号标题" class="headerlink" title="五号标题"></a>五号标题</h5><h6 id="六号标题"><a href="#六号标题" class="headerlink" title="六号标题"></a>六号标题</h6><p>使用 <code>===</code> 或者 <code>---</code> 表示，例如：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>正文字体</p><p>1、改变字体<br>在 Markdown 语法中，使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签的 &nbsp;<code>face</code>&nbsp; 属性修改文字字体。字体在不同环境中支持程度不同，表现结果可能也不同。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font face="HEI"&gt;这里是黑体&lt;/font&gt;&lt;font face="KAI"&gt;这里是楷体&lt;/font&gt;&lt;font face="GB18030 Bitmap"&gt;这里是扩展字体&lt;/font&gt;</code></pre><p><font face="HEI">这里是黑体</font><br><font face="KAI">这里是楷体</font><br><font face="GB18030 Bitmap">这里是扩展字体</font></p><p>2、修改字号<br>Markdown 有三种主要方式<br>第一种是使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签；<br>第二种通过 &nbsp;<code>&lt;big&gt;</code>&nbsp; 或者 &nbsp;<code>&lt;small&gt;</code>&nbsp; 标签<br>第三种是通过修改 &nbsp;<code>style</code>&nbsp; 样式实现。</p><p>使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签 &nbsp;<code>size</code>&nbsp; 属性修改局部字号</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font size="1"&gt;1 号字 最小&lt;/font&gt;&lt;font size="2"&gt;2 号字&lt;/font&gt;&lt;font size="3"&gt;3 号字 默认&lt;/font&gt;&lt;font size="4"&gt;4 号字&lt;/font&gt;&lt;font size="5"&gt;5 号字&lt;/font&gt;&lt;font size="6"&gt;6 号字&lt;/font&gt;&lt;font size="7"&gt;7 号字 最大&lt;/font&gt;</code></pre><p><font size="1">1 号字 最小</font></p><p><font size="2">2 号字</font></p><p><font size="3">3 号字 默认</font></p><p><font size="4">4 号字</font></p><p><font size="5">5 号字</font></p><p><font size="6">6 号字</font></p><p><font size="7">7 号字 最大</font></p><p>3、字体颜色<br>在 Markdown 语法中，使用 &nbsp;<code>&lt;font&gt;</code>&nbsp; 标签的 &nbsp;<code>color</code>&nbsp; 属性修改文字颜色。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font color="red"&gt;红色&lt;/font&gt;&lt;font color="green"&gt;绿色&lt;/font&gt;&lt;font color="blue"&gt;蓝色&lt;/font&gt;&lt;font color="rgb(200, 100, 100)"&gt;使用 rgb 颜色值&lt;/font&gt;&lt;font color="#FF00BB"&gt;使用十六进制颜色值&lt;/font&gt;</code></pre><p><font color="red">红色</font><br><font color="green">绿色</font><br><font color="blue">蓝色</font><br><font color="rgb(200, 100, 100)">使用 rgb 颜色值</font><br><font color="#FF00BB">使用十六进制颜色值</font></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);"&gt;这是七色光彩背景颜色&lt;/font&gt;</code></pre><p><font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);">这是七色光彩背景颜色</font></p><h1 id="二、分割线"><a href="#二、分割线" class="headerlink" title="二、分割线"></a>二、分割线</h1><p>分隔线是用一条明显的横线，来划分文章的上下两个部分，从而使排版变得美观</p><p>123</p><hr><hr><h1 id="三、粗体斜体"><a href="#三、粗体斜体" class="headerlink" title="三、粗体斜体"></a>三、粗体斜体</h1><p>使用 <code>*</code> 和 <code>**</code> 分别表示斜体和粗体，例如</p><p><em>斜体</em><br><strong>粗体</strong><br><strong><em>又斜又粗</em></strong></p><p><del>我是要删掉的文字</del></p><p>使用 <code>==</code> 高亮<br>==123==</p><h1 id="四、超链接和图片"><a href="#四、超链接和图片" class="headerlink" title="四、超链接和图片"></a>四、超链接和图片</h1><p>Markdown 支持两种超链接的定义方式：<code>行内定义</code> 和 <code>全局声明</code><br>都是由 「中括号 &nbsp;<code>[]</code>」来声明。</p><p>语法：<code>中括号[链接名称](目标链接)</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Obsidan 简单入门教程[哔哩哔哩](https://space.bilibili.com/507578555/?spm_id_from=333.999.0.0 "IOI")</code></pre><p>Obsidan 简单入门教程<a href="https://space.bilibili.com/507578555/?spm_id_from=333.999.0.0" title="IOI">哔哩哔哩</a></p><p>在 Markdown 语法中，<br>语法：<code>![替换文字](图片路径 "标题(可选)")</code>&nbsp; 的形式定义图片</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">![马博峰](http://t13.baidu.com/it/u=3695680119,4124722001&amp;fm=224&amp;app=112&amp;f=JPEG?w=350&amp;h=350)</code></pre><p><img src="http://t13.baidu.com/it/u=3695680119,4124722001&amp;fm=224&amp;app=112&amp;f=JPEG?w=350&amp;h=350" alt="马博峰"></p><p><img src="https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E9%A9%AC%E5%8D%9A%E5%B3%B0&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=7108135681980891137&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=1637495421,647503309&amp;os=1482974809,4155393326&amp;simid=1637495421,647503309&amp;adpicid=0&amp;lpn=0&amp;ln=450&amp;fr=&amp;fmq=1655308061627_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=15&amp;oriquery=&amp;objurl=https://gimg2.baidu.com/image_search/src=http://zhengxin-pub.cdn.bcebos.com/mark/305f97293a328dcf971e1e684159c120.jpg&amp;refer=http://zhengxin-pub.cdn.bcebos.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1657900066&amp;t=678054910d3c0a812fadecd69827c195&amp;fromurl=ippr_z2C$qAzdH3FAzdH3Fwtqtviw_z&amp;e3Bkwt17_z&amp;e3Bv54AzdH3F4w6hAzdH3Ff?q=%25Cd%25ED%25Bd%25Al%25B0%25Ec&amp;gsm=1&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;nojc=undefined&amp;dyTabStr=MCwzLDYsMSw0LDUsNyw4LDIsOQ=="></p><h1 id="五、有序和无需列表"><a href="#五、有序和无需列表" class="headerlink" title="五、有序和无需列表"></a>五、有序和无需列表</h1><p><strong>1、无序列表</strong></p><p>使用 <code>-</code>、<code>+</code> 和 <code>*</code> 表示无序列表，前后留一行空白，可嵌套，例如</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">使用星号生成无序列表- 项目 1  使用加号生成无序列表* 项目 2  使用减号生成无序列表- 项目 3</code></pre><p>使用星号生成无序列表</p><ul><li>项目 1<br>使用加号生成无序列表</li></ul><ul><li>项目 2<br>使用减号生成无序列表</li></ul><ul><li>项目 3</li></ul><p><strong>2、无序列表的嵌套</strong></p><p>在 <code>-</code>、<code>+</code> 和 <code>*</code> 之前使用 tab 键将其缩进，每个 tab 表示一层。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">无序列表的嵌套- 第一层 1  - 第二层 1    - 第三层 1      - 第四层 1        - 第五层 1    - 第三层 2  - 第二层 2</code></pre><ul><li>第一层 1<ul><li>第二层 1<ul><li>第三层 1<ul><li>第四层 1<ul><li>第五层 1</li></ul></li></ul></li><li>第三层 2</li></ul></li><li>第二层 2</li></ul></li></ul><p><strong>3、有序列表</strong></p><p>通过「数字 +&nbsp;<code>.</code>&nbsp;」的形式定义有序列表，有序列表在发布后会被转化为：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">### 有序列表使用数字实现有序列表1. 项目 12. 项目 23. 项目 3源码中的数字与渲染后的数字并不一一对应，但可以决定列表的开始序号</code></pre><h1 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h1><p>使用 <code>&gt;</code> 表示，可以有多个 <code>&gt;</code>，表示层级更深，例如</p><blockquote><p>第一层</p><blockquote><p>第二层<br>这样是跳不出去的</p><blockquote><p>还可以更深</p></blockquote></blockquote></blockquote><h1 id="七、代码样式"><a href="#七、代码样式" class="headerlink" title="七、代码样式"></a>七、代码样式</h1><p>1、行内代码</p><p>使用 「反引号 &nbsp;<code>`</code>」符号定义行内代码。</p><p><code>行内代码</code></p><p>2、代码块</p><p>使用四个空格缩进表示代码块，例如</p><pre><code>public class HelloWorld{    public static void main(String[] args)    {        System.out.println( "Hello, World!" );    }}</code></pre><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p><strong>Markdown 表格包含三个部分：表头、分割线、数据。</strong></p><ul><li><strong>表头</strong>&nbsp; 用来对列名对象进行描述，也就是通常所说的列名；</li><li><strong>数据</strong>&nbsp; 用来展示每行的具体内容，数据是表格的核心；</li><li><strong>分割线</strong>&nbsp; 用来区分表头和数据，也是 Markdown 中表格定义的最基本语法要求。</li></ul><p><strong>Markdown 表格由 「竖线 &nbsp;<code>|</code>」、「减号 &nbsp;<code>-</code>」、「冒号 &nbsp;<code>:</code>」三种符号组成。</strong></p><ul><li><strong>竖线</strong>&nbsp; 用来定义列，每两个竖线之间为一个单元格元素；</li><li><strong>减号</strong>&nbsp; 用来定义分割线，也就是分割表头和数据体；</li><li><strong>冒号</strong>&nbsp; 配合减号使用，用于定义列数据的对齐属性。</li></ul><table><thead><tr><th>商品</th><th align="right">数量</th><th align="center">单价</th></tr></thead><tbody><tr><td>苹果苹果苹果</td><td align="right">10</td><td align="center">$1</td></tr><tr><td>电脑</td><td align="right">1</td><td align="center">$1999</td></tr></tbody></table><h1 id="九、数学公式"><a href="#九、数学公式" class="headerlink" title="九、数学公式"></a>九、数学公式</h1><p>Markdown 中的数学公式支持支持 <strong>LaTeX</strong>，分为「行中公式」和「独立公式」两种。</p><p>行中公式用两个单独的「美元符 &nbsp;<code>$</code>」表示。</p><p>世界上最难的问题$1+1=2$，如何证明？</p><p>独立公式用两个连续的「美元符 &nbsp;<code>$$</code>」表示，换行通过 &nbsp;<code>\</code>&nbsp; 实现。</p><p>平均数符号：$overline{xyz}$<br>开二次方符号：$sqrt x$<br>开方符号：$sqrt[3]{x+y}$<br>对数符号：$log(x)$<br>极限符号：$lim^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>极限符号：$displaystyle lim^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>求和符号：$sum^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>求和符号：$displaystyle sum^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>积分符号：$int^{infty}<em>{0}{xdx}$<br>积分符号：$displaystyle int^{infty}</em>{0}{xdx}$</p><h1 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h1><p>在 Markdown 文件中，在 ” 无序列表 &nbsp;<code>-,+,*</code>&nbsp;” 后面使用 &nbsp;<code>「中括号 []」</code>&nbsp; 声明复选框。在中括号中写入 &nbsp;<code>x</code>&nbsp;，便可实现选中效果。</p><ul><li><input disabled="" type="checkbox"> Java</li><li><input checked="" disabled="" type="checkbox"> Php</li></ul><h1 id="十一、标签"><a href="#十一、标签" class="headerlink" title="十一、标签"></a>十一、标签</h1><p>#标签<br>#dark</p><h1 id="十二、绘图"><a href="#十二、绘图" class="headerlink" title="十二、绘图"></a>十二、绘图</h1><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">gantt    title A Gantt Diagram    dateFormat  YYYY-MM-DD    section Section    A task           :a1, 2014-01-01, 30d    Another task     :after a1  , 20d    section Another    Task in sec      :2014-01-12  , 12d    another task      : 24d</code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR%% s=start  e=end  c=convergence  o=one-way%% 汇聚点 朱标s1[朱雄英]--&gt;|长子|c1[朱标]s2_帝((朱允炆))--&gt;|次子|c1%%汇聚点 朱八八c1--&gt;|长子|c2_帝((朱八八))s3[朱樉]--&gt;|次子|c2_帝s4[朱棡]--&gt;|三子|c2_帝s5((朱高炽))--&gt;|长子|o1_帝((朱棣))--&gt;|四子|c2_帝%% 单行线c2_帝--&gt;|子|o2[朱五四]--&gt;|子|o3[朱四九]--&gt;|子|e[朱百六]</code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">classDiagram    Animal &lt;|-- Duck    Animal &lt;|-- Fish    Animal &lt;|-- Zebra    Animal : +int age    Animal : +String gender    Animal: +isMammal()    Animal: +mate()    class Duck{      +String beakColor      +swim()      +quack()    }    class Fish{      -int sizeInFeet      -canEat()    }    class Zebra{      +bool is_wild      +run()    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> md语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础（二）数组、函数、作用域与预解析</title>
      <link href="/2023/01/03/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/01/03/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>数组(Array)是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放<strong>任意类型</strong>的元素。数组是一种将<strong>一组数据存储在单个变量名</strong>下的优雅方式。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//普通变量一次只能存储一个值var num = 10;//数组一次可以存储多个值var arr =[1,2,3,4,5];</code></pre><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1. 创建数组"></a>1. 创建数组</h2><p>JavaScript 中创建数组有两种方式：</p><ul><li>利用 new 创建数组</li><li>利用数组字面量创建数组</li></ul><h3 id="1-1-利用-new-创建数组"><a href="#1-1-利用-new-创建数组" class="headerlink" title="1.1 利用 new 创建数组"></a>1.1 利用 new 创建数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var 数组名 = new Array();var arr = new Array(); //创建一个新的空数组</code></pre><ul><li>这种方式暂且了解，等学完对象再看</li><li>注意 <code>Array()</code>，A要大写</li></ul><h2 id="1-2-利用数组字面量创建数组"><a href="#1-2-利用数组字面量创建数组" class="headerlink" title="1.2 利用数组字面量创建数组"></a>1.2 利用数组字面量创建数组</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.利用数组字面量方式创建空的数组 var 数组名 =[];// 2.使用数组字面量方式创建带初始值的数组var 数组名 =['小白'，12，true，28.9];</code></pre><ul><li>数组的字面量是方括号 <code>[]</code></li><li>声明数组并赋值称为数组的初始化</li><li>这种字面量方式也是我们<strong>以后最多使用</strong>的方式</li></ul><h2 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2. 遍历数组"></a>2. 遍历数组</h2><p>索引 (下标) ：用来访问数组元素的序号（数组下标<strong>从 0 开始</strong>）</p><p>我们可以通过 for 循环索引遍历数组中的每一项</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 数组索引访问数组中的元素var arr = ['red','green', 'blue'];console.log(arr[0]) // redconsole.log(arr[1]) // greenconsole.log(arr[2]) // blue// for循环遍历数组var arr = ['red','green', 'blue'];for (var i = 0; i &lt; arr.length; i++){    console.log(arrStus[i]);}</code></pre><h3 id="2-1-数组的长度"><a href="#2-1-数组的长度" class="headerlink" title="2.1 数组的长度"></a>2.1 数组的长度</h3><p>使用“<code>数组名.length</code>”可以访问数组元素的数量（数组长度）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arrStus = [1,2,3];alert(arrStus.length);  // 3</code></pre><p><strong>注意</strong>：</p><ul><li>此处数组的长度是<strong>数组元素的个数</strong> ，不要和<strong>数组的索引号</strong>混淆</li><li>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</li></ul><h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><p><strong>1. 求数组[2,6,1,77,52,25,7]中的最大值</strong></p><ul><li>声明一个保存最大元素的变量 max。</li><li>默认最大值可以取数组中的第一个元素。</li><li>遍历这个数组，把里面每个数组元素和 max 相比较。</li><li>如果这个数组元素大于max 就把这个数组元素存到 max 里面，否则继续下一轮比较。</li><li>最后输出这个 max。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [2, 6, 1, 77, 52, 25, 7];var max = arr[0];for (var i = 1; i &lt; arr.length; i++) {    if (arr[i] &gt; max) {        max = arr[i];    }}console.log('最大值为' + max);</code></pre><h2 id="3-数组中新增元素"><a href="#3-数组中新增元素" class="headerlink" title="3. 数组中新增元素"></a>3. 数组中新增元素</h2><h3 id="3-1-通过修改-length-长度新增数组元素"><a href="#3-1-通过修改-length-长度新增数组元素" class="headerlink" title="3.1 通过修改 length 长度新增数组元素"></a>3.1 通过修改 length 长度新增数组元素</h3><ul><li>可以通过修改 length 长度来实现数组扩容的目的</li><li>length 属性是可读写的</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = ['red', 'green', 'blue', 'pink'];arr.length = 7;console.log(arr);console.log(arr[4]);console.log(arr[5]);console.log(arr[6]);</code></pre><p>其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 <strong>undefined</strong></p><h3 id="3-2-通过修改数组索引新增数组元素"><a href="#3-2-通过修改数组索引新增数组元素" class="headerlink" title="3.2 通过修改数组索引新增数组元素"></a>3.2 通过修改数组索引新增数组元素</h3><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li><li>这种方式也是我们<strong>最常用</strong>的一种方式</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = ['red', 'green', 'blue', 'pink'];arr[4] = 'hotpink';console.log(arr);</code></pre><p><strong>案例：</strong></p><p><strong>将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组</strong></p><ul><li>声明一个新的数组用于存放新数据。</li><li>遍历原来的数组，找出大于等于 10 的元素。</li><li>依次追加给新数组 newArr。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];var newArr = [];for (var i = 0; i &lt; arr.length; i++) {    if (arr[i] &gt;= 10) {        // 给新数组        newArr[newArr.length] = arr[i];    }}console.log(newArr);</code></pre><h2 id="4-数组案例"><a href="#4-数组案例" class="headerlink" title="4. 数组案例"></a>4. 数组案例</h2><h3 id="4-1-删除指定数组元素"><a href="#4-1-删除指定数组元素" class="headerlink" title="4.1 删除指定数组元素"></a>4.1 删除指定数组元素</h3><p><strong>将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数组。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];var newArr = [];   // 空数组的默认的长度为 0 // 定义一个变量 i 用来计算新数组的索引号for (var i = 0; i &lt; arr.length; i++) {    // 找出大于 10 的数    if (arr[i] != 0) {        // 给新数组        // 每次存入一个值，newArr长度都会 +1          newArr[newArr.length] = arr[i];    }}console.log(newArr);</code></pre><h3 id="4-2-翻转数组"><a href="#4-2-翻转数组" class="headerlink" title="4.2 翻转数组"></a>4.2 翻转数组</h3><p><strong>将数组 [‘red’, ‘green’, ‘blue’, ‘pink’, ‘purple’] 的内容反过来存放</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 把旧数组索引号的第4个取过来(arr.length - 1),给新数组索引号第0个元素(newArr.length)var arr = ['red','green','blue','pink','purple'];var newArr = [];for (var i = arr.length -1; i&gt;=0; i-- {    newArr[newArr.length] = arr[i];}console.log(newArr);</code></pre><h3 id="4-3-冒泡排序"><a href="#4-3-冒泡排序" class="headerlink" title="4.3 冒泡排序"></a>4.3 冒泡排序</h3><p><strong>冒泡排序</strong>：是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小）。</p><p>将数组 [5, 4, 3, 2, 1]中的元素按照从小到大的顺序排序，输出： 1，2，3，4，5（考虑此<strong>极端情况</strong>，即所有数顺序有误）</p><p><img src="https://img-blog.csdnimg.cn/be5d94f31bb346bda947f6f27f891d2f.png#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var arr = [5,4,3,2,1];for (var i = 0; i &lt; arr.length-1; i++){ //表示要重复从头开始比较4趟    for (var j = 0; j &lt; arr.length - i - 1; j++){        //里层循环管每一趟比较的次数        //前一个和后面一个数组元素相比较        if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }      }}console.log(arr);</code></pre><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><p>函数：就是封装了一段<strong>可被重复调用执行的代码块</strong>。通过此代码块可以实现大量代码的重复使用。</p><h2 id="1-函数的使用"><a href="#1-函数的使用" class="headerlink" title="1. 函数的使用"></a>1. 函数的使用</h2><p>函数在使用时分为两步：<strong>声明函数</strong>和<strong>调用函数</strong></p><h3 id="1-1-声明函数"><a href="#1-1-声明函数" class="headerlink" title="1.1 声明函数"></a>1.1 声明函数</h3><h4 id="1-1-1-自定义函数方式-命名函数"><a href="#1-1-1-自定义函数方式-命名函数" class="headerlink" title="1.1.1 自定义函数方式 (命名函数)"></a>1.1.1 自定义函数方式 (命名函数)</h4><p>利用函数关键字 <code>function</code> 自定义函数方式。</p><p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为<strong>动词</strong>，比如 <code>getSum</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">函数名();function 函数名() {     //函数体代码}</code></pre><ul><li>因为<strong>有名字</strong>，所以也被称为命名函数</li><li><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></li></ul><h4 id="1-1-2-函数表达式方式-匿名函数"><a href="#1-1-2-函数表达式方式-匿名函数" class="headerlink" title="1.1.2 函数表达式方式 (匿名函数)"></a>1.1.2 函数表达式方式 (匿名函数)</h4><p>利用函数表达式方式的写法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...};// 调用时以变量名fn调用fn();</code></pre><ul><li>因为函数<strong>没有名字</strong>，所以也称为匿名函数</li><li>这个fn 里面存储的是一个函数</li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ul><h3 id="1-2-调用函数"><a href="#1-2-调用函数" class="headerlink" title="1.2 调用函数"></a>1.2 调用函数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">函数名(); //通过调用函数名来执行函数体代码</code></pre><ul><li>调用的时候<strong>千万不要忘记添加小括号</strong></li><li>口诀：函数不调用，自己不执行</li></ul><h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2. 函数的参数"></a>2. 函数的参数</h2><h3 id="2-1-形参和实参"><a href="#2-1-形参和实参" class="headerlink" title="2.1 形参和实参"></a>2.1 形参和实参</h3><p><strong>在声明函数时</strong>，可以在函数名称后面的小括号中添加一些参数，这些参数被称为<strong>形参</strong>，而在<strong>调用该函数</strong>时，同样也需要传递相应的参数，这些参数被称为<strong>实参</strong>。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>形参</td><td>形式上的参数 <strong>函数定义</strong>时传递的参数 当前并不知道是什么（<strong>默认值是undefined</strong>）</td></tr><tr><td>实参</td><td>实际上的参数 <strong>函数调用</strong>时传递的参数 实参是传递给形参的</td></tr></tbody></table><p><strong>参数的作用</strong> : 在<strong>函数内部</strong>某些值不能固定，我们可以通过参数在<strong>调用函数时传递不同的值</strong>进去</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔  // 函数体}// 带参数的函数调用函数名(实参1, 实参2, 实参3...); </code></pre><h3 id="2-2-形参和实参个数不匹配"><a href="#2-2-形参和实参个数不匹配" class="headerlink" title="2.2 形参和实参个数不匹配"></a>2.2 形参和实参个数不匹配</h3><table><thead><tr><th>参数个数</th><th>说明</th></tr></thead><tbody><tr><td>实参个数等于形参个数</td><td>输出正确结果</td></tr><tr><td>实参个数多于形参个数</td><td>只取到形参的个数</td></tr><tr><td>实参个数小于形参个数</td><td>多的形参定义为undefined，结果为NaN</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function sum(num1, num2) {    console.log(num1 + num2);}sum(100, 200);             // 300，形参和实参个数相等，输出正确结果sum(100, 400, 500, 700);   // 500，实参个数多于形参，只取到形参的个数sum(200);                  // 实参个数少于形参，多的形参定义为undefined，结果为NaN</code></pre><h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3. 函数的返回值"></a>3. 函数的返回值</h2><h3 id="3-1-return语句"><a href="#3-1-return语句" class="headerlink" title="3.1 return语句"></a>3.1 return语句</h3><p>有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 声明函数function 函数名（）{    ...    return  需要返回的值;}// 调用函数函数名();    // 此时调用函数就可以得到函数体内return 后面的值</code></pre><ul><li>在使用 return 语句时，函数会停止执行，并返回指定的值</li><li>如果函数<strong>没有 return</strong> ，返回的值是 <strong>undefined</strong></li></ul><h3 id="3-2-return-终止函数"><a href="#3-2-return-终止函数" class="headerlink" title="3.2 return 终止函数"></a>3.2 return 终止函数</h3><p>return 语句之后的代码不被执行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function add(num1，num2) {    return num1 + num2; // 注意：return 后的代码不执行    alert('我不会被执行，因为前面有 return');}var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值alert(resNum);          // 27</code></pre><h3 id="3-3-return-的返回值"><a href="#3-3-return-的返回值" class="headerlink" title="3.3 return 的返回值"></a>3.3 return 的返回值</h3><p>return <strong>只能返回一个值</strong>。如果用逗号隔开多个值，<strong>以最后一个为准</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function add(num1，num2) {    return num1, num2;}var resNum = add(21, 6); // 调用函数alert(resNum);          // 6</code></pre><h3 id="3-4-break、continue、return-的区别"><a href="#3-4-break、continue、return-的区别" class="headerlink" title="3.4 break、continue、return 的区别"></a>3.4 break、continue、return 的区别</h3><ul><li><code>break</code> ： 结束当前循环体(如 for、while)</li><li><code>continue</code> ：跳出本次循环，<strong>继续执行</strong>下次循环(如for、while)</li><li><code>return</code> ：不仅可以退出循环，还能够<strong>返回 return 语句中的值</strong>，同时还可以结束当前的函数体内的代码</li></ul><h2 id="4-arguments的使用"><a href="#4-arguments的使用" class="headerlink" title="4. arguments的使用"></a>4. arguments的使用</h2><p>当我们<strong>不确定有多少个参数传递</strong>的时候，可以用 arguments 来获取。</p><ul><li>arguments 实际上是所有函数中的一个内置对象，arguments 对象中<strong>存储了传递的所有实参</strong>。</li><li>arguments <strong>展示形式是一个伪数组</strong>，因此可以进行遍历。伪数组具有以下特点：<ul><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ul></li></ul><p>例如：利用函数求任意个数的最大值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> function maxValue() {    var max = arguments[0];    for (var i = 1; i &lt; arguments.length; i++) {        if (arguments[i] &gt; max) {            max = arguments[i];        }    }    return max;}console.log(maxValue(2, 4, 5, 9)); // 9console.log(maxValue(12, 4, 9)); // 12</code></pre><h2 id="5-函数调用另外一个函数"><a href="#5-函数调用另外一个函数" class="headerlink" title="5. 函数调用另外一个函数"></a>5. 函数调用另外一个函数</h2><p>因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。</p><p><strong>例：用户输入年份，输出当前年份2月份的天数，如果是闰年，则2月份是 29天， 如果是平年，则2月份是 28天</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function backDay() {    var year = prompt('请您输入年份:');    if (isRun(year)) { //调用函数需要加小括号        alert('你输入的' + year + '是闰年，2月份有29天');    } else {        alert('您输入的' + year + '不是闰年，2月份有28天');    }}backDay();//判断是否是闰年的函数function isRun(year) {    var flag = false;    if (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0) {        flag = true;    }    return flag;}</code></pre><h2 id="6-函数作业"><a href="#6-函数作业" class="headerlink" title="6. 函数作业"></a>6. 函数作业</h2><p>做一个简易计算器</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var tan = prompt('1.加法运算\n2.减法运算\n3.乘法运算\n4.除法运算\n5.退出');function jisuan(shuzi) {//封装计算功能var num1 = parseInt(prompt('请输入第一个数：'));var num2 = parseInt(prompt('请输入第二个数：'));var result = 0;switch (parseInt(shuzi)) {case 1:result = num1 + num2;break;case 2:result = num1 - num2;break;case 3:result = num1 * num2;break;case 4:result = num1 / num2;break;}alert(result);tan = prompt('1.+运算\n2.减法运算\n3.乘法运算\n4.除法运算\n5.退出');}while (1 == 1) {if (tan == '1') {jisuan(tan);}if (tan == '2') {jisuan(tan);}if (tan == '3') {jisuan(tan);}if (tan == '4') {jisuan(tan);}if (tan == '5') {break;}}</code></pre><h1 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h1><p>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的<strong>可用性的代码范围</strong>就是这个名字的<strong>作用域</strong>。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</p><p>JavaScript (ES6前) 中的作用域有两种：</p><ul><li>全局作用域</li><li>局部作用域(函数作用域)</li></ul><h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h2><h3 id="1-1-全局作用域"><a href="#1-1-全局作用域" class="headerlink" title="1.1 全局作用域"></a>1.1 全局作用域</h3><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件</p><h3 id="1-2-局部（函数）作用域"><a href="#1-2-局部（函数）作用域" class="headerlink" title="1.2 局部（函数）作用域"></a>1.2 局部（函数）作用域</h3><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域</p><h3 id="1-3-JS-没有块级作用域"><a href="#1-3-JS-没有块级作用域" class="headerlink" title="1.3 JS 没有块级作用域"></a>1.3 JS 没有块级作用域</h3><ul><li>块作用域由 <code>{}</code> 包括</li><li>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(true){    int num = 123;    System.out.println(num);// 123}System.out.println(num);// 报错</code></pre></li></ul><p>JS 中没有块级作用域(在ES6之前)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(true){var num = 123;console.log(num); //123}console.log(num);   //123</code></pre><h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2. 变量的作用域"></a>2. 变量的作用域</h2><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p><ul><li>全局变量</li><li>局部变量</li></ul><h3 id="2-1-全局变量"><a href="#2-1-全局变量" class="headerlink" title="2.1 全局变量"></a>2.1 全局变量</h3><p>在全局作用域下声明的变量叫做全局变量（<strong>在函数外部定义的变量</strong>）</p><ul><li>全局变量在代码的任何位置都可以使用</li><li>在全局作用域下 var 声明的变量 是全局变量</li><li>特殊情况下，<strong>在函数内不使用 var 声明的变量也是全局变量</strong>（不建议使用）</li></ul><h3 id="2-2-局部变量"><a href="#2-2-局部变量" class="headerlink" title="2.2 局部变量"></a>2.2 局部变量</h3><p>在局部作用域下声明的变量叫做局部变量（<strong>在函数内部定义的变量</strong>）</p><ul><li>局部变量只能在该函数<strong>内部</strong>使用</li><li>在函数内部 var 声明的变量是局部变量</li><li>函数的<strong>形参</strong>实际上就是<strong>局部变量</strong></li></ul><h3 id="2-3-区别"><a href="#2-3-区别" class="headerlink" title="2.3 区别"></a>2.3 区别</h3><ul><li><p>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</p></li><li><p>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</p></li></ul><h2 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3. 作用域链"></a>3. 作用域链</h2><ol><li>只要是代码，就至少有一个作用域</li><li>写在函数内部的叫局部作用域</li><li>如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域</li><li>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function f1() {var num = 123;function f2() {console.log( num );}f2();}var num = 456;f1(); //123</code></pre><p>作用域链：采取<strong>就近原则</strong>的方式来查找变量最终的值。</p><h1 id="四、预解析"><a href="#四、预解析" class="headerlink" title="四、预解析"></a>四、预解析</h1><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行代码的时候分为两步：<strong>预解析和代码执行</strong>。</p><ul><li>预解析：js引擎会把js里面所有的 <code>var</code> 还有 <code>function</code> 提升到当前作用域的最前面</li><li>代码执行：<strong>从上到下</strong>执行JS语句</li></ul><p>预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道<strong>为什么在变量声明之前访问变量的值是 undefined，为什么在函数声明之前就可以调用函数。</strong></p><h2 id="1-变量预解析-变量提升"><a href="#1-变量预解析-变量提升" class="headerlink" title="1. 变量预解析(变量提升)"></a>1. 变量预解析(变量提升)</h2><p>变量的声明会被提升到<strong>当前作用域</strong>的最上面，<strong>变量的赋值不会提升</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(num);  // 结果是undefinedvar num = 10;   //相当于执行了以下代码var num;// 变量声明提升到当前作用域最上面console.log(num);num = 10;// 变量的赋值不会提升</code></pre><h2 id="2-函数预解析-函数提升"><a href="#2-函数预解析-函数提升" class="headerlink" title="2. 函数预解析(函数提升)"></a>2. 函数预解析(函数提升)</h2><p>函数的声明会被提升到<strong>当前作用域</strong>的最上面，但是<strong>不会调用函数</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn();//11function fn() {    console.log('11');}</code></pre><h3 id="2-1-解决函数表达式声明调用问题"><a href="#2-1-解决函数表达式声明调用问题" class="headerlink" title="2.1 解决函数表达式声明调用问题"></a>2.1 解决函数表达式声明调用问题</h3><p>对于函数表达式声明调用需要记住：<strong>函数表达式调用必须写在函数声明的下面</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面fn();var  fn = function() {    console.log('22'); // 报错}//相当于执行了以下代码var fn;fn();      //fn没赋值，没这个，报错fn = function() {    console.log('22'); //报错}</code></pre><h2 id="3-预解析练习"><a href="#3-预解析练习" class="headerlink" title="3. 预解析练习"></a>3. 预解析练习</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 练习1var num = 10;fun();  // 最终结果是 undefinedfunction fun() {    console.log(num);    var num = 20;} //相当于执行了以下操作var num;function fun() {    var num;    console.log(num);    num = 20;}num = 10;fun();</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 练习2var num = 10;function fn(){    console.log(num);    var num = 20;    console.log(num);}fn(); // 最终结果是 undefined 20//相当于执行了以下操作var num;function fn(){    var num;    console.log(num);    num = 20;    console.log(num);}num = 10;fn();</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 练习3var a = 18;f1();  // 最终结果是 undefined 9function f1() {    var b = 9;    console.log(a);    console.log(b);    var a = '123';}//相当于执行了以下操作var a;function f1() {    var b;    var a    b = 9;    console.log(a);//undefined    console.log(b);//9    a = '123';}a = 18;f1();</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 练习4f1();  // 9 9 9console.log(c); // 9console.log(b); // 9console.log(a); // undefinedfunction f1() {    var a = b = c = 9;    // 相当于 var a = 9; b = 9;c = 9;  b和c的前面没有var声明,当全局变量看    // 集体声明应为 var a = 9,b = 9,c = 9;    console.log(a);    console.log(b);    console.log(c);}//相当于执行了以下操作function f1() {    var a;    a = b = c = 9;    console.log(a);//9    console.log(b);//9    console.log(c);//9}f1();console.log(c);//9console.log(b);//9console.log(a);//报错 a是局部变量</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础（一）JavaScript基础语法汇总</title>
      <link href="/2023/01/02/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2023/01/02/JavaScript-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaScript简介"><a href="#一、JavaScript简介" class="headerlink" title="一、JavaScript简介"></a>一、JavaScript简介</h1><ul><li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</li><li>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</li><li>现在也可以基于 Node.js 技术进行服务器端编程<br><img src="e2723434f61a4598b0363572c4690c9f.png" alt="在这里插入图片描述"></li></ul><h2 id="1-HTML-CSS-JS-的关系"><a href="#1-HTML-CSS-JS-的关系" class="headerlink" title="1. HTML/CSS/JS 的关系"></a>1. HTML/CSS/JS 的关系</h2><p><strong>HTML/CSS 标记语言–描述类语言</strong> </p><ul><li>HTML 决定网页结构和内容( 决定看到什么 )，相当于人的身体</li><li>CSS 决定网页呈现给用户的模样( 决定好不好看 )， 相当于给人穿衣服、化妆</li></ul><p><strong>JS 脚本语言–编程类语言</strong> </p><ul><li>实现业务逻辑和页面控制( 决定功能 )，相当于人的各种<strong>动作</strong></li></ul><h2 id="2-浏览器执行JS简介"><a href="#2-浏览器执行JS简介" class="headerlink" title="2. 浏览器执行JS简介"></a>2. 浏览器执行JS简介</h2><p>浏览器分成两部分：<strong>渲染引擎</strong>和 <strong>JS 引擎</strong></p><ul><li>渲染引擎：用来<strong>解析HTML与CSS</strong>，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit</li><li>JS 引擎：也称为 JS 解释器。 用来<strong>读取网页中的JavaScript代码</strong>，对其处理后运行，比如 chrome 浏览器的 V8</li></ul><p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会<strong>逐行解释执行</strong>。</p><p><img src="7ed2bdc8d0194937a6c54d21290edea2.png" alt="在这里插入图片描述"></p><h2 id="3-JS的组成"><a href="#3-JS的组成" class="headerlink" title="3. JS的组成"></a>3. JS的组成</h2><p>JavaScript 包括 <strong>ECMAScript</strong>、<strong>DOM</strong>、<strong>BOM</strong></p><p><img src="5b01560c8de24ab7a8ebb4cef64c5f31.png" alt="在这里插入图片描述"></p><h3 id="3-1-ECMAScript"><a href="#3-1-ECMAScript" class="headerlink" title="3.1 ECMAScript"></a>3.1 ECMAScript</h3><p><strong>ECMAScript</strong> 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p><img src="b5cf64f04a6147558712329f76920812.png" alt="在这里插入图片描述"></p><p>ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><p>更多参看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN</a></p><h3 id="3-2-DOM——文档对象模型"><a href="#3-2-DOM——文档对象模型" class="headerlink" title="3.2 DOM——文档对象模型"></a>3.2 DOM——文档对象模型</h3><p><strong>文档对象模型</strong>（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。 通过 DOM 提供的接口可以<strong>对页面上的各种元素</strong>进行操作（大小、位置、颜色等）。</p><h3 id="3-3-BOM-——浏览器对象模型"><a href="#3-3-BOM-——浏览器对象模型" class="headerlink" title="3.3 BOM ——浏览器对象模型"></a>3.3 BOM ——浏览器对象模型</h3><p><strong>浏览器对象模型</strong> (Browser Object Model，简称BOM) ，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以<strong>操作浏览器窗口</strong>，比如弹出框、控制浏览器跳转、获取分辨率等。</p><h2 id="4-JS初体验"><a href="#4-JS初体验" class="headerlink" title="4. JS初体验"></a>4. JS初体验</h2><p>JS 有3种书写位置，分别为行内、内嵌和外部。</p><h3 id="4-1-行内式"><a href="#4-1-行内式" class="headerlink" title="4.1 行内式"></a>4.1 行内式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type="button" value="点我试试" onclink="javascript:alert('Hello World')" /&gt;</code></pre><ol><li>可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性)，如： onclink</li><li>注意单双引号的使用：在HTML中我们推荐使用<strong>双引号</strong>，JS中我们推荐使用<strong>单引号</strong></li><li>可读性差，在 HTML 中编入 JS 大量代码时，不方便阅读</li><li>特殊情况下使用</li></ol><h3 id="4-2-内嵌式"><a href="#4-2-内嵌式" class="headerlink" title="4.2 内嵌式"></a>4.2 内嵌式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;     alert('Hello World!');&lt;/script&gt;</code></pre><ul><li>可以将多行JS代码写到<code>&lt;script&gt;</code>标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul><h3 id="4-3-外部式"><a href="#4-3-外部式" class="headerlink" title="4.3 外部式"></a>4.3 外部式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script src="my.js"&gt;&lt;/script&gt;</code></pre><ul><li>利于HTML页面代码结构化，把单独JS代码独立到HTML页面之外，既美观，又方便</li><li>引用外部JS文件的script标签中间不可以写代码</li><li>适合于JS代码量比较大的情况</li></ul><h2 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h2><h3 id="5-1-单行注释"><a href="#5-1-单行注释" class="headerlink" title="5.1 单行注释"></a>5.1 单行注释</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//  单行注释</code></pre><ul><li>快捷键<code>ctrl + /</code></li></ul><h3 id="5-2-多行注释"><a href="#5-2-多行注释" class="headerlink" title="5.2 多行注释"></a>5.2 多行注释</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">/*多行注释*/    </code></pre><ul><li>vscode中修改快捷键方式：vscode → 首选项按钮→ 键盘快捷方式 → 查找原来的快捷键 → 修改为新的快捷键 → 回车确认</li><li>快捷键<code>ctrl + shift + /</code></li></ul><h1 id="二、JavaScript-基本语法"><a href="#二、JavaScript-基本语法" class="headerlink" title="二、JavaScript 基本语法"></a>二、JavaScript 基本语法</h1><h2 id="1-输入输出语句"><a href="#1-输入输出语句" class="headerlink" title="1. 输入输出语句"></a>1. 输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p><table><thead><tr><th>方法</th><th>说明</th><th>归属</th></tr></thead><tbody><tr><td>alert(msg);</td><td>浏览器弹出警示框</td><td>浏览器</td></tr><tr><td>console.log(msg);</td><td>浏览器控制台打印输出信息</td><td>浏览器</td></tr><tr><td>prompt(info);</td><td>浏览看弹出输入框，用户可以输入</td><td>浏览器</td></tr></tbody></table><p>注意：</p><ul><li><code>alert()</code> 主要用来显示消息给用户</li><li><code>console.log()</code> 用来给程序员自己看运行时的消息</li></ul><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><ul><li>变量是用于<strong>存放数据的容器</strong>，我们通过变量名获取数据，甚至数据可以修改。</li><li>本质：变量是程序在内存中申请的一块用来存放数据的空间。</li></ul><h3 id="2-1-变量的使用"><a href="#2-1-变量的使用" class="headerlink" title="2.1 变量的使用"></a>2.1 变量的使用</h3><p>变量在使用时分为两步： 1. 声明变量 2. 赋值</p><h4 id="2-1-1-声明变量"><a href="#2-1-1-声明变量" class="headerlink" title="2.1.1 声明变量"></a>2.1.1 声明变量</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var age;//声明一个名称为age的变量</code></pre><ul><li><code>var</code> 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会<strong>自动为变量分配</strong>内存空间，不需要程序员管；</li><li><code>age</code> 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</li><li>同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var age = 10, name = 'zs', sex = 2;</code></pre></li></ul><p><em><strong>声明变量特殊情况：</strong></em></p><table><thead><tr><th>情况</th><th>说明</th><th>结果</th></tr></thead><tbody><tr><td>var age; console.log(age);</td><td>只声明，不赋值</td><td>undefined</td></tr><tr><td>console.log(age);</td><td>不声明 不赋值 直接使用</td><td>报错</td></tr><tr><td>age = 10;console.log(age);</td><td>不声明 只赋值</td><td>10</td></tr></tbody></table><h4 id="2-1-2-赋值"><a href="#2-1-2-赋值" class="headerlink" title="2.1.2 赋值"></a>2.1.2 赋值</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">age = 10;//给 age 这个变量赋值为 10</code></pre><ul><li><code>=</code> 用来把右边的值赋给左边的变量空间中</li><li>变量值是程序员保存到变量空间里的值</li><li>一个变量被重新赋值后，它原有的值就会被覆盖，<strong>变量值将以最后一次赋的值为准</strong>。</li></ul><h3 id="2-2-变量的命名规范"><a href="#2-2-变量的命名规范" class="headerlink" title="2.2 变量的命名规范"></a>2.2 变量的命名规范</h3><ol><li>由字母<code>(A-Z,a-z)</code>，数字<code>(0-9)</code>，下划线<code>(_)</code>，美元符号<code>($)</code>组成；</li><li>严格区分大小写。 <code>var app; </code>和 <code>var App; </code>是两个变量；</li><li>不能以数字开头；</li><li>不能是关键字，保留字。例如：<code>var,for,while</code></li><li>遵循驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：<code>myFirstName</code></li></ol><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><ul><li>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。</li><li>JavaScript 是一种弱类型或者说动态语言。这意味着<strong>不用提前声明变量的类型</strong>，在程序运行过程中，类型会被自动确定。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var age = 10; // 这是一个数字型 var areYouOk = '是的'; // 这是一个字符串</code></pre><ul><li>在代码运行时，变量的数据类型是由 JS引擎 <strong>根据 = 右边变量值的数据类型</strong> 来判断的，运行完毕之后， 变量就确定了数据类型。</li><li>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var x = 6; // x 为数字 var x = "Bill"; // x 为字符串</code></pre><h3 id="3-1-简单数据类型"><a href="#3-1-简单数据类型" class="headerlink" title="3.1 简单数据类型"></a>3.1 简单数据类型</h3><p>JS 把数据类型分为两类： </p><ul><li>简单数据类型（Number,String,Boolean,Undefined,Null） </li><li>复杂数据类型 （object)</li></ul><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>Number</td><td>数字型，包含整型值和浮点型值，如21，0.21</td><td>0</td></tr><tr><td>Boolean</td><td>布尔值类型，如true、false ，等价于1和0</td><td>false</td></tr><tr><td>String</td><td>字符串类型，如“张三”</td><td>‘ ‘</td></tr><tr><td>Undefined</td><td>var a; 声明了变量a但是没有赋值，此时a=undefined</td><td>undefined</td></tr><tr><td>Null</td><td>var a = null;声明了变量a为空值</td><td>null</td></tr></tbody></table><h4 id="3-1-1-数字型-Number"><a href="#3-1-1-数字型-Number" class="headerlink" title="3.1.1 数字型 Number"></a>3.1.1 数字型 Number</h4><p>JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。</p><p><strong>1. 数字型进制</strong></p><p>最常见的进制有二进制、八进制、十进制、十六进制。 </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.八进制数字序列范围：0~7 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~F var num = 0xA;</code></pre><p>现阶段我们只需要记住，在JS中八进制前面加<code>0</code>，十六进制前面加 <code>0x</code></p><p><strong>2. 数字型范围</strong></p><p>JavaScript中数值的最大和最小值 </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">alert(Number.MAX_VALUE); // 1.7976931348623157e+308 alert(Number.MIN_VALUE); // 5e-324</code></pre><p><strong>3. 数字型三个特殊值</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">alert(Infinity); //Infinity(无穷大)alert(-Infinity); //-Infinity(无穷小)alert(NaN);       //Not a Number ,代表任何一个非数值</code></pre><p><strong>4. isNaN</strong></p><p><img src="31d11b1f94e044c4b19267f13fe1e8df.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var userAge = 21;var isOk = isNan(userAge);console.log(isOk);//false,21不是一个非数字var userName = "andy";console.log(isNan(userName));//true,"andy"是一个非数字</code></pre><h4 id="3-1-2-字符串型-String"><a href="#3-1-2-字符串型-String" class="headerlink" title="3.1.2 字符串型 String"></a>3.1.2 字符串型 String</h4><p><strong>1. 字符串引号嵌套</strong></p><p>JS可以用 <strong>单引号嵌套双引号</strong>，或者用 <strong>双引号嵌套单引号</strong>（<strong>外双内单，外单内双</strong>）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var strMsg ='我是一个“高富帅”' //可以用 '' 包含 ""var strMsg2 ="我是'高富帅'" //可以用"" 包含  ''</code></pre><p><strong>2. 字符串转义符</strong></p><p>类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</p><p>转义符都是 <code>\</code> 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符，n是newline</td></tr><tr><td><code>\\</code></td><td>斜杠<code>\</code></td></tr><tr><td><code>\'</code></td><td>‘ 单引号</td></tr><tr><td><code>\''</code></td><td>‘’ 双引号</td></tr><tr><td><code>\t</code></td><td>tab 缩进</td></tr><tr><td><code>\b</code></td><td>空格，b是blank的意思</td></tr></tbody></table><p><strong>3. 字符串长度</strong></p><p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <code>length</code> 属性可以获取整个字符串的长度。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//通过字符串的length属性可以获取整个字符串的长度var strMsg = "我是高富帅！";alert(strMsg.length);     //显示6</code></pre><p><strong>4. 字符串拼接</strong></p><ul><li>多个字符串之间可以使用 + 进行拼接，其拼接方式为 <strong>字符串 + 任何类型 = 拼接之后的新字符串</strong></li><li>拼接前会把<strong>与字符串相加的任何类型转成字符串</strong>，再拼接成一个新的字符串</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">//1 字符串相加alert('hello' + ' ' + 'World');  //hello World//2 数值字符串相加alert('100' + '100'); //100100//3 数值字符串+数值alert('12'+ 12); //1212 自动转换为字符串//4 数值+数值alert(12 + 12); //24</code></pre><h4 id="3-1-3-布尔型-Boolean"><a href="#3-1-3-布尔型-Boolean" class="headerlink" title="3.1.3 布尔型 Boolean"></a>3.1.3 布尔型 Boolean</h4><ul><li>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</li><li>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var flag = true;console.log(flag + 1); // 2 true当加法来看当1来看，flase当0来看</code></pre><h4 id="3-1-4-未定义-undefined"><a href="#3-1-4-未定义-undefined" class="headerlink" title="3.1.4 未定义 undefined"></a>3.1.4 未定义 undefined</h4><ul><li>一个<strong>声明后没有被赋值</strong>的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 如果一个变量声明未赋值，就是undefined 未定义数据类型var str;console.log(str);//undefinedvar variable = undefined;console.log(variable + 'Pink'); //undefinedPinkconsole.log(variable + 18); //NaN </code></pre><ol><li>undefined 和 字符串 相加，会拼接字符串</li><li>undefined 和 数字相加，最后结果是<strong>NaN</strong></li></ol><h4 id="3-1-5-空值-null"><a href="#3-1-5-空值-null" class="headerlink" title="3.1.5 空值 null"></a>3.1.5 空值 null</h4><ul><li>一个声明变量给 null 值，里面存的值为空</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var space = null;console.log(space + 'pink'); //nullpinkconsole.llog(space + 1); // 1 </code></pre><h3 id="3-2-获取变量的数据类型"><a href="#3-2-获取变量的数据类型" class="headerlink" title="3.2 获取变量的数据类型"></a>3.2 获取变量的数据类型</h3><ul><li><code>typeof</code> 可用来获取检测变量的数据类型</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num = 18;console.log(typeof num) // 结果 number  </code></pre><table><thead><tr><th>类型</th><th>例</th><th>结果</th></tr></thead><tbody><tr><td>string</td><td>typeof “小白”</td><td>“string”</td></tr><tr><td>number</td><td>typeof 18</td><td>“number”</td></tr><tr><td>boolean</td><td>typeof true</td><td>“boolean”</td></tr><tr><td>undefined</td><td>typeof undefined</td><td>“undefined”</td></tr><tr><td>null</td><td>typeof null</td><td>“object”</td></tr></tbody></table><h3 id="3-3-数据类型转换"><a href="#3-3-数据类型转换" class="headerlink" title="3.3 数据类型转换"></a>3.3 数据类型转换</h3><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，<strong>就是把一种数据类型的变量转换成另外一种数据类型</strong>。</p><p>我们通常会实现3种方式的转换：</p><ul><li>转换为字符串类型</li><li>转换为数字型</li><li>转换为布尔型</li></ul><h4 id="3-3-1-转换为字符串型"><a href="#3-3-1-转换为字符串型" class="headerlink" title="3.3.1 转换为字符串型"></a>3.3.1 转换为字符串型</h4><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>toString()</td><td>转成字符串</td><td>var num = 1; alert(num.toString());</td></tr><tr><td>String()强制转换</td><td>转成字符串</td><td>var num = 1; alert(String(num));</td></tr><tr><td>加号拼接字符串</td><td>和字符串拼接的结果都是字符串</td><td>var num =1; alert(num+’我是字符串’);</td></tr></tbody></table><ul><li>toString() 和 String() 使用方式不一样</li><li>三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一方式也称为隐式转换</li></ul><h4 id="3-3-2-转换为数字型（重点）"><a href="#3-3-2-转换为数字型（重点）" class="headerlink" title="3.3.2 转换为数字型（重点）"></a>3.3.2 转换为数字型（重点）</h4><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><strong>parseInt(string)函数</strong></td><td>将string类型转成整数数值型</td><td>parseInt(‘78’)</td></tr><tr><td><strong>parseFloat(string)函数</strong></td><td>将string类型转成浮点数数值型</td><td>parseFloat(‘78.21’)</td></tr><tr><td>Number()强制转换函数</td><td>将string类型转换为数值型</td><td>Number(‘12’)</td></tr><tr><td>js 隐式转换(- * /)</td><td>利用算术运算隐式转换为数值型</td><td>‘12’-0</td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 1.parseInt()var age =prompt('请输入您的年龄');consolo.log(parseInt(age));  //数字型18consolo.log(parseInt('3.14'));  //3取整consolo.log(parseInt('3.94'));  //3,不会四舍五入consolo.log(parseInt('120px'));  //120,会去掉单位// 2.parseFloat()console.log(parseFloat('3.14'));  //3.14consolo.log(parseFloat('120px'));  //120,会去掉单位// 3.利用Number(变量)var str ='123';console.log(Number(str));console.log(Number('12'));   // 4.利用了算术运算 - * /   隐式转换console.log('12'-0);  // 12console.log('123' - '120');  //3console.log('123' * 1);  // 123</code></pre><ul><li>注意 <strong>parseInt</strong> 和 <strong>parseFloat</strong> ，这两个是重点</li><li>隐式转换是我们在进行算数运算的时候，JS自动转换了数据类型</li></ul><h4 id="3-3-3-转换为布尔型"><a href="#3-3-3-转换为布尔型" class="headerlink" title="3.3.3 转换为布尔型"></a>3.3.3 转换为布尔型</h4><table><thead><tr><th>方法</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>Boolean()函数</td><td>其他类型转成布尔值</td><td>Boolean(‘true’);</td></tr></tbody></table><ul><li>代表<strong>空、否定的值</strong>会被转换为false，如 ‘ ‘ , 0, NaN , null , undefined</li><li>其余的值都会被被转换为true</li></ul><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><p>运算符（operator）也被称为<strong>操作符</strong>，是用于实现赋值、比较和执行算数运算等功能的符号</p><p>JavaScript 中常用的运算符有：</p><ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><h3 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h3><p>概念：算术运算使用的符号，用于执行两个变量或值的算术运算。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>10 + 20 =30</td></tr><tr><td>-</td><td>减</td><td>10 - 20 =-10</td></tr><tr><td>*</td><td>乘</td><td>10 * 20 =200</td></tr><tr><td>/</td><td>除</td><td>10 / 20 =0.5</td></tr><tr><td>%</td><td>取余数（取模）</td><td>返回出发的余数 9 % 2 =1</td></tr></tbody></table><ul><li>浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数</li><li><strong>所以不要直接判断两个浮点数是否相等</strong><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var result = 0.1 +0.2; //结果不是0.3，0.30000000000000004console.log(0.07 * 100); //结果不是7，而是7.000000000000001</code></pre></li></ul><h3 id="4-2-递增和递减运算符"><a href="#4-2-递增和递减运算符" class="headerlink" title="4.2 递增和递减运算符"></a>4.2 递增和递减运算符</h3><p>递增（++）</p><p>递减（- -）</p><p>放在变量前面时，我们称为<strong>前置递增(递减)运算符</strong></p><p>放在变量后面时，我们称为<strong>后置递增(递减)运算符</strong></p><p><strong>注意</strong>：递增和递减运算符必须和变量配合使用。</p><h4 id="4-2-1-前置递增运算符"><a href="#4-2-1-前置递增运算符" class="headerlink" title="4.2.1 前置递增运算符"></a>4.2.1 前置递增运算符</h4><p>++num：前置递增，就是自加1<br>使用口诀:<strong>先自加，后返回值</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num = 10;alert (++num + 10); // 21</code></pre><h4 id="4-2-2-后置递增运算符"><a href="#4-2-2-后置递增运算符" class="headerlink" title="4.2.2 后置递增运算符"></a>4.2.2 后置递增运算符</h4><p>num ++：后置递增，就是自加1</p><p>使用口诀:<strong>先返回原值，后自加</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num = 10;alert(10 + num++); // 20</code></pre><p><strong>小结：</strong></p><ul><li><strong>单独使用时，运行结果相同</strong>，与其他代码联用时，执行结果会不同</li><li>后置：先原值运算，后自加（先人后己）</li><li>前置：先自加，后运算（先已后人）</li><li>开发时，大多使用后置递增/减，并且代码独占一行</li></ul><h3 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a>4.3 比较运算符</h3><p>比较运算符是<strong>两个数据进行比较时所使用的运算符</strong>，比较运算后，会<strong>返回一个布尔值</strong>(true / false)作为比较运算的结果。</p><table><thead><tr><th>运算符名称</th><th>说明</th><th>案例</th><th>结果</th></tr></thead><tbody><tr><td>&lt;</td><td>小于号</td><td>1 &lt; 2</td><td>true</td></tr><tr><td>&gt;</td><td>大于号</td><td>1 &gt; 2</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于号(大于或者等于)</td><td>2 &gt;= 2</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于号(小于或者等于)</td><td>3 &lt;= 2</td><td>false</td></tr><tr><td>==</td><td>判等号(会转型)</td><td>37 == 37</td><td>true</td></tr><tr><td>!=</td><td>不等号</td><td>37 != 37</td><td>false</td></tr><tr><td><code>===</code> <code>!==</code></td><td>全等 要求<strong>值和数据类型都一致</strong></td><td>37 === ‘37’</td><td>false</td></tr></tbody></table><ul><li>含有 <code>=</code> 的（除 <code>===</code> <code>!==</code> ）会对变量进行隐式转换为数字型</li></ul><h3 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。</p><table><thead><tr><th>逻辑运算符</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>“逻辑与”，简称”与”and</td><td><code>true &amp;&amp; false</code></td></tr><tr><td>`</td><td></td><td>`</td></tr><tr><td><code>!</code></td><td>“逻辑非”，简称”非”not</td><td><code>！true</code></td></tr></tbody></table><ul><li>逻辑与：两边都是 true才返回 true，否则返回 false</li><li>逻辑或：两边都为 false 才返回 false，否则都为true</li><li>逻辑非：逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</li></ul><h4 id="4-4-1-短路运算-逻辑中断"><a href="#4-4-1-短路运算-逻辑中断" class="headerlink" title="4.4.1 短路运算(逻辑中断)"></a>4.4.1 短路运算(逻辑中断)</h4><p><strong>原理</strong>：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值<br><strong>注意</strong>：正常情况下，是布尔值参与逻辑运算。当值或表达式参与逻辑运算时，出现逻辑中断。</p><p><strong>1. 逻辑与</strong></p><ul><li>语法：表达式1 &amp;&amp; 表达式2</li><li>如果第一个表达式的值为真，则返回表达式2</li><li>如果第一个表达式的值为假，则返回表达式1</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(123 &amp;&amp; 456);   //456console.log(0 &amp;&amp; 456);     //0console.log(123 &amp;&amp; 456 &amp;&amp; 789);  //789</code></pre><p><strong>2. 逻辑或</strong></p><ul><li>语法：表达式1 || 表达式2</li><li>如果第一个表达式的值为真，则返回表达式1</li><li>如果第一个表达式的值为假，则返回表达式2</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(123 || 456); // 123console.log(123 || 456 || 456 + 123); // 123console.log(0 || 456 || 456 + 123); // 456// 逻辑中断很重要 它会影响我们程序运行结果var num = 0;console.log(123 || num++);//123console.log(num); // 0 num++未执行</code></pre><h3 id="4-5-赋值运算符"><a href="#4-5-赋值运算符" class="headerlink" title="4.5 赋值运算符"></a>4.5 赋值运算符</h3><p>概念：用来把数据赋值给变量的运算符。</p><table><thead><tr><th>赋值运算符</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><code>=</code></td><td>直接赋值</td><td>var usrName = ‘我是值’</td></tr><tr><td><code>+= ，-=</code></td><td>加、减一个数后再赋值</td><td>var age = 10； age+=5；//15</td></tr><tr><td><code>*=，/=，%=</code></td><td>乘、除、取模后再赋值</td><td>varage = 2; age*=5; //10</td></tr></tbody></table><h3 id="4-6-运算符优先级"><a href="#4-6-运算符优先级" class="headerlink" title="4.6 运算符优先级"></a>4.6 运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>顺序</th></tr></thead><tbody><tr><td>1</td><td>小括号</td><td>()</td></tr><tr><td>2</td><td>一元运算符</td><td>++  –  ！</td></tr><tr><td>3</td><td>算数运算符</td><td><strong>先 * / 后 + -</strong></td></tr><tr><td>4</td><td>关系运算符</td><td><strong>&gt;, &gt;= , &lt; , &lt;=</strong></td></tr><tr><td>5</td><td>相等运算符</td><td><code>== ，!=，=== ，!==</code></td></tr><tr><td>6</td><td>逻辑运算符</td><td><strong>先与后或</strong></td></tr><tr><td>7</td><td>赋值运算符</td><td>=</td></tr><tr><td>8</td><td>逗号运算符</td><td>，</td></tr><tr><td>1.一元运算符里面的<strong>逻辑非</strong>优先级很高</td><td></td><td></td></tr><tr><td>2.<strong>逻辑与</strong> 比 <strong>逻辑或</strong> 优先级高</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log( 4 &gt;= 6 || '人' != '阿凡达' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true)// truevar a = 3 &gt; 5 &amp;&amp; 2 &lt; 7 &amp;&amp; 3 == 4; console.log(a); //false var b = 3 &lt;= 4 || 3 &gt; 1 || 3 != 2; console.log(b); //truevar c = 2 === "2"; console.log(c);  //falsevar d = !c || b &amp;&amp; a ;console.log(d);//true</code></pre><h2 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a>5. 流程控制</h2><p>流程控制主要有三种结构，分别是<strong>顺序结构、分支结构和循环结构</strong>，这三种结构代表三种代码执行的顺序</p><h3 id="5-0-断点调试"><a href="#5-0-断点调试" class="headerlink" title="5.0 断点调试"></a>5.0 断点调试</h3><ol><li>浏览器中按 F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点(在行数点一下)</li><li>刷新浏览器</li><li>Watch: 监视，通过watch可以监视变量的值的变化，非常的常用</li><li>F11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化</li></ol><h3 id="5-1-分支结构"><a href="#5-1-分支结构" class="headerlink" title="5.1 分支结构"></a>5.1 分支结构</h3><p>JS 语言提供了两种分支结构语句：</p><ul><li>if 语句 </li><li>switch 语句</li></ul><h4 id="5-1-1-if-语句"><a href="#5-1-1-if-语句" class="headerlink" title="5.1.1 if 语句"></a>5.1.1 if 语句</h4><p><strong>1. if 语句</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 条件成立执行代码，否则什么也不做if (条件表达式) {    //条件成立执行的代码语句}</code></pre><p><strong>2. if else 语句</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 条件成立，执行if里面代码，否则执行else里面的代码if(条件表达式) {    //[如果]条件成立执行的代码}else {        //[否则]执行的代码    }</code></pre><p>案例：判断闰年</p><p>接收用户输入的年份，如果是闰年就弹出闰年，否则弹出是平年</p><p><strong>算法</strong>：能被4整除且不能整除100的为闰年（如2004年就是闰年，1901年不是闰年）或者能够被 400 整除的就是闰年</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var year = prompt('请输入年份');if (year % 4 == 0 &amp;&amp; year % 100 !=0 || year % 400 ==0) {   alert('这个年份是闰年');}else {  alert('这个年份是平年');}</code></pre><p><strong>3. if else if 语句</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(条件表达式1) {  语句1;}else if(条件表达式2) {   语句2;}else if(条件表达式3) {  语句3;}else {   //上述条件都不成立执行此处代码}</code></pre><p>案例:接收用户输入的分数，根据分数输出对应的等级字母 A、B、C、D、E</p><p>其中：<br>90分(含)以上 ，输出：A<br>80分(含)~ 90 分(不含)，输出：B<br>70分(含)~ 80 分(不含)，输出：C<br>60分(含)~ 70 分(不含)，输出：D<br>60分(不含) 以下，输出： E</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var score = prompt('请您输入分数:');       if (score &gt;= 90) {           alert('宝贝，你是我的骄傲');       } else if (score &gt;= 80) {           alert('宝贝，你已经很出色了');       } else if (score &gt;= 70) {           alert('你要继续加油喽');       } else if (score &gt;= 60) {           alert('孩子，你很危险');       } else {           alert('可以再努力点吗，你很棒，但还不够棒');       }</code></pre><h4 id="5-1-2-三元表达式"><a href="#5-1-2-三元表达式" class="headerlink" title="5.1.2 三元表达式"></a>5.1.2 三元表达式</h4><p>如果表达式1为 true ，则返回表达式2的值；如果表达式1为 false，则返回表达式3的值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">表达式1 ? 表达式2 : 表达式3;</code></pre><ul><li>常用于比较几个数的大小</li></ul><p><strong>案例：数字补0</strong></p><p>用户输入数字，如果数字小于10，则在前面补0，比如01，09<br>如果数字大于10，则不需要补，比如20</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num = prompt('请输入0~59之间的一个数字');var result = num &lt; 10 ? '0' + num : numalert(result);</code></pre><h4 id="5-1-3-switch-语句"><a href="#5-1-3-switch-语句" class="headerlink" title="5.1.3 switch 语句"></a>5.1.3 switch 语句</h4><p>switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置<strong>一系列特定值</strong>的选项时，就可以使用 switch。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">switch(表达式){  case value1:     //表达式等于 value1 时要执行的代码     break;  case value2:     //表达式等于value2 时要执行的代码     break;  default:     //表达式不等于任何一个value时要执行的代码  }</code></pre><ul><li>关键字 switch 后面括号内可以是表达式或值， 通常是一个变量</li><li>关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号</li><li>switch 表达式的值会与结构中的 case 的值做比较</li><li>如果存在匹配<strong>全等</strong>(<code>===</code>) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束</li><li>如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码</li><li><strong>执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">// 用户在弹出框里面输入一个水果，如果有就弹出该水果的价格， 如果没有该水果就弹出“没有此水果”var fruit = prompt('请您输入查询的苹果');switch (fruit) {    case '苹果':    alert('苹果的价格为3.5元/千克');        break;    case '香蕉':        alert('香蕉的价格为3元/千克');        break;    default:        alert('没有这种水果');        }</code></pre><p><em><strong>switch 语句和 if else if 语句的区别：</strong></em></p><ul><li>一般情况下，它们两个语句可以相互替换 </li><li>switch…case 语句通常处理 <strong>case为比较确定值</strong>的情况， 而 if…else…语句更加灵活，<strong>常用于范围判断</strong>(大于、等于某个范围) </li><li>switch 语句进行条件判断后直接执行到程序的条件语句，<strong>效率更高</strong>。而if…else 语句有几种条件，就得判断多少次。 <ul><li>当分支比较少时，if… else语句的执行效率比 switch语句高。 </li><li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。</li></ul></li></ul><h3 id="5-2-循环结构"><a href="#5-2-循环结构" class="headerlink" title="5.2 循环结构"></a>5.2 循环结构</h3><p>在Js 中，主要有三种类型的循环语句：</p><ul><li>for 循环</li><li>while 循环</li><li>do…while 循环</li></ul><h4 id="5-2-1-for-循环"><a href="#5-2-1-for-循环" class="headerlink" title="5.2.1 for 循环"></a>5.2.1 for 循环</h4><p>for 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for(初始化变量;条件表达式;操作表达式) {   //循环体}</code></pre><p>执行过程： </p><ol><li>初始化变量，<strong>初始化操作在整个 for 循环只会执行一次</strong>。 </li><li><strong>执行条件表达式</strong>，如果为true，则执行循环体语句，否则退出循环，循环结束。 </li><li><strong>执行操作表达式</strong>，此时第一轮结束。 </li><li>第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。</li><li>继续执行操作表达式，第二轮结束。 </li><li>后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。</li></ol><p><strong>案例：</strong></p><p><strong>1. 要求用户输入班级人数，之后依次输入每个学生的成绩，最后打印出该班级总的成绩以及平均成绩。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num = prompt('请输入班级总的人数:'); // num 班级总的人数var sum = 0; // 总成绩var average = 0; // 平均成绩for (var i = 1; i &lt;= num; i++) {     var score = prompt('请输入第' + i + '个学生的成绩');    //这里接收的是str，必须转换为数值     sum = sum + parseFloat(score);         }average = sum / num;alert('班级总的成绩是：' + sum);alert('班级总的平均成绩是：' + average);</code></pre><p><strong>2. 一行打印五颗星星</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var star = '';for (var i = 1; i &lt;= 5; i++) {     star += '☆'; }console.log(star);</code></pre><h4 id="5-2-2-双重-for-循环"><a href="#5-2-2-双重-for-循环" class="headerlink" title="5.2.2 双重 for 循环"></a>5.2.2 双重 for 循环</h4><p><strong>循环嵌套</strong>是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for(外循环的初始;外循环的条件;外形循环的操作表达式){    for(内循环的初始;内循环的条件;内循环的操作表达式){        需执行的代码;    }}</code></pre><ul><li>内层循环可以看做外层循环的语句</li><li>内层循环执行的顺序也要遵循 for 循环的执行顺序</li><li><strong>外层循环执行一次，内层循环要执行全部次数</strong></li></ul><p><strong>案例：</strong></p><p><strong>1. 打印五行五列星星</strong></p><p>核心：</p><ul><li>内层循环负责一行打印五个星星</li><li>外层循环负责打印五行</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var star = '';for(var j = 1;j&lt;=5;j++){   for (var i = 1; i &lt;= 5; i++)   {     star += '☆'   }    //每次满5个星星就加一次换行    star +='\n'  }console.log(star);</code></pre><p><strong>2. 打印倒三角形</strong></p><p><img src="5719a4092c954a65b3616a10e0711479.png" alt="在这里插入图片描述"></p><ul><li>一共有10行，但是每行的星星个数不一样，因此需要用到双重 for 循环</li><li>外层的 for 控制行数 i ，循环10次可以打印10行</li><li>内层的 for 控制每行的星星个数 j<ul><li>核心算法： 每一行星星的个数： j = i ; j &lt;= 10; j++</li></ul></li><li>每行打印完毕后，都需要重新换一行</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var star = '';for (var i = 1; i &lt;= 10; i++) {    for (var j = i; j &lt;= 10; j++) {        star += '☆';    }    star += '\n';}console.log(star);</code></pre><p><strong>3. 打印九九乘法表</strong></p><ul><li>一共有9行，但是每行的个数不一样，因此需要用到双重 for 循环 </li><li>外层的 for 循环控制行数 i ，循环9次 ，可以打印 9 行 </li><li>内层的 for 循环控制每行公式 j <ul><li>核心算法：每一行 公式的个数正好和行数一致， j &lt;= i;</li></ul></li><li>每行打印完毕，都需要重新换一行 </li><li>把公式用 i 和 j 替换</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = ''; for (var i = 1; i &lt;= 9; i++) { // 外层for控制 行数 9行 for (var j = 1; j &lt;= i; j++) { // j 控制列数 列数和行数是一样的 j &lt;= i str += j + " × " + i + " = " + i * j + '\t'; } str += '\n'; } console.log(str);</code></pre><h4 id="5-2-3-while-循环"><a href="#5-2-3-while-循环" class="headerlink" title="5.2.3 while 循环"></a>5.2.3 while 循环</h4><p>while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">while(条件表达式){  //循环体代码}</code></pre><p>执行过程：</p><ul><li>先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</li><li>执行循环体代码</li><li>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</li></ul><p><strong>注意</strong>：</p><ul><li>使用 while 循环时一定要注意，它必须要有退出条件，否则会称为死循环</li><li>while 循环和 for 循环的不同之处在于 <strong>while 循环可以做较为复杂的条件判断</strong>，比如判断用户名和密码</li></ul><p><strong>案例：</strong></p><p>弹出一个提示框， 你爱我吗？ 如果输入我爱你，就提示结束，否则，一直询问。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str = prompt('你爱我吗');while (str !== '我爱你') {str = prompt('你爱我吗');}alert('结束');</code></pre><h4 id="5-2-4-do-while-循环"><a href="#5-2-4-do-while-循环" class="headerlink" title="5.2.4 do while 循环"></a>5.2.4 do while 循环</h4><p>do… while 语句其实是 while 语句的一个变体。该循环<strong>会先执行一次代码块</strong>，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">do {  //循环体代码-条件表达式为true的时候重复执行循环一代码} while(条件表达式);</code></pre><p>执行过程：</p><ol><li>先执行一次循环体代码</li><li>再执行表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面的代码</li></ol><p><strong>注意</strong>：</p><ul><li>先执行再判断循环体，<strong>所以 do… while 循环语句至少会执行一次循环体代码</strong></li></ul><p><strong>案例：</strong></p><p>弹出一个提示框， 你爱我吗？ 如果输入我爱你，就提示结束，否则，一直询问。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">do {var str = prompt('你爱我吗？');} while (str !== '我爱你');alert('结束');</code></pre><p>==循环小结：==</p><ul><li>三个循环很多情况下都可以相互替代使用 </li><li>如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用 for </li><li>while 和 do…while 可以做更复杂的判断条件，比 for 循环灵活一些 </li><li>实际工作中，我们<strong>更常用for 循环语句</strong>，它写法更简洁直观， 所以这个要重点学习</li></ul><h4 id="5-2-5-continue-和-break"><a href="#5-2-5-continue-和-break" class="headerlink" title="5.2.5 continue 和 break"></a>5.2.5 continue 和 break</h4><ol><li><code>continue</code> 关键字用于<strong>立即跳出本次循环，继续下一次循环</strong>（本次循环体中 continue 之后的代码就会少执行一次）。</li></ol><p>例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var i = 1; i &lt;= 5; i++) { if (i == 3) {     console.log('这个包子有虫子，扔掉');     continue; // 跳出本次循环，跳出的是第3次循环   }  console.log('我正在吃第' + i + '个包子呢');}</code></pre><ol start="2"><li><code>break</code> 关键字用于<strong>立即跳出整个循环</strong></li></ol><p>例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的也不吃了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var i = 1; i &lt;= 5; i++) {   if (i == 3) {       break; // 直接退出整个for 循环，跳到整个for下面的语句   }   console.log('我正在吃第' + i + '个包子呢'); }</code></pre><h4 id="5-2-6-循环作业"><a href="#5-2-6-循环作业" class="headerlink" title="5.2.6 循环作业"></a>5.2.6 循环作业</h4><p><strong>1.打印出正金字塔 （1357）</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var i = 1; i &lt;= 4; i++) {for (var k = 1; k &lt;= 4 - i; k++) {document.write('&amp;ensp;');}for (j = 1; j &lt;= 2 * i - 1; j++) {document.write('☆');}document.write('&lt;br/&gt;');}</code></pre><p><strong>2.打印出倒金字塔 （7531）</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var i = 4; i &gt;= 1; i--) {for (var k = 1; k &lt;= 4 - i; k++) {document.write('&amp;ensp;');}for (j = 1; j &lt;= 2 * i - 1; j++) {document.write('☆');}document.write('&lt;br/&gt;');}</code></pre><p><strong>3. 穷举：从1遍历到无穷大，找出符合条件的</strong></p><p>需求 ：有一群人，如果3个人站一排多出一人；如果4个人站一排多出来2个人；如果5人一排多出3人。<br>请问：这群人的数量</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var i = 1;while (i &lt;= Infinity) {if (i % 3 == 1 &amp;&amp; i % 4 == 2 &amp;&amp; i % 5 == 3) {alert(i);break;}i++;}</code></pre><p><strong>4. 简易ATM</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var money = 100;var num = prompt('请输入您要的操作：\n1.存钱\n2.取钱\n3.显示余额\n4.退出');//该处添加while是为了在进行一个操作（如存钱）后，可以继续执行其他操作while (money &gt;= 0) {if (num == '1') {var msg = prompt('请输入需要存的金额');msg = parseInt(msg);money = money + msg;alert('余额' + money);}if (num == '2') {var msg = prompt('请输入需要取的金额');msg = parseInt(msg);money = money - msg;alert('余额' + money);}if (num == '3') {alert('余额' + money);}if (num == '4') {// num = false;break;}num = prompt('操作:\n1.存钱\n2.取钱\n3.显示余额\n4.退出');}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css之移动端适配方案vw、rem详解</title>
      <link href="/2022/12/31/css%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88vw%E3%80%81rem%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/31/css%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88vw%E3%80%81rem%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-CSS-常见单位"><a href="#1-CSS-常见单位" class="headerlink" title="1. CSS 常见单位"></a>1. CSS 常见单位</h1><p>整体可以分成两类：</p><ul><li>绝对长度单位（Absolute length units）</li><li>相对长度单位（Relative length units）</li></ul><h2 id="1-1-绝对单位"><a href="#1-1-绝对单位" class="headerlink" title="1.1 绝对单位"></a>1.1 绝对单位</h2><p>绝对单位：</p><ul><li>与其他任何东西都没有关系，通常被认为总是相同的大小。</li><li>这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm。</li><li>惟一一个经常使用的值是px(像素)。</li></ul><table><thead><tr><th>绝对单位</th><th>名称</th><th>等价换算</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td><td>1cm = 96px/2.54</td></tr><tr><td>mm</td><td>毫米</td><td>1mm = 1/10th of 1cm</td></tr><tr><td>Q</td><td>四分之一毫米</td><td>1Q = 1/40th of 1cm</td></tr><tr><td>in</td><td>英寸</td><td>1in = 2.54cm = 96px</td></tr><tr><td>pc</td><td>十二点活字</td><td>1pc = 1/16th of 1in</td></tr><tr><td>pt</td><td>点</td><td>1pt = 1/72th of 1in</td></tr><tr><td>px</td><td>像素</td><td>1px = 1/96th of 1in</td></tr></tbody></table><h2 id="1-2-相对单位"><a href="#1-2-相对单位" class="headerlink" title="1.2 相对单位"></a>1.2 相对单位</h2><p>相对单位：</p><ul><li>相对长度单位<strong>相对于其他一些东西</strong></li><li>比如父元素的字体大小，或者视图端口的大小</li><li>使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应</li></ul><table><thead><tr><th>相对单位</th><th>相对于</th></tr></thead><tbody><tr><td>em</td><td>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td>ex</td><td>字符“x”的高度</td></tr><tr><td>ch</td><td>数字“0”的宽度</td></tr><tr><td>rem</td><td>根元素的字体大小</td></tr><tr><td>lh</td><td>元素的line-height</td></tr><tr><td>vw</td><td>视窗宽度的1%</td></tr><tr><td>vh</td><td>视窗高度的1%</td></tr></tbody></table><h2 id="1-3-px-详细介绍"><a href="#1-3-px-详细介绍" class="headerlink" title="1.3 px 详细介绍"></a>1.3 px 详细介绍</h2><p>px是pixel单词的缩写，翻译为像素。像素是影响显示的基本单位。</p><p><img src="6d50758caf2b46d59ac80e5ce9fe5793.png" alt="在这里插入图片描述"></p><p>像素单位常见的有三种像素名称：设备像素（也称之为物理像素）；设备独立像素（也称之为逻辑像素）；CSS像素</p><ul><li>设备像素，也叫物理像素。<ul><li>设备像素指的是<strong>显示器上的真实像素，每个像素的大小是屏幕固有的属性</strong>，屏幕出厂以后就不会改变了</li><li>我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小</li><li>比如iPhone X的分辨率 1125x2436，指的就是设备像素</li></ul></li><li>设备独立像素，也叫逻辑像素。<ul><li>如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的</li><li>开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发</li><li>所以在设备像素之上，<strong>操作系统为开发者进行抽象，提供了逻辑像素的概念</strong></li><li>比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小。</li></ul></li><li>CSS像素<ul><li>CSS中我们经常使用的单位也是pixel，它<strong>在默认情况下等同于设备独立像素（也就是逻辑像素）</strong>，毕竟逻辑像素才是面向我们开发者的</li><li>我们可以通过JavaScript中的screen.width和screen.height获取到电脑的逻辑分辨率</li></ul></li></ul><h1 id="2-移动端适配"><a href="#2-移动端适配" class="headerlink" title="2. 移动端适配"></a>2. 移动端适配</h1><p>移动端开发目前主要包括三类：</p><ul><li>原生App开发（iOS、Android、RN、uniapp、Flutter等）</li><li>小程序开发（原生小程序、uniapp、Taro等）</li><li>Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）</li></ul><p>移动端适配包括两个概念：自适应、响应式</p><h2 id="2-1-视口-viewport"><a href="#2-1-视口-viewport" class="headerlink" title="2.1 视口 viewport"></a>2.1 视口 viewport</h2><p>在一个浏览器中，我们可以看到的区域就是视口（viewport）</p><p><strong>视口划分为三种：布局视口、视觉视口、理想视口</strong></p><ul><li>在PC端的页面中，我们是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个</li><li>移动端的网页窗口往往比较小，布局视口是大于视觉视口的</li></ul><hr><p>布局视口：</p><ul><li>一个在PC端的网页在移动端会<strong>按照宽度为980px来布局</strong>一个页面的盒子和内容</li><li>这个视口称为布局视口，<strong>默认宽度980px</strong></li></ul><p>视觉视口：</p><ul><li>如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域 就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中</li><li>那么<strong>显示在可见区域的这个视口</strong>，就是视觉视口</li></ul><p><img src="a576718fd709423c85b06bf6b0bb5302.png" alt="在这里插入图片描述"></p><p>理想视口：</p><ul><li>如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示。<strong>我们希望的是设置100px，那么显示的就是100px。</strong></li><li>这时需要设置理想视口。</li><li>设置meta中的viewport</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;</code></pre><table><thead><tr><th>值</th><th>可能的附加值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>一个正整数，或者字符串 device-width</td><td>定义 viewport 的宽度。</td></tr><tr><td>height</td><td>一个正整数，或者字符串 device-height</td><td>定义 viewport 的高度。未被任何浏览器使用。</td></tr><tr><td>initial-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义设备宽度与 viewport 大小之间的缩放比例。</td></tr><tr><td>maximum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最大值，必须大于等于 minimum-scale，否则表现将不可预测。</td></tr><tr><td>minimum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最小值，必须小于等于 maximum-scale，否则表现将不可预测。</td></tr><tr><td>user-scalable</td><td>yes 或者 no</td><td>默认为 yes，如果设置为 no，将无法缩放当前页面。浏览器可以忽略此规则</td></tr></tbody></table><h2 id="2-2-移动端适配方案"><a href="#2-2-移动端适配方案" class="headerlink" title="2.2 移动端适配方案"></a>2.2 移动端适配方案</h2><ul><li>方案一：百分比设置<ul><li>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一</li><li>所以百分比在移动端适配中使用是非常少的</li></ul></li><li>方案二：rem单位+动态html的font-size</li><li>方案三：vw单位</li><li>方案四：flex的弹性布局</li></ul><h3 id="2-2-1-rem-适配方案"><a href="#2-2-1-rem-适配方案" class="headerlink" title="2.2.1 rem 适配方案"></a>2.2.1 rem 适配方案</h3><p>rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以<strong>动态的修改html的 font-size尺寸</strong></p><p>在开发中，我们只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，<strong>设置html不同的font-size</strong></li><li>问题二：将原来要设置的尺寸，<strong>转化成rem单位</strong></li></ul><h4 id="font-size-尺寸"><a href="#font-size-尺寸" class="headerlink" title="font-size 尺寸"></a>font-size 尺寸</h4><table><thead><tr><th>屏幕尺寸</th><th>html的font-size</th><th>盒子的设置宽度</th><th>盒子的最终宽度</th></tr></thead><tbody><tr><td>375px</td><td>37.5px</td><td>1rem</td><td>37.5px</td></tr><tr><td>320px</td><td>32px</td><td>1rem</td><td>32px</td></tr><tr><td>414px</td><td>41.4px</td><td>1rem</td><td>41.4px</td></tr></tbody></table><ul><li>方案一：媒体查询<ul><li>可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸</li><li>缺点： <ul><li>1.我们需要针对不同的屏幕编写大量的媒体查询</li><li>2.如果动态改变尺寸，不会实时的进行更新</li></ul></li></ul></li><li>方案二：编写js代码<ul><li>如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码</li><li>方法：<ul><li>1.根据html的宽度计算出font-size的大小，并且设置到html上</li><li>2.监听页面的实时改变，并且重新设置font-size的大小到html上</li></ul></li></ul></li><li>方案三：lib-flexible库<ul><li>事实上，lib-flexible库做的事情是相同的，你也可以直接引入它</li></ul></li></ul><p><img src="cb299e092059423286d07240d0b525c4.png" alt="在这里插入图片描述"></p><h4 id="rem的单位换算"><a href="#rem的单位换算" class="headerlink" title="rem的单位换算"></a>rem的单位换算</h4><ul><li>方案一：手动换算<ul><li>比如有一个在375px屏幕上，100px宽度和高度的盒子</li><li>我们需要将100px转成对应的rem值</li><li>100/37.5=2.6667，其他也是相同的方法计算即可</li></ul></li><li>方案二：less/scss函数</li><li><strong>方案三：postcss-pxtorem</strong><ul><li>目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li><li><code>npm install postcss-pxtorem</code></li></ul></li><li>方案四：VSCode插件<ul><li>px to rem 的插件，在编写时自动转化</li></ul></li></ul><h3 id="2-2-2-vw-适配方案"><a href="#2-2-2-vw-适配方案" class="headerlink" title="2.2.2 vw 适配方案"></a>2.2.2 vw 适配方案</h3><p>1vw等于屏幕的1%，vw我们只面临一个问题：将尺寸换算成vw的单位即可</p><p>vw相比于rem的优势：</p><ul><li>优势一：不需要去计算html的font-size大小，也<strong>不需要给html设置这样一个font-size</strong></li><li>优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承</li><li>优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱</li><li>优势四：<strong>vw相比于rem更加语义化</strong>，1vw刚才是1/100的viewport的大小</li><li>优势五：可以具备rem之前所有的优点</li></ul><h4 id="vw-的单位换算"><a href="#vw-的单位换算" class="headerlink" title="vw 的单位换算"></a>vw 的单位换算</h4><ul><li>方案一：手动换算<ul><li>比如有一个在375px屏幕上，100px宽度和高度的盒子</li><li>我们需要将100px转成对应的vw值</li><li>100/3.75=26.667，其他也是相同的方法计算即可</li></ul></li><li>方案二：less/scss函数</li><li><strong>方案三：postcss-px-to-viewport-8-plugin</strong><ul><li>和rem一样，在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li><li><code>npm install postcss-px-to-viewport-8-plugin</code></li></ul></li><li>方案四：VSCode插件<ul><li>px to vw 的插件，在编写时自动转化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 之 flex布局</title>
      <link href="/2022/12/30/CSS-%E4%B9%8B-flex%E5%B8%83%E5%B1%80/"/>
      <url>/2022/12/30/CSS-%E4%B9%8B-flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识-flex-布局"><a href="#一、认识-flex-布局" class="headerlink" title="一、认识 flex 布局"></a>一、认识 flex 布局</h1><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 <strong>floats 和 positioning</strong>。 但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举。</p><p>一些布局上的痛点无法解决：</p><ul><li>比如在父内容里面垂直居中一个块内容</li><li>比如使容器的所有子项等分可用宽度/高度，而不管有多少宽度/高度可用</li><li>比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同</li></ul><h2 id="1-flex-布局的重要概念"><a href="#1-flex-布局的重要概念" class="headerlink" title="1. flex 布局的重要概念"></a>1. flex 布局的重要概念</h2><p>两个重要的概念：</p><ul><li>开启了 flex 布局的元素叫 <strong>flex container</strong></li><li>flex container 里面的直接子元素叫做 <strong>flex item</strong></li></ul><p>使元素成为 flex container：</p><ul><li><code>display: flex</code>： flex container 以 block-level 形式存在（常用）</li><li><code>display: inline-flex</code>： flex container 以 inline-level 形式存在</li></ul><p><strong>flex item</strong>元素具有以下特点：</p><ul><li>flex item的布局将<strong>受flex container属性的设置</strong>来进行控制和布局</li><li>flex item<strong>不再严格区分块级元素和行内级元素</strong></li><li>flex item默认情况下是包裹内容的, 但是可以设置宽度和高度</li></ul><p><img src="99d54c486c1e4d009905a535df53dbab.png" alt="在这里插入图片描述"></p><h1 id="二、flex-相关属性"><a href="#二、flex-相关属性" class="headerlink" title="二、flex 相关属性"></a>二、flex 相关属性</h1><p>属性分为两类：<br><img src="1d3cb53339f94d87a51e3f301f39f998.png" alt="在这里插入图片描述"></p><h2 id="1-flex-container-中的属性"><a href="#1-flex-container-中的属性" class="headerlink" title="1. flex container 中的属性"></a>1. flex container 中的属性</h2><h3 id="1-1-flex-direction：item-的排布方向"><a href="#1-1-flex-direction：item-的排布方向" class="headerlink" title="1.1 flex-direction：item 的排布方向"></a>1.1 flex-direction：item 的排布方向</h3><p>flex items 默认都是沿着 main axis（主轴）<strong>从 main start 开始往 main end 方向</strong>排布</p><p>flex-direction 决定了 main axis 的方向，有 4 个取值：</p><ul><li>row（默认值）</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><p><img src="0ce90fb234a94e478f39debd207d95d6.png" alt="在这里插入图片描述"></p><h3 id="1-2-flex-wrap：排布是否换行"><a href="#1-2-flex-wrap：排布是否换行" class="headerlink" title="1.2 flex-wrap：排布是否换行"></a>1.2 flex-wrap：排布是否换行</h3><p>flex-wrap 决定了 flex container 是单行还是多行：</p><ul><li>nowrap（默认）：单行</li><li>wrap：多行</li><li>wrap-reverse：多行（对比 wrap，cross start 与 cross end 相反）</li></ul><p><img src="05b00512175744d79b634a9718e34c11.png" alt="在这里插入图片描述"></p><p><strong>注意：</strong><br>flex-wrap 取默认值时，若一行放不下所有的item元素，则会<strong>等比例压缩每个item的宽度</strong>，不会换行</p><h3 id="1-3-flex-flow：属性的合并写法"><a href="#1-3-flex-flow：属性的合并写法" class="headerlink" title="1.3 flex-flow：属性的合并写法"></a>1.3 flex-flow：属性的合并写法</h3><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写，顺序任何</p><pre class="line-numbers language-none"><code class="language-none">flex-flow: row-reverse wrap-reverse</code></pre><h3 id="1-4-justify-content：item-的水平对齐方式"><a href="#1-4-justify-content：item-的水平对齐方式" class="headerlink" title="1.4 justify-content：item 的水平对齐方式"></a>1.4 justify-content：item 的水平对齐方式</h3><p>justify-content 决定了 flex items 在 main axis 上的对齐方式：</p><ul><li><strong>flex-start（默认值）</strong>：与 main start 对齐</li><li><strong>flex-end</strong>：与 main end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>space-between</strong>：<ul><li>flex items 之间的距离相等</li><li>与 main start、main end两端对齐</li></ul></li><li><strong>space-around</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</li></ul></li><li><strong>space-evenly</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离等于 flex items 之间的距离</li></ul></li></ul><p><img src="29b815d29eed48509a27cc7b9b7694a5.png" alt="在这里插入图片描述"></p><h3 id="1-5-align-item：item-的垂直对齐方式"><a href="#1-5-align-item：item-的垂直对齐方式" class="headerlink" title="1.5 align-item：item 的垂直对齐方式"></a>1.5 align-item：item 的垂直对齐方式</h3><p>align-items 决定了 flex items 在 cross axis 上的对齐方式：</p><ul><li><strong>normal</strong>：在弹性布局中，效果和stretch一样</li><li><strong>flex-start</strong>：与 cross start 对齐</li><li><strong>flex-end</strong>：与 cross end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>stretch</strong>：当 flex items 在 cross axis 方向的 size 为 auto 时（未定义高度），会自动拉伸至填充 flex container</li><li><strong>baseline</strong>：与文字的基准线对齐</li></ul><p><img src="eb50960363c74b3ca5712746ab24bf09.png" alt="在这里插入图片描述"></p><h3 id="1-6-align-content：多行-item-的垂直对齐方式"><a href="#1-6-align-content：多行-item-的垂直对齐方式" class="headerlink" title="1.6 align-content：多行 item 的垂直对齐方式"></a>1.6 align-content：多行 item 的垂直对齐方式</h3><p>align-content 决定了多行 flex items 在 cross axis 上的对齐方式：</p><ul><li><strong>stretch（默认值）</strong>：与 align-items 的 stretch 类似</li><li><strong>flex-start</strong>：与 cross start 对齐</li><li><strong>flex-end</strong>：与 cross end 对齐</li><li><strong>center</strong>：居中对齐</li><li><strong>space-between</strong>：<ul><li>flex items 之间的距离相等</li><li>与 cross start、cross end两端对齐</li></ul></li><li><strong>space-around</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul></li><li><strong>space-evenly</strong>：<ul><li>flex items 之间的距离相等</li><li>flex items 与 cross start、cross end 之间的距离等于 flex items 之间的距离</li></ul></li></ul><p><img src="ee127a6d01434eb2a8e281bfd850f185.png" alt="在这里插入图片描述"></p><h2 id="2-flex-item-中的属性"><a href="#2-flex-item-中的属性" class="headerlink" title="2. flex-item 中的属性"></a>2. flex-item 中的属性</h2><h3 id="2-1-order：item-的排布顺序"><a href="#2-1-order：item-的排布顺序" class="headerlink" title="2.1 order：item 的排布顺序"></a>2.1 order：item 的排布顺序</h3><p>order 决定了 flex items 的排布顺序：</p><ul><li>可以<strong>设置任意整数</strong>（正整数、负整数、0），值越小就越排在前面</li><li>默认值是 0</li></ul><h3 id="2-2-align-self：覆盖-align-items-设置的垂直对齐方式"><a href="#2-2-align-self：覆盖-align-items-设置的垂直对齐方式" class="headerlink" title="2.2 align-self：覆盖 align-items 设置的垂直对齐方式"></a>2.2 align-self：覆盖 align-items 设置的垂直对齐方式</h3><p>通过 align-self 覆盖 flex container 设置的 align-items：</p><ul><li>auto（默认值）：遵从 flex container 的 align-items 设置</li><li>stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致</li></ul><p><img src="e39cb90baf1344dcb89193572901a3d4.png" alt="在这里插入图片描述"></p><h3 id="2-3-flex-grow：item-如何拉伸"><a href="#2-3-flex-grow：item-如何拉伸" class="headerlink" title="2.3 flex-grow：item 如何拉伸"></a>2.3 flex-grow：item 如何拉伸</h3><p>flex-grow 决定了 flex items 如何扩展(拉伸/成长) ：</p><ul><li>可以设置<strong>任意非负数字</strong>（正小数、正整数、0），默认值是 0</li><li>当 flex container 在 main axis 方向上<strong>有剩余 size</strong> 时，flex-grow 属性才会有效</li></ul><p>注意：</p><ul><li>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size = <code>flex container的剩余size * (flex-grow / sum)</code></li><li>items 扩展后的最终 size 不能超过 max-width\max-height</li></ul><p><img src="3c6e47102a104c3682e8246ea5cca778.png" alt="在这里插入图片描述"></p><h3 id="2-4-flex-shrink：item-如何收缩"><a href="#2-4-flex-shrink：item-如何收缩" class="headerlink" title="2.4 flex-shrink：item 如何收缩"></a>2.4 flex-shrink：item 如何收缩</h3><p>flex-shrink 决定了 flex items 如何收缩(缩小)：</p><ul><li>可以设置<strong>任意非负数字</strong>（正小数、正整数、0），默认值是 1 </li><li>当 flex items 在 main axis 方向上<strong>超过了 flex container 的 size</strong>，flex-shrink 属性才会有效</li></ul><p>注意：</p><ul><li>如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size = <code>items超出flex container的size * (收缩比例 / 所有flex items的收缩比例之和)</code></li><li>flex items 收缩后的最终 size 不能小于 min-width\min-height</li></ul><h3 id="2-5-flex-basis：设置-items-的-base-size"><a href="#2-5-flex-basis：设置-items-的-base-size" class="headerlink" title="2.5 flex-basis：设置 items 的 base size"></a>2.5 flex-basis：设置 items 的 base size</h3><p>flex-basis 用来设置 flex items 在 main axis 方向上的 base size：</p><ul><li>auto（默认值）、具体的宽度数值（100px）</li><li>若item中某个英文单词超出flex-basis宽度（中文不会出现此种情况），可以自动显示完全，若设置的是width则不可</li></ul><p><img src="3f056e6065974077bc544d41b0053c2b.png" alt="在这里插入图片描述"></p><p>决定 flex items 最终 base size 的因素，从优先级高到低：</p><ul><li>max-width\max-height\min-width\min-height</li><li>flex-basis</li><li>width\height</li><li>内容本身的 size</li></ul><h3 id="2-6-flex-属性：属性的合并写法"><a href="#2-6-flex-属性：属性的合并写法" class="headerlink" title="2.6 flex 属性：属性的合并写法"></a>2.6 flex 属性：属性的合并写法</h3><p>flex 是 flex-grow || flex-shrink || flex-basis 的简写，flex 属性可以指定1个、2个或3个值。<br><img src="1398171db19543d9aa3f49a1ad002ae5.png" alt="在这里插入图片描述"></p><p>单值：</p><ul><li>一个<strong>无单位</strong>数(number): 它会被当作 flex-grow 的值。</li><li>一个<strong>有效的宽度</strong>(width)值: 它会被当作 flex-basis 的值。</li><li>关键字none，auto或initial</li></ul><p>双值：</p><ul><li>第一个值必须为一个<strong>无单位数</strong>，并且它会被当作 flex-grow 的值</li><li>第二个值必须为以下之一：<ul><li>一个无单位数：它会被当作 flex-shrink 的值</li><li>一个有效的宽度值: 它会被当作 flex-basis 的值</li></ul></li></ul><p>三值：</p><ul><li>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值</li></ul><h1 id="三、一个布局思考"><a href="#三、一个布局思考" class="headerlink" title="三、一个布局思考"></a>三、一个布局思考</h1><p>在日常应用布局中，经常会出现item个数未知的情况。此时布局会出现下列情况：</p><p><img src="9baf944c208d4cba8b8da39c91a34f03.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;.container {width: 500px;background-color: orange;display: flex;flex-wrap: wrap;justify-content: space-between;}.item {width: 110px;height: 140px;}.container &gt; i {/* 只能设置宽度，不能设置高度，这样i的数量超出时也不会影响布局 */width: 110px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item1"&gt;1&lt;/div&gt;&lt;div class="item item2"&gt;2&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;div class="item item3"&gt;3&lt;/div&gt;&lt;!-- 添加i的个数是列数减-2 --&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt;&lt;script src="./js/itemRandomColor.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>item 多出1个的时候，布局仍是正常的；只有item大于等于2个时，才会出现分散的分布，需要i进行补齐。因此添加i的个数是列数减-2</p><p><img src="e6246f82d48c4237ae2a1f764e9f139e.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML和CSS补充知识</title>
      <link href="/2022/12/25/HTML%E5%92%8CCSS%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/12/25/HTML%E5%92%8CCSS%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS高级"><a href="#一、CSS高级" class="headerlink" title="一、CSS高级"></a>一、CSS高级</h1><h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1. 精灵图"></a>1. 精灵图</h2><p>一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。</p><p>因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。</p><p><strong>核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。</strong></p><p><strong>精灵图的使用：</strong></p><ol><li>精灵技术主要针对于背景图片使用。就是把<strong>多个小背景图片整合到一张大图片中</strong>。</li><li>移动背景图片位置， 此时可以使用 <code>background-position</code>。</li><li>移动的距离就是这个目标图片的 <code>x</code> 和 <code>y</code> 坐标。一般情况下都是负值（网页中的坐标： x 轴右边走是正值，左边走是负值， y 轴往下走是正值，往上走是负值。）</li></ol><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2. 字体图标"></a>2. 字体图标</h2><p><strong>字体图标使用场景</strong>：主要用于显示网页中通用、常用的一些小图标。</p><p>精灵图图片文件比较大、图片本身放大和缩小会失真、一旦图片制作完毕想要更换非常复杂。</p><p>此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。字体图标可以为前端工程师提供一种方便高效的图标使用方式，<strong>展示的是图标，本质属于字体</strong>。</p><h3 id="2-1-字体图标的优点"><a href="#2-1-字体图标的优点" class="headerlink" title="2.1 字体图标的优点"></a>2.1 字体图标的优点</h3><ul><li>轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求；</li><li>灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等；</li><li>兼容性：几乎支持所有的浏览器，请放心使用。</li></ul><p>总结：</p><ol><li>如果遇到一些结构和样式比较简单的小图标，就用字体图标。</li><li>如果遇到一些结构和样式复杂一点的小图片，就用精灵图。</li></ol><h3 id="2-2-字体图标的使用"><a href="#2-2-字体图标的使用" class="headerlink" title="2.2 字体图标的使用"></a>2.2 字体图标的使用</h3><p>推荐下载网站： </p><ul><li><p>icomoon 字库 <a href="http://icomoon.io/">http://icomoon.io</a>。IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。（现在部分要付费）</p></li><li><p>阿里 iconfont 字库 <a href="http://www.iconfont.cn/">http://www.iconfont.cn</a> 。这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 Al 制作图标上传生成。重点是，免费！</p></li></ul><h4 id="2-2-1-IcoMoon"><a href="#2-2-1-IcoMoon" class="headerlink" title="2.2.1 IcoMoon"></a>2.2.1 IcoMoon</h4><ol><li>选择字体并下载</li><li>将下载文件中的 fonts 文件夹复制到项目根目录下</li><li>字体声明，将 <code>style.css</code> 文件中的开头的字体声明代码赋值到 html 中</li><li>打开 <code>demo.html</code>，复制页面中的方框图标到 html 代码<code>&lt;span&gt; &lt;/span&gt;</code>中。</li><li>给 <code>span</code> 声明字体：<pre class="line-numbers language-none"><code class="language-none">span {font-family: "icomoon";}</code></pre></li></ol><h4 id="2-2-2-阿里-iconfont"><a href="#2-2-2-阿里-iconfont" class="headerlink" title="2.2.2 阿里 iconfont"></a>2.2.2 阿里 iconfont</h4><ol><li>下载图标</li></ol><ul><li>图标管理-&gt;我的项目-&gt;然后新建项目</li><li>选择图标添加到购物车-&gt;购物车中选择加入项目</li><li>打开项目-&gt;下载到本地-&gt;放入项目根目录下</li></ul><ol start="2"><li>引入图标</li></ol><ul><li>在文件中引入iconfont.css <code>&lt;link rel="stylesheet" href="font/iconfont.css"&gt;</code> font为图标文件夹名称</li><li>在HTML结构中引用<code>&lt;span class="iconfont icon-shouye"&gt;&lt;/span&gt;</code></li></ul><ol start="3"><li>更改图标样式</li></ol><ul><li>更改颜色：可直接在文件样式style中更改</li><li>更改字体：需要在引入的iconfont.css中改</li></ul><h2 id="3-CSS-三角"><a href="#3-CSS-三角" class="headerlink" title="3. CSS 三角"></a>3. CSS 三角</h2><p>正放的等边三角形：</p><pre class="line-numbers language-none"><code class="language-none">.box1 {  width: 0;  height: 0;  border: 10px solid transparent;  border-bottom-color: black;  /* 照顾兼容性 */  line-height: 0;  font-size: 0;}</code></pre><p>不规则三角形：<br><img src="63adaa1b842a488d923b5c5f80980e8f.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">.box {width: 0;height: 0;/* 1.只保留右边的边框有颜色 */border-color: transparent red transparent transparent;/* 2. 样式都是solid */border-style: solid;/* 3. 上边框宽度要大， 右边框宽度稍小， 其余的边框该为 0 */border-width: 100px 50px 0 0 ;}</code></pre><h2 id="4-CSS-用户界面样式"><a href="#4-CSS-用户界面样式" class="headerlink" title="4. CSS 用户界面样式"></a>4. CSS 用户界面样式</h2><p>所谓的界面样式，就是更改一些用户操作样式，以便<strong>提高更好的用户体验</strong>。</p><h3 id="4-1-鼠标样式-cursor"><a href="#4-1-鼠标样式-cursor" class="headerlink" title="4.1 鼠标样式 cursor"></a>4.1 鼠标样式 cursor</h3><pre class="line-numbers language-none"><code class="language-none">cursor: default | pointer | move | text | not-allowed;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>default</td><td>默认</td></tr><tr><td>pointer</td><td>小手</td></tr><tr><td>move</td><td>移动</td></tr><tr><td>text</td><td>文本</td></tr><tr><td>not-allowed</td><td>禁止</td></tr></tbody></table><h3 id="4-2-取消表单蓝色边框和防止拖拽文本域"><a href="#4-2-取消表单蓝色边框和防止拖拽文本域" class="headerlink" title="4.2 取消表单蓝色边框和防止拖拽文本域"></a>4.2 取消表单蓝色边框和防止拖拽文本域</h3><pre class="line-numbers language-none"><code class="language-none">input {  outline: none;}textarea {  outline: none;  resize: none;}</code></pre><h2 id="5-vertical-align-属性应用"><a href="#5-vertical-align-属性应用" class="headerlink" title="5. vertical-align 属性应用"></a>5. vertical-align 属性应用</h2><p>CSS 的 <code>vertical-align</code> 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 </p><p>官方解释： 用于设置<strong>行内元素/行内块元素</strong>的<strong>垂直对齐方式</strong>。</p><pre class="line-numbers language-none"><code class="language-none">vertical-align :  top | middle | baseline(默认) | bottom</code></pre><p><img src="953482b4850149ef9d9b82274e69cedf.png" alt="在这里插入图片描述"></p><h3 id="5-1-图片、表单和文字对齐"><a href="#5-1-图片、表单和文字对齐" class="headerlink" title="5.1 图片、表单和文字对齐"></a>5.1 图片、表单和文字对齐</h3><pre class="line-numbers language-none"><code class="language-none">img {  vertical-align: middle;}li {  disaplay: inline-block;  vertical-align: middle;}</code></pre><h3 id="5-2-解决图片底部默认空白缝隙问题"><a href="#5-2-解决图片底部默认空白缝隙问题" class="headerlink" title="5.2 解决图片底部默认空白缝隙问题"></a>5.2 解决图片底部默认空白缝隙问题</h3><p>bug ：图片底侧会有一个空白缝隙，原因是<strong>行内块元素会预留和文字的基线对齐</strong>。主要解决方法有两种：</p><ol><li>给图片添加 <code>vertical—align: middle top bottom;</code> 等。（提倡使用的）</li><li>把图片转换为块级元素 <code>display: block；</code></li></ol><h2 id="6-溢出的文字省略号显示"><a href="#6-溢出的文字省略号显示" class="headerlink" title="6. 溢出的文字省略号显示"></a>6. 溢出的文字省略号显示</h2><h3 id="6-1-单行文本溢出显示省略号"><a href="#6-1-单行文本溢出显示省略号" class="headerlink" title="6.1 单行文本溢出显示省略号"></a>6.1 单行文本溢出显示省略号</h3><pre class="line-numbers language-none"><code class="language-none">/*1·先强制一行内显示文本*/white-space: nowrap;（默认normal 自动换行）/*2·超出的部分隐藏*/overflow: hidden;/*3.文字用省略号替代超出的部分*/text-overflow: ellipsis;</code></pre><h3 id="6-2-多行文本溢出显示省略号"><a href="#6-2-多行文本溢出显示省略号" class="headerlink" title="6.2 多行文本溢出显示省略号"></a>6.2 多行文本溢出显示省略号</h3><p><strong>更推荐让后台人员来做这个效果</strong>，因为后台人员可以设置显示多少个字，操作更简单。</p><pre class="line-numbers language-none"><code class="language-none">overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 2; /* 设置或检索伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical;</code></pre><h2 id="7-常见布局技巧"><a href="#7-常见布局技巧" class="headerlink" title="7. 常见布局技巧"></a>7. 常见布局技巧</h2><h3 id="7-1-margin负值运用"><a href="#7-1-margin负值运用" class="headerlink" title="7.1 margin负值运用"></a>7.1 margin负值运用</h3><ol><li>解决相邻盒子之间的<strong>边框宽度加倍</strong>问题。 原理：让每个盒子压住前面的盒子，边框叠加。</li></ol><pre class="line-numbers language-none"><code class="language-none">ul li {width: 150px;height: 200px;border: 1px solid red;margin-left: -1px;}</code></pre><ol start="2"><li>鼠标移动边框颜色变化效果。鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有定位，则加相对定位（保留位置）；如果有定位，则加z-index）</li></ol><pre class="line-numbers language-none"><code class="language-none">/*如果盒子li没有定位，则鼠标经过添加相对定位即可*/ul li:hover {  position: relative;  border: 1px solid orange;}/*若盒子li都有定位，则使用 z-index 提高层级*/ul li:hover {  z-index: 1;  border: 1px solid orange;}</code></pre><h3 id="7-2-文字围绕浮动元素"><a href="#7-2-文字围绕浮动元素" class="headerlink" title="7.2 文字围绕浮动元素"></a>7.2 文字围绕浮动元素</h3><p>原理：浮动元素不会遮住文字。</p><pre class="line-numbers language-none"><code class="language-none">div {  float: left;}</code></pre><p><img src="53d89feee196487fadb4e931ecde915f.png" alt="在这里插入图片描述"></p><h3 id="7-3-行内块巧妙运用"><a href="#7-3-行内块巧妙运用" class="headerlink" title="7.3 行内块巧妙运用"></a>7.3 行内块巧妙运用</h3><p>利用行内块元素做<strong>页码跳转组件</strong>：</p><ol><li>把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; </li><li>利用<strong>行内块元素中间有缝隙</strong>，并且给父级添加 text-align:center; 行内块元素会水平会居中</li></ol><h2 id="8-CSS-初始化"><a href="#8-CSS-初始化" class="headerlink" title="8. CSS 初始化"></a>8. CSS 初始化</h2><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对 HTML 文本呈现的差异，<strong>照顾浏览器的兼容</strong>，我们需要对 CSS 初始化</p><p>简单理解： CSS 初始化是指重设浏览器的样式。（也称为 CSS reset ）每个网页都必须首先进行 CSS 初始化。 这里我们以京东 css 初始化代码为例。</p><p>Unicode 编码字体： 把中文字体的名称用相应的 Unicode 编码来代替，这样就可以有效的避免浏览器解释 CSS 代码时候出现乱码的问题。<br>比如： 黑体：<code>\9ED1\4F53</code> 宋体：<code>\5B8B\4F53</code> 微软雅黑：<code>\5FAE\8F6F196C519ED1</code></p><h1 id="二、HTML5新增特性"><a href="#二、HTML5新增特性" class="headerlink" title="二、HTML5新增特性"></a>二、HTML5新增特性</h1><h2 id="1-新增的语义化标签"><a href="#1-新增的语义化标签" class="headerlink" title="1. 新增的语义化标签"></a>1. 新增的语义化标签</h2><ul><li><code>&lt;header&gt;</code>：头部标签</li><li><code>&lt;nav&gt;</code>：导航标签</li><li><code>&lt;article&gt;</code>：内容标签</li><li><code>&lt;section&gt;</code>：定义文档某个区域</li><li><code>&lt;asider&gt;</code>：侧边栏标签</li><li><code>&lt;footer&gt;</code>：尾部标签</li></ul><h2 id="2-新增的多媒体标签"><a href="#2-新增的多媒体标签" class="headerlink" title="2. 新增的多媒体标签"></a>2. 新增的多媒体标签</h2><h3 id="2-1-视频"><a href="#2-1-视频" class="headerlink" title="2.1 视频<video>"></a>2.1 视频<code>&lt;video&gt;</code></h3><p>所有浏览器支持 mp4 格式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;video src="文件地址" controls="controls"&gt;&lt;/video&gt;</code></pre><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>src</code></td><td>url</td><td>视频地址</td></tr><tr><td><code>autoplay</code></td><td>autoplay</td><td>视频就绪自动播放(google需要添加muted来实现)</td></tr><tr><td><code>muted</code></td><td>muted</td><td>静音播放</td></tr><tr><td><code>controls</code></td><td>controls</td><td>显示播放控件</td></tr><tr><td><code>width</code></td><td>像素</td><td>设置视频宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>设置视频高度</td></tr><tr><td><code>loop</code></td><td>loop</td><td>设置视频循环播放</td></tr><tr><td><code>preload</code></td><td>auto/none</td><td>是否预加载，如有autoplay就忽略</td></tr><tr><td><code>poster</code></td><td>imgurl</td><td>加载等待的封面图片</td></tr></tbody></table><h3 id="2-2-音频"><a href="#2-2-音频" class="headerlink" title="2.2 音频<audio>"></a>2.2 音频<code>&lt;audio&gt;</code></h3><p>所有浏览器支持 mp3 格式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;audio src="文件地址" controls="controls"&gt;&lt;/audio&gt;</code></pre><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>src</code></td><td>url</td><td>音频的地址</td></tr><tr><td><code>autoplay</code></td><td>autoplay</td><td>音频就绪后自动播放</td></tr><tr><td><code>controls</code></td><td>controls</td><td>显示播放控件</td></tr><tr><td><code>loop</code></td><td>loop</td><td>设置循环播放</td></tr><tr><td><strong>注：谷歌浏览器把音频和视频自动播放禁止了</strong></td><td></td><td></td></tr></tbody></table><h2 id="3-新增的input相关参数"><a href="#3-新增的input相关参数" class="headerlink" title="3. 新增的input相关参数"></a>3. 新增的input相关参数</h2><h3 id="3-1-新增的input类型"><a href="#3-1-新增的input类型" class="headerlink" title="3.1 新增的input类型"></a>3.1 新增的input类型</h3><p>重点：number  tel  search</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>type="email"</code></td><td>输入必须为Email类型</td></tr><tr><td><code>type="url"</code></td><td>输入必须为url类型</td></tr><tr><td><code>type="date"</code></td><td>输入必须为日期类型</td></tr><tr><td><code>type="time"</code></td><td>输入必须为时间类型</td></tr><tr><td><code>type="month"</code></td><td>输入必须为月类型</td></tr><tr><td><code>type="week"</code></td><td>输入必须为周类型</td></tr><tr><td><code>type="number"</code></td><td>输入必须为数字类型</td></tr><tr><td><code>type="tel"</code></td><td>输入必须为手机号码</td></tr><tr><td><code>type="search"</code></td><td>搜索框</td></tr><tr><td><code>type="color"</code></td><td>生成一个颜色选择表单</td></tr></tbody></table><h3 id="3-2-新增的表单属性"><a href="#3-2-新增的表单属性" class="headerlink" title="3.2 新增的表单属性"></a>3.2 新增的表单属性</h3><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>required</td><td>required</td><td>表单拥有该属性表示其内容不能为空，必填</td></tr><tr><td>placeholder</td><td>提示文本</td><td>表单的提示信息</td></tr><tr><td>autofocus</td><td>autofocus</td><td>自动聚焦属性，页面加载完成自动聚焦到指定表单</td></tr><tr><td>autocomplete</td><td>off/on</td><td>当用户在字段开始键入时，浏览器基于之前键入过的值，可以显示出在字段中填写的选项。默认状态为打开。需要放在表单内，同时加上name属性，同时成功提交</td></tr><tr><td>multiple</td><td>multiple</td><td>可以多选文件上传</td></tr><tr><td>可以通过以下设置方式修改placeholder里面的字体颜色：</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">input::placeholder {    color: pink;}</code></pre><h1 id="三、CSS3-的新特性"><a href="#三、CSS3-的新特性" class="headerlink" title="三、CSS3 的新特性"></a>三、CSS3 的新特性</h1><h2 id="1-新增选择器"><a href="#1-新增选择器" class="headerlink" title="1. 新增选择器"></a>1. 新增选择器</h2><h3 id="1-1-属性选择器"><a href="#1-1-属性选择器" class="headerlink" title="1.1 属性选择器"></a>1.1 属性选择器</h3><p>属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>E[att]</code></td><td>选择具有att属性的E元素</td></tr><tr><td><code>E[att="val"</code></td><td>选择具有att属性且属性值<strong>等于</strong>val的E元素</td></tr><tr><td><code>E[att^="val"]</code></td><td>匹配具有att属性且值以val<strong>开头</strong>的E元素</td></tr><tr><td><code>E[att$="val"]</code></td><td>匹配具有att属性且值以val<strong>结尾</strong>的E元素</td></tr><tr><td><code>E[att*="val"]</code></td><td>匹配具有att属性且值中<strong>含有</strong>val的E元素</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">input[type="text"] {    color: green;}&lt;input type="text"&gt;</code></pre><p>类选择器、属性选择器、伪类选择器的<strong>权重都为 10</strong></p><h3 id="1-2-结构伪类选择器"><a href="#1-2-结构伪类选择器" class="headerlink" title="1.2 结构伪类选择器"></a>1.2 结构伪类选择器</h3><p>结构伪类选择器主要根据<strong>文档结构</strong>来选择器元素，常用于选择父级选择器里面的子元素。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>E: first-child</code></td><td>匹配父元素中的第一个子元素,类型为E</td></tr><tr><td><code>E: last-child</code></td><td>匹配父元素中最后一个子元素，类型为E</td></tr><tr><td><code>E: nth-child(n)</code></td><td>匹配父元素中的第n个子元素，类型为E</td></tr><tr><td><code>E: first-of-type</code></td><td>匹配子元素E类型中的第一个</td></tr><tr><td><code>E: last-of-type</code></td><td>匹配子元素E类型中的最后一个</td></tr><tr><td><code>E: nth-of-type(n)</code></td><td>匹配子元素E类型中的第n个</td></tr></tbody></table><p><strong>重点：</strong><code>E: nth-child(n)</code></p><ul><li>n 可以是整数、关键字（<code>even/odd</code>）、公式（<code>n/2n/2n+1</code>）</li><li>如果 n 是公式，则从0开始计算，但是第 0 个元素或者超出了元素的个数会被忽略</li></ul><table><thead><tr><th>公式</th><th>取值</th></tr></thead><tbody><tr><td>2n</td><td>偶数</td></tr><tr><td>2n-1</td><td>奇数</td></tr><tr><td>5n</td><td>5的倍数</td></tr><tr><td>n+5</td><td>5 6 7 8 …</td></tr><tr><td>-n+5</td><td>前五个</td></tr></tbody></table><p><strong>关于 <code>nth-of-type</code> 与 <code>nth-child</code></strong></p><ol><li><code>div: nth-child</code> 会<strong>把所有的盒子都排列序号</strong>。执行的时候首先看 <code>:nth-child(1)</code>， 之后回去看前面 <code>div</code>，若选中的元素类型不符合，则不起效。</li><li><code>div: nth-of-type</code> 会<strong>把指定元素的盒子排列序号</strong>。执行的时候首先看指定的元素类型<code>div</code>，之后回去看 <code>:nth-of-type(1)</code> 第几个孩子</li></ol><p>区别：</p><ol><li>nth-child 对父元素里面所有孩子排序选择（序号是固定的）先找到第n个孩子，然后看看是否和E匹配</li><li>nth-of-type 对父元素里面指定子元素进行排序选择。先去匹配E ，然后再根据E找第n个孩子</li></ol><h3 id="1-3-伪元素选择器（重点）"><a href="#1-3-伪元素选择器（重点）" class="headerlink" title="1.3 伪元素选择器（重点）"></a>1.3 伪元素选择器（重点）</h3><p>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td><code>::before</code></td><td>在元素内部的前面插入内容</td></tr><tr><td><code>::after</code></td><td>在元素内部的后面插入内容</td></tr></tbody></table><p>注意：</p><ul><li>before 和 after 创建一个元素，但是属于<strong>行内元素</strong></li><li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li><li>语法：<code>element::before {}</code></li><li>before 和 after <strong>必须有 content 属性</strong></li><li>before 在父元素内容的前面创建元素， after 在父元素内容的后面插入元素</li><li>伪元素选择器和标签选择器一样，权重为 1</li></ul><h4 id="1-3-1-应用：伪元素字体图标"><a href="#1-3-1-应用：伪元素字体图标" class="headerlink" title="1.3.1 应用：伪元素字体图标"></a>1.3.1 应用：伪元素字体图标</h4><p>父级添加after伪元素</p><pre class="line-numbers language-none"><code class="language-none">.clearfix::after {    content: '';    display: block;     height: 0;    clear: both;    visibility: hidden;}</code></pre><p>父级添加双伪元素</p><pre class="line-numbers language-none"><code class="language-none">.clearfix::before,.clearfix::after {    content: '';    display: block;}.clearfix::after {    clear: both;}</code></pre><h2 id="2-盒子属性"><a href="#2-盒子属性" class="headerlink" title="2. 盒子属性"></a>2. 盒子属性</h2><p>CSS3中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为 content-box，border-box ，这样我们计算盒子大小的方式就发生了改变。</p><p>可以分成两种情况：</p><ol><li><code>box-sizing：content-box</code> 盒子大小为 width + padding + border （以前默认的）</li><li><code>box-sizing: border-box</code> 盒子大小为 width 如果盒子模型我们改为了 box-sizing： border-box ，那padding 和 border就不会撑大盒子了（前提 padding 和 border 不会超过 width 宽度）</li></ol><h2 id="3-transition过渡（重点）"><a href="#3-transition过渡（重点）" class="headerlink" title="3. transition过渡（重点）"></a>3. transition过渡（重点）</h2><p>过渡（transition）是CSS3中具有颠覆性的特征之一，我们可以在不使用Flash动画或JavaScript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p><p>过渡动画：是从一个状态<strong>渐渐的</strong>过渡到另外一个状态 可以让我们页面更好看，更动感十足，虽然低版本浏览器不支持（ie9以下版本）但是不会影响页面布局。</p><p>我们现在经常和 :hover 一起搭配使用。</p><pre class="line-numbers language-none"><code class="language-none">transition: 要过渡的属性 花费时间 运动曲线 何时开始;</code></pre><p><strong>记住过渡的使用口诀： 谁做过渡给谁加</strong></p><ol><li><p>属性：想要变化的css属性，宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以。</p></li><li><p>花费时间：单位是秒（必须写单位）比如 0.5s</p></li><li><p>运动曲线：默认是ease（可以省略）<br><img src="2ed9c74503c84ae4acd00e47d5591616.png" alt="在这里插入图片描述"></p></li><li><p>何时开始：单位是秒（必须写单位）可以设置延迟触发时间默认是0s（可以省略）</p></li></ol><h2 id="4-CSS3-其他特性（了解）"><a href="#4-CSS3-其他特性（了解）" class="headerlink" title="4. CSS3 其他特性（了解）"></a>4. CSS3 其他特性（了解）</h2><h3 id="4-1-CSS3-滤镜-filter"><a href="#4-1-CSS3-滤镜-filter" class="headerlink" title="4.1 CSS3 滤镜 filter"></a>4.1 CSS3 滤镜 filter</h3><p>ilter CSS属性将模糊或颜色偏移等图形效果应用于元素。</p><pre class="line-numbers language-none"><code class="language-none">filter: 函数();</code></pre><p>例如： <code>filter： blur(5px);</code> blur 模糊处理数值越大越模糊</p><h3 id="4-2-CSS3-calc-函数"><a href="#4-2-CSS3-calc-函数" class="headerlink" title="4.2 CSS3 calc 函数"></a>4.2 CSS3 calc 函数</h3><p>此 CSS 函数让你在声明CSS属性值时执行一些计算。</p><pre class="line-numbers language-none"><code class="language-none">width: calc(100%-30px);/* 子盒子永远比父盒子小30px */</code></pre><p>括号里面可以使用 <code>+ - * /</code> 来进行计算。</p><h2 id="5-2D-转换"><a href="#5-2D-转换" class="headerlink" title="5. 2D 转换"></a>5. 2D 转换</h2><p>转换（<code>transform</code>）是 CSS3 中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。</p><p>转换可以理解为变形。</p><ul><li>移动：<code>translate</code></li><li>旋转：<code>rotate</code></li><li>缩放：<code>scale</code><br><img src="baa21c87b83e43f1830d99047cf230de.png" alt="在这里插入图片描述"></li></ul><h3 id="5-1-2D-转换之移动-translate"><a href="#5-1-2D-转换之移动-translate" class="headerlink" title="5.1 2D 转换之移动 translate"></a>5.1 2D 转换之移动 translate</h3><p>2D移动是2D转换里面的一种功能，可以<strong>改变元素在页面中的位置</strong>，类似定位。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: translate(x, y);transform: translateX(x);transform: translateY(y);</code></pre><ul><li>定义 2D 转换中的移动，沿着X和Y轴移动元素</li><li>translate 最大的优点：<strong>不会影响到其他元素的位置</strong></li><li>参数 <code>x, y</code> 可以是百分数，translate 中的百分比单位是相对于 <strong>自身元素</strong> 的宽度或高度的百分比 <code>translate:(50%，50%)</code></li><li>对<strong>行内标签</strong>没有效果</li></ul><p><em><strong>盒子实现水平和垂直居中</strong></em></p><pre class="line-numbers language-none"><code class="language-none">/*子绝父相*/position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);</code></pre><h3 id="5-2-2D-转换之旋转-rotate"><a href="#5-2-2D-转换之旋转-rotate" class="headerlink" title="5.2 2D 转换之旋转 rotate"></a>5.2 2D 转换之旋转 rotate</h3><p>2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: rotate(45deg);</code></pre><ul><li>值为正数则顺时针旋转，为负数则逆时针旋转。</li><li>默认旋转的中心点是<strong>元素的中心点</strong></li></ul><h4 id="5-2-1-2D-转换中心点-transform-origin"><a href="#5-2-1-2D-转换中心点-transform-origin" class="headerlink" title="5.2.1 2D 转换中心点 transform-origin"></a>5.2.1 2D 转换中心点 transform-origin</h4><p>我们可以通过设置 <code>transform-origin</code> 设置元素转换的中心点。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform-origin: x y;</code></pre><ul><li>x y 默认转换的中心点是元素的中心点（50% 50%）</li><li>还可以给 x y 设置像素或者方位名词（top bottom left right center）</li></ul><h3 id="5-3-2D-转换之缩放scale"><a href="#5-3-2D-转换之缩放scale" class="headerlink" title="5.3 2D 转换之缩放scale"></a>5.3 2D 转换之缩放scale</h3><p>缩放，顾名思义，可以放大和缩小。 只要给元素添加上了这个属性就能控制它放大还是缩小。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">transform: scale(x, y);</code></pre><ul><li>参数大于 <code>1</code> 则放大，小于 <code>1</code> 则缩小。</li><li><code>x, y</code> 不跟单位的话，是指缩放的倍数。</li><li><code>transform: scale(2)</code>：只写一个参数，第二个参数则和第一个参数一样，相当于 <code>scale(2,2)</code></li><li>可以配合 <code>transform-origin</code> 使用，改变缩放中心。</li><li>scale 的优势：不占空间</li></ul><h3 id="5-4-2D-转换综合写法"><a href="#5-4-2D-转换综合写法" class="headerlink" title="5.4 2D 转换综合写法"></a>5.4 2D 转换综合写法</h3><ol><li>同时使用多个转换，其格式为： <code>transform: translate() rotate() scale();</code></li><li>其<strong>顺序会影响</strong>转换的效果。（如先旋转会改变坐标轴方向）</li><li>当我们同时有位移和其他属性的时候，记得要将位移放到最前。</li></ol><h2 id="6-动画"><a href="#6-动画" class="headerlink" title="6. 动画"></a>6. 动画</h2><p>动画( animation ) 是 CSS3 中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。</p><h3 id="6-1-动画的基本使用"><a href="#6-1-动画的基本使用" class="headerlink" title="6.1 动画的基本使用"></a>6.1 动画的基本使用</h3><p>分为两步：</p><ol><li>定义动画 (动画序列 <code>%α</code>)</li><li>使用动画<pre class="line-numbers language-none"><code class="language-none"> /* 1. 定义动画 */@keyframes move {    /*开始状态*/    0% {        transform: translateX(0px);    }    /*结束状态*/    100% {        transform: translateX(1000px);    }}div {    width: 200px;    height: 200px;    background-color: pink;    /* 2. 调用动画 */    /* 动画名称 */    animation-name: move;    /* 持续时间 */    animation-duration: 5s;}</code></pre></li></ol><p><strong>动画序列</strong></p><ul><li>0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。</li><li>在 <code>@keyframes</code> 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</li><li>一个元素可以添加多个动画，调用时用逗号分隔。<code>animation: bear .4s, move 3s;</code></li><li>请用百分比来规定变化发生的时间，或用关键词”from”和“to”，等同于0%和100%。</li></ul><p>注意：</p><ol><li>可以做多个状态的变化 <code>keyframes</code> 关键帧</li><li>百分比必须是<strong>整数</strong></li><li>百分比是总时间 <code>animation-duration</code> 的划分</li></ol><h3 id="6-2-动画常用属性"><a href="#6-2-动画常用属性" class="headerlink" title="6.2 动画常用属性"></a>6.2 动画常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>@keyframes</code></td><td>规定动画。</td></tr><tr><td><code>animation</code></td><td>所有动画属性的简写属性，除了animation-play-state属性。</td></tr><tr><td><code>animation-name</code></td><td>规定@keyframes动画的名称。(必须的)</td></tr><tr><td><code>animation-duration</code></td><td>规定动画完成一个周期所花费的秒或毫秒，默认是0。(必须的)</td></tr><tr><td><code>animation-timing-function</code></td><td>规定动画的速度曲线，默认是“ease” .</td></tr><tr><td><code>animation-delay</code></td><td>规定动画何时开始，默认是0.</td></tr><tr><td><code>animation-iteration-count</code></td><td>规定动画被播放的次数，默认是1，还有infinite</td></tr><tr><td><code>animation-direction</code></td><td>规定动画是否在下一周期逆向播放，默认是 “normal”,alternate逆播放</td></tr><tr><td><code>animation-play-state</code></td><td>规定动画是否正在运行或暂停。默认是”running”,还有”paused”.</td></tr><tr><td><code>animation-fill-mode</code></td><td>规定动画结束后状态,保持forwards回到起始backwards</td></tr></tbody></table><p><img src="7f16501478d5437193c6fe15c4435a9c.png" alt="在这里插入图片描述"></p><p><strong>动画属性简写</strong></p><pre class="line-numbers language-none"><code class="language-none">animation: 动画名称(必) 持续时间(必) 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;</code></pre><pre class="line-numbers language-none"><code class="language-none">animation: myfirst 5s linear 2s infinite alternate;</code></pre><ul><li>简写属性里面不包含 <code>animation-play-state</code></li><li>暂停动画: <code>animation-play-state: puased;</code></li><li>经常和鼠标经过等其他配合使用想要动画走回来，而不是直接跳回来: <code>animation-direction: alternate</code></li><li>盒子动画结束后，停在结束位置:  <code>animation-fill-mode: forwards</code></li></ul><h2 id="7-3D-转换"><a href="#7-3D-转换" class="headerlink" title="7. 3D 转换"></a>7. 3D 转换</h2><p>三维坐标系其实就是指立体空间，立体空间是由3个轴共同组成的。 </p><ul><li>x轴：水平向右 注意： x 右边是正值，左边是负值 </li><li>y轴：垂直向下 注意： y 下面是正值，上面是负值 </li><li>z轴：垂直屏幕 注意： 往外面是正值，往里面是负值<br><img src="e58016773b084eb38618e64f60f968e4.png" alt="在这里插入图片描述"></li></ul><h3 id="7-1-3D-移动-translate3d"><a href="#7-1-3D-移动-translate3d" class="headerlink" title="7.1 3D 移动 translate3d"></a>7.1 3D 移动 translate3d</h3><p>3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向。</p><ul><li><code>transform:translateX(100px)</code>：仅仅是在x轴上移动 </li><li><code>transform:translateY(100px)</code>：仅仅是在Y轴上移动 </li><li><code>transform:translateZ(100px)</code>：仅仅是在Z轴上移动（注意：translateZ一般用px单位） </li><li><code>transform:translate3d(x,y,z)</code>：其中 x、y、z 分别指要移动的轴的方向的距离</li></ul><p>因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动</p><h3 id="7-2-透视-perspective"><a href="#7-2-透视-perspective" class="headerlink" title="7.2 透视 perspective"></a>7.2 透视 perspective</h3><p>在2D平面产生近大远小视觉立体，但是只是效果二维的 </p><ul><li>如果想要在网页产生<strong>3D效果</strong>需要透视（理解成3D物体投影在2D平面内）。 </li><li>模拟人类的视觉位置，可认为安排一只眼睛去看 </li><li><strong>透视也称为视距</strong>：视距就是人的眼睛到屏幕的距离 </li><li>距离视觉点越近的在电脑平面成像越大，越远成像越小 </li><li>透视的单位是像素</li></ul><p>透视写在<strong>被观察元素的父盒子</strong>上面的<br><strong>d</strong>：就是视距，视距就是一个距离人的眼睛到屏幕的距离。视距越小，看到的物体越大。<br><strong>z</strong>：就是 z轴，物体距离屏幕的距离，z轴越大（正值） 我们看到的物体就越大。<br><strong>d 需要&gt;= z</strong>，否则无法显示<br><img src="95b8f12938ce4bb3a552661bc811025d.png" alt="在这里插入图片描述"></p><h3 id="7-3-3D-旋转-rotate3d"><a href="#7-3-3D-旋转-rotate3d" class="headerlink" title="7.3 3D 旋转 rotate3d"></a>7.3 3D 旋转 rotate3d</h3><p>3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴（原点在元素中心位置）或者自定义轴进行旋转。</p><ul><li><code>transform:rotateX(45deg)</code>：沿着x轴正方向旋转 45度 </li><li><code>transform:rotateY(45deg)</code>：沿着y轴正方向旋转 45deg </li><li><code>transform:rotateZ(45deg)</code>：沿着Z轴正方向旋转 45deg </li><li><code>transform:rotate3d(x,y,z,deg)</code>： 沿着自定义轴旋转 deg为角度（了解即可）。<ul><li>xyz是表示旋转轴的矢量</li><li><code>transform:rotate3d(1,0,0,45deg)</code>就是沿着x轴旋转 45deg</li><li><code>transform:rotate3d(1,1,0,45deg)</code>就是沿着对角线旋转 45deg</li></ul></li></ul><p><strong>旋转方向判断——左手准则</strong> </p><ul><li>左手拇指指向 x/y/z 轴的正方向 </li><li>其余手指的弯曲方向就是该元素沿着 x/y/z 轴旋转的方向（正值）</li></ul><h3 id="7-4-3D-呈现-transfrom-style"><a href="#7-4-3D-呈现-transfrom-style" class="headerlink" title="7.4 3D 呈现 transfrom-style"></a>7.4 3D 呈现 transfrom-style</h3><p>控制<strong>子元素</strong>是否开启三维立体环境。</p><ul><li><code>transform-style: flat;</code>：子元素不开启3D立体空间（默认）</li><li><code>transform-style: preserve-3d;</code>：子元素开启立体空间 </li><li><strong>代码写给父级，但是影响的是子盒子</strong></li><li>这个属性很重要，后面必用</li></ul><h3 id="7-5-案例"><a href="#7-5-案例" class="headerlink" title="7.5 案例"></a>7.5 案例</h3><h4 id="7-5-1-两面魔方翻转"><a href="#7-5-1-两面魔方翻转" class="headerlink" title="7.5.1 两面魔方翻转"></a>7.5.1 两面魔方翻转</h4><p>HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="box"&gt;&lt;div class="front"&gt;你好呀&lt;/div&gt;&lt;div class="back"&gt;你是谁&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS：</p><pre class="line-numbers language-none"><code class="language-none">.box {position: relative;width: 200px;height: 100px;margin: 100px auto;transition: all .6s;transform-style: preserve-3d;}.box:hover {transform: rotateX(90deg);}.front,.back {position: absolute;top: 0;left: 0;width: 100%;height: 100%;line-height: 100px;text-align: center;font-size: 16px;color: white;backface-visibility: hidden;}.front {background-color: pink;/* 重要！！！应该向前移动front，这样box的旋转中心轴就在立方体中间了 */transform: translateZ(50px);}.back {background-color: purple;/* 不能先旋转再移动 */transform: translateY(50px) rotateX(-90deg);}</code></pre><ul><li><strong>旋转会改变 x/y/z 轴的方向</strong></li></ul><h4 id="7-5-2-旋转木马"><a href="#7-5-2-旋转木马" class="headerlink" title="7.5.2 旋转木马"></a>7.5.2 旋转木马</h4><p><img src="9aae961d66344c1ab0019510d62c4187.png" alt="在这里插入图片描述"></p><p>HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;section&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/section&gt;</code></pre><p>CSS：</p><pre class="line-numbers language-none"><code class="language-none">body {perspective: 1000px;}section {position: relative;width: 300px;height: 200px;margin: 150px auto;transform-style: preserve-3d;animation: rotate 7s linear infinite;background: url(media/pig.jpg) no-repeat;}section:hover {animation-play-state: paused;}@keyframes rotate {0% {}100% {transform: rotateY(360deg);}}div {position: absolute;top: 0;left: 0;width: 100%;height: 100%;background: url(media/dog.jpg) no-repeat;}div:nth-child(1) {transform: translateZ(300px);}div:nth-child(2) {/* 先旋转再移动 *//* 这里旋转的时候z轴方向也跟着旋转，因此还是300px */transform: rotateY(60deg) translateZ(300px);}div:nth-child(3) {transform: rotateY(120deg) translateZ(300px);}div:nth-child(4) {transform: rotateY(180deg) translateZ(300px);}div:nth-child(5) {transform: rotateY(240deg) translateZ(300px);}div:nth-child(6) {transform: rotateY(300deg) translateZ(300px);}</code></pre><h1 id="四、品优购项目"><a href="#四、品优购项目" class="headerlink" title="四、品优购项目"></a>四、品优购项目</h1><h2 id="1-常用模块类名命名"><a href="#1-常用模块类名命名" class="headerlink" title="1. 常用模块类名命名"></a>1. 常用模块类名命名</h2><p><img src="1e7295a5263c4963a97e5614566849a5.png" alt="在这里插入图片描述"></p><h2 id="2-模块化开发"><a href="#2-模块化开发" class="headerlink" title="2. 模块化开发"></a>2. 模块化开发</h2><h3 id="2-1-初始化文件"><a href="#2-1-初始化文件" class="headerlink" title="2.1 初始化文件"></a>2.1 初始化文件</h3><p>一些页面样式的初始化统一写入 base.css 文件中。</p><h3 id="2-2-公共样式文件"><a href="#2-2-公共样式文件" class="headerlink" title="2.2 公共样式文件"></a>2.2 公共样式文件</h3><p>有些样式和结构在很多页面都会出现，比如页面头部和底部，大部分页面都有。此时，可以把这些结构和样式单独作为一个模块 common.css ，然后重复使用。</p><p><strong>common.css 公共样式里面包含版心宽度、清除浮动、页面文字颜色等公共样式。</strong></p><h2 id="3-网站-favicon-图标"><a href="#3-网站-favicon-图标" class="headerlink" title="3. 网站 favicon 图标"></a>3. 网站 favicon 图标</h2><p>favicon.ico 一般用于作为缩略的网站标志，它显示在浏览器的地址栏或者标签上。</p><ol><li>制作 favicon 图标。把 png 图片转换为 ico 图标，这需要借助于第三方转换网站，例如比特虫：<a href="http://www.bitbug.net/">http://www.bitbug.net/</a></li><li>把 favicon 图标放到项目文件根目录下</li><li>在html 页面里面的<code>&lt;head&gt;&lt;/head&gt;</code>元素之间引入代码。<code>&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/&gt; </code></li></ol><h2 id="4-LOGO-SEO-优化"><a href="#4-LOGO-SEO-优化" class="headerlink" title="4. LOGO SEO 优化"></a>4. LOGO SEO 优化</h2><ol><li>logo 里面首先放一个 <code>h1</code> 标签，目的是为了提权，告诉搜索引擎，这个地方很重要。</li><li>h1 里面再放一个<code>a链接</code>，可以返回首页的，把 logo 的背景图片给链接即可。 </li><li>为了搜索引擎收录我们，我们<strong>链接里面要放文字（网站名称）</strong>，但是文字不要显示出来。<ol><li>方法1：<code>text-indent</code> 移到盒子外面（<code>text-indent: -9999px</code>) ，然后 <code>overflow:hidden</code>，淘宝的做法。 </li><li>方法2：直接给 <code>font-size: 0;</code> 就看不到文字了，京东的做法。</li></ol></li><li>最后给链接一个 <code>title</code> 属性，这样鼠标放到 logo 上就可以看到提示文字了。</li></ol><h2 id="5-一些tips"><a href="#5-一些tips" class="headerlink" title="5. 一些tips"></a>5. 一些tips</h2><ol><li>若要让相邻两个文字中间有一段距离，直接用<code>&amp;nbsp;</code>（空格符）即可。</li><li>nav导航栏处的dropdown盒子有讲究，它和下面的盒子是一体的，包含.dt 和.dd两个盒子<br><img src="490d976d82df478faa4e316864e12e9c.png" alt="在这里插入图片描述"></li></ol><p><img src="7475593a2d59417a9e1ed01af3a7a59a.png" alt="在这里插入图片描述"></p><ol start="3"><li><p>两行文字不需要分为两个<code>&lt;p&gt;</code>，可以直接在中间加<code>&lt;br&gt;</code>即可实现换行。若要增加两行文字间的距离，可以增大<code>line-height</code>属性即可。</p></li><li><p>一行文字中有文字需要加粗，则给需要加粗的文字套一个<code>&lt;strong&gt;&lt;/strong&gt;</code></p></li><li><p>多个<code>li</code>排成的多行<img src="57ad8614778f41cd9ea36bb55ade9207.png" alt="在这里插入图片描述"></p></li><li><p><code>text-align</code> 属性的巧用：<br>在一个 div 中包含 i（行内元素），此时对 div 赋予 <code>text-align: center</code>，i 也会在 div 内水平居中；<br>在一个 div 中包含 img（行内块元素），此时对 div 赋予 <code>text-align: center</code>，img 也会在 div 内水平居中；<br>在一个 div 中包含 p（块元素），此时对 div 赋予 <code>text-align: center</code>，p 会继承该属性，内容在标签内水平居中。</p></li><li><p>Tab栏原理-布局需求<br>要求选项卡个数要和内容个数一致，tab_content 里面包含 内容部分。<br><img src="606a50640560432386a8238c485aa3e7.png" alt="在这里插入图片描述"></p></li><li><p><code>vertical-align: middle;</code> 可以使行内块元素与文字对齐</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 之预处理器 less 语法</title>
      <link href="/2022/12/24/css-%E4%B9%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less-%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/12/24/css-%E4%B9%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>常见的预处理器：</p><ul><li>Sass/Scss：<ul><li>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分</li><li>目前受LESS影响，已经进化到了全面兼容CSS的SCSS</li></ul></li><li>Less:<ul><li>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手</li><li>比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用</li><li>另外反过来也影响了SASS演变到了SCSS的时代</li><li>著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括React的UI框架AntDesign。</li></ul></li><li>Stylus:<ul><li>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持</li><li>语法偏向于Python, 使用率相对于Sass/Less少很多</li></ul></li></ul><h1 id="1-less-语法"><a href="#1-less-语法" class="headerlink" title="1. less 语法"></a>1. less 语法</h1><p>less 代码如何被编译成CSS代码运行：</p><ul><li>方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译</li><li>方法二：通过VSCode插件来编译成CSS或者在线编译<ul><li><a href="https://lesscss.org/less-preview/">https://lesscss.org/less-preview/</a></li></ul></li><li>方式三：引入CDN的less编译代码，对less进行实时的处理<ul><li><code>&lt;script src="https://cdn.jsdelivr.net/npm/less@4" &gt;&lt;/script&gt;</code></li></ul></li><li>方式四：将less编译的js代码下载到本地，执行js代码对less进行编译</li></ul><h2 id="1-1-变量（Variables）"><a href="#1-1-变量（Variables）" class="headerlink" title="1.1 变量（Variables）"></a>1.1 变量（Variables）</h2><p>在Less中使用如下的格式来定义变量：</p><p><code>@变量名: 变量值;</code></p><h2 id="1-2-嵌套（Nesting）"><a href="#1-2-嵌套（Nesting）" class="headerlink" title="1.2 嵌套（Nesting）"></a>1.2 嵌套（Nesting）</h2><p>Less提供了选择器的嵌套</p><p>特殊符号：&amp; 表示当前选择器的父级</p><pre class="line-numbers language-less" data-language="less"><code class="language-less">// 1.定义变量@mainColor: #a40011;@smallFontSize: 12px;@normalFontSize: 14px;@bigFontSize: 18px;// 2.选择器的嵌套.box {.pel {color: @mainColor;font-size: @normalFontSize;}h1 {.keyword {color: @mainColor;font-size: @bigFontSize;}}p {a.link {color: @mainColor;font-size: @smallFontSize;background-color: #0f0;&amp;:hover {// 等于 a:hovercolor: #00f;}}}}</code></pre><h2 id="1-3-运算（Operations）"><a href="#1-3-运算（Operations）" class="headerlink" title="1.3 运算（Operations）"></a>1.3 运算（Operations）</h2><p>在Less中，算术运算符 +、-、 * 、/ 可以对任何数字、颜色或变量进行运算。</p><ul><li>算术运算符在加、减或比较之前会进行单位换算，计算的结果<strong>以最左侧操作数的单位类型</strong>为准</li><li>如果单位换算无效或失去意义，则忽略单位</li></ul><h2 id="1-4-混合（Mixins）和映射（Maps）"><a href="#1-4-混合（Mixins）和映射（Maps）" class="headerlink" title="1.4 混合（Mixins）和映射（Maps）"></a>1.4 混合（Mixins）和映射（Maps）</h2><p>混合是一种将一组属性<strong>从一个规则集（或混入）到另一个规则集</strong>的方法</p><ul><li>混入也可以传入变量</li></ul><p>映射是提取一组属性中的某个属性的方法</p><pre class="line-numbers language-less" data-language="less"><code class="language-less">// 1.运算// .box {//   font-size: 20px;//   width: 10% + 50px;//   height: 100px;//   background-color: #ff0000 + #00ff00;// }// 2.混入.nowrap_ellipsis {white-space: nowrap;text-overflow: ellipsis;overflow: hidden;}.box_border(@borderWidth: 5px, @borderColor: purple) {border: @borderWidth solid @borderColor;}  .box_size {width: 100px;height: 100px;}.box1 {// 2.3.混入和映射(Map)结合使用// 作用: 弥补less中不能自定义函数的缺陷width: .box_size()[width];background-color: #f00;// 2.1. 混入的基本使用.nowrap_ellipsis();.box_border();}.box2 {width: 150px;background-color: #0f0;.nowrap_ellipsis();// 2.2.混入是可以传递参数(定义变量)的.box_border(10px, orange);}</code></pre><h2 id="1-5-其他语法补充"><a href="#1-5-其他语法补充" class="headerlink" title="1.5 其他语法补充"></a>1.5 其他语法补充</h2><ul><li>extend继承：<ul><li>和mixins作用类似，用于复用代码</li><li>和mixins相比，继承代码最终会转化成并集选择器</li></ul></li><li>Less内置函数：<ul><li>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等</li><li><strong>内置函数手册</strong>：<a href="https://less.bootcss.com/functions/">https://less.bootcss.com/functions/</a></li></ul></li><li>作用域：<ul><li>在查找一个变量时，首先在本地查找变量和混合（mixins）</li><li>如果找不到，则从“父”级作用域继承</li></ul></li><li>导入：<ul><li><strong>导入的方式和CSS的用法是一致的</strong></li><li>导入一个 .less 文件，此文件中的所有变量就可以全部使用了</li><li>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">``````less// 1.extend// .box_border {//   border: 5px solid #f00;// }// .box {//   width: 100px;//   background-color: orange;//   .box_border();//   &amp;:extend(.box_border);// }// 2.内置函数// .box {//   color: color(skyblue);//   width: convert(100px, "in");//   font-size: ceil(18.5px);//   background-color: orange;// }// 3.作用域(scope)@mainColor: #f00;.box_mixin {@mainColor: orange;}.box {// @mainColor: #0f0;.item {span {color: @mainColor;.box_mixin();// @mainColor: #00f;}}}</code></pre><h1 id="2-认识-Sass-和-Scss"><a href="#2-认识-Sass-和-Scss" class="headerlink" title="2. 认识 Sass 和 Scss"></a>2. 认识 Sass 和 Scss</h1><p>Sass的语法使用的是类似于Ruby的语法，<strong>没有花括号，没有分号，具有严格的缩进</strong>；后来官方推出了全新的语法SCSS，意思是Sassy CSS，他是<strong>完全兼容CSS的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 页面布局三大核心</title>
      <link href="/2022/12/16/CSS-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/"/>
      <url>/2022/12/16/CSS-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><strong>网页布局过程：</strong></p><ol><li>准备网页元素，网页元素基本都是盒子 box</li><li>利用 CSS 设置好盒子样式，然后摆放到相应位置。</li><li>往盒子里放东西。</li></ol><p><strong>网页布局的核心本质</strong>：利用 CSS 摆盒子。</p><p><strong>CSS 提供了三种传统布局方式：</strong></p><ul><li>普通流（标准流）</li><li>浮动</li><li>定位</li></ul><p>所谓的标准流，就是标签按照规定好的默认方式排列（<strong>最基本的布局方式</strong>）。</p><ol><li>块级元素会独占一行，从上到下顺序排列 常用元素：div、hr、p、h1-h6、ul、ol、dl、form、table</li><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 常用元素：span、a、i、em</li></ol><h1 id="一、盒子模型"><a href="#一、盒子模型" class="headerlink" title="一、盒子模型"></a>一、盒子模型</h1><h2 id="1-盒子模型的组成"><a href="#1-盒子模型的组成" class="headerlink" title="1. 盒子模型的组成"></a>1. 盒子模型的组成</h2><p>CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素。</p><p><strong>包括：边框、外边距、内边距和实际内容。</strong></p><p><img src="604bacd3c99c449c8a0da847b9241d8a.png"></p><h2 id="2-边框（border）"><a href="#2-边框（border）" class="headerlink" title="2. 边框（border）"></a>2. 边框（border）</h2><p>border 可以设置元素边框。边框有三个组成：<code>border-width</code>、<code>border-style</code>、<code>border-color</code></p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">/*属性可连写*/border: border-width || border-style || border-color;</code></pre><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>定义边框粗细，单位 px</td></tr><tr><td>border-style</td><td>边框样式：none(默认无边框)、solid(单实线)、dashed(虚线)、dotted(点线)</td></tr><tr><td>border-color</td><td>边框颜色</td></tr></tbody></table><p><strong>边框属性分写：</strong></p><pre class="line-numbers language-none"><code class="language-none">/*注意层叠性*/border-top: 1px solid red;</code></pre><h3 id="2-1-表格的边框合并"><a href="#2-1-表格的边框合并" class="headerlink" title="2.1 表格的边框合并"></a>2.1 表格的边框合并</h3><p><code>border-collapse</code> 属性控制浏览器绘制表格边框的方式。它可以使相邻单元格的边框合并在一起。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-collapse: collapse;</code></pre><h3 id="2-2-圆角边框"><a href="#2-2-圆角边框" class="headerlink" title="2.2 圆角边框"></a>2.2 圆角边框</h3><p>CSS3 新增 <strong>圆角边框</strong> 属性，盒子可以变成圆角。</p><p><code>border-radius</code> 属性用于设置元素的外边框圆角。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-radius: length;</code></pre><p><strong>原理：</strong><br>（椭）圆与边框的交集形成的圆角效果。</p><p><strong>参数：</strong></p><ul><li>参数值可以为数值或百分比的形式</li><li>若是正方形，想要设置一个圆，则将数值修改为高度或者宽度的一般即可，或者直接写为 50%</li><li>简写属性，跟四个值，分别代表左上角、右上角、右下角、左下角</li><li>分开来写：<code>border-top-left-radius</code>、<code>border-top-right-radius</code>、<code>border-bottom-right-radius</code>、<code>border-bottom-left-radius</code></li></ul><h3 id="2-3-边框会影响盒子大小"><a href="#2-3-边框会影响盒子大小" class="headerlink" title="2.3 边框会影响盒子大小"></a>2.3 边框会影响盒子大小</h3><p>边框会额外增加盒子的实际大小，因此有两种方案解决。</p><ol><li>测量盒子大小的时候，不量边框。</li><li>若测量的时候包含了边框，则需要 width/height-边框宽度。</li></ol><h2 id="3-内边距（padding）"><a href="#3-内边距（padding）" class="headerlink" title="3. 内边距（padding）"></a>3. 内边距（padding）</h2><p><code>padding</code> 属性设置内边距，即边框与内容之间的距离。</p><ul><li><code>padding-left</code>: 左内边距</li><li><code>padding-right</code>: 右内边距</li><li><code>padding-top</code>: 上内边距</li><li><code>padding-bottom</code>: 下内边距</li></ul><p><strong>padding 属性简写：</strong></p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>padding: 5px;</td><td>上下左右5</td></tr><tr><td>padding: 5px 10px;</td><td>上下5 左右10</td></tr><tr><td>padding: 5px 10px 20px;</td><td>上5 左右10 下20</td></tr><tr><td>padding: 5px 10px 20px 30px;</td><td>上5 右10 下20 左30</td></tr></tbody></table><h3 id="3-1-内边距会影响盒子大小"><a href="#3-1-内边距会影响盒子大小" class="headerlink" title="3.1 内边距会影响盒子大小"></a>3.1 内边距会影响盒子大小</h3><p>当给盒子指定了 <code>padding</code> 值以后，发生了两件事情：</p><ol><li>内容和边框有了距离，增加内边距</li><li>padding 值影响了盒子实际大小</li></ol><p>也就是说，<strong>当盒子已经有了宽度和高度</strong>，再指定内边距，会撑大盒子。（如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小）</p><p>要保证盒子和效果图一样大，则让 <code>width/height</code>-多出来的内边距大小。</p><h2 id="4-盒子大小变动解决方案"><a href="#4-盒子大小变动解决方案" class="headerlink" title="4. 盒子大小变动解决方案"></a>4. 盒子大小变动解决方案</h2><p>在设置了一个盒子的 <code>width/height</code> 后，再设置其 <code>border/padding</code> 会影响盒子实际大小。当进行响应式布局时，这个尤其烦人。</p><p><code>box-sizing</code> 属性可以被用来调整这些表现。</p><ul><li><p><code>content-box</code> 是默认值。如果你设置一个元素的宽为<code>100px</code>，那么这个元素整体会有 <code>100px</code> 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: content-box;</code></pre></li><li><p><code>border-box</code> 告诉浏览器：你想要设置的边框和内边距的值是包含在 <code>width</code> 内的。也就是说，如果你将一个元素的 <code>width</code> 设为 <code>100px</code>，那么这 <code>100px</code> 会包含它的 <code>border</code> 和 <code>padding</code>，内容区的实际宽度是 <code>width</code> 减去 <code>(border + padding)</code> 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: border-box;</code></pre><p>尺寸计算公式： <code>width = border + padding + 内容的宽度</code> 、<code>height = border + padding + 内容的高度</code></p></li></ul><h2 id="5-外边距（margin）"><a href="#5-外边距（margin）" class="headerlink" title="5. 外边距（margin）"></a>5. 外边距（margin）</h2><p><code>margin</code> 属性用于设置外边距，即控制盒子与盒子之间的距离。</p><ul><li><code>margin-left</code>: 左外边距</li><li><code>margin-right</code>: 右外边距</li><li><code>margin-top</code>: 上外边距</li><li><code>margin-bottotm</code>: 下外边距</li></ul><p><code>margin</code> 简写方式与 <code>padding</code> 一致。</p><h3 id="5-1-外边距典型应用"><a href="#5-1-外边距典型应用" class="headerlink" title="5.1 外边距典型应用"></a>5.1 外边距典型应用</h3><p>外边距可以让块级盒子 <strong>水平居中</strong>，但是必须满足两个条件：</p><ol><li>盒子必须指定宽度（width）</li><li>盒子左右的外边距都设置为 <code>auto</code></li></ol><pre class="line-numbers language-none"><code class="language-none">.header {  width: 960px;  margin: 0 auto;}</code></pre><h3 id="5-2-外边距合并"><a href="#5-2-外边距合并" class="headerlink" title="5.2 外边距合并"></a>5.2 外边距合并</h3><p>使用 <code>margin</code> 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><h4 id="5-2-1-上下相邻块元素垂直外边距的合并"><a href="#5-2-1-上下相邻块元素垂直外边距的合并" class="headerlink" title="5.2.1 上下相邻块元素垂直外边距的合并"></a>5.2.1 上下相邻块元素垂直外边距的合并</h4><p>当上下相邻块元素相遇时，若上面的元素有下外边距，下面的元素有上外边距，则他们之间的垂直间距不是 <code>margin-bottotm</code> 与 <code>margin-top</code> 之和。<strong>取两个值中的较大者</strong>这种现象被称为相邻元素垂直外边距的合并。</p><p>解决方案：尽量只给一个盒子添加margin值。</p><p>![[Pasted image 20221209144024.png]]</p><h4 id="5-2-2-嵌套块元素垂直外边距的塌陷"><a href="#5-2-2-嵌套块元素垂直外边距的塌陷" class="headerlink" title="5.2.2 嵌套块元素垂直外边距的塌陷"></a>5.2.2 嵌套块元素垂直外边距的塌陷</h4><p>对于两个嵌套关系的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><p>解决方案：</p><ol><li>为父元素定义上边框</li><li>为父元素定义上内边距</li><li>为父元素添加 <code>overflow:hidden</code></li></ol><p><img src="2884c415f1284d7abcfa54e3115596dd.png" alt="在这里插入图片描述"></p><h2 id="6-清除内外边距"><a href="#6-清除内外边距" class="headerlink" title="6. 清除内外边距"></a>6. 清除内外边距</h2><p>网页元素很多都带有默认内外边距，而且不同浏览器默认的也不一致，因此在布局前，要先清除网页元素的内外边距。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">* {  margin: 0;  padding: 0;}</code></pre><p><em><strong>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距（不起效果）。但是转换为块级和行内块元素就可以设置。</strong></em></p><h2 id="7-盒子阴影"><a href="#7-盒子阴影" class="headerlink" title="7. 盒子阴影"></a>7. 盒子阴影</h2><p>CSS3 新增盒子阴影，使用 <code>box-shadow</code> 属性。</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">bxo-shadow: h-shadow v-shadow blur spread color inset;</code></pre><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必需，水平阴影的位置，允许负值</td></tr><tr><td>v-shadow</td><td>必需，垂直阴影的位置，允许负值</td></tr><tr><td>blur</td><td>可选，模糊距离</td></tr><tr><td>spread</td><td>可选，阴影的尺寸</td></tr><tr><td>color</td><td>可选，阴影的颜色</td></tr><tr><td>inset</td><td>可选，将外部阴影改为内部阴影（默认是外部阴影）</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3);</code></pre><p>注意：</p><ol><li>默认是外阴影，但是不可以写这个单词（outset）</li><li><strong>盒子阴影不占空间，不会影响其他盒子排列</strong></li></ol><h1 id="二、浮动"><a href="#二、浮动" class="headerlink" title="二、浮动"></a>二、浮动</h1><h2 id="1-浮动相关概念"><a href="#1-浮动相关概念" class="headerlink" title="1. 浮动相关概念"></a>1. 浮动相关概念</h2><h3 id="1-1-为什么需要浮动"><a href="#1-1-为什么需要浮动" class="headerlink" title="1.1 为什么需要浮动"></a>1.1 为什么需要浮动</h3><ol><li><p>如何让多个块级盒子(div)水平排列成一行？<br>比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的<strong>空白缝隙</strong>，很难控制。</p></li><li><p>如何实现两个盒子的左右对齐？</p></li></ol><p>总结：很多布局效果，标准流没办法完成，此时就可以利用浮动完成布局。浮动可以改变元素标签默认排列方式。</p><p><strong>浮动最典型应用：让多个块级元素一行显示。</strong></p><p>网页布局第一准则：<em><strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</strong></em>。<br>网页布局第二准则：先设置盒子大小，再设置盒子位置。</p><h3 id="1-2-什么是浮动"><a href="#1-2-什么是浮动" class="headerlink" title="1.2 什么是浮动"></a>1.2 什么是浮动</h3><p><code>float</code> 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 { float: 属性值; }</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h3 id="1-3-浮动特性（重点）"><a href="#1-3-浮动特性（重点）" class="headerlink" title="1.3 浮动特性（重点）"></a>1.3 浮动特性（重点）</h3><p>加了浮动之后的元素，会具有一些特性。</p><ol><li>浮动元素会脱离标准流（脱标）</li><li>浮动元素会一行内显示并且元素顶部对齐</li><li>浮动的元素会具有行内块元素的特性</li></ol><h4 id="1-3-1-重要特性"><a href="#1-3-1-重要特性" class="headerlink" title="1.3.1 重要特性"></a>1.3.1 重要特性</h4><ol><li><p>脱离文档流的控制（浮）移动到指定位置（动）（俗称脱标）。浮动的盒子不再保留原先的位置。<br><img src="a33af70ed3d541f889d93ffc584a2252.png" alt="在这里插入图片描述"></p></li><li><p>如果多个盒子都设置了浮动，则它们会按照属性值<strong>一行显示并且顶端对齐排列</strong>。 浮动的元素是相互贴在一起的（没有间隙），若父级宽度放不下这些浮动的盒子，多出的盒子会另起一行对齐。</p></li><li><p>浮动元素具有行内块元素特性。 任何元素都可以浮动，元素添加浮动后都具有<strong>行内块元素</strong>性质。</p></li></ol><ul><li>若块级元素没有设置宽度，则默认和父级一样宽。但添加浮动后，大小根据内容来决定</li><li>浮动盒子中间无间隙，紧挨着</li><li>行内块元素同理</li></ul><h4 id="1-3-2-浮动布局注意点"><a href="#1-3-2-浮动布局注意点" class="headerlink" title="1.3.2 浮动布局注意点"></a>1.3.2 浮动布局注意点</h4><p><strong>1. 浮动和标准流的父盒子搭配</strong></p><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</p><p><strong>2. 一个元素浮动了，理论上其余兄弟元素也要浮动</strong></p><ul><li><p>一个盒子里有多个盒子，其中一个盒子浮动，其他兄弟也应该浮动，防止引起问题。 </p></li><li><p>浮动的盒子只会影响浮动盒子<strong>后面</strong>的标准流，不会影响前面的标准流。</p></li></ul><h2 id="2-清除浮动"><a href="#2-清除浮动" class="headerlink" title="2. 清除浮动"></a>2. 清除浮动</h2><h3 id="2-1-为什么需要清除浮动"><a href="#2-1-为什么需要清除浮动" class="headerlink" title="2.1 为什么需要清除浮动"></a>2.1 为什么需要清除浮动</h3><p>由于父级盒子很多情况下，<strong>不方便给高度</strong>（产品可能有很多很多；新闻页面不知道有多少字不方便给高度）。<br>盒子浮动不占有位置，<strong>若父级盒子高度为 0 时，就会影响下面的盒子</strong>，对后面元素排版产生影响。<br><img src="48fc3938fad84506b096e53a1bf40817.png" alt="在这里插入图片描述"></p><h3 id="2-2-清除浮动的本质"><a href="#2-2-清除浮动的本质" class="headerlink" title="2.2 清除浮动的本质"></a>2.2 清除浮动的本质</h3><ul><li>清除浮动的本质是清除浮动元素造成的影响</li><li>如果父盒子本身具有高度，则不需要清除浮动</li><li>清除浮动之后，<strong>父级会根据浮动的子盒子自动检测高度</strong>，父级有了高度，就不会影响下面的标准流了。</li></ul><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 {  clear: 属性值;}</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素</td></tr><tr><td>right</td><td>不允许右侧有浮动元素</td></tr><tr><td>both</td><td>同时清除左右两侧浮动</td></tr><tr><td>清除浮动策略：闭合浮动</td><td></td></tr></tbody></table><h3 id="2-3-清除浮动的方法"><a href="#2-3-清除浮动的方法" class="headerlink" title="2.3 清除浮动的方法"></a>2.3 清除浮动的方法</h3><h4 id="2-3-1-额外标签法（隔墙法）"><a href="#2-3-1-额外标签法（隔墙法）" class="headerlink" title="2.3.1 额外标签法（隔墙法）"></a>2.3.1 额外标签法（隔墙法）</h4><p>额外标签法是在最后一个浮动元素末尾添加一个<strong>空块级元素</strong>，给其赋以属性 <code>clear: both;</code>。(不常用)</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;  .clear {  clear: both;}&lt;/style&gt;&lt;div class="clear"&gt;&lt;/div&gt;</code></pre><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义的标签，结构化差</li></ul><h4 id="2-3-2-父级添加-overflow-属性"><a href="#2-3-2-父级添加-overflow-属性" class="headerlink" title="2.3.2 父级添加 overflow 属性"></a>2.3.2 父级添加 overflow 属性</h4><p>可以给父级添加 <code>overflow</code> 属性，将其属性设置为 <code>hidden</code>、<code>auto</code>或<code>scroll</code>。</p><p>注意是<strong>给父元素添加代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">.box {overflow: hidden;}</code></pre><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出部分</li></ul><h4 id="2-3-3-after-伪元素法"><a href="#2-3-3-after-伪元素法" class="headerlink" title="2.3.3 :after 伪元素法"></a>2.3.3 :after 伪元素法</h4><p><code>:after</code> 方式是额外标签法的升级版。给父元素添加（常用）</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:after {content: "";display: block;height: 0;clear: both;visibility: hidden;}.clearfix {/*IE6、7专有*/*zoom: 1;}</code></pre><p>优点：没有增加标签，结构更简单</p><h4 id="2-3-4-双伪元素清除浮动"><a href="#2-3-4-双伪元素清除浮动" class="headerlink" title="2.3.4 双伪元素清除浮动"></a>2.3.4 双伪元素清除浮动</h4><p>给父元素添加（常用）</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:before,.clearfix:after {  content: "";  display: table;}.clearfix:after {  clear: both;}.clearfix {  *zoom: 1;}</code></pre><h2 id="3-学成在线案例"><a href="#3-学成在线案例" class="headerlink" title="3. 学成在线案例"></a>3. 学成在线案例</h2><h3 id="3-1-CSS属性书写顺序"><a href="#3-1-CSS属性书写顺序" class="headerlink" title="3.1 CSS属性书写顺序"></a>3.1 CSS属性书写顺序</h3><p><img src="9f10784467f742579317d741a3e25e16.png" alt="在这里插入图片描述"></p><h3 id="3-2-页面布局分析"><a href="#3-2-页面布局分析" class="headerlink" title="3.2 页面布局分析"></a>3.2 页面布局分析</h3><p>为了提高网页制作的效率，布局时通常有以下的布局流程：</p><ol><li>必须确定页面的版心（可视区），我们测量可得知。</li><li>分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成的。</li><li>制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</li><li>开始运用盒子模型的原理，通过 div+css 布局来控制网页的各个模块。</li></ol><h3 id="3-3-注意点"><a href="#3-3-注意点" class="headerlink" title="3.3 注意点"></a>3.3 注意点</h3><p>导航栏注意点：</p><p>实际开发中，不会直接用链接 a 而是用 li 包含链接（li+a）的做法。</p><ol><li><p>li+a 语义更清晰，一看就是有条理的列表型内容。</p></li><li><p>如果直接用 a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名。</p></li><li><p>让导航栏一行显示，给 <code>li</code> 加浮动，因为 li 是块级元素，需要一行显示。</p></li><li><p>这个 nav 导航栏可以不给宽度，将来可以继续添加其余文字。</p></li><li><p>因为导航栏里面文字不一样多，所以最好<strong>给链接 a 左右 padding 撑开盒子</strong>，而不是指定宽度。</p></li></ol><p>其他注意点：</p><ol><li><p>浮动的盒子不会出现外边距合并的问题。</p></li><li><p>注意元素的显示模式（块级、行内、行内块），必要时进行模式转换。</p></li><li><p>若添加了margin导致5个盒子无法在父元素的一行显示、一个盒子到下一行显示的问题时，直接增加父元素的宽度即可。</p></li></ol><h1 id="三、定位"><a href="#三、定位" class="headerlink" title="三、定位"></a>三、定位</h1><h2 id="1-为什么需要定位"><a href="#1-为什么需要定位" class="headerlink" title="1. 为什么需要定位"></a>1. 为什么需要定位</h2><p>在一些场景，我们希望实现以下功能：</p><ol><li>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子</li><li>当我们滚动窗口的时候，盒子是固定屏幕某个位置的。</li></ol><p>以上效果，标准流或浮动都无法快速实现，此时<strong>需要定位来实现</strong>。 所以： </p><ol><li>浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 </li><li>定位则是可以<strong>让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置</strong>，并且可以压住其他盒子。</li></ol><h2 id="2-定位组成"><a href="#2-定位组成" class="headerlink" title="2. 定位组成"></a>2. 定位组成</h2><p>定位：将盒子定在某一个位置，所以<strong>定位也是在摆放盒子，按照定位的方式移动盒子</strong>。定位=定位模式+边偏移。</p><p><strong>定位模式</strong>用于指定一个元素在文档中的定位方式。<strong>边偏移</strong>则决定了该元素的最终位置。</p><h3 id="2-1-定位模式"><a href="#2-1-定位模式" class="headerlink" title="2.1 定位模式"></a>2.1 定位模式</h3><p>定位模式决定元素的定位方式，它通过 CSS 的 <code>position</code> 属性来设置，其值可以分为四个值：</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><h3 id="2-2-边偏移"><a href="#2-2-边偏移" class="headerlink" title="2.2 边偏移"></a>2.2 边偏移</h3><p>边偏移就是定位的盒子移动到最终位置。有 top， bottom， left 和 right 4 个属性</p><p><strong>注意：如果一个盒子既有left属性又有right属性，则默认会执行left属性。同理top和bottom默认会执行top。</strong></p><table><thead><tr><th>边偏移属性</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td><strong>top</strong></td><td><code>top:80px</code></td><td>顶端偏移量，定义元素相对于其父元素上边线的距离。</td></tr><tr><td>bottom</td><td><code>bottom: 80px</code></td><td>底部偏移量，定义元素相对于其父元素下边线的距离。</td></tr><tr><td><strong>left</strong></td><td><code>left： 80px</code></td><td>左侧偏移量，定义元素相对于其父元素左边线的距离。</td></tr><tr><td>right</td><td><code>right: 80px</code></td><td>右侧偏移量，定义元素相对于其父元素右边线的距离。</td></tr></tbody></table><h2 id="3-定位模式介绍"><a href="#3-定位模式介绍" class="headerlink" title="3. 定位模式介绍"></a>3. 定位模式介绍</h2><h3 id="3-1-静态定位-static（了解）"><a href="#3-1-静态定位-static（了解）" class="headerlink" title="3.1 静态定位 static（了解）"></a>3.1 静态定位 static（了解）</h3><p>静态定位是元素的<strong>默认定位方式</strong>，无定位的意思。语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: static;}</code></pre><p>静态定位<strong>按照标准流特性</strong>摆放位置，它没有边偏移，在布局时很少用到。</p><h3 id="3-2-相对定位-relative（重要）"><a href="#3-2-相对定位-relative（重要）" class="headerlink" title="3.2 相对定位 relative（重要）"></a>3.2 相对定位 relative（重要）</h3><p>相对定位是元素在移动位置的时候，是<strong>相对于它原来的位置</strong>来说的（自恋型）。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: relative;}</code></pre><p><strong>相对定位的特点：（务必记住）</strong></p><ol><li><p>它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。</p></li><li><p><strong>原来</strong>在标准流的<strong>位置继续占有</strong>，后面的盒子仍然以标准流的方式对待它。（<strong>不脱标</strong>，继续保留原来位置。它最典型的应用是给绝对定位当爹。）</p></li></ol><h3 id="3-3-绝对定位-absolute（重要）"><a href="#3-3-绝对定位-absolute（重要）" class="headerlink" title="3.3 绝对定位 absolute（重要）"></a>3.3 绝对定位 absolute（重要）</h3><p>绝对定位是元素在移动位置的时候，是相对于它<strong>祖先元素</strong>来说的（拼爹型）。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: absolute;}</code></pre><p>绝对定位的特点： （务必记住）</p><ol><li><p>如果 <strong>没有祖先元素</strong> 或者 <strong>祖先元素没有定位</strong>，则以 <strong>浏览器</strong> 为准定位（ Document 文档）。</p></li><li><p>如果祖先元素有定位（相对、绝对、固定定位） ，则以<strong>最近一级的有定位祖先元素</strong>为参考点移动位置。</p></li><li><p>绝对定位<strong>不再占有原先的位置</strong>。（脱标）</p></li></ol><h4 id="3-3-1-子绝父相"><a href="#3-3-1-子绝父相" class="headerlink" title="3.3.1 子绝父相"></a>3.3.1 子绝父相</h4><ul><li><p><strong>子级绝对定位，不占有位置</strong>，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p></li><li><p>父盒子需要<strong>加定位限制子盒子</strong>在父盒子内显示。</p></li><li><p>父盒子布局时，<strong>需要占有位置</strong>，因此父亲只能是相对定位。</p></li></ul><p>这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。<br><strong>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</strong></p><p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，<strong>子绝父绝</strong>也会遇到。</p><h3 id="3-4-固定定位-fixed-（重要）"><a href="#3-4-固定定位-fixed-（重要）" class="headerlink" title="3.4 固定定位 fixed （重要）"></a>3.4 固定定位 fixed （重要）</h3><p>固定定位是元素<strong>固定于浏览器可视区的位置</strong>。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {  position: fixed;}</code></pre><p>固定定位的特点： （务必记住）</p><ol><li>以浏览器的可视窗口为参照点移动元素。<ul><li>跟父元素没有任何关系</li><li>不随滚动条滚动</li></ul></li><li>固定定位<strong>不占有原先的位置</strong>。 固定定位也是脱标的，其实固定定位也可以看做是<strong>一种特殊的绝对定位</strong>。</li></ol><p><em><strong>固定定位小技巧：固定在版心右侧位置。</strong></em></p><ol><li>让固定定位的盒子 left：50%，走到浏览器可视区（也可以看做版心）的一半位置。</li><li>让固定定位的盒子 margin-left：板心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了</li></ol><h3 id="3-5-粘性定位-sticky（了解）"><a href="#3-5-粘性定位-sticky（了解）" class="headerlink" title="3.5 粘性定位 sticky（了解）"></a>3.5 粘性定位 sticky（了解）</h3><p>粘性定位可以被认为是相对定位和固定定位的混合。<br><strong>应用：滑动到元素所在定义位置（如top: 10px表示滑动到浏览器可视窗口距元素10px）后，继续下滑时元素固定。</strong></p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {position: sticky;top: 10px;}</code></pre><p>粘性定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li><strong>必须添加 top， left， right， bottom 其中一个</strong>才有效跟页面滚动搭配使用。兼容性较差， IE 不支持。</li></ol><h3 id="3-6-定位模式总结"><a href="#3-6-定位模式总结" class="headerlink" title="3.6 定位模式总结"></a>3.6 定位模式总结</h3><table><thead><tr><th>定位模式</th><th>是否脱标</th><th>移动位置</th><th>是否常用</th></tr></thead><tbody><tr><td>static静态定位</td><td>否 (占有位置)</td><td>不能使用边偏移</td><td>很少</td></tr><tr><td>relative相对定位</td><td>否 (占有位置)</td><td>相对于自身位置移动</td><td>常用</td></tr><tr><td>absolute绝对定位</td><td>是 (不占有位置)</td><td>带有定位的父级</td><td>常用</td></tr><tr><td>fixed固定定位</td><td>是 (不占有位置)</td><td>浏览器可视区</td><td>常用</td></tr><tr><td>sticky粘性定位</td><td>否 (占有位置)</td><td>浏览器可视区</td><td>当前阶段少</td></tr></tbody></table><h2 id="4-定位的拓展"><a href="#4-定位的拓展" class="headerlink" title="4. 定位的拓展"></a>4. 定位的拓展</h2><h3 id="4-1-定位叠放次序-z-index"><a href="#4-1-定位叠放次序-z-index" class="headerlink" title="4.1 定位叠放次序 z-index"></a>4.1 定位叠放次序 z-index</h3><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 <code>z-index</code> 来控制盒子的前后次序（z 轴）</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">选择器 {z-index: 1;}</code></pre><ul><li>数值可以是正整数、负整数或 0，默认是 auto ，<strong>数值越大，盒子越靠上</strong></li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有 <code>z-index</code> 属性</li></ul><h3 id="4-2-绝对定位的盒子居中"><a href="#4-2-绝对定位的盒子居中" class="headerlink" title="4.2 绝对定位的盒子居中"></a>4.2 绝对定位的盒子居中</h3><p>加了<strong>绝对定位</strong>的盒子不能通过 margin：0 auto 水平居中，但是可以通过以下计算方法实现水平和垂直居中。</p><ul><li><code>left: 50%;</code>：让盒子的左侧移动到父级元素的水平中心位置。</li><li><code>margin-left: -100px;</code>：让盒子向左移动自身宽度的一半。</li></ul><h3 id="4-3-绝对定位和固定定位的特殊特性"><a href="#4-3-绝对定位和固定定位的特殊特性" class="headerlink" title="4.3 绝对定位和固定定位的特殊特性"></a>4.3 绝对定位和固定定位的特殊特性</h3><h4 id="4-3-1-元素模式转换"><a href="#4-3-1-元素模式转换" class="headerlink" title="4.3.1 元素模式转换"></a>4.3.1 元素模式转换</h4><p><strong>绝对定位和固定定位</strong>也和<strong>浮动</strong>类似。添加后<strong>变为行内块元素</strong>。</p><ol><li>行内元素添加绝对或者固定定位，可以直接设置高度和完度。</li><li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li></ol><h4 id="4-3-2-不会触发外边距合并"><a href="#4-3-2-不会触发外边距合并" class="headerlink" title="4.3.2 不会触发外边距合并"></a>4.3.2 不会触发外边距合并</h4><p><strong>浮动</strong>元素、<strong>绝对定位/固定定位</strong>的元素 都不会触发外边距合并的问题。</p><h4 id="4-3-3-完全压住盒子"><a href="#4-3-3-完全压住盒子" class="headerlink" title="4.3.3 完全压住盒子"></a>4.3.3 完全压住盒子</h4><ul><li><p>浮动元素不同，只会压住它下面标准流的盒子，但是<strong>不会压住下面标准流盒子里面的文字（图片）</strong></p><blockquote><p>因为浮动产生的目的最初是为了<strong>做文字环绕效果</strong>的。文字会围绕浮动元素。</p></blockquote></li><li><p>绝对定位（固定定位）会压住<strong>下面标准流所有的内容</strong>。</p></li></ul><h2 id="5-网页布局总结"><a href="#5-网页布局总结" class="headerlink" title="5. 网页布局总结"></a>5. 网页布局总结</h2><p>通过盒子模型，清楚知道大部分 html 标签是一个盒子。<br>通过 CSS 浮动、定位可以让每个盒子排列成为网页。<br>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p><p><strong>1.  标准流</strong></p><ul><li>可以让盒子上下排列或者左右排列，<strong>垂直的块级盒子显示就用标准流布局</strong>。<br><strong>2.  浮动</strong></li><li>可以让多个块级元素一行显示或者左右对齐盒子，<strong>多个块级盒子水平显示就用浮动布局</strong>。<br><strong>3.  定位</strong></li><li>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。<strong>如果元素自由在某个盒子内移动就用定位布局</strong>。</li></ul><h2 id="6-元素的显示与隐藏"><a href="#6-元素的显示与隐藏" class="headerlink" title="6. 元素的显示与隐藏"></a>6. 元素的显示与隐藏</h2><p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！<br>本质：<strong>让一个元素在页面中隐藏或者显示出来</strong>。</p><h3 id="6-1-display-属性"><a href="#6-1-display-属性" class="headerlink" title="6.1 display 属性"></a>6.1 display 属性</h3><p><code>display</code> 属性用于设置一个元素应如何显示。</p><ul><li><code>display: none;</code> 隐藏对象</li><li><code>display: block;</code> 除了转换为块级元素之外，同时还有显示元素的意思。</li></ul><p>display 隐藏元素后，<strong>不再占有原来的位置</strong>。</p><p>后面应用及其广泛，搭配 JS 可以做很多的网页特效。</p><h3 id="6-2-visibility-可见性"><a href="#6-2-visibility-可见性" class="headerlink" title="6.2 visibility 可见性"></a>6.2 visibility 可见性</h3><p><code>visibility</code> 属性用于指定一个元素应可见还是隐藏。</p><ul><li><code>visibility: hidden;</code> 元素隐藏</li><li><code>visibility: visible;</code> 元素可视</li></ul><p>visibility 隐藏元素后，<strong>继续占有原来的位置</strong>。</p><p><em><strong>如果隐藏元素想要原来位置，就用 <code>visibility：hidden</code><br>如果隐藏元素不想要原来位置，就用 <code>display：none</code> （用处更多，重点）</strong></em></p><h3 id="6-3-overflow-溢出"><a href="#6-3-overflow-溢出" class="headerlink" title="6.3 overflow 溢出"></a>6.3 overflow 溢出</h3><p><code>overflow</code> 属性指定了如果<strong>内容溢出</strong>一个元素的框（超过其指定高度及宽度）时，会发生什么。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>不剪切内容也不添加滚动条</td></tr><tr><td>hidden</td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td>scroll</td><td>不管是否超出内容，总是显示滚动条</td></tr><tr><td>auto</td><td>超出则自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><p>一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。但是如果有定位的盒子，请慎用 <code>overflow: hidden</code> 因为它会隐藏多余的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里iconfont的使用方法</title>
      <link href="/2022/12/15/%E9%98%BF%E9%87%8Ciconfont%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/12/15/%E9%98%BF%E9%87%8Ciconfont%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最近学习CSS中研究了一下阿里妈妈出品的阿里iconfont图标的引入方法。网页的各种常用图标引入不愁啦~</p><p>主要分为<strong>线上引用</strong>和<strong>本地引用</strong>（更稳定）。</p><h3 id="一、线上引用"><a href="#一、线上引用" class="headerlink" title="一、线上引用"></a>一、线上引用</h3><p>不足：线上引用比较依赖阿里iconfont图标平台的稳定性</p><p>优势：方便，不需下载文件至本地，推荐日常练习时使用</p><p><strong>1. 寻找图标</strong></p><p>打开网站<a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p><ul><li>图标管理-&gt;我的项目-&gt;然后<strong>新建项目</strong></li><li>选择图标添加到购物车-&gt;购物车中选择<strong>加入项目</strong>，将图标加入项目</li><li>打开项目<br><img src="8e92705d9346483e858e895c2cf63d38.png" alt="在这里插入图片描述"></li></ul><p> 此时可以看到我们将三个箭头图标添加进了项目中。</p><p><strong>2. 引入图标</strong></p><p>首先复制链接（点此复制代码）<br><img src="ac5dd43ab6504a9086f23f51cf70ebf3.png" alt="在这里插入图片描述"></p><p>然后在css中<code>&lt;head&gt;&lt;/head&gt;</code>内插入<code>&lt;link&gt;</code>，注意加上http:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;</code></pre><p>此时需要在html结构中引用这些图标</p><p>可以看到，红框中为三个图标各自对应的类名<br><img src="5daaadc1391e47c2a9e5fbe924ef206d.png" alt="在这里插入图片描述"></p><p>在引入时，分别引入这些类名即可</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;!-- 引入在线链接 --&gt;&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;&lt;style&gt;span {/* 图标颜色变为粉色 */color: pink;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 引入各图标，iconfont为图标字体类名，必写 --&gt;&lt;span class="iconfont icon-shangla1"&gt;&lt;/span&gt;&lt;span class="iconfont icon-jinrujiantou"&gt;&lt;/span&gt;&lt;span class="iconfont icon-xiala"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>3. 更改图标</strong></p><ul><li>更改颜色：可直接在文件样式style中更改</li><li>更改字体：需要复制.iconfont代码，在其中更改<code>font-size</code></li></ul><p>获取.iconfont：点击红框处，在弹出页面找到.iconfont</p><p><img src="4f0c5887f40a46ae8530bdbccaa43ab7.png" alt="在这里插入图片描述"><br><img src="13398e5109ae4a6eab6430294dd0233d.png" alt="在这里插入图片描述"></p><h3 id="二、本地引用"><a href="#二、本地引用" class="headerlink" title="二、本地引用"></a>二、本地引用</h3><p>不足：没有线上引用方便</p><p>优势：稳定</p><p><strong>1. 下载图标</strong></p><p>打开网站<a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p><ul><li>图标管理-&gt;我的项目-&gt;然后<strong>新建项目</strong></li><li>选择图标添加到购物车-&gt;购物车中选择<strong>加入项目</strong>，将图标加入项目</li><li>打开项目-&gt;下载到本地-&gt;放入本地项目的根目录下<br><img src="f0ea2af40dab4adb94c22caed4691aea.png" alt="在这里插入图片描述"></li></ul><p>fonts为下载的图标文件夹</p><p><strong>2. 引入图标</strong></p><p>在文件中引入iconfont.css，fonts为图标文件夹名称</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;link rel="stylesheet" href="fonts/iconfont.css"&gt;</code></pre><p>然后在html结构中引用这些图标，与线上引用类似</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!-- 引入图标文件 --&gt;    &lt;link rel="stylesheet" href="fonts/iconfont.css"&gt;    &lt;style&gt;        span {            /* 图标颜色变为粉色 */            color: pink;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 引入各图标，iconfont为图标字体类名，必写 --&gt;    &lt;span class="iconfont icon-shangla1"&gt;&lt;/span&gt;    &lt;span class="iconfont icon-jinrujiantou"&gt;&lt;/span&gt;    &lt;span class="iconfont icon-xiala"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="PS-添加-font-family-和-content-的引入方法"><a href="#PS-添加-font-family-和-content-的引入方法" class="headerlink" title="PS: 添加 font-family 和 content 的引入方法"></a>PS: 添加 font-family 和 content 的引入方法</h3><p>以上方法都是需要在元素中加入class属性。</p><p>在使用过程中，我发现了另一种引入方法：此方法不需要在元素中添加class属性，<strong>支持伪元素选择器添加图标</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;!-- 引入线上链接 --&gt;&lt;link rel="stylesheet" href="http://at.alicdn.com/t/c/font_3829262_6kaipqldfn4.css"&gt;&lt;style&gt;div::after {/* content中为下拉符 */content: '\e69a';/* 一定要添加font-family属性 */font-family: 'iconfont';}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;更多推荐&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>ps：content中的内容在此找<br><img src="d8391a0b2695468ba33cca66e1519154.png" alt="在这里插入图片描述"><br><img src="d3f00bd9c72d4cf682d1d8ed7a9088cc.png" alt="在这里插入图片描述"></p><p><strong>代码效果如下：</strong><br><img src="82c795b941f141f489f123f7de525ad8.png" alt="在这里插入图片描述"></p><p>此方法常用于<strong>使用伪元素选择器（<code>::before</code>,<code>::after</code>）添加图标时</strong>（此时无法在html结构中引入iconfont等class类名）</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS属性&amp;元素显示模式&amp;引用方式&amp;三大特性</title>
      <link href="/2022/12/15/CSS%E5%B1%9E%E6%80%A7-%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2022/12/15/CSS%E5%B1%9E%E6%80%A7-%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS-属性"><a href="#一、CSS-属性" class="headerlink" title="一、CSS 属性"></a>一、CSS 属性</h1><h2 id="1-CSS-字体属性"><a href="#1-CSS-字体属性" class="headerlink" title="1. CSS 字体属性"></a>1. CSS 字体属性</h2><p>CSS fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。</p><h3 id="1-1-字体系列"><a href="#1-1-字体系列" class="headerlink" title="1.1 字体系列"></a>1.1 字体系列</h3><p>CSS 使用 <code>font-family</code> 属性定义文本字体系列。 </p><pre class="line-numbers language-none"><code class="language-none">body {  font-family: "Microsoft YaHei", Arial, Helvetica, sans-serif;}</code></pre><p><strong>注意：</strong></p><ul><li>尽量使用默认字体，保证不同浏览器的兼容性。（谷歌浏览器默认字体为微软雅黑）</li><li>最常见的几个字体：<code>body {font-family: 'Microsoft YaHei',tahoma,arial,'Hiragino Sans GB'; }</code></li><li>支持同时定义多个字体，<strong>从左至右优先级</strong>，以防因电脑未装字体而无法正常显示。</li></ul><h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。</p><pre class="line-numbers language-none"><code class="language-none">body {  font-size: 16px;}</code></pre><ul><li>谷歌浏览器默认是 <code>16px</code></li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 <code>body</code> 指定整个页面文字大小</li></ul><h3 id="1-3-字体粗细"><a href="#1-3-字体粗细" class="headerlink" title="1.3 字体粗细"></a>1.3 字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置字体粗细</p><pre class="line-numbers language-none"><code class="language-none">p {  font-weight: 700;}</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值（不加粗）</td></tr><tr><td>bold</td><td>定义粗体（加粗）</td></tr><tr><td>100-900</td><td>400 等价于 normal，700 等价于 bold，无单位</td></tr></tbody></table><h3 id="1-4-文字样式"><a href="#1-4-文字样式" class="headerlink" title="1.4 文字样式"></a>1.4 文字样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本风格。</p><pre class="line-numbers language-none"><code class="language-none">p { font-style: italic; }</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常显示</td></tr><tr><td>italic</td><td>斜体</td></tr></tbody></table><p><strong>注意：</strong><br>平常很少给字体加斜体，而是给斜体标签（<code>em</code>,<code>i</code>）改为不倾斜字体。</p><h3 id="1-5-字体复合属性写法"><a href="#1-5-字体复合属性写法" class="headerlink" title="1.5 字体复合属性写法"></a>1.5 字体复合属性写法</h3><p>将各种字体属性写在同一选择器下，节约代码。</p><p>规则：严格遵守顺序，且 <code>font-size</code> 和 <code>font-family</code> 必须有。</p><pre class="line-numbers language-none"><code class="language-none">body {  font: font-style font-weight font-size/line-hight font-family;}</code></pre><h3 id="1-6-字体属性总结"><a href="#1-6-字体属性总结" class="headerlink" title="1.6 字体属性总结"></a>1.6 字体属性总结</h3><table><thead><tr><th>字体属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>font-family</td><td>字体</td><td>按照团队约定来写</td></tr><tr><td>font-size</td><td>字号</td><td>单位是<code>px</code></td></tr><tr><td>font-weight</td><td>字体粗细</td><td>400=normal,700=bold</td></tr><tr><td>font-style</td><td>字体样式</td><td>italic，normal，常用 normal</td></tr><tr><td>font</td><td>属性连写</td><td>顺序不能变，字体和字号属性必须有</td></tr></tbody></table><h2 id="2-CSS-文本属性"><a href="#2-CSS-文本属性" class="headerlink" title="2. CSS 文本属性"></a>2. CSS 文本属性</h2><p>CSS text(文本)属性定义文本<strong>外观</strong>，比如颜色、对齐、装饰、缩进、行间距等。</p><h3 id="2-1-文本颜色"><a href="#2-1-文本颜色" class="headerlink" title="2.1 文本颜色"></a>2.1 文本颜色</h3><p><code>color</code> 属性定义文本颜色。</p><pre class="line-numbers language-none"><code class="language-none">div {  color: red;}</code></pre><table><thead><tr><th>表示颜色</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色值</td><td>red,green,pink</td></tr><tr><td>十六进制（常用)</td><td><code>#FF0000</code>，<code>#FF6600</code></td></tr><tr><td>RGB 代码</td><td>rgb(255,0,0)</td></tr></tbody></table><h3 id="2-2-装饰文本"><a href="#2-2-装饰文本" class="headerlink" title="2.2 装饰文本"></a>2.2 装饰文本</h3><p><code>text-decoration</code> 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><pre class="line-numbers language-none"><code class="language-none">text-decoration: underline;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，无装饰（最常用）</td></tr><tr><td>underline</td><td>下划线，a 标签自带（常用）</td></tr><tr><td>overline</td><td>上划线。（几乎不用）</td></tr><tr><td>line-through</td><td>删除线。（不常用）</td></tr></tbody></table><h3 id="2-3-对齐文本"><a href="#2-3-对齐文本" class="headerlink" title="2.3 对齐文本"></a>2.3 对齐文本</h3><p><code>text-align</code> 属性用于设置元素文本内容的对齐方式。</p><pre class="line-numbers language-none"><code class="language-none">div {  text-align: center;}</code></pre><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="2-4-文本缩进"><a href="#2-4-文本缩进" class="headerlink" title="2.4 文本缩进"></a>2.4 文本缩进</h3><p><code>text-indent</code>定义段落首行缩进。</p><pre class="line-numbers language-none"><code class="language-none">p {  text-indet: 5px;}</code></pre><p><code>em</code> 是一个相对单位，<code>1em</code> 就是一个字符所占大小。当 <code>text-indent=2em</code>，则恰好缩进两个文字。</p><h3 id="2-5-行高"><a href="#2-5-行高" class="headerlink" title="2.5 行高"></a>2.5 行高</h3><p><code>line-height</code> 设置行间的距离，行间距=文本高度+上间距+下间距</p><pre class="line-numbers language-none"><code class="language-none">p { line-height: 26px; }</code></pre><p><img src="a67be00ff20c43c69f6db5ac463be879.png" alt="在这里插入图片描述"></p><h4 id="2-5-1-单行文字垂直居中的小技巧"><a href="#2-5-1-单行文字垂直居中的小技巧" class="headerlink" title="2.5.1 单行文字垂直居中的小技巧"></a>2.5.1 单行文字垂直居中的小技巧</h4><p>CSS 没有给我们提供文字垂直居中的代码. 这里我们可以使用一个小技巧来实现。</p><ul><li><p>解决方案：让<strong>文字的行高等于盒子的高度</strong>。</p></li><li><p>原理分析：行高=文字本身高度+上空隙+下空隙=盒子高度</p></li><li><p>当行高小于盒子高度，则文字偏上；当行高大于盒子高度，文字偏下。</p></li></ul><h3 id="2-6-文本属性总结"><a href="#2-6-文本属性总结" class="headerlink" title="2.6 文本属性总结"></a>2.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常十六进制缩写</td></tr><tr><td>text-decoration</td><td>文本装饰</td><td>添加下划线underline，取消下划线none</td></tr><tr><td>text-align</td><td>文本对齐</td><td>可以设定文字水平的对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>通常用于段落首行缩进2个字的距离，记住 <code>text-indent: 2em;</code></td></tr><tr><td>line-height</td><td>行高</td><td>控制行与行之间的距离</td></tr></tbody></table><h2 id="3-CSS背景属性"><a href="#3-CSS背景属性" class="headerlink" title="3. CSS背景属性"></a>3. CSS背景属性</h2><p>CSS 背景属性可以给元素添加背景样式。</p><p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p><h3 id="3-1-背景颜色"><a href="#3-1-背景颜色" class="headerlink" title="3.1 背景颜色"></a>3.1 背景颜色</h3><p><code>background-color</code> 定义了元素的背景颜色。</p><pre class="line-numbers language-none"><code class="language-none">background-color: 颜色值;</code></pre><p>一般而言，颜色默认值是 <code>transparent</code>（透明），我们也可以指定背景颜色为透明色或其他色。</p><h4 id="3-1-1-背景色半透明"><a href="#3-1-1-背景色半透明" class="headerlink" title="3.1.1 背景色半透明"></a>3.1.1 背景色半透明</h4><p>CSS3 提供 <code>background: rgba(r,g,b,a)</code> 属性设置图片透明度。</p><pre class="line-numbers language-none"><code class="language-none">background-color: rgba(0, 0, 0, .3);</code></pre><p><strong>注意：</strong></p><ul><li>背景半透明是指盒子背景半透明，盒子里面的内容不受影响。</li></ul><h3 id="3-2-背景图片"><a href="#3-2-背景图片" class="headerlink" title="3.2 背景图片"></a>3.2 背景图片</h3><p><code>background-image</code> 属性描述了元素的背景图像，实际开发用于 logo 或者一些装饰性开发的小图片或者是超大的背景图片，优点是<strong>便于控制位置</strong>。（也用于精灵图）</p><pre class="line-numbers language-none"><code class="language-none">background-image: none（默认无背景图）|  url(图片url) （使用绝对或相对地址指定图片）;</code></pre><h3 id="3-3-背景平铺"><a href="#3-3-背景平铺" class="headerlink" title="3.3 背景平铺"></a>3.3 背景平铺</h3><p>若需要在 HTML 页面上对背景图进行平铺，可以使用 <code>background-repeat</code> 属性。</p><pre class="line-numbers language-none"><code class="language-none">background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y;</code></pre><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>repeat</td><td>背景图像在纵向和横向上平铺（默认）</td></tr><tr><td>no-repeat</td><td>背景图像不平铺</td></tr><tr><td>repeat-x</td><td>背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td>背景图像在纵向上平铺</td></tr></tbody></table><h3 id="3-4-背景图像固定"><a href="#3-4-背景图像固定" class="headerlink" title="3.4 背景图像固定"></a>3.4 背景图像固定</h3><p><code>background-attachment</code> 属性设置背景图像是否随着页面其余部分滚动。</p><p><code>background-attachment</code> 后期可以制作视差滚动效果。</p><pre class="line-numbers language-none"><code class="language-none">background-attachment: scroll | fixed;</code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>scroll</td><td>背景图像随着对象内容滚动</td></tr><tr><td>fixed</td><td>背景图像固定</td></tr></tbody></table><h3 id="3-5-背景图片位置"><a href="#3-5-背景图片位置" class="headerlink" title="3.5 背景图片位置"></a>3.5 背景图片位置</h3><p><code>background-position</code> 可以改变图片在背景中的位置。</p><pre class="line-numbers language-none"><code class="language-none">background-position: x y;</code></pre><p>参数代表的意思是：x 坐标和 y 坐标。 可以使用 <strong>方位名词</strong> 或者 <strong>精确单位</strong></p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>百分数 / 由浮点数字和单位字符组成的长度值</td></tr><tr><td>position</td><td>top / center / bottom / left / center / right 方位名词</td></tr></tbody></table><p><strong>1.参数是方位名词</strong></p><ul><li>若两个值都是方位名词，则两个值前后顺序无关，比如<code>left top</code>和<code>top left</code> 效果一致。</li><li>若只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐。</li></ul><p><strong>2.参数是精确单位</strong></p><ul><li>第一个必定是 x 坐标，第二个是 y 坐标</li><li>若只指定一个数值，那该值一定是x坐标，另一个默认垂直居中</li></ul><p><strong>3.参数是混合单位</strong></p><ul><li>若是混合单位，则第一个值是 x 坐标，第二个值是 y 坐标。</li></ul><h3 id="3-6-背景属性复合写法"><a href="#3-6-背景属性复合写法" class="headerlink" title="3.6 背景属性复合写法"></a>3.6 背景属性复合写法</h3><p>简化代码，将属性写在同一个属性 <code>background</code> 下。 </p><p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p><p><code>background：背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</code></p><pre class="line-numbers language-none"><code class="language-none">background: transparent url(image.jpg) repeat-y fixed top;</code></pre><h3 id="3-7-背景属性总结"><a href="#3-7-背景属性总结" class="headerlink" title="3.7 背景属性总结"></a>3.7 背景属性总结</h3><table><thead><tr><th>属性</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td>背景图片</td><td>url(图片路径)</td></tr><tr><td>background-repeat</td><td>背景平铺</td><td>repeat(默认)/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-attachment</td><td>背景固定</td><td>scroll/fixed</td></tr><tr><td>background-position</td><td>背景位置</td><td>x,y坐标</td></tr><tr><td>背景复合写法</td><td>简化书写</td><td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td></tr></tbody></table><h1 id="二、元素显示模式"><a href="#二、元素显示模式" class="headerlink" title="二、元素显示模式"></a>二、元素显示模式</h1><p>元素显示模式就是<strong>元素（标签）以什么方式进行显示</strong>，比如<code>&lt;div&gt;</code>自己占一行，比如一行可以放多个<code>span</code>。</p><h2 id="1-块元素"><a href="#1-块元素" class="headerlink" title="1. 块元素"></a>1. 块元素</h2><p>常见的块元素有 <code>h1-h6</code>、<code>p</code>、<code>div</code>、<code>ul</code>、<code>ol</code>、<code>li</code>等，典型块元素是 <code>div</code>。</p><p>块级元素的特点：</p><ol><li>独占一行。</li><li>高度、宽度、外边距以及内边距都可以控制。</li><li>宽度默认是容器（父级宽度）的 100%。</li><li>是一个容器及盒子，里面可以放行内或块级元素。</li></ol><p><strong>注意：</strong></p><ul><li>文字类的标签（主要用于存放文字）内不能放块级元素。</li><li>文字类标签有 <code>p</code>，<code>h1-h6</code>，里面不能放块级元素，特别不能放 <code>div</code> 元素。</li></ul><h2 id="2-行内元素"><a href="#2-行内元素" class="headerlink" title="2. 行内元素"></a>2. 行内元素</h2><p>常见行内元素：<code>a</code>、<code>strong</code>、<code>b</code>、<code>em</code>、<code>i</code>、<code>del</code>、<code>s</code>、<code>ins</code>、<code>u</code>、<code>span</code>，典型行内元素是 <code>span</code>，行内元素也叫内联元素。</p><p>行内元素的特点：</p><ol><li>相邻行内元素在一行上，<strong>之间存在空白缝隙</strong>，一行可以显示多个。</li><li><strong>高、宽直接设置是无效的</strong>。</li><li><strong>默认宽度就是它本身内容宽度</strong>。</li><li>行内元素只能容纳文本或其他行内元素。</li></ol><p><strong>注意</strong></p><ul><li><code>a</code> 链接里面不能放链接</li><li>特殊情况链接 <code>a</code> 里面可以放块级元素，但是给 <code>a</code> 转换一下块级模式最安全。</li></ul><h2 id="3-行内块元素"><a href="#3-行内块元素" class="headerlink" title="3. 行内块元素"></a>3. 行内块元素</h2><p>在行内元素中有几个特殊标签——<code>img</code>, <code>input</code>、<code>td</code>，它们同时具有块元素和行内元素的特点。有些资料称为行内块元素。</p><p><strong>特点：</strong></p><ol><li>和相邻行内元素（行内块）在一行上，之间存在空白缝隙，一行可以显示多个（<strong>行内元素特点</strong>）。</li><li>默认宽度是本身内容宽度（<strong>行内元素特点</strong>）。</li><li>高度、行高、外边距、内边距都可以控制（<strong>块级元素特点</strong>）。</li></ol><h2 id="4-元素显示模式转换"><a href="#4-元素显示模式转换" class="headerlink" title="4. 元素显示模式转换"></a>4. 元素显示模式转换</h2><p>特殊情况下，需要将一个元素的模式转换为另外一种模式，使其具有另外一种模式的特性。<br>比如想要增加链接 <code>a</code> 的触发范围。</p><ul><li>行内-&gt;块级</li></ul><pre class="line-numbers language-none"><code class="language-none">a {  display: block;}</code></pre><ul><li>块级-&gt;行内</li></ul><pre class="line-numbers language-none"><code class="language-none">div {  display: inline;}</code></pre><ul><li>行内/块级-&gt; 行内块元素</li></ul><pre class="line-numbers language-none"><code class="language-none">span {  display: inline-block;}</code></pre><h2 id="5-元素显示模式总结"><a href="#5-元素显示模式总结" class="headerlink" title="5. 元素显示模式总结"></a>5. 元素显示模式总结</h2><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置高度宽度</td><td>容器的 100%</td><td>可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以设置宽度高度</td><td>本身内容宽度</td><td>容纳文本或者其他行内元素</td></tr><tr><td>行内块元素</td><td>一行可以放置多个行内块元素</td><td>可以设置高度宽度</td><td>本身内容宽度</td><td></td></tr></tbody></table><h1 id="三、CSS-引用方式"><a href="#三、CSS-引用方式" class="headerlink" title="三、CSS 引用方式"></a>三、CSS 引用方式</h1><p>按照 CSS 书写的位置不同，CSS 样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h2 id="1-行内样式表"><a href="#1-行内样式表" class="headerlink" title="1. 行内样式表"></a>1. 行内样式表</h2><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式，适合修改简单样式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style="color: red; font-size: 12px"&gt;行内样式表&lt;/div&gt;</code></pre><h2 id="2-内部样式表"><a href="#2-内部样式表" class="headerlink" title="2. 内部样式表"></a>2. 内部样式表</h2><p>将 CSS 代码写在 HTML 页面内部，单独放在一个 <code>&lt;style&gt;</code> 标签中。</p><ul><li><code>&lt;style&gt;</code> 理论上可以放在 HTML 文档中任何一个地方，一般放在 <code>&lt;head&gt;</code> 标签中。</li><li>方便控制整个页面中的元素样式。</li></ul><p>练习时使用，实际开发不用。</p><h2 id="3-外部样式表"><a href="#3-外部样式表" class="headerlink" title="3. 外部样式表"></a>3. 外部样式表</h2><p>实际开发中都是外部样式表，适用于样式比较多的情况。<br>核心：样式单独写到 CSS 文件中，再将 CSS 文件引入到 HTML 页面中。</p><p><strong>引入外部样式表分为两步：</strong></p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 </li><li>在 HTML 页面中，使用 标签引入这个文件。<pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="css文件路径" /&gt;</code></pre></li></ol><ul><li>rel：定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个<strong>样式表文件</strong>。</li><li>href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</li></ul><h1 id="四、CSS三大特性"><a href="#四、CSS三大特性" class="headerlink" title="四、CSS三大特性"></a>四、CSS三大特性</h1><h2 id="1-层叠性"><a href="#1-层叠性" class="headerlink" title="1. 层叠性"></a>1. 层叠性</h2><p><strong>相同选择器设置相同的样式</strong>，此时一个样式就会覆盖另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p><em><strong>层叠性原则：</strong></em></p><ul><li>样式冲突：遵循的原则是<strong>就近原则</strong>，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><h2 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2. 继承性"></a>2. 继承性</h2><p>CSS 中子标签会继承父标签的某些样式，如文本颜色和字号。</p><ul><li>恰当使用继承可以简化代码，降低 CSS 的复杂性</li><li>子元素可以继承父元素的样式（<strong>text-, font-, line-这些元素开头的可以继承，以及 color 属性</strong>）</li><li>不继承width、height、内外边距</li></ul><h3 id="2-1-行高的继承性"><a href="#2-1-行高的继承性" class="headerlink" title="2.1 行高的继承性"></a>2.1 行高的继承性</h3><pre class="line-numbers language-none"><code class="language-none">body {  font: 12px/1.5 Microsoft Yahei;}</code></pre><ul><li>行高可以跟单位也可以不跟</li><li>如果子元素没有设置行高，则会继承父元素的行高为 1.5</li><li>此时子元素的行高是：当前<strong>子元素的文字大小<code>*1.5</code></strong></li><li>body 行高 1.5 这样写法最大优势就是里面的子元素<strong>可以根据文字大小自动调整行高</strong></li></ul><h2 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3. 优先级"></a>3. 优先级</h2><p>当一个元素指定多个选择器时，就会有有优先级的产生。</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，则根据选择器权重执行</li></ul><p><strong>选择器权重：</strong></p><p>important&gt;style=””&gt;id&gt;伪类&gt;class&gt;元素&gt;<code>*</code>&gt;浏览器&gt;继承</p><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承或者<code>*</code></td><td><code>0,0,0,0</code></td></tr><tr><td>元素选择器</td><td><code>0,0,0,1</code></td></tr><tr><td>类选择器，伪类选择器</td><td><code>0,0,1,0</code></td></tr><tr><td>id 选择器</td><td><code>0,1,0,0</code></td></tr><tr><td>行内样式 <code>style=""</code></td><td><code>1,0,0,0</code></td></tr><tr><td><code>!important</code></td><td>∞ 无穷大</td></tr><tr><td><code>!important</code>写法：</td><td></td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">p {  color: pink !important;}</code></pre><ul><li>权重是有4组数字组成，但是不会有进位。可以理解为类选择器永远大于元素选择器，以此类推..</li><li><strong>继承的权重为 0</strong>，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。</li><li><code>a</code> 链接，浏览器默认指定了一个样式（蓝色，下划线），不会继承父级样式。</li></ul><p><strong>复合选择器权重的叠加</strong></p><p>权重可以叠加，需要计算权重，但是没有进位。</p><ul><li>div ul li ——&gt; 0,0,0,3 </li><li>.nav ul li ——&gt; 0,0,1,2 </li><li>a:hover —–—&gt; 0,0,1,1 </li><li>.nav a ——&gt; 0,0,1,1</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS简介与选择器</title>
      <link href="/2022/12/15/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2022/12/15/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS-简介"><a href="#一、CSS-简介" class="headerlink" title="一、CSS 简介"></a>一、CSS 简介</h1><h2 id="1-CSS-和-HTML"><a href="#1-CSS-和-HTML" class="headerlink" title="1. CSS 和 HTML"></a>1. CSS 和 HTML</h2><pre class="line-numbers language-none"><code class="language-none">HTML 是网友的骨架，只关注内容的语义。例如`&lt;h1&gt;`表示大标题，`&lt;p&gt;`表示段落。早期的时候，HTML 只能做一些简单的样式，网页非常丑，而且使 HTML 代码臃肿。</code></pre><pre class="line-numbers language-none"><code class="language-none">CSS 是 层叠样式表（Cascading Style Sheets）的简称。它也是一种标记语言。CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</code></pre><p><em><strong>CSS 最大价值:</strong></em> 由 HTML 专注去做结构呈现，样式交给 CSS，即<strong>结构 ( HTML ) 与样式( CSS )</strong> 相分离。</p><h2 id="2-CSS-语法规范"><a href="#2-CSS-语法规范" class="headerlink" title="2. CSS 语法规范"></a>2. CSS 语法规范</h2><p><strong>CSS 规则由两个部分组成：选择器和一条或多条声明。</strong></p><p><img src="bde5b4c3556b40e59a58f8d4222e9530.png"></p><ul><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式 </li><li>属性和属性值以<code>键值对</code>的形式出现 </li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等 </li><li>属性和属性值之间用英文<code>:</code>分开 </li><li>多个“键值对”之间用英文<code>;</code>进行区分</li></ul><p>所有的样式，都包含在<code>&lt;style&gt;</code>标签内，表示是样式表。</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;p {color: red;font-size: 12px;}&lt;/style&gt;</code></pre><h2 id="3-CSS-代码风格"><a href="#3-CSS-代码风格" class="headerlink" title="3. CSS 代码风格"></a>3. CSS 代码风格</h2><p>以下代码书写风格不是强制规范,而是符合实际开发书写方式。</p><ul><li>展开格式（分行）<pre class="line-numbers language-none"><code class="language-none">h3 { color: pink;font-size: 20px; }</code></pre></li><li>空格规范（选择器和大括号中间保留空格；冒号后面保留一个空格）<pre class="line-numbers language-none"><code class="language-none">h3 {color: pink; }</code></pre></li><li>样式选择器，属性名，属性关键字全部<strong>小写</strong></li></ul><h2 id="5-emmet-语法"><a href="#5-emmet-语法" class="headerlink" title="5. emmet 语法"></a>5. emmet 语法</h2><h3 id="5-1-快速生成-HTML-结构语法"><a href="#5-1-快速生成-HTML-结构语法" class="headerlink" title="5.1 快速生成 HTML 结构语法"></a>5.1 快速生成 HTML 结构语法</h3><ol><li>生成标签：直接输入标签名，按tab键即可。如：div 然后tab 键， 就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></li><li>生成多个相同标签：加上 <code>*</code> 。如：<code>div*3</code> 可以快速生成3个<code>&lt;div&gt;&lt;/div&gt;</code></li><li>生成父子级关系的标签：用 <code>&gt;</code> 。如： <code>ul&gt;li</code></li><li>生成兄弟关系的标签：用 <code>+</code> 。 如： <code>div+p</code> </li><li>生成带有类名或者id名字的标签： 直接写 <code>.demo</code> 或者 <code>#two</code>，再按 tab 键</li><li>生成的标签名称/内容按1、2…顺序：用 自增符号 <code>$</code></li><li>在生成的标签内部写内容：用 <code>{}</code> 表示</li></ol><h3 id="5-2-快速生成-CSS-样式语法"><a href="#5-2-快速生成-CSS-样式语法" class="headerlink" title="5.2 快速生成 CSS 样式语法"></a>5.2 快速生成 CSS 样式语法</h3><p>CSS 基本采取简写形式即可。</p><ol><li>比如 w200 按 tab 可以生成 width: 200px。</li><li>比如 lh26px 按 tab 可以生成 line-height: 26px。</li></ol><h1 id="二、CSS-基础选择器"><a href="#二、CSS-基础选择器" class="headerlink" title="二、CSS 基础选择器"></a>二、CSS 基础选择器</h1><p>选择器就是根据不同需求把不同标签选择出来。简单来说，就是<em><strong>用于选择标签</strong></em>的。</p><p>选择器分为<strong>基础选择器</strong>和<strong>复合选择器</strong>两大类。</p><ul><li>基础选择器由单个选择器组成</li><li>基础选择器包括：标签选择器、类选择器、id 选择器和通配符选择器</li></ul><h2 id="1-标签选择器"><a href="#1-标签选择器" class="headerlink" title="1. 标签选择器"></a>1. 标签选择器</h2><p>直接用 <strong>HTML 标签名</strong>作为选择器，按标签名称分类，<strong>为页面某一类标签指定统一的 CSS 样式。</strong></p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">标签名 {    属性1： 属性值1;    属性2： 属性值2;    属性3： 属性值3;}</code></pre><p>优点：标签选择器可以<strong>把某一标签全部选择出来</strong>，快速为同类型标签设置统一样式。</p><p>缺点：<strong>不能设置差异化样式</strong>，只能选择全部当前标签。</p><h2 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2. 类选择器"></a>2. 类选择器</h2><p>差异化选择不同标签，<strong>单独选一个或者某几个</strong>标签。</p><p><strong>语法</strong></p><p>类选择器在 HTML 中以 <code>class</code> 属性表示，在 CSS 中，类选择器以一个 <code>.</code> 号显示。</p><pre class="line-numbers language-none"><code class="language-none">.类名 { 属性1: 属性值1; ... }</code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;div class="类名"&gt; &lt;/div&gt;</code></pre><p><em>记忆口诀：</em><br>样式<code>点</code>定义，结构<code>类</code>调用。一个或多个，开发最常用。</p><p><strong>注意</strong></p><ol><li>类选择器用 <code>.</code> 标识，后面紧跟类名。</li><li>类名小写，长名称或词组使用 <code>-</code> 连接单词。不要用纯数字、中文。</li><li>命名要有意义。</li></ol><h3 id="2-1-多类名"><a href="#2-1-多类名" class="headerlink" title="2.1 多类名"></a>2.1 多类名</h3><p>简单来说，就是一个标签有多个名字。</p><p><strong>使用场景：</strong></p><ul><li>一些标签元素具有相同的样式(共同的部分)，多类名可以把他们放到一个类里面。</li><li>这些标签都可以调用这个公共的类,然后再调用自己独有的类。</li><li>从而节省CSS代码,统一修改也非常方便。<pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;.box {width: 150px;height: 100px;}.red {background-color: red;}.green {background-color: green;}&lt;/style&gt;&lt;body&gt;&lt;div class="box red"&gt;红色&lt;/div&gt;&lt;div class="box green"&gt;绿色&lt;/div&gt;&lt;/body&gt;</code></pre></li></ul><p><strong>语法</strong></p><p>在标签class中书写多个类名，类名间用空格分开</p><pre class="line-numbers language-none"><code class="language-none">&lt;p class="class-name1 class-name2"&gt;&lt;/p&gt;</code></pre><h2 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3. id选择器"></a>3. id选择器</h2><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p><strong>语法</strong></p><p>HTML 元素以 <code>id</code> 属性来设置 id 选择器，用 <code>#</code> 来定义。</p><pre class="line-numbers language-none"><code class="language-none">#id名 {    属性1: 属性值1;    ...}&lt;div id="id名"&gt; &lt;/div&gt;</code></pre><p><em>记忆口诀：</em><br>样式 <code>#</code> 定义，结构 <code>id</code> 调用，别人切勿使用。</p><p><em><strong>id 选择器与类选择器的区别</strong></em></p><ol><li>class 类选择器好比<strong>名字</strong>，一个人可以有多个名字，同时一个名字也可以被多个人使用。（一对多，多对一）</li><li>id 选择器好比<strong>身份证号码</strong>，每个人对应唯一的一个号码，不得重复。（一一配对）</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h2 id="4-通配符选择器"><a href="#4-通配符选择器" class="headerlink" title="4. 通配符选择器"></a>4. 通配符选择器</h2><p>在 CSS 中，通配符选择器使用 <code>*</code> 定义，它表示选取页面中所有元素（标签）。</p><pre class="line-numbers language-none"><code class="language-none">* {    属性1: 属性值1;    ...}</code></pre><p><strong>特殊情况（常见）使用：</strong></p><pre class="line-numbers language-none"><code class="language-none">* {    margin: 0;    padding: 0;}</code></pre><h2 id="5-基础选择器总结"><a href="#5-基础选择器总结" class="headerlink" title="5. 基础选择器总结"></a>5. 基础选择器总结</h2><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>选中所有相同标签</td><td>不能差异化选择</td><td>较多</td><td><code>p{color:red;}</code></td></tr><tr><td>类选择器</td><td>选出一个或多个标签</td><td>可以根据需求选择</td><td>最多</td><td><code>.nav {color: red;}</code></td></tr><tr><td>id选择器</td><td>一次只能选中一个标签</td><td>一一配对</td><td>一般配合js使用</td><td><code>#nav {color: red;}</code></td></tr><tr><td>通配符选择器</td><td>选择所有标签元素</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td><code>* {color: red; }</code></td></tr></tbody></table><h1 id="三、CSS-复合选择器"><a href="#三、CSS-复合选择器" class="headerlink" title="三、CSS 复合选择器"></a>三、CSS 复合选择器</h1><p>复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。</p><p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等</p><h2 id="1-后代选择器（重要）"><a href="#1-后代选择器（重要）" class="headerlink" title="1. 后代选择器（重要）"></a>1. 后代选择器（重要）</h2><p>后代选择器又称为包含选择器，可以<strong>选择父元素里的子元素</strong>。写法是将外层标签写在前面，内层标签写在后面，中间空格分开。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1 元素2 { 样式声明; }</code></pre><ul><li>上述语法表示选择元素1里面的所有元素2（后代元素）。</li><li>元素2可以是儿子，也可以是孙子等，只要是<strong>元素1的后代</strong>即可。</li><li>元素1 是父级，元素2 是子级，<strong>最终选择的是元素2</strong></li></ul><h2 id="2-子选择器（重要）"><a href="#2-子选择器（重要）" class="headerlink" title="2. 子选择器（重要）"></a>2. 子选择器（重要）</h2><p>子元素选择器（子选择器）只能选择作为元素作为元素的最近一级子元素。简单理解就是<strong>选亲儿子</strong>。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1 &gt; 元素2 { 样式声明; }</code></pre><ul><li>上述语法表示选择元素1里面的所有直接后代（子元素）元素2。</li><li>元素2必须是<strong>亲儿子</strong>，其孙子、重孙之类都不归他管。</li><li>元素1是父级，元素2是子级，<strong>最终选择的是元素2</strong></li></ul><h2 id="3-并集选择器（重要）"><a href="#3-并集选择器（重要）" class="headerlink" title="3. 并集选择器（重要）"></a>3. 并集选择器（重要）</h2><p>并集选择器可以<strong>选择多组标签</strong>，同时为他们<strong>定义相同的样式</strong>。通常用于集体声明。</p><p>并集选择器是各选择器通过英文逗号 <code>,</code> 连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p><p><strong>语法</strong></p><pre class="line-numbers language-none"><code class="language-none">元素1, 元素2 { 样式声明; }</code></pre><h2 id="4-伪类选择器（重要）"><a href="#4-伪类选择器（重要）" class="headerlink" title="4. 伪类选择器（重要）"></a>4. 伪类选择器（重要）</h2><p>伪类选择器用于向某些选择器添加特殊的效果。<br>伪类选择器书写最大特点是用冒号 <code>:</code> 表示。<br>伪类选择器种类多，比如链接伪类选择器、结构选择器等。</p><h3 id="4-1-链接伪类选择器"><a href="#4-1-链接伪类选择器" class="headerlink" title="4.1 链接伪类选择器"></a>4.1 链接伪类选择器</h3><pre class="line-numbers language-none"><code class="language-none">a:link /*选择所有未被访问的链接*/a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/a:active /*选择活动链接（鼠标按下未弹起的链接）*/</code></pre><p><strong>注意事项</strong></p><ol><li>确保样式生效，要按照 <strong>LVHA</strong> 的顺序声明：link,visited,hover, active。</li><li>a 链接在浏览器中有默认样式，所以实际开发都需要给链接单独指定样式。</li></ol><h3 id="4-2-focus-伪类选择器"><a href="#4-2-focus-伪类选择器" class="headerlink" title="4.2 focus 伪类选择器"></a>4.2 focus 伪类选择器</h3><p><code>:focus</code> 伪类选择器用于获取焦点的表单元素。<br>焦点就是光标，一般情况 <code>&lt;input&gt;</code> 类表单元素才能获取，因此这个选择器也主要针对表单元素来说。</p><pre class="line-numbers language-none"><code class="language-none">input:focus {  background-color: yellow;}</code></pre><h3 id="4-3-其他标准伪类选择器"><a href="#4-3-其他标准伪类选择器" class="headerlink" title="4.3 其他标准伪类选择器"></a>4.3 其他标准伪类选择器</h3><p>1.<code>first-child</code>、<code>last-child</code>、<code>nth-child(n)</code></p><ul><li><code>:first-child</code>表示父元素的第一个子元素。</li><li><code>:last-child</code>表示父元素的最后一个子元素。</li><li><code>:nth-child(an+b)</code> 首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从 1 开始排序，选择的结果为 CSS 伪类 <code>:nth-child</code>括号中表达式 <code>(an+b)</code> 匹配到的元素集合 <code>(n=0，1，2，3...)</code></li></ul><ol start="2"><li><p><code>:not(p)</code><br><code>:not()</code> 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negation pseudo-class）。</p></li><li><p><code>::after (:after)</code><br><code>::after</code> 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合 <code>content</code> 属性（必有该字段）来为该元素添加装饰内容。这个虚拟元素默认是行内元素。</p></li></ol><pre class="line-numbers language-none"><code class="language-none">.sad::after {·content: "";  background-color: green;}</code></pre><ol start="4"><li><code>::before (:before)</code><br><code>::before</code> 用来创建一个伪元素，作为已选中元素的第一个子元素。通常会配合 <code>content</code> 属性（必有该字段）来为该元素添加装饰内容。这个虚拟元素默认是行内元素。 使用 <code>::before</code> 伪元素的一个简单示例就是用于加入引号。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;q&gt;一些引用&lt;/q&gt;, 他说, &lt;q&gt;比没有好。&lt;/q&gt;.q::before {content: "«";color: blue;}q::after {content: "»";color: red;}</code></pre><h2 id="5-复合选择器总结"><a href="#5-复合选择器总结" class="headerlink" title="5. 复合选择器总结"></a>5. 复合选择器总结</h2><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择后代元素</td><td>可以是子孙后代</td><td>较多</td><td>符号是空格 <code>.nav a</code></td></tr><tr><td>子选择器</td><td>选择最近一级元素</td><td>只能选亲儿子</td><td>较少</td><td>符号是大于 <code>.nav&gt;p</code></td></tr><tr><td>并集选择器</td><td>选择某些相同样式的元素</td><td>可以用于集体声明</td><td>较多</td><td>符号是逗号，<code>.nav, a</code></td></tr><tr><td>链接伪类选择器</td><td>选择不同状态的链接</td><td>跟链接相关</td><td>较多</td><td>重点记住<code>a{}</code>和<code>a:hover{}</code></td></tr><tr><td>focus选择器</td><td>选择获得光标的表单</td><td>跟表单相关</td><td>较少</td><td>记住<code>input:focus</code>用法</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/2022/12/11/HTML%E6%A0%87%E7%AD%BE/"/>
      <url>/2022/12/11/HTML%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-HTML预备知识"><a href="#一、-HTML预备知识" class="headerlink" title="一、 HTML预备知识"></a>一、 HTML预备知识</h1><h2 id="1-基本语法规范"><a href="#1-基本语法规范" class="headerlink" title="1.  基本语法规范"></a>1.  基本语法规范</h2><ol><li>HTML 标签是由尖括号包围的关键词，例如<code>&lt;html&gt;</code>。 </li><li>双标签：HTML 标签通常是成对出现的，例如<code>&lt;html&gt;</code>和<code>&lt;html/&gt;</code>，称为双标签。第一个是开始标签，第二个是结束标签。</li><li>单标签：有些特殊标签必须是单个标签（极少情况），例如<code>&lt;br/&gt;</code>，我们称之为单标签。</li><li>标签关系：包含关系和并列关系。</li></ol><h2 id="2-基本结构标签"><a href="#2-基本结构标签" class="headerlink" title="2. 基本结构标签"></a>2. 基本结构标签</h2><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p><table><thead><tr><th align="center">标签名</th><th align="center">定义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">html /html</td><td align="center">HTML标签</td><td align="center">页面中最大的标签，称为根标签</td></tr><tr><td align="center">head /head</td><td align="center">文档的头部</td><td align="center">注意在head标签中必须要设置的是title</td></tr><tr><td align="center">title /title</td><td align="center">文档的标题</td><td align="center">让页面拥有一个属于自己的网页标题</td></tr><tr><td align="center">body /body</td><td align="center">文档的主体</td><td align="center">元素包含文档的所有内容，页面内容基本放于此</td></tr></tbody></table><p><img src="Pasted%20image%2020221206150125.png"></p><h2 id="3-VSCode-工具生成骨架标签新增代码"><a href="#3-VSCode-工具生成骨架标签新增代码" class="headerlink" title="3. VSCode 工具生成骨架标签新增代码"></a>3. VSCode 工具生成骨架标签新增代码</h2><h3 id="3-1-文档类型声明标签"><a href="#3-1-文档类型声明标签" class="headerlink" title="3.1 文档类型声明标签"></a>3.1 文档类型声明标签</h3><p><code>!&lt;DOCTYPE&gt;</code>&nbsp;文档类型声明，告诉浏览器使用何种 HTML 版本来显示网页。</p><pre><code>&lt;!DOCTYPE html&gt;</code></pre><p>此代码表明：当前页面采用的是 HTML5 版本来显示网页。</p><p><strong>注意：</strong></p><ol><li><code>&lt;!DOCTYPE&gt;</code>&nbsp;声明位于文档最前面的位置，处于<code>&lt;html&gt;</code>标签之前。</li><li><code>&lt;!DOCTYPE&gt;</code>&nbsp;不是一个 HTML 标签，他就是文档类型声明标签。</li></ol><h3 id="3-2-lang-语言种类"><a href="#3-2-lang-语言种类" class="headerlink" title="3.2 lang 语言种类"></a>3.2 lang 语言种类</h3><p>用来显示当前文档显示的语言。</p><pre><code>&lt;html lang="zh-CN"&gt;    &lt;html lang="en"&gt;&lt;/html&gt; &lt;/html&gt;</code></pre><ol><li><code>en</code>&nbsp;定义语言为英文。</li><li><code>zh-CN</code>&nbsp;定义语言为中文。</li></ol><h3 id="3-3-charset-字符集"><a href="#3-3-charset-字符集" class="headerlink" title="3.3 charset 字符集"></a>3.3 charset 字符集</h3><pre><code>&lt;meta charset="UTF-8" /&gt;</code></pre><p>字符集（character set）是多个字符的集合，以便计算机能够识别和存储各种文字。</p><p>在<code>&lt;head&gt;</code>标签内，可以通过<code>&lt;meta&gt;</code>标签的<code>charset</code>&nbsp;属性来设置文档使用何种字符编码。</p><p><code>charset</code>常用的值有：GBK、UTF-8，其中UTF-8被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><hr><h1 id="二、HTML基础标签"><a href="#二、HTML基础标签" class="headerlink" title="二、HTML基础标签"></a>二、HTML基础标签</h1><h2 id="1-标题标签"><a href="#1-标题标签" class="headerlink" title="1. 标题标签"></a>1. 标题标签</h2><p>为了使网页具有语义化，经常使用标题标签，HTML 提供 6 个等级的网页标题标签即&nbsp;<code>&lt;h1&gt;-&lt;h6&gt;</code>。</p><p><strong>特点：</strong></p><ol><li>加了标题的文字会<strong>加粗</strong>，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;h1&gt;标题标签&lt;/h1&gt;&lt;h1&gt;标题一共六级选,&lt;/h1&gt;&lt;h2&gt;文字加粗一行显。&lt;/h2&gt;&lt;h3&gt;由大到小依次减，&lt;/h3&gt;&lt;h4&gt;从重到轻随之变。&lt;/h4&gt;&lt;h5&gt;语法规范书写后，&lt;/h5&gt;&lt;h6&gt;具体效果刷新见。&lt;/h6&gt;</code></pre><h2 id="2-段落和换行标签"><a href="#2-段落和换行标签" class="headerlink" title="2. 段落和换行标签"></a>2. 段落和换行标签</h2><ul><li>在 html 中，<code>&lt;p&gt;</code>&nbsp;标签用于定义段落，将整个网页分成若干个段落。</li></ul><blockquote><p><code>p</code>&nbsp;指<strong>paragraph</strong>，意为段落。把文字有条理的显示出来就需要将文字分段显示。</p></blockquote><p>**特点：</p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。 </li><li>段落和段落之间保有空隙。</li></ol><ul><li>在 html 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望 某段文本强制换行显示，就需要使用换行标签 <code>&lt;br/&gt;</code>。</li></ul><blockquote><p><code>&lt;br/&gt;</code>&nbsp;是 break 缩写，意为打断、换行。</p></blockquote><p><strong>特点：</strong></p><ol><li><code>&lt;br/&gt;</code>&nbsp;是个单标签。</li><li><code>&lt;br/&gt;</code>&nbsp;标签只是简单地开始新的一行，跟段落不一样，<em><strong>段落之间会插入一些垂直的间距</strong></em>。</li></ol><p><img src="Pasted%20image%2020221206154311.png"></p><h2 id="3-文本格式化标签"><a href="#3-文本格式化标签" class="headerlink" title="3. 文本格式化标签"></a>3. 文本格式化标签</h2><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code></td><td>更推荐<code>&lt;strong&gt;</code>，语义更强烈</td></tr><tr><td>斜体</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code></td><td>更推荐使用<code>&lt;em&gt;</code>，语义更强烈</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;s/&gt;</code></td><td>更推荐使用<code>&lt;del&gt;</code>，语义更强烈</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code></td><td>更推荐使用<code>&lt;ins&gt;</code>，语义更强烈</td></tr></tbody></table><h2 id="4-注释和特殊字符号"><a href="#4-注释和特殊字符号" class="headerlink" title="4.注释和特殊字符号"></a>4.注释和特殊字符号</h2><ol><li><p>注释:&nbsp;<code>&lt;!--注释--&gt;</code>&nbsp;VSCode 中快捷键：Ctrk + /</p></li><li><p>字符实体</p></li></ol><table><thead><tr><th>字符</th><th>显示</th></tr></thead><tbody><tr><td><code>&amp;nbsp;</code></td><td>空格</td></tr><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr><tr><td><code>&amp;copy;</code></td><td>©</td></tr><tr><td>补充：（使用较少，按需查阅）</td><td></td></tr></tbody></table><p><img src="Pasted%20image%2020221206161316.png"></p><h2 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5. 超链接标签"></a>5. 超链接标签</h2><h3 id="5-1-链接的语法格式"><a href="#5-1-链接的语法格式" class="headerlink" title="5.1 链接的语法格式"></a>5.1 链接的语法格式</h3><p>a 是单词 anchor 的简写，是锚的意思。</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt;</code></pre><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>指定链接地址 url，为必须属性。</td></tr><tr><td><code>target</code></td><td>指定页面打开方式，<code>_self</code>为默认值，<code>_blank</code>为在新窗口中打开</td></tr></tbody></table><h3 id="5-2-链接分类"><a href="#5-2-链接分类" class="headerlink" title="5.2 链接分类"></a>5.2 链接分类</h3><ol><li>外部链接：例如 <code>&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;</code>。 </li><li>内部链接：网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href="index.html"&gt;首页&lt;/a&gt;</code>。 </li><li>空链接：<code>#</code></li><li>下载链接：地址链接的是文件.exe、压缩包.zip 等。<code>&lt;a href="img.zip"&gt;下载文件&lt;/a&gt;</code></li><li>网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接。<code>&lt;a href="http://www.baidu.com"&gt;&lt;img src="img.jpg"/&gt;&lt;/a&gt;</code></li><li>**锚点链接：点击链接，可以快速定位到页面中的某个位置。<ul><li>在链接文本的 href 属性中，设置属性值为<code> #名字</code> 的形式，如：<code>&lt;a href="#two"&gt;第二季&lt;/a&gt;</code>。</li><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id="two"&gt;第二季介绍&lt;/h3&gt;</code></li></ul></li></ol><h2 id="6-图像标签和路径"><a href="#6-图像标签和路径" class="headerlink" title="6. 图像标签和路径"></a>6. 图像标签和路径</h2><h3 id="6-1-图像标签"><a href="#6-1-图像标签" class="headerlink" title="6.1 图像标签"></a>6.1 图像标签</h3><p>在 HTML 标签中，<code>&lt;img /&gt;</code>&nbsp;标签用于定义 HTML 标签页面中的图像。</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src="图像url" /&gt;</code></pre><p><strong>标签内属性</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，当图片不显示时显示文字</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本。鼠标放到图像上显示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>图像宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>图像高度</td></tr><tr><td><code>border</code></td><td>像素</td><td>图像边框粗细</td></tr><tr><td>图像标签属性注意点：</td><td></td><td></td></tr></tbody></table><ol><li>图像标签可以拥有多个属性，必须写在标签名称的后面。 </li><li>属性之间不分先后顺序，标签名称与属性、属性与属性之间均以<strong>空格</strong>分开。 </li><li>属性采取键值对的格式，即 key=“value” 的格式，属性 =“属性值”。</li></ol><h3 id="6-2-路径"><a href="#6-2-路径" class="headerlink" title="6.2 路径"></a>6.2 路径</h3><ul><li><strong>相对路径：</strong>&nbsp;以引用文件位置为参考基础，而建立出来的目录路径。是<em><strong>图片相对于 HTML 页面的位置</strong></em>。</li></ul><table><thead><tr><th>分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同级路径</td><td></td><td>同一级</td></tr><tr><td>下一级路径</td><td><code>/</code></td><td>图像文件位于HTML文件下一级</td></tr><tr><td>上一级路径</td><td><code>../</code></td><td>图像文件位于HTML文件上一级</td></tr></tbody></table><ul><li><strong>绝对路径：</strong>&nbsp;是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径或者完整的网络地址。</li></ul><blockquote><p>例如，<code>D:\web\img\logo.gif</code>或完整的网络地址“<a href="http://www.itcast.cn/images/logo.gif%E2%80%9D%E3%80%82">http://www.itcast.cn/images/logo.gif”。</a></p></blockquote><h2 id="7-div-和-span-标签"><a href="#7-div-和-span-标签" class="headerlink" title="7. div 和 span 标签"></a>7. div 和 span 标签</h2><p><code>&lt;div&gt;</code>&nbsp;和&nbsp;<code>&lt;span&gt;</code>&nbsp;是没有语义的，它们是一个盒子，用来装内容的。</p><blockquote><p>div 是 division 的缩写，表示分割、分区。span 意思是跨度、跨距。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;这是头部&lt;/div&gt;&lt;span&gt;今日价格&lt;/span&gt;</code></pre><p>特点：</p><ol><li><p>div 标签用来布局，一行只能放一个 div大盒子。</p></li><li><p>span 标签用来布局，一行可以多个 span小盒子。</p></li></ol><h1 id="三、HTML高阶标签"><a href="#三、HTML高阶标签" class="headerlink" title="三、HTML高阶标签"></a>三、HTML高阶标签</h1><h2 id="1-表格标签"><a href="#1-表格标签" class="headerlink" title="1. 表格标签"></a>1. 表格标签</h2><h3 id="1-1-表格的基本语法"><a href="#1-1-表格的基本语法" class="headerlink" title="1.1 表格的基本语法"></a>1.1 表格的基本语法</h3><ol><li><code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;用于定义表格的标签。</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;标签用于定义表格中的行，必须嵌套在&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>中。</li><li><code>&lt;th&gt;&lt;/th&gt;</code>（table head）&nbsp;标签用于定义表格的表头部分，必须嵌套在&nbsp;<code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;中。常用于表格第一行，突出重要性，表头单元格里面的文字会<strong>加粗居中</strong>显示。</li><li><code>&lt;td&gt;&lt;/td&gt;</code>&nbsp;（table data）标签用于定义表格中的单元格，必须嵌套在&nbsp;<code>&lt;tr&gt;&lt;/tr&gt;</code>&nbsp;中。</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table&gt;&lt;tr&gt;&lt;th&gt;表头名称&lt;/th&gt;...&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单元格内的文字&lt;/td&gt;...&lt;/tr&gt;...&lt;/table&gt;</code></pre><h3 id="1-2-表格属性"><a href="#1-2-表格属性" class="headerlink" title="1.2 表格属性"></a>1.2 表格属性</h3><p>只作了解，后期通过 CSS 来设置。 这些属性都要写到&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;标签中</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>align</code></td><td>left、center、right</td><td>表格元素对齐方式</td></tr><tr><td><code>border</code></td><td>1或””</td><td>规定是否有边框，默认为<code>""</code>，表示没有边框</td></tr><tr><td><code>cellpadding</code></td><td>像素值</td><td>规定单元边沿与其内容之间空白，默认1px</td></tr><tr><td><code>cellspacing</code></td><td>像素值</td><td>规定单元格之间的空白，默认为2px</td></tr><tr><td><code>width</code></td><td>像素值或百分比</td><td>规定表格宽度</td></tr><tr><td><code>hight</code></td><td>像素值或百分比</td><td>规定表格高度</td></tr></tbody></table><h3 id="1-3-表格结构标签"><a href="#1-3-表格结构标签" class="headerlink" title="1.3 表格结构标签"></a>1.3 表格结构标签</h3><p>场景：表格可能很长，将表格分割为表格头部和表格主题两大部分。</p><p><code>&lt;thead&gt;</code>&nbsp;表示头部区域，<code>&lt;tbody&gt;</code>&nbsp;表示主体区域，更好区分表格结构。</p><p>注意：</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：定义表格头部，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：定义表格主体，存放数据，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li>以上标签都放在&nbsp;<code>&lt;table&gt;&lt;/table&gt;</code>&nbsp;里面。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;表头名称&lt;/th&gt;...&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单元格内的文字&lt;/td&gt;&lt;/tr&gt;...&lt;/tbody&gt;</code></pre><h3 id="1-4-合并单元格"><a href="#1-4-合并单元格" class="headerlink" title="1.4 合并单元格"></a>1.4 合并单元格</h3><ul><li>跨行合并：rowspan=”合并单元格个数”</li><li>跨列合并：colspan=”合并单元格个数”</li></ul><p>合并三部曲：</p><ol><li>确定跨行 or 跨列。</li><li>找到目标单元格：跨行取最上面为目标单元格，跨列取最左边为目标单元格。<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code></li><li>删除多余单元格。</li></ol><h2 id="2-列表标签"><a href="#2-列表标签" class="headerlink" title="2. 列表标签"></a>2. 列表标签</h2><h3 id="2-1-无序列表"><a href="#2-1-无序列表" class="headerlink" title="2.1 无序列表"></a>2.1 无序列表</h3><p><code>&lt;ul&gt;</code>&nbsp;标签标识 HTML 页面项目中的无序列表，一般以项目符号呈现列表项，而列表项使用<code>&lt;li&gt;</code>标签定义。</p><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt;</code></pre><p>注意：</p><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能包含<code>&lt;li&gt;&lt;/li&gt;</code>，写入其他标签或文字是不允许的。</li><li><code>&lt;li&gt;&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</li><li>无序列表带有自己的属性，可用 CSS 修改样式属性。</li></ol><h3 id="2-2-有序列表"><a href="#2-2-有序列表" class="headerlink" title="2.2 有序列表"></a>2.2 有序列表</h3><p>使用&nbsp;<code>&lt;ol&gt;</code>&nbsp;标签来定义有序列表，<code>&lt;li&gt;</code>&nbsp;来定义列表项。</p><pre class="line-numbers language-none"><code class="language-none">&lt;ol&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt;</code></pre><p>与无序列表类似，有自己的样式属性，通过 CSS 设置。</p><h3 id="2-3-自定义列表"><a href="#2-3-自定义列表" class="headerlink" title="2.3 自定义列表"></a>2.3 自定义列表</h3><p>自定义列表的列表项前没有任何项目符号。</p><p><code>&lt;dl&gt;</code>&nbsp;定义描述列表，与&nbsp;<code>&lt;dt&gt;</code>&nbsp;和&nbsp;<code>&lt;dd&gt;</code>&nbsp;标签配合使用。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;    &lt;dt&gt;名词1&lt;/dt&gt;    &lt;dd&gt;名词1解释1&lt;/dd&gt;    &lt;dd&gt;名词1解释2&lt;/dd&gt;&lt;/dl&gt;</code></pre><p><strong>注意</strong></p><ol><li>dl 里面只能包含 dt 和 dd。</li><li>dt和dd个数没有限制，经常是一个dt对应多个dd。</li></ol><h2 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="3. 表单标签"></a>3. 表单标签</h2><h3 id="3-1-表单组成"><a href="#3-1-表单组成" class="headerlink" title="3.1 表单组成"></a>3.1 表单组成</h3><p>在 HTML 中，一个完整的表单通常由<strong>表单域、表单控件（也称为表单元素）和 提示信息</strong>3个部分构成。</p><p><img src="Pasted%20image%2020221206201222.png"></p><h3 id="3-2-表单域"><a href="#3-2-表单域" class="headerlink" title="3.2 表单域"></a>3.2 表单域</h3><p>表单域是一个包含表单元素的区域。 使用&nbsp;<code>&lt;form&gt;</code>&nbsp;标签用于定义表单域，以实现用户信息的收集和传递。<br><code>&lt;form&gt;</code>标签会将它范围内的表单元素信息提交给服务器。</p><pre class="line-numbers language-none"><code class="language-none">&lt;form action="url地址" method="提交方式" name="表单域名称"&gt;  各种表单元素控件&lt;/form&gt;</code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url地址</td><td>指定接受并处理表单数据的服务器的 url 地址</td></tr><tr><td>method</td><td>get/post</td><td>设置表单数据的提交方式</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单名称，区分同一个页面中的多个表单域</td></tr><tr><td>**注意：</td><td></td><td></td></tr></tbody></table><ol><li>写表单元素之前需要有表单域将其包含。</li><li>表单域是&nbsp;<code>form</code>&nbsp;标签。</li></ol><h3 id="3-3-表单控件"><a href="#3-3-表单控件" class="headerlink" title="3.3 表单控件"></a>3.3 表单控件</h3><h4 id="3-3-1-表单元素"><a href="#3-3-1-表单元素" class="headerlink" title="3.3.1 <input>&nbsp;表单元素"></a>3.3.1 <code>&lt;input&gt;</code>&nbsp;表单元素</h4><p><code>&lt;input&gt;</code>&nbsp;标签用于收集用户信息。</p><p><code>input</code>&nbsp;标签包含&nbsp;<code>type</code>&nbsp;属性，决定了输入字段的不同形式：***文本字段、复选框、掩码后的文本控件、单选按钮、按钮等。</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="属性值" /&gt;</code></pre><ul><li><code>input</code>&nbsp;标签为单标签</li><li><code>type</code>&nbsp;属性设置不同属性值来指定不同控件类型</li></ul><p><em><strong>type 常用属性值</strong></em></p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>输入字段。用户可输入文本，默认宽度为 20 个字符。</td></tr><tr><td>button</td><td>可点击按钮，后期结合js搭配使用。</td></tr><tr><td>radio</td><td>单选按钮</td></tr><tr><td>checkbox</td><td>复选框</td></tr><tr><td>password</td><td>密码字段。字符被掩码。</td></tr><tr><td>file</td><td>定义输入字段和“浏览”按钮，供文件上传</td></tr><tr><td>submit</td><td>提交按钮。会把表单数据发送到服务器。</td></tr><tr><td>reset</td><td>重置按钮，清除表单所有数据。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr></tbody></table><p><em><strong>input 的其他属性</strong></em></p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>自定义</td><td>定义 input 元素名称</td></tr><tr><td>value</td><td>自定义</td><td>规定 input 元素的值（可以显示出来）</td></tr><tr><td>checked</td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字段字符的最大长度</td></tr></tbody></table><ol><li><code>name 和 value</code> 是每个表单元素都有的属性值,主要给<strong>后台人员</strong>使用。<ol><li>name：多选一或复选时，所有的单选按钮和复选框要有<strong>相同</strong>的name值。</li><li>value：多选一或复选时，每个单选按钮和复选框要有<strong>不同</strong>的value值。</li></ol></li><li>checked 属性主要针对于单选按钮和复选框, 主要作用一打开页面,就要可以<strong>默认选中</strong>某个表单元素。</li><li>maxlength 是用户可以在表单元素输入的最大字符数, 一般较少使用。</li></ol><p><em><strong>label标签</strong></em></p><p><code>&lt;label&gt;</code>&nbsp;标签为 input 元素定义标注。<br><code>&lt;label&gt;</code>&nbsp;标签用于绑定一个表单源深路，当<strong>点击 label 标签内的文本</strong>时，浏览器<strong>自动将焦点转到或者选择</strong>对应的表单元素上，提升用户体验。</p><pre class="line-numbers language-none"><code class="language-none">&lt;label for="nan"&gt;男&lt;/label&gt;&lt;input type="radio" name="sex" id="nan" /&gt;</code></pre><p><strong>核心：</strong>&nbsp;<code>&lt;lable&gt;</code>标签的 for 属性与input元素的 id 属性相同。</p><h4 id="3-3-2-下拉表单元素"><a href="#3-3-2-下拉表单元素" class="headerlink" title="3.3.2 <select>下拉表单元素"></a>3.3.2 <code>&lt;select&gt;</code>下拉表单元素</h4><pre class="line-numbers language-none"><code class="language-none">&lt;select&gt;    &lt;option&gt;选项1&lt;/option&gt;    &lt;option&gt;选项2&lt;/option&gt;    &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;</code></pre><p><strong>注意</strong></p><ol><li>select 中至少包含一对 option。</li><li>在 option 中定义属性<code>selected="selected"</code>，当前项即为默认选项。</li></ol><h4 id="3-3-3-文本域元素"><a href="#3-3-3-文本域元素" class="headerlink" title="3.3.3 <textarea> 文本域元素"></a>3.3.3 <code>&lt;textarea&gt;</code> 文本域元素</h4><pre class="line-numbers language-none"><code class="language-none">&lt;textarea rows="3" cols="20"&gt;    文本内容&lt;/textarea&gt;</code></pre><ul><li>cols=”每行的字符数”，rows=”显示的行数”。**我们在实际开发中不会使用，都是用 CSS 来改变大小。</li></ul><h1 id="四、搜索优化"><a href="#四、搜索优化" class="headerlink" title="四、搜索优化"></a>四、搜索优化</h1><h2 id="1-TDK-标签-SEO-优化"><a href="#1-TDK-标签-SEO-优化" class="headerlink" title="1. TDK 标签 SEO 优化"></a>1. TDK 标签 SEO 优化</h2><p>SEO（Search Engine Optimization），即搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。</p><p>SEO 的目的是对网站进行深度优化，从而帮助网站获得免费流量，进而在搜索引擎上提升网站排名，提高网站知名度。</p><p>页面必须有三个标签用来进行 SEO 优化。</p><ul><li><code>title</code></li><li><code>description</code></li><li><code>keyword</code></li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 网站标题 --&gt;&lt;title&gt;&lt;/title&gt;&lt;!-- 网站说明 --&gt;&lt;meta name="description" content=""&gt;&lt;!-- 网站关键词 --&gt;&lt;meta name="keywords" content=""&gt;</code></pre><h3 id="1-1-title-网站标题"><a href="#1-1-title-网站标题" class="headerlink" title="1.1 title 网站标题"></a>1.1 title 网站标题</h3><p><code>title</code>&nbsp;具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点。</p><p>建议：网站名（产品名）- 网站的介绍（尽量不要超过30个汉字）</p><p>例如：</p><ul><li>京东(JD.COM) - 综合网购首选-正品低价、品质保障、配送及时、轻松购物！</li><li>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</li></ul><h3 id="1-2-description-网站说明"><a href="#1-2-description-网站说明" class="headerlink" title="1.2 description 网站说明"></a>1.2 description 网站说明</h3><p>简要说明我们网站主要是做什么的。</p><p>我们提倡，description 作为网站的总体业务和主题概括，多采用“我们是…”、“我们提供…”、“×××网作为…”、“电话：010…”之类语句。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"&gt;</code></pre><h3 id="1-3-keywords-关键字"><a href="#1-3-keywords-关键字" class="headerlink" title="1.3 keywords 关键字"></a>1.3 keywords 关键字</h3><ul><li>keywords 是页面关键词，是搜索引擎的关注点之一。</li><li>keywords 最好限制为6～8 个关键词，关键词之间用英文逗号隔开，采用关键词1,关键词2 的形式。</li></ul><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name= " keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"&gt;</code></pre><h2 id="2-LOGO-SEO-优化"><a href="#2-LOGO-SEO-优化" class="headerlink" title="2. LOGO SEO 优化"></a>2. LOGO SEO 优化</h2><ol><li>logo 首先放一个<code>h1</code>标签，目的是为了提权，告诉搜索引擎，这个地方很重要。</li><li><code>h1</code>里面再放一个<code>a</code>链接，可以返回首页的，把logo 的背景图片给a链接即可。</li><li>为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来。</li></ol><ul><li>方法1：text-indent 移到盒子外面（text-indent: -9999px) ，然后overflow:hidden ，淘宝的做法。</li><li>方法2：直接给font-size: 0; 就看不到文字了，京东的做法。</li></ul><ol start="4"><li>最后给logo图片一个<code>title</code>属性，这样鼠标放到 logo 上就可以看到提示文字了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML简介</title>
      <link href="/2022/12/11/HTML%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/12/11/HTML%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网页"><a href="#1-网页" class="headerlink" title="1. 网页"></a>1. 网页</h2><h3 id="1-1-什么是网页"><a href="#1-1-什么是网页" class="headerlink" title="1.1 什么是网页"></a>1.1 什么是网页</h3><ol><li><p>网页是根据因特网上一定的规则，使用 html 等制作的用于展示特定内容的网页集合。</p></li><li><p>网页是构成网站的基本元素。</p></li><li><p>网页是图片、链接、文字、声音、视频等源深路组成，其实就是一个 html 文件。</p></li></ol><h3 id="1-2-什么是-HTML"><a href="#1-2-什么是-HTML" class="headerlink" title="1.2 什么是 HTML"></a>1.2 什么是 HTML</h3><p>HTML 指的是超文本标记语言（Hyper Text Markup Language）,它是用来描述网页的一种语言。</p><p>HTML 不是一种编程语言，而是一种标记语言（markup language）。 标记语言是一套标记标签（markup tag）。</p><p><strong>超文本的含义：</strong></p><ol><li>它可以加入图片、声音、动画、多媒体等内容（超越文本限制）。</li><li>它可以从一个文件跳转到另一个文件，于世界各地主机的文件连接（超级链接文本）。</li></ol><h3 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h3><p>网页由网页元素组成，这些元素通过 html 标签描述出来，然后通过浏览器解析并显示出来。</p><h2 id="2-常用浏览器及其内核"><a href="#2-常用浏览器及其内核" class="headerlink" title="2. 常用浏览器及其内核"></a>2. 常用浏览器及其内核</h2><h3 id="2-1-常用浏览器"><a href="#2-1-常用浏览器" class="headerlink" title="2.1 常用浏览器"></a>2.1 常用浏览器</h3><p>浏览器是网页显示、运行的平台。</p><p>五大浏览器有 IE、Firefox、Chrome、Safari 和 Opera。</p><p>四大内核：Trident, Gecko, Webkit, Blink</p><h3 id="2-2-浏览器内核"><a href="#2-2-浏览器内核" class="headerlink" title="2.2 浏览器内核"></a>2.2 浏览器内核</h3><p>浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。<br><img src="Pasted%20image%2020221206114523.png"></p><h2 id="3-Web-标准"><a href="#3-Web-标准" class="headerlink" title="3. Web 标准"></a>3. Web 标准</h2><p>Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。</p><h3 id="3-1-为什么需要-Web-标准"><a href="#3-1-为什么需要-Web-标准" class="headerlink" title="3.1 为什么需要 Web 标准"></a>3.1 为什么需要 Web 标准</h3><p>浏览器不同，它们显示的页面或者排版有些许差异。</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li>让 Web 标准发展前景更为广阔</li><li>内容能被更广泛的设备访问。</li><li>更容易被搜索引擎了搜索。</li><li>降低网站流量费用。</li><li>易于维护。</li><li>提高页面浏览速度。</li></ol><h3 id="3-2-Web-标准的构成"><a href="#3-2-Web-标准的构成" class="headerlink" title="3.2 Web 标准的构成"></a>3.2 Web 标准的构成</h3><p>主要包括结构（Structure） 、表现（Presentation）和行为（Behavior）三个方面。<br><img src="Pasted%20image%2020221206114713.png"><br>Web 标准提出的最佳体验方案：结构、样式、行为相分离。</p><p>简单理解： ==结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中==。</p><p><img src="Pasted%20image%2020221206114849.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端三件套 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/10/hello-world/"/>
      <url>/2022/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
